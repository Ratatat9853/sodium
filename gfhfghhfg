
local __bundle = {}
local __loaded = {}
local __native_require = require

local function __bundle_require(path)
    if __loaded[path] then
        return __loaded[path]
    end

    local chunk = __bundle[path]
    if not chunk then
        return __native_require(path)
    end
    local env = {}
    setmetatable(env, { __index = _G })
    env.require = __bundle_require

    local fn, err
    if type(setfenv) == "function" then
        fn, err = load(chunk, path)
        if not fn then
            error("Failed to load module: " .. path .. " (" .. tostring(err) .. ")")
        end
        setfenv(fn, env)
    else
        fn, err = load(chunk, path, nil, env)
        if not fn then
            error("Failed to load module: " .. path .. " (" .. tostring(err) .. ")")
        end
    end

    local result = fn()
    __loaded[path] = result or true
    return __loaded[path]
end

__bundle["require/aa/player_condition"] = [[
local libs = require("require/help/libs")
local aa_funcs = libs.get("antiaim_funcs")
local entity = libs.get("entity") or entity
local bit = libs.get("bit") or bit
local menu_setup = require('require/abc/menu_setup')
local air_tick_state = { last_air = false, last_tick = 0, last_cond = nil }

local function cond_allowed(cond)
    if cond == 'global' then return true end
    if not menu_setup or not menu_setup.ui then return true end
    local enable_key = 'enable_' .. cond
    local item = menu_setup.ui[enable_key]
    if not item then
        return true
    end
    local ok, val = pcall(ui.get, item)
    return ok and val == true
end


local function get_antiaim_condition()
    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then
        return nil
    end
    
    if client.key_state(0x45) then
        if cond_allowed('legit') then return "legit" end
    end

    local get_double_tap = false
    if aa_funcs and aa_funcs.get_double_tap then
        get_double_tap = aa_funcs.get_double_tap()
    else
        get_double_tap = true
    end

    if get_double_tap == false then
        if cond_allowed('fakelag') then return "fakelag" end
    end

    if misc_gs_hotkey_slowmotion and ui.get(misc_gs_hotkey_slowmotion) == true then
        if cond_allowed('walk') then return "walk" end
    end
    
    if client.key_state(0x10) then
        local vel_x, vel_y = entity.get_prop(lp, 'm_vecVelocity')
        local velocity = math.sqrt((vel_x or 0)^2 + (vel_y or 0)^2)
        if velocity >= 20 and velocity <= 140 then
            if cond_allowed('walk') then return "walk" end
        end
    end

    local vel_x, vel_y = entity.get_prop(lp, 'm_vecVelocity')
    local velocity = math.sqrt((vel_x or 0)^2 + (vel_y or 0)^2)
    local ducking = entity.get_prop(lp, 'm_flDuckAmount') > 0.5
    local on_ground = bit.band(entity.get_prop(lp, 'm_fFlags') or 0, 1) == 1
    local tick = globals.tickcount()

    if not on_ground then
        if ducking then
            air_tick_state.last_air = true
            air_tick_state.last_tick = tick
            air_tick_state.last_cond = "jump+"
            if cond_allowed('jump+') then return "jump+" end
        else
            air_tick_state.last_air = true
            air_tick_state.last_tick = tick
            air_tick_state.last_cond = "jump"
            if cond_allowed('jump') then return "jump" end
        end
    else
        if air_tick_state.last_air and (tick - air_tick_state.last_tick <= 2) then
            if air_tick_state.last_cond and cond_allowed(air_tick_state.last_cond) then
                return air_tick_state.last_cond
            end
        end
        air_tick_state.last_air = false
        air_tick_state.last_cond = nil
    end

    if ducking then
        if velocity >= 2 then
            if cond_allowed('duck+') then return "duck+" end
        else
            if cond_allowed('duck') then return "duck" end
        end
    else
        if velocity >= 2 then
            if cond_allowed('move') then return "move" end
        else
            if cond_allowed('stand') then return "stand" end
        end
    end

    return "global"
end

return {
    get = get_antiaim_condition
}]]
__bundle["require/abc/build_menu"] = [[tab = {
    "RAGE",
    "AA",
    "LEGIT",
    "VISUALS",
    "MISC",
    "PLIST",
    "CONFIG",
    "LUA"
}

cont = {
    {
        "Aimbot",
        "Other"
    },
    {
        "Anti-aimbot angles",
        "Fake lag",
        "Other"
    },
    {},
    {
        "Player ESP",
        "Other ESP",
        "Colored models",
        "Effects"
    },
    {},
    {},
    {},
    {
        "A",
        "B",
    }
}

local conditions = {
    "global",
    "stand",
    "move",
    "duck",
    "duck+",
    "jump",
    "jump+",
    "walk",
    "fakelag",
    "legit",
}

local menu_setup = require("require/abc/menu_setup")
local COLORS = require("require/help/color")
local screenlog = require("require/abc/screen_logger")
local emojis = require("require/help/emojis")

local function build_menu(modules)
    local CFG_LIST_KEY = 'inDGnidgdisgndsin'

    local function read_cfg_names()
        local t = database.read(CFG_LIST_KEY)
        return type(t) == 'table' and t or {}
    end

    local function write_cfg_names(t)
        database.write(CFG_LIST_KEY, t)
    end

    local function find_index_by_name(t, name)
        for i = 1, #t do if t[i] == name then return i end end
        return nil
    end

    local function should_pushlog()
        if not (modules and modules.menu_setup and modules.menu_setup.ui and modules.menu_setup.ui.paint_logger) then
            return false
        end
        local ok, val = pcall(ui.get, modules.menu_setup.ui.paint_logger)
        if not ok or not val then return false end
        if type(val) == 'table' then
            for _, v in ipairs(val) do
                if tostring(v) == 'config' then return true end
            end
            return false
        else
            return tostring(val) == 'config'
        end
    end

    local function refresh_cfg_listbox(preserve_name)
        local names = read_cfg_names()
        if #names == 0 then names = {'(empty)'} end
            if menu_setup.ui.cfg_listbox then
                pcall(ui.set_visible, menu_setup.ui.cfg_listbox, false)
            end
            menu_setup.ui.cfg_listbox = menu_setup.register_ui(
                ui.new_listbox(tab[2], cont[2][1], 'Configs', names),
                { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
            )
        if preserve_name then
            local idx = find_index_by_name(names, preserve_name)
            if idx then ui.set(menu_setup.ui.cfg_listbox, idx-1) end
        end
    end
 
    
    
    
    menu_setup.ui.cache_credentials = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("pin") .. COLORS.get("default", "ui") .. 'Cache credentials'),
        { requires_login = false, key = 'cache_credentials', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.login_username = menu_setup.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Username', 'username'),
        { requires_login = false, key = 'login_username', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    menu_setup.ui.login_password = menu_setup.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Password', 'password'),
        { requires_login = false, key = 'login_password', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    menu_setup.ui.login_howto_header = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], COLORS.get("grey", "ui") .. '───────[ ' .. COLORS.get("white", "ui") .. 'How to ' .. COLORS.get("green", "ui") .. 'log in' .. COLORS.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'login_howto_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.login_console_register = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], COLORS.get("grey", "ui") .. '1. In console -> "register ' .. COLORS.get("green", "ui") .. 'user' .. COLORS.get("grey", "ui") .. ' ' .. COLORS.get("red", "ui") .. 'pass' .. COLORS.get("grey", "ui") .. ' ' .. COLORS.get("blue", "ui") .. 'code' .. COLORS.get("grey", "ui") .. '"'),
        { requires_login = false, key = 'login_console_register', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.login_menu_credentials = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], COLORS.get("grey", "ui") .. '2. Write password & username in the menu.'),
        { requires_login = false, key = 'login_menu_credentials', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.login_press_login = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], COLORS.get("grey", "ui") .. '3. Press log in and enjoy ' .. COLORS.get("green", "ui") .. 'premium features' .. COLORS.get("grey", "ui") .. '.'),
        { requires_login = false, key = 'login_press_login', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.login_spacer1 = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer1', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.reset_header = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], COLORS.get("grey", "ui") .. '───────[ ' .. COLORS.get("white", "ui") .. 'How to ' .. COLORS.get("yellow", "ui") .. 'reset pass' .. COLORS.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'reset_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.reset_step1 = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], COLORS.get("grey", "ui") .. '1. Write username -> press reset.'),
        { requires_login = false, key = 'reset_step1', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.reset_step2 = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], COLORS.get("grey", "ui") .. '2. Login with your oldest password.'),
        { requires_login = false, key = 'reset_step2', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.login_spacer2 = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer2', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.support_header = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], COLORS.get("grey", "ui") .. '───────[ ' .. COLORS.get("red", "ui") .. 'Support & Other' .. COLORS.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'support_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.support_discord = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], COLORS.get("grey", "ui") .. '1. Join the ' .. COLORS.get("discord", "ui") .. 'discord ' .. COLORS.get("grey", "ui") .. 'for support.'),
        { requires_login = false, key = 'support_discord', tab = 'AA', visible = true, config_type = 'label' }
    )

    menu_setup.ui.login_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("lock_open") .. COLORS.get("default", "ui") .. 'Login', function()
            local username = modules.safe.safe_get(menu_setup.ui.login_username)
            local password = modules.safe.safe_get(menu_setup.ui.login_password)
            local cache = modules.safe.safe_get(menu_setup.ui.cache_credentials)
            if username ~= '' and password ~= '' then
                local success = modules.login.login(username, password)
                if success then
                    modules.pushlog("Welcome back, " .. modules.str.capitalize(username) .. ". You logged in successfully.", 3, 75, 145, 55, 255)
                    if cache then
                        database.write('cached_credentials', { username = username, password = password })
                    else
                        database.write('cached_credentials', nil)
                    end
                    local r,g,b = COLORS.get("green", "log")
                    modules.screenlog("Login successful!", 4, r, g, b, 255)
                else
                    local r,g,b = COLORS.get("red", "log")
                    modules.screenlog("Login failed!", 4, r, g, b, 255)
                end
            end
                if modules.menu_visibility and modules.menu_visibility.update then
                    modules.menu_visibility.update(modules)
                end
        end),
        { requires_login = false, key = 'login_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    menu_setup.ui.logout_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][3], COLORS.get("red", "ui") .. emojis.get("lock") .. COLORS.get("default", "ui") .. 'Logout', function()
            modules.login.logout()
            local r,g,b = COLORS.get("red", "log")
            modules.screenlog("Logged out!", 4, r, g, b, 255)
                if modules.menu_visibility and modules.menu_visibility.update then
                    modules.menu_visibility.update(modules)
                end
        end),
        { requires_login = true, key = 'logout_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    menu_setup.ui.reset_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][1], COLORS.get("yellow", "ui") .. emojis.get("warning") .. COLORS.get("default", "ui") .. 'Reset', function()
            local username = modules.safe.safe_get(menu_setup.ui.login_username)
            modules.login.reset_password(username)
            local r,g,b = COLORS.get("yellow", "log")
            modules.screenlog("Password reset.", 4, r, g, b, 255)
            modules.pushlog("Password reset for user: " .. username, 5, 255, 255, 0, 255)
                if modules.menu_visibility and modules.menu_visibility.update then
                    modules.menu_visibility.update(modules)
                end
        end),
        { requires_login = true, key = 'reset_button', tab = 'AA', visible = true, config_type = 'button' }
    )

    menu_setup.ui.discord_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][3], COLORS.get("discord", "ui") .. emojis.get("chat") .. COLORS.get("default", "ui") .. 'Discord', function()
            local ref = ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            modules.safe.safe_set(ref, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://discord.gg/a2bFbVWWg9')
        end),
        { requires_login = true, key = 'discord_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    menu_setup.ui.youtube_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][3], COLORS.get("youtube", "ui") .. emojis.get("play") .. COLORS.get("default", "ui") .. 'YouTube', function()
            local ref = ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            modules.safe.safe_set(ref, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://www.youtube.com/@vile-gs/videos')
        end),
        { requires_login = true, key = 'youtube_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    menu_setup.ui.sellhub_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][3], COLORS.get("sellhub", "ui") .. emojis.get("folder") .. COLORS.get("default", "ui") .. 'Sellhub', function()
            local ref = ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            modules.safe.safe_set(ref, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://sodium.sellhub.cx/#products-list')
        end),
        { requires_login = true, key = 'sellhub_button', tab = 'AA', visible = true, config_type = 'button' }
    )


    
    
    
    menu_setup.ui.condition_label = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("menu") .. COLORS.get("default", "ui") .. 'Condition', unpack(conditions)),
        { requires_login = true, key = 'condition_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.condition = menu_setup.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nCondition', unpack(conditions)),
        { requires_login = true, key = 'condition', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    menu_setup.ui.condition_label2 = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][1], '\ncondition label'),
        { requires_login = true, key = 'condition_label2', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.misc_resolver = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("wrench") .. COLORS.get("default", "ui") .. 'Resolver'),
        { requires_login = true, key = 'misc_resolver', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.misc_ragebot = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("arrow_double") .. COLORS.get("default", "ui") .. 'Ragebot'),
        { requires_login = true, key = 'misc_ragebot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.misc_dormantaimbot = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("time") .. COLORS.get("default", "ui") .. 'Dormant aimbot'),
        { requires_login = true, key = 'misc_dormantaimbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.misc_dormantaimbot_key = menu_setup.register_ui(
        ui.new_hotkey(tab[2], cont[2][1], '\ndormant aimbot key', true),
        { requires_login = true, key = 'misc_dormantaimbot_key', tab = 'MISC', visible = true, config_type = 'hotkey' }
    )
    menu_setup.ui.misc_dormantaimbot_value = menu_setup.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\ndormant aimbot value', 60, 100, 0, true, '%'),
        { requires_login = true, key = 'misc_dormantaimbot_value', tab = 'MISC', visible = true, config_type = 'slider' }
    )
    menu_setup.ui.misc_exploit_fakelag = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("latency3") .. COLORS.get("default", "ui") .. 'Limit exploit fakelag'),
        { requires_login = true, key = 'misc_exploit_fakelag', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.misc_walkbot = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("arrow_up") .. COLORS.get("default", "ui") .. 'Walkbot'),
        { requires_login = true, key = 'misc_walkbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.misc_backstab = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("triangle_upside") .. COLORS.get("default", "ui") .. 'Backstab Assist'),
        { requires_login = true, key = 'misc_backstab', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.misc_spindead = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("turning2") .. COLORS.get("default", "ui") .. 'Spin on dead enemies'),
        { requires_login = true, key = 'misc_spindead', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.aa_gskey_freestandh = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][3], COLORS.get("green", "ui") .. emojis.get("turning2") .. COLORS.get("default", "ui") .. 'Freestand'),
        { requires_login = false, key = 'aa_gskey_freestandh', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.aa_gskey_freestand = menu_setup.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'freestand', true),
        { requires_login = true, key = 'aa_gskey_freestand', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    menu_setup.ui.aa_gskey_slowmotionh = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][3], COLORS.get("green", "ui") .. emojis.get("gear") .. COLORS.get("default", "ui") .. 'Slowmotion'),
        { requires_login = false, key = 'aa_gskey_slowmotionh', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.aa_gskey_slowmotion = menu_setup.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'slowmotion', true),
        { requires_login = true, key = 'aa_gskey_slowmotion', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    menu_setup.ui.aa_gskey_edgeyawh = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][3], COLORS.get("green", "ui") .. emojis.get("recycle") .. COLORS.get("default", "ui") .. 'Edge Yaw'),
        { requires_login = false, key = 'aa_gskey_edgeyawh', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.aa_gskey_edgeyaw = menu_setup.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'edge yaw', true),
        { requires_login = true, key = 'aa_gskey_edgeyaw', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    menu_setup.ui.aa_gskey_onshoth = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][3], COLORS.get("green", "ui") .. emojis.get("arrow_double") .. COLORS.get("default", "ui") .. 'On-shot aa'),
        { requires_login = false, key = 'aa_gskey_onshoth', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.aa_gskey_onshot = menu_setup.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'on-shot aa', true),
        { requires_login = true, key = 'aa_gskey_onshot', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    
    for _, cond in ipairs(conditions) do
        local enable_key = 'enable_' .. cond
        menu_setup.ui[enable_key] = menu_setup.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("accept") .. COLORS.get("default", "ui") .. 'Enable ' .. cond),
            { requires_login = true, key = enable_key, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        menu_setup.ui['pitch_' .. cond] = menu_setup.register_ui(
            ui.new_combobox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("triangle_upside") .. COLORS.get("default", "ui") .. 'Pitch', 'off', 'up', 'down', 'minimal', 'ideal'),
            { requires_login = true, key = 'pitch_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        menu_setup.ui['yaw_base_' .. cond] = menu_setup.register_ui(
            ui.new_combobox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("recycle") .. COLORS.get("default", "ui") .. 'Yaw Base', 'target', 'view', 'threat', 'distance', 'smart'),
            { requires_login = true, key = 'yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        menu_setup.ui['yaw_' .. cond] = menu_setup.register_ui(
            ui.new_combobox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("turning2") .. COLORS.get("default", "ui") .. 'Yaw', 'off', 'spin', '180', '3way', 'ideal'),
            { requires_login = true, key = 'yaw_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        menu_setup.ui['label1_' .. cond] = menu_setup.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label1_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        menu_setup.ui['body_yaw_base_' .. cond] = menu_setup.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Base', -90, 90, 0, true, '°'),
            { requires_login = true, key = 'body_yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        menu_setup.ui['body_yaw_left_' .. cond] = menu_setup.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Left', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_left_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        menu_setup.ui['body_yaw_right_' .. cond] = menu_setup.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Right', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_right_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        menu_setup.ui['randomize_yaw_' .. cond] = menu_setup.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Randomize Yaw', 0, 30, 0, true, '%', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'randomize_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        menu_setup.ui['label2_' .. cond] = menu_setup.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label2_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        menu_setup.ui['yaw_jitter_' .. cond] = menu_setup.register_ui(
            ui.new_combobox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("turning") .. COLORS.get("default", "ui") .. 'Yaw Jitter', 'off', 'center', 'skitter'),
            { requires_login = true, key = 'yaw_jitter_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        menu_setup.ui['yaw_jitter_base_' .. cond] = menu_setup.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Yaw Jitter - Base', 0, 120, 0, true, '°', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'yaw_jitter_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        menu_setup.ui['body_yaw_mode_' .. cond] = menu_setup.register_ui(
            ui.new_combobox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("gear") .. COLORS.get("default", "ui") .. 'Body Yaw Mode', 'off', 'static', 'opposite', 'jitter'),
            { requires_login = true, key = 'body_yaw_mode_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        menu_setup.ui['static_body_yaw_' .. cond] = menu_setup.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Static Body Yaw', -58, 58, 0, true, '°'),
            { requires_login = true, key = 'static_body_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        menu_setup.ui['body_yaw_value_' .. cond] = menu_setup.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw Value', 1, 3, 2, true, '', 2, {
                [1] = 'left', [2] = 'back', [3] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_value_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        menu_setup.ui['delay_' .. cond] = menu_setup.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Delay', 0, 17, 1, true, 't', 1, {
                [0] = 'jitter'
            }),
            { requires_login = true, key = 'delay_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        menu_setup.ui['label3_' .. cond] = menu_setup.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label3_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        menu_setup.ui['fifty_fifty_' .. cond] = menu_setup.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("question") .. COLORS.get("default", "ui") .. '50/50'),
            { requires_login = true, key = 'fifty_fifty_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        menu_setup.ui['only_flip_on_0_choke_' .. cond] = menu_setup.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("time") .. COLORS.get("default", "ui") .. 'Only Flip on 0 Choke'),
            { requires_login = true, key = 'only_flip_on_0_choke_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        menu_setup.ui['aa_label_space' .. cond] = menu_setup.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n abc'),
            { requires_login = true, key = 'aa_label_space', tab = 'AA', visible = true, config_type = 'label' }
        )
        menu_setup.ui['aa_label_combo' .. cond] = menu_setup.register_ui(
            ui.new_label(tab[2], cont[2][1], 'Send state -> state'),
            { requires_login = true, key = 'aa_label_combo', tab = 'AA', visible = true, config_type = 'label' }
        )
        menu_setup.ui['send_combo' .. cond] = menu_setup.register_ui(
            ui.new_combobox(tab[2], cont[2][1], '\n', unpack(conditions)),
            { requires_login = true, key = 'send_combo' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        menu_setup.ui['send_button' .. cond] = menu_setup.register_ui(
            ui.new_button(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("upload") .. COLORS.get("default", "ui") .. 'Send', function() end),
            { requires_login = true, key = 'send_button', tab = 'AA', visible = true, config_type = 'button' }
        )

    end


    
    
    
    menu_setup.ui.fakelag_mode = menu_setup.register_ui(
        ui.new_combobox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("gear") .. COLORS.get("default", "ui") .. 'Mode', 'defensive', 'stealer', 'fakelag', 'settings'),
        { requires_login = true, key = 'fakelag_mode', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    menu_setup.ui.fakelag_defensive = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("turning2") .. COLORS.get("default", "ui") .. 'Defensive'),
        { requires_login = true, key = 'fakelag_defensive', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.fakelag_force = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("exclamation") .. COLORS.get("default", "ui") .. 'Force'),
        { requires_login = true, key = 'fakelag_force', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.fakelag_fakedef = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("globe") .. COLORS.get("default", "ui") .. 'Unmatched.gg'),
        { requires_login = true, key = 'fakelag_fakedef', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.fakelag_force_on = menu_setup.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("clip") .. COLORS.get("default", "ui") .. 'Force whilst', 'peek', 'reload', 'shot', 'damaged'),
        { requires_login = true, key = 'fakelag_force_on', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    
    
    
    menu_setup.ui.cfg_load_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("arrow_double") .. COLORS.get("default", "ui") .. 'Load', function()
            local names = read_cfg_names()
            local idx = ui.get(menu_setup.ui.cfg_listbox)
            local name_from_list = names[(idx or 0) + 1]
            local input_name = ui.get(menu_setup.ui.cfg_input_box)
            local name = (name_from_list and name_from_list ~= '(empty)' and name_from_list ~= '') and name_from_list or input_name

            if name and name ~= '' and name ~= '(empty)' then
                local config_system = require("require/abc/config_system")
                local function get_include_tabs()
                    if not menu_setup.ui.cfg_selection then return nil end
                    local ok, sel = pcall(ui.get, menu_setup.ui.cfg_selection)
                    if not ok or not sel or type(sel) ~= 'table' or #sel == 0 then return nil end
                    local map = { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local out = {}
                    for _, v in ipairs(sel) do
                        local t = map[tostring(v)]
                        if t then out[#out+1] = t end
                    end
                    if #out == 0 then return nil end
                    return out
                end
                local include_tabs = get_include_tabs()
                config_system.load(name, include_tabs)
                modules.screenlog('[Config] Loaded config: ' .. name, 4, 120, 180, 255, 255)
                if modules and modules.pushlog and should_pushlog() then
                    modules.pushlog('Loaded config: ' .. name, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for load.')
                if modules and modules.pushlog and should_pushlog() then
                    modules.pushlog('No config name selected for load.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_load_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    menu_setup.ui.cfg_save_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("config") .. COLORS.get("default", "ui") .. 'Save', function()
            local names = read_cfg_names()
            local idx = ui.get(menu_setup.ui.cfg_listbox)
            local name_from_list = names[(idx or 0) + 1]
            local input_name = ui.get(menu_setup.ui.cfg_input_box)
            local name = (name_from_list and name_from_list ~= '(empty)' and name_from_list ~= '') and name_from_list or input_name

            if name and name ~= '' then
                local config_system = require("require/abc/config_system")
                local function get_include_tabs()
                    if not menu_setup.ui.cfg_selection then return nil end
                    local ok, sel = pcall(ui.get, menu_setup.ui.cfg_selection)
                    if not ok or not sel or type(sel) ~= 'table' or #sel == 0 then return nil end
                    local map = { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local out = {}
                    for _, v in ipairs(sel) do
                        local t = map[tostring(v)]
                        if t then out[#out+1] = t end
                    end
                    if #out == 0 then return nil end
                    return out
                end
                local include_tabs = get_include_tabs()
                config_system.save(name, include_tabs)
                local names = read_cfg_names()
                if not find_index_by_name(names, name) then
                    names[#names+1] = name
                    write_cfg_names(names)
                end
                refresh_cfg_listbox(name)
                modules.screenlog('[Config] Saved config: ' .. name, 4, 120, 180, 255, 255)
                if modules and modules.pushlog and should_pushlog() then
                    modules.pushlog('Saved config: ' .. name, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name provided for save.')
                if modules and modules.pushlog and should_pushlog() then
                    modules.pushlog('No config name provided for save.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_save_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    menu_setup.ui.cfg_create_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("plus") .. COLORS.get("default", "ui") .. 'Create', function()
            local input_name = ui.get(menu_setup.ui.cfg_input_box)
            if not input_name or input_name == '' then
                client.error_log('[Config] No config name provided for create.')
                if modules and modules.pushlog and should_pushlog() then
                    modules.pushlog('No config name provided for create.', 4, 255, 255, 255, 255)
                end
                return
            end

            local names = read_cfg_names()
            if find_index_by_name(names, input_name) then
                client.error_log('[Config] Config with that name already exists: ' .. input_name)
                if modules and modules.pushlog and should_pushlog() then
                    modules.pushlog('Config already exists: ' .. input_name, 4, 255, 255, 255, 255)
                end
                return
            end

            local config_system = require("require/abc/config_system")
            local function get_include_tabs()
                if not menu_setup.ui.cfg_selection then return nil end
                local ok, sel = pcall(ui.get, menu_setup.ui.cfg_selection)
                if not ok or not sel or type(sel) ~= 'table' or #sel == 0 then return nil end
                local map = { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local out = {}
                for _, v in ipairs(sel) do
                    local t = map[tostring(v)]
                    if t then out[#out+1] = t end
                end
                if #out == 0 then return nil end
                return out
            end
            local include_tabs = get_include_tabs()
            config_system.save(input_name, include_tabs)
            names[#names+1] = input_name
            write_cfg_names(names)
            refresh_cfg_listbox(input_name)
            modules.screenlog('[Config] Created config: ' .. input_name, 4, 120, 180, 255, 255)
            if modules and modules.pushlog and should_pushlog() then
                modules.pushlog('Created config: ' .. input_name, 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_create_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    menu_setup.ui.cfg_delete_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][1], COLORS.get("red", "ui") .. emojis.get("trash") .. COLORS.get("default", "ui") .. 'Delete', function()
            local names = read_cfg_names()
            local idx = ui.get(menu_setup.ui.cfg_listbox)
            local name_from_list = names[(idx or 0) + 1]
            local input_name = ui.get(menu_setup.ui.cfg_input_box)
            local name = (name_from_list and name_from_list ~= '(empty)' and name_from_list ~= '') and name_from_list or input_name

            if name and name ~= '' and name ~= '(empty)' then
                local config_system = require("require/abc/config_system")
                config_system.delete(name)
                local names = read_cfg_names()
                local idx = find_index_by_name(names, name)
                if idx then
                    table.remove(names, idx)
                    write_cfg_names(names)
                end
                refresh_cfg_listbox()
                modules.screenlog('[Config] Deleted config: ' .. name, 4, 255, 80, 80, 255)
                if modules and modules.pushlog and should_pushlog() then
                    modules.pushlog('Deleted config: ' .. name, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for delete.')
                if modules and modules.pushlog and should_pushlog() then
                    modules.pushlog('No config name selected for delete.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_delete_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    menu_setup.ui.cfg_refresh_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("turning") .. COLORS.get("default", "ui") ..'Refresh', function()
            refresh_cfg_listbox()
            modules.screenlog('[Config] Refreshed config list.', 4, 120, 180, 255, 255)
            if modules and modules.pushlog and should_pushlog() then
                modules.pushlog('Refreshed config list.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_refresh_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    
    local config_system = require("require/abc/config_system")
    local _ok_clipboard, _clipboard = pcall(require, 'gamesense/clipboard')
    local clipboard = _clipboard
    if not _ok_clipboard or not clipboard then
        clipboard = {
            set = function(_) end,
            get = function() return '' end,
        }
    end


    menu_setup.ui.cfg_export_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("upload") .. COLORS.get("default", "ui") .. 'Export', function()
            local function get_include_tabs()
                if not menu_setup.ui.cfg_selection then return nil end
                local ok, sel = pcall(ui.get, menu_setup.ui.cfg_selection)
                if not ok or not sel or type(sel) ~= 'table' or #sel == 0 then return nil end
                local map = { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local out = {}
                for _, v in ipairs(sel) do
                    local t = map[tostring(v)]
                    if t then out[#out+1] = t end
                end
                if #out == 0 then return nil end
                return out
            end
            local include_tabs = get_include_tabs()
            local export_str = config_system.build(include_tabs)
            clipboard.set(export_str)
            client.log('[Config] Exported config string:')
            client.log(export_str)
            modules.screenlog('[Config] Exported config string to clipboard and console.', 4, 120, 180, 255, 255)
            if modules and modules.pushlog and should_pushlog() then
                modules.pushlog('Exported config string to clipboard.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_export_button', tab = 'CFG', visible = true, config_type = 'button' }
    )

    menu_setup.ui.cfg_import_button = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("download") .. COLORS.get("default", "ui") .. 'Import', function()
            local import_str = clipboard.get()
            if import_str and import_str ~= '' then
                local function get_include_tabs()
                    if not menu_setup.ui.cfg_selection then return nil end
                    local ok, sel = pcall(ui.get, menu_setup.ui.cfg_selection)
                    if not ok or not sel or type(sel) ~= 'table' or #sel == 0 then return nil end
                    local map = { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local out = {}
                    for _, v in ipairs(sel) do
                        local t = map[tostring(v)]
                        if t then out[#out+1] = t end
                    end
                    if #out == 0 then return nil end
                    return out
                end
                local include_tabs = get_include_tabs()
                config_system.apply(import_str, include_tabs)
                modules.screenlog('[Config] Imported config string from clipboard.', 4, 120, 180, 255, 255)
                if modules and modules.pushlog and should_pushlog() then
                    modules.pushlog('Imported config string from clipboard.', 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config string found in clipboard.')
                if modules and modules.pushlog and should_pushlog() then
                    modules.pushlog('No config string found in clipboard for import.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_import_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    menu_setup.ui.cfg_selection = menu_setup.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\n selection', 'antiaim', 'paint', 'misc'),
        { requires_login = true, key = 'cfg_selection', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    menu_setup.ui.cfg_input_box = menu_setup.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Config name'),
        { requires_login = true, key = 'cfg_input_box', tab = 'CFG', visible = true, config_type = 'textbox' }
    )
    menu_setup.ui.cfg_listbox = menu_setup.register_ui(
        ui.new_listbox(tab[2], cont[2][1], 'Configs', {}),
        { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    refresh_cfg_listbox()

    menu_setup.ui.cfg_cloud_apply = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("globe") .. COLORS.get("default", "ui") .. ' Apply cloud', function()
            local ok, sel = pcall(ui.get, menu_setup.ui.cfg_cloud)
            if not ok then
                client.log('cfg_cloud_apply: failed to read selection')
                return
            end

            local choices = { 'Reset', 'Defensive', 'Unmatched', 'Community' }
            local name = nil

            if type(sel) == 'number' then
                local idx = sel + 1
                name = choices[idx]
            elseif type(sel) == 'table' then
                if #sel > 0 and type(sel[1]) == 'number' then
                    name = choices[sel[1] + 1]
                else
                    name = tostring(sel[1])
                end
            else
                name = tostring(sel)
            end

            if not name or name == '' then
                client.log('cfg_cloud_apply: no selection')
                return
            end

            local ok_cloud, cloud = pcall(require, 'require/abc/config_cloud')
            if not ok_cloud or not cloud then
                client.log('cfg_cloud_apply: failed to load config_cloud module')
                return
            end

            local enc = cloud[name]
            if not enc then
                client.log('cfg_cloud_apply: no cloud config string for', tostring(name))
                return
            end

            local ok_cfg, config_system = pcall(require, 'require/abc/config_system')
            if not ok_cfg or not config_system or not config_system.apply then
                client.log('cfg_cloud_apply: config_system.apply not available')
                return
            end

            config_system.apply(enc)
            client.log('cfg_cloud_apply: applied cloud config', tostring(name))
        end),
        { requires_login = true, key = 'cfg_cloud_apply', tab = 'AA', visible = true, config_type = 'button' }
    )

    menu_setup.ui.cfg_cloud = menu_setup.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'Cloud', { COLORS.get("red", "ui") .. 'Reset', COLORS.get("reddark", "ui") .. 'Defensive', COLORS.get("yellow", "ui") .. 'Unmatched', COLORS.get("grey", "ui") .. 'Community'}),
        { requires_login = true, key = 'cfg_cloud', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    menu_setup.ui.fakelag_stealer = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("download") .. COLORS.get("default", "ui") .. 'Stealer' .. COLORS.get("blue", "ui") .. ' [BETA]' ),
        { requires_login = true, key = 'fakelag_stealer', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.fakelag_stealer_type = menu_setup.register_ui(
        ui.new_combobox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("gear") .. COLORS.get("default", "ui") .. 'Type', 'mimic', 'import'),
        { requires_login = true, key = 'fakelag_stealer_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    menu_setup.ui.fakelag_stealer_target = menu_setup.register_ui(
        ui.new_combobox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("id") .. COLORS.get("default", "ui") .. 'Target', 'threat', 'closest', 'random', 'best kdas'),
        { requires_login = true, key = 'fakelag_stealer_target', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    menu_setup.ui.fakelag_stealer_list = menu_setup.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'target list', {'-'}),
        { requires_login = true, key = 'fakelag_stealer_list', tab = 'AA', visible = true, config_type = 'listbox' }
    )
    menu_setup.ui.fakelag_stealer_refresh = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("refresh") .. COLORS.get("default", "ui") .. 'Refresh', function() end),
        { requires_login = true, key = 'fakelag_stealer_refresh', tab = 'AA', visible = true, config_type = 'button' }
    )
    menu_setup.ui.fakelag_stealer_steal = menu_setup.register_ui(
        ui.new_button(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("clip") .. COLORS.get("default", "ui") .. 'Steal', function() end),
        { requires_login = true, key = 'fakelag_stealer_steal', tab = 'AA', visible = true, config_type = 'button' }
    )
    menu_setup.ui.fakelag_fakelag = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("latency3") .. COLORS.get("default", "ui") .. 'Fakelag'),
        { requires_login = true, key = 'fakelag_fakelag', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.fakelag_fakelag_type = menu_setup.register_ui(
        ui.new_combobox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("gear") .. COLORS.get("default", "ui") .. 'Type', 'gamesense', 'sodium'),
        { requires_login = true, key = 'fakelag_fakelag_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    menu_setup.ui.fakelag_fakelag_amount = menu_setup.register_ui(
        ui.new_combobox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("plus") .. COLORS.get("default", "ui") .. 'Amount', 'dynamic', 'maximum', 'fluctuate'),
        { requires_login = true, key = 'fakelag_fakelag_amount', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    menu_setup.ui.fakelag_fakelag_variance = menu_setup.register_ui(
        ui.new_slider(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("recycle") .. COLORS.get("default", "ui") .. 'Variance', 0, 100, 0, true, '%'),
        { requires_login = true, key = 'fakelag_fakelag_variance', tab = 'AA', visible = true, config_type = 'slider' }
    )
    menu_setup.ui.fakelag_fakelag_limit = menu_setup.register_ui(
        ui.new_slider(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("lock") .. COLORS.get("default", "ui") .. 'Limit', 1, 15, 1, true, 't'),
        { requires_login = true, key = 'fakelag_fakelag_limit', tab = 'AA', visible = true, config_type = 'slider' }
    )
    menu_setup.ui.fakelag_fakelag_type2 = menu_setup.register_ui(
        ui.new_combobox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("config") .. COLORS.get("default", "ui") .. 'Preset', 'jitter', 'max'),
        { requires_login = true, key = 'fakelag_fakelag_type2', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    menu_setup.ui.fakelag_settings_freestanding = menu_setup.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("turning2") .. COLORS.get("default", "ui") .. 'Freestanding options', 'static', 'zero pitch', 'defensive', 'side flip', 'pitch flip'),
        { requires_login = true, key = 'fakelag_settings_freestanding', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    menu_setup.ui.fakelag_settings_enhance_onshot = menu_setup.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("arrow_double") .. COLORS.get("default", "ui") .. 'Enhance on-shot aa', 'defensive', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_enhance_onshot', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    menu_setup.ui.fakelag_settings_antibrute = menu_setup.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("exclamation") .. COLORS.get("default", "ui") .. 'Antibrute', 'defensive', 'flip', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_antibrute', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    menu_setup.ui.fakelag_settings_roll_checkbox = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], '\nuse roll'),
        { requires_login = true, key = 'fakelag_settings_roll_checkbox', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.fakelag_settings_roll_label = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("recycle") .. COLORS.get("default", "ui") .. 'Roll'),
        { requires_login = false, key = 'label_roll', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.fakelag_settings_roll = menu_setup.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nroll', 0, 45, 0, true, '°'),
        { requires_login = true, key = 'fakelag_settings_roll', tab = 'AA', visible = true, config_type = 'slider' }
    )
    menu_setup.ui.fakelag_settings_side = menu_setup.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nside', 1, 3, 1, true, '', 1, {
            [1] = 'left', [2] = 'swap', [3] = 'right'
        }),
        { requires_login = true, key = 'fakelag_settings_side', tab = 'AA', visible = true, config_type = 'slider' }
    )

    
    
    
    menu_setup.ui.paint_advertisement = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nadvertisement', true),
        { requires_login = true, key = 'paint_advertisement', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_advertisement_animation = menu_setup.register_ui(
        ui.new_slider(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("speaker") .. COLORS.get("default", "ui") .. 'Advertisement', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_advertisement_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    menu_setup.ui.paint_advertisement_color = menu_setup.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'rizz546456', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_advertisement_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    menu_setup.ui.paint_watermark = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nwatermark'),
        { requires_login = true, key = 'paint_watermark', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_watermark_type = menu_setup.register_ui(
        ui.new_slider(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("text") .. COLORS.get("default", "ui") .. 'Watermark', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_watermark_type', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    menu_setup.ui.paint_watermark_color = menu_setup.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'sigma9745', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_watermark_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    menu_setup.ui.label_space2 = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][1], '\n abc'),
        { requires_login = false, key = 'label_space2', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.label_space3 = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][1], COLORS.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space3', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.paint_entidx = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'entidx'),
        { requires_login = true, key = 'paint_entidx', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_target_info = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'target info'),
        { requires_login = true, key = 'paint_target_info', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_filter_console = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'filter console'),
        { requires_login = true, key = 'paint_filter_console', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_minimum_damage = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'minimum damage'),
        { requires_login = true, key = 'paint_minimum_damage', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_show_damage_penetration = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'show damage penetration'),
        { requires_login = true, key = 'paint_show_damage_penetration', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_hitmiss_indicator = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'hit/miss indicator'),
        { requires_login = true, key = 'paint_hitmiss_indicator', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_self_skeleton = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'self skeleton'),
        { requires_login = true, key = 'paint_self_skeleton', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_bullet_tracer = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'bullet tracer'),
        { requires_login = true, key = 'paint_bullet_tracer', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_lagcomp_box = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lagcomp box'),
        { requires_login = true, key = 'paint_lagcomp_box', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_lagcomp_box_color = menu_setup.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'lagcomp box color', 47, 117, 221, 255),
        { requires_login = true, key = 'paint_lagcomp_box_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    menu_setup.ui.paint_presmoke = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'presmoke warning'),
        { requires_login = true, key = 'paint_presmoke', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_bombwarning = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'c4 warning'),
        { requires_login = true, key = 'paint_bombwarning', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_insults = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'insults'),
        { requires_login = true, key = 'paint_insults', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_rainbow_esp = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'rainbow esp'),
        { requires_login = true, key = 'paint_rainbow_esp', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_molotov = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'molotov particles'),
        { requires_login = true, key = 'paint_molotov', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_lag_record = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lag record'),
        { requires_login = true, key = 'paint_lag_record', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.label_space4 = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][1], COLORS.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space4', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.paint_clantag = menu_setup.register_ui(
        ui.new_combobox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("id") .. COLORS.get("default", "ui") .. 'Clantag', 'off', 'gamesense', 'sodium'),
        { requires_login = true, key = 'paint_clantag', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    menu_setup.ui.paint_aimbot_logs = menu_setup.register_ui(
        ui.new_combobox(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("clipboard") .. COLORS.get("default", "ui") .. 'Aimbot logs', 'off', 'gamesense', 'gamesense beta', 'sodium'),
        { requires_login = true, key = 'paint_aimbot_logs', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    menu_setup.ui.label_space1 = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][1], '\nextra space'),
        { requires_login = false, key = 'label_space1', tab = 'AA', visible = true, config_type = 'label' }
    )
    
    menu_setup.ui.paint_indicators_enable = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n enable'),
        { requires_login = true, key = 'paint_indicators_enable', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_indicators_label = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("pallete") .. COLORS.get("default", "ui") .. 'Indicators'),
        { requires_login = false, key = 'paint_indicators_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.paint_indicators = menu_setup.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nIndicators', 'off', 'small', 'bold'),
        { requires_login = true, key = 'paint_indicators', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    menu_setup.ui.paint_indicator_color = menu_setup.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_indicator_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    menu_setup.ui.paint_indicators_bar = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n bar'),
        { requires_login = true, key = 'paint_indicators_bar', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_indicators_animation = menu_setup.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_indicators_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    menu_setup.ui.paint_logger_checkbox = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n abc'),
        { requires_login = true, key = 'paint_logger_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_logger_label = menu_setup.register_ui(
        ui.new_label(tab[2], cont[2][1], COLORS.get("green", "ui") .. emojis.get("pen") .. COLORS.get("default", "ui") .. 'Logger'),
        { requires_login = false, key = 'paint_logger_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    menu_setup.ui.paint_logger = menu_setup.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\nLogger', 'aimbot', 'config', 'anti-aim', 'other'),
        { requires_login = true, key = 'paint_logger', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    menu_setup.ui.paint_logger_color = menu_setup.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_logger_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    menu_setup.ui.paint_logger_animation = menu_setup.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_logger_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    menu_setup.ui.paint_hitmarker = menu_setup.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("reject") .. COLORS.get("default", "ui") .. 'Hitmarkers', 'world +', 'skeleton', 'damage'),
        { requires_login = true, key = 'paint_hitmarker', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    menu_setup.ui.paint_hitmarker_color = menu_setup.register_ui(
        ui.new_color_picker(tab[2], cont[2][2], '\n + color', 0, 225, 225, 255),
        { requires_login = true, key = 'paint_hitmarker_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    menu_setup.ui.paint_warnings = menu_setup.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("warning") .. COLORS.get("default", "ui") .. 'Warnings', 'lethal', 'cant fire', 'low bullets'),
        { requires_login = true, key = 'paint_warnings', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    menu_setup.ui.paint_performance_mode = menu_setup.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("latency4") .. COLORS.get("default", "ui") .. 'Performance mode', 'blood', 'ragdolls', 'particles', 'lens flare', 'animations', 'feature updates'),
        { requires_login = true, key = 'paint_performance_mode', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    menu_setup.ui.paint_animations = menu_setup.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], COLORS.get("green", "ui") .. emojis.get("turning2") .. COLORS.get("default", "ui") .. 'Animations', 'kingaru', 'body lean', 'gamesense legs', 'moonwalk', 'allah', 'static legs', 'no pitch on land', 'reversed legs', 'earthquake', 't-pose', 'blind', 'pitch up'),
        { requires_login = true, key = 'paint_animations', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    menu_setup.ui.paint_aspect_ratio_checkbox = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], COLORS.get("green", "ui") .. emojis.get("expand") .. COLORS.get("default", "ui") .. 'Aspect ratio'),
        { requires_login = true, key = 'paint_aspect_ratio_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_aspect_ratio = menu_setup.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\naspect ratio', 0, 300, 0, true, '', 0.01, {
            [0] = 'default', [125] = '5:4', [133] = '4:3', [150] = '3:2', [160] = '16:10', [177] = '16:9'
        }),
        { requires_login = true, key = 'paint_aspect_ratio', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    menu_setup.ui.paint_third_person_distance_checkbox = menu_setup.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], COLORS.get("green", "ui") .. emojis.get("camera") .. COLORS.get("default", "ui") .. 'Third person distance'),
        { requires_login = true, key = 'paint_third_person_distance_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    menu_setup.ui.paint_third_person_distance = menu_setup.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\nthird person distance', 30, 166, 150, true, '', 1, {
            [150] = 'default'
        }),
        { requires_login = true, key = 'paint_third_person_distance', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    
    
    
    
    local type_map = {
        checkbox = 'c',
        slider = 's',
        combobox = 'o',
        multiselect = 'm',
    }
    for key, item in pairs(menu_setup.ui) do
        for _, entry in ipairs(menu_setup.registered_items or {}) do
            if entry.key == key and entry.config_type and type_map[entry.config_type] then
                config_system.register(key, item, type_map[entry.config_type], entry.tab)
            end
        end
    end
end

return build_menu]]
__bundle["require/abc/callbacks"] = [[




local callbacks = {}

local next_id = 1
local regs = {}          
local by_event = {}      
local dispatchers = {}   

local function safe_require_login()
	local ok, login = pcall(require, "require/abc/login_system")
	if not ok or not login then return false end
	return login.logged_in == true
end

local function requirements_ok(opts)
	if not opts then return true end
	if opts.menu_only and not (ui and ui.is_menu_open and ui.is_menu_open()) then return false end
	if opts.alive_only then
		local lp = (entity and entity.get_local_player) and entity.get_local_player()
		if not lp or not entity.is_alive(lp) then return false end
	end
	if opts.require_login then
		if not safe_require_login() then return false end
	end
	return true
end

local function make_dispatcher(event)
	return function(ev)
		local handlers = by_event[event]
		if not handlers then return end
		local snap = {}
		for i=1,#handlers do snap[i] = handlers[i] end
		for i=1,#snap do
			local id = snap[i]
			local reg = regs[id]
			if reg and reg.wrapper then
				local ok, err = pcall(reg.wrapper, ev)
				if not ok then
					local info = nil
					pcall(function()
						info = debug.getinfo(reg.user_fn, "Sln")
					end)
					local src = info and info.short_src or "<unknown>"
					local lined = info and (info.linedefined or -1) or -1
					pcall(client.error_log, string.format("callback[%d] error: %s (source=%s:%d)", id, tostring(err), src, lined))
				end
			end
		end
	end
end



function callbacks.register(event, fn, a, b, c)
	if type(event) ~= 'string' then error('event must be a string') end
	if type(fn) ~= 'function' then error('callback must be a function') end

	local opts = nil
	if type(a) == 'table' then opts = a
	else
		opts = { menu_only = (a == true), alive_only = (b == true), require_login = (c == true) }
	end

	local id = next_id; next_id = next_id + 1
	local wrapper = function(ev)
		if requirements_ok(opts) then
			return fn(ev)
		end
	end

	regs[id] = { event = event, wrapper = wrapper, user_fn = fn, opts = opts }
	by_event[event] = by_event[event] or {}
	by_event[event][#by_event[event] + 1] = id

	
	if not dispatchers[event] then
		local disp = make_dispatcher(event)
		dispatchers[event] = disp
		pcall(client.set_event_callback, event, disp)
	end

	return id
end

function callbacks.callback(event, a, b, c, d)
	if type(a) == 'function' then
		return callbacks.register(event, a, b)
	end
	if type(d) == 'function' then
		local fn = d
		local opts = { menu_only = (a == true), alive_only = (b == true), require_login = (c == true) }
		return callbacks.register(event, fn, opts)
	end
	error('invalid callback signature')
end

function callbacks.unregister(id)
	local reg = regs[id]
	if not reg then return false end
	local event = reg.event
	regs[id] = nil
	local list = by_event[event]
	if list then
		for i=#list,1,-1 do if list[i] == id then table.remove(list, i) end end
		if #list == 0 then
			by_event[event] = nil
			local disp = dispatchers[event]
			if disp then pcall(client.unset_event_callback, event, disp) end
			dispatchers[event] = nil
		end
	end
	return true
end

function callbacks.clear_all()
	for event, disp in pairs(dispatchers) do
		pcall(client.unset_event_callback, event, disp)
	end
	regs = {}
	by_event = {}
	dispatchers = {}
end

function callbacks._list()
	return { regs = regs, by_event = by_event }
end

pcall(function()
	if lua and lua.defer then
		lua.defer(callbacks.clear_all)
	else
		pcall(client.set_event_callback, 'shutdown', callbacks.clear_all)
	end
end)

return callbacks
]]
__bundle["require/abc/config_cloud"] = [[local M = {
    Reset = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfbW92ZXx0PW98dj1vZmYKeWF3X2Zha2VsYWd8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wK3x0PXN8dj0wCmZha2VsYWdfc2V0dGluZ3Nfc2lkZXx0PXN8dj0xCnBpdGNoX21vdmV8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbW92ZXx0PXN8dj0wCmZha2VsYWdfZm9yY2Vfb258dD1tfHY9CmZha2VsYWdfZGVmZW5zaXZlfHQ9Y3x2PWZhbHNlCnlhd193YWxrfHQ9b3x2PW9mZgpzdGF0aWNfYm9keV95YXdfZmFrZWxhZ3x0PXN8dj0wCnBpdGNoX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfanVtcHx0PXN8dj0yCmJvZHlfeWF3X21vZGVfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXArfHQ9c3x2PTIKeWF3X2ppdHRlcl9iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfYmFzZV9kdWNrK3x0PW98dj10YXJnZXQKb25seV9mbGlwX29uXzBfY2hva2VfZHVjayt8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PWZhbHNlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9MApib2R5X3lhd19sZWZ0X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19zdGFuZHx0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19nbG9iYWx8dD1zfHY9MApwaXRjaF9kdWNrfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PW9mZgp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRhcmdldApmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wfHQ9c3x2PTAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PQpzZW5kX2NvbWJvanVtcHx0PW98dj1nbG9iYWwKc2VuZF9jb21ib2p1bXArfHQ9b3x2PWdsb2JhbApvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj1mYWxzZQpzdGF0aWNfYm9keV95YXdfbW92ZXx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVjayt8dD1zfHY9MAp5YXdfYmFzZV9nbG9iYWx8dD1vfHY9dGFyZ2V0CmVuYWJsZV9sZWdpdHx0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PQpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9kdWNrK3x0PXN8dj0yCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfdmFsdWVfbGVnaXR8dD1zfHY9Mgpib2R5X3lhd19iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfanVtcCt8dD1vfHY9b2ZmCmRlbGF5X3dhbGt8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdHlwZTJ8dD1vfHY9aml0dGVyCnlhd19sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9zdGFuZHx0PXN8dj0wCmVuYWJsZV9qdW1wK3x0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZmFrZWxhZ3x0PW98dj1nbG9iYWwKeWF3X2ppdHRlcl9iYXNlX2R1Y2t8dD1zfHY9MApmaWZ0eV9maWZ0eV9qdW1wfHQ9Y3x2PWZhbHNlCnBpdGNoX2xlZ2l0fHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfc3RhbmR8dD1zfHY9MAp5YXdfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfanVtcHx0PW98dj1vZmYKYm9keV95YXdfcmlnaHRfZHVja3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVjayt8dD1zfHY9MApib2R5X3lhd19tb2RlX3dhbGt8dD1vfHY9b2ZmCmJvZHlfeWF3X3JpZ2h0X2p1bXArfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10YXJnZXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj1mYWxzZQp5YXdfanVtcHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV93YWxrfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19nbG9iYWx8dD1zfHY9MApmaWZ0eV9maWZ0eV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfbW92ZXx0PW98dj1vZmYKeWF3X2Jhc2VfanVtcCt8dD1vfHY9dGFyZ2V0CnBpdGNoX2R1Y2srfHQ9b3x2PW1pbmltYWwKYm9keV95YXdfbW9kZV9qdW1wK3x0PW98dj1vZmYKc2VuZF9jb21ib2R1Y2t8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfZmFrZWxhZ3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVja3x0PW98dj1vZmYKZmFrZWxhZ19zdGVhbGVyX3RhcmdldHx0PW98dj10aHJlYXQKZmlmdHlfZmlmdHlfZHVjayt8dD1jfHY9ZmFsc2UKb25seV9mbGlwX29uXzBfY2hva2VfanVtcHx0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTAKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0wCmRlbGF5X2R1Y2srfHQ9c3x2PTEKYm9keV95YXdfbW9kZV9sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfZHVja3x0PXN8dj0yCmVuYWJsZV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PW9mZgp5YXdfYmFzZV9zdGFuZHx0PW98dj10YXJnZXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PW9mZgp5YXdfaml0dGVyX3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2xlZ2l0fHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19iYXNlX2xlZ2l0fHQ9b3x2PXRhcmdldApzdGF0aWNfYm9keV95YXdfd2Fsa3x0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X2Zha2VsYWd8dD1zfHY9MApkZWxheV9kdWNrfHQ9c3x2PTEKZmFrZWxhZ19zZXR0aW5nc19yb2xsfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2xpbWl0fHQ9c3x2PTEKZmFrZWxhZ19mYWtlbGFnX3ZhcmlhbmNlfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2Ftb3VudHx0PW98dj1keW5hbWljCmZha2VsYWdfZmFrZWxhZ190eXBlfHQ9b3x2PWdhbWVzZW5zZQpyYW5kb21pemVfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9nbG9iYWx8dD1zfHY9MApyYW5kb21pemVfeWF3X3dhbGt8dD1zfHY9MApjZmdfc2VsZWN0aW9ufHQ9bXx2PWFudGlhaW0KYm9keV95YXdfdmFsdWVfbW92ZXx0PXN8dj0yCmZpZnR5X2ZpZnR5X21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfbW92ZXx0PWN8dj1mYWxzZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ3x0PWN8dj1mYWxzZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfd2Fsa3x0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9zdGFuZHx0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZHVjayt8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnlhd19qaXR0ZXJfanVtcCt8dD1vfHY9b2ZmCnlhd19iYXNlX2p1bXB8dD1vfHY9dGFyZ2V0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKcGl0Y2hfanVtcCt8dD1vfHY9b2ZmCnlhd19kdWNrfHQ9b3x2PW9mZgpkZWxheV9qdW1wK3x0PXN8dj0xCmRlbGF5X3N0YW5kfHQ9c3x2PTEKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj0wCmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVja3x0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10YXJnZXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9MApib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgpib2R5X3lhd19sZWZ0X2dsb2JhbHx0PXN8dj0wCmRlbGF5X21vdmV8dD1zfHY9MQpkZWxheV9qdW1wfHQ9c3x2PTEKZW5hYmxlX2p1bXB8dD1jfHY9ZmFsc2UKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PTAKYm9keV95YXdfbGVmdF9qdW1wK3x0PXN8dj0wCnlhd19tb3ZlfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PWZhbHNlCmZha2VsYWdfZmFrZWRlZnx0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX2dsb2JhbHx0PW98dj1vZmYKZmlmdHlfZmlmdHlfanVtcCt8dD1jfHY9ZmFsc2UKY29uZGl0aW9ufHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X21vdmV8dD1zfHY9MApkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PWZhbHNl0000',
    Defensive = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9dHJ1ZQp5YXdfd2Fsa3x0PW98dj0xODAKc3RhdGljX2JvZHlfeWF3X2Zha2VsYWd8dD1zfHY9MApwaXRjaF9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXB8dD1zfHY9Mgpib2R5X3lhd19tb2RlX3N0YW5kfHQ9b3x2PWppdHRlcgpib2R5X3lhd192YWx1ZV9qdW1wK3x0PXN8dj0yCnlhd19qaXR0ZXJfYmFzZV9mYWtlbGFnfHQ9c3x2PTAKeWF3X2Jhc2VfZHVjayt8dD1vfHY9dGhyZWF0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2srfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PXRydWUKZGVsYXlfbGVnaXR8dD1zfHY9MQp5YXdfc3RhbmR8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVja3x0PXN8dj0wCmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKcGl0Y2hfZHVja3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfZHVjayt8dD1vfHY9aml0dGVyCnlhd19iYXNlX21vdmV8dD1vfHY9dGhyZWF0CmZha2VsYWdfbW9kZXx0PW98dj1zZXR0aW5ncwpwaXRjaF93YWxrfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9iYXNlX2p1bXB8dD1zfHY9MTIwCnNlbmRfY29tYm93YWxrfHQ9b3x2PWdsb2JhbApmYWtlbGFnX3NldHRpbmdzX2ZyZWVzdGFuZGluZ3x0PW18dj1zdGF0aWMJemVybyBwaXRjaAlkZWZlbnNpdmUJc2lkZSBmbGlwCnNlbmRfY29tYm9qdW1wfHQ9b3x2PWdsb2JhbApzZW5kX2NvbWJvanVtcCt8dD1vfHY9Z2xvYmFsCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXArfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9dHJ1ZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PWRlZmVuc2l2ZQlyb2xsCWppdHRlcgpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9MgpzZW5kX2NvbWJvbGVnaXR8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfbGVnaXR8dD1zfHY9LTU4Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTQKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9MApyYW5kb21pemVfeWF3X2R1Y2srfHQ9c3x2PTAKYm9keV95YXdfbW9kZV93YWxrfHQ9b3x2PXN0YXRpYwpib2R5X3lhd19yaWdodF9qdW1wK3x0PXN8dj0zNwpvbmx5X2ZsaXBfb25fMF9jaG9rZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmZha2VsYWdfc2V0dGluZ3NfYW50aWJydXRlfHQ9bXx2PQp5YXdfYmFzZV93YWxrfHQ9b3x2PXRocmVhdApmYWtlbGFnX3N0ZWFsZXJ8dD1jfHY9ZmFsc2UKZW5hYmxlX3N0YW5kfHQ9Y3x2PXRydWUKeWF3X2p1bXB8dD1vfHY9MTgwCmJvZHlfeWF3X2Jhc2Vfd2Fsa3x0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19zdGFuZHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZ2xvYmFsfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZHVja3x0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX21vdmV8dD1vfHY9aml0dGVyCnlhd19iYXNlX2p1bXArfHQ9b3x2PXRocmVhdApwaXRjaF9kdWNrK3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2p1bXB8dD1zfHY9MTgKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0tMwpkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjcKc2VuZF9jb21ib21vdmV8dD1vfHY9Z2xvYmFsCnJhbmRvbWl6ZV95YXdfbW92ZXx0PXN8dj0wCnBpdGNoX2p1bXB8dD1vfHY9ZG93bgp5YXdfYmFzZV9zdGFuZHx0PW98dj10aHJlYXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9zdGFuZHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2dsb2JhbHx0PWN8dj1mYWxzZQp5YXdfYmFzZV9sZWdpdHx0PW98dj10aHJlYXQKc3RhdGljX2JvZHlfeWF3X3dhbGt8dD1zfHY9MApib2R5X3lhd19yaWdodF9mYWtlbGFnfHQ9c3x2PTAKZGVsYXlfZHVja3x0PXN8dj01CmZha2VsYWdfc2V0dGluZ3Nfcm9sbHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19saW1pdHx0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ192YXJpYW5jZXx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19hbW91bnR8dD1vfHY9ZHluYW1pYwpmYWtlbGFnX2Zha2VsYWdfdHlwZXx0PW98dj1zb2RpdW0KcmFuZG9taXplX3lhd19qdW1wfHQ9c3x2PTAKeWF3X2ppdHRlcl9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKcmFuZG9taXplX3lhd193YWxrfHQ9c3x2PTAKY2ZnX3NlbGVjdGlvbnx0PW18dj1hbnRpYWltCmJvZHlfeWF3X3ZhbHVlX21vdmV8dD1zfHY9MgpmaWZ0eV9maWZ0eV9tb3ZlfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfYmFzZV9kdWNrK3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX21vdmV8dD1jfHY9dHJ1ZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0yNApmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV93YWxrfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCnNlbmRfY29tYm9kdWNrK3x0PW98dj1nbG9iYWwKYm9keV95YXdfcmlnaHRfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9qdW1wK3x0PW98dj1vZmYKeWF3X2Jhc2VfanVtcHx0PW98dj10aHJlYXQKb25seV9mbGlwX29uXzBfY2hva2VfbGVnaXR8dD1jfHY9dHJ1ZQpib2R5X3lhd19tb2RlX2R1Y2t8dD1vfHY9c3RhdGljCnN0YXRpY19ib2R5X3lhd19sZWdpdHx0PXN8dj0wCnBpdGNoX2p1bXArfHQ9b3x2PWRvd24KeWF3X2R1Y2t8dD1vfHY9MTgwCmRlbGF5X2p1bXArfHQ9c3x2PTMKZGVsYXlfc3RhbmR8dD1zfHY9NApmYWtlbGFnX2ZvcmNlfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X3JpZ2h0X2R1Y2srfHQ9c3x2PTQ0CmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0tMTUKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTE0Cnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9NTgKYm9keV95YXdfdmFsdWVfZ2xvYmFsfHQ9c3x2PTIKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApkZWxheV9tb3ZlfHQ9c3x2PTEKZGVsYXlfanVtcHx0PXN8dj0xCmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTQKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PS0xNgpib2R5X3lhd19sZWZ0X2p1bXArfHQ9c3x2PS05Cnlhd19tb3ZlfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PS0xNQpzdGF0aWNfYm9keV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3dhbGt8dD1jfHY9dHJ1ZQpmYWtlbGFnX2Zha2VkZWZ8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9nbG9iYWx8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmNvbmRpdGlvbnx0PW98dj1zdGFuZApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfbW92ZXx0PXN8dj00MgpkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PXRydWU00=',
    Unmatched = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9MgplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9ZmFsc2UKeWF3X3dhbGt8dD1vfHY9MTgwCnN0YXRpY19ib2R5X3lhd19mYWtlbGFnfHQ9c3x2PTAKcGl0Y2hfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9qdW1wfHQ9c3x2PTIKYm9keV95YXdfbW9kZV9zdGFuZHx0PW98dj1qaXR0ZXIKYm9keV95YXdfdmFsdWVfanVtcCt8dD1zfHY9Mgp5YXdfaml0dGVyX2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19iYXNlX2R1Y2srfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV9kdWNrK3x0PWN8dj10cnVlCnlhd19iYXNlX2Zha2VsYWd8dD1vfHY9dGFyZ2V0CnNlbmRfY29tYm9nbG9iYWx8dD1vfHY9Z2xvYmFsCnN0YXRpY19ib2R5X3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3dhbGt8dD1zfHY9MgplbmFibGVfd2Fsa3x0PWN8dj10cnVlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9LTM0CmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIxCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX3dhbGt8dD1zfHY9MApib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PWppdHRlcgpmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9ZG93bgp5YXdfaml0dGVyX2Jhc2VfanVtcHx0PXN8dj0xMjAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PXN0YXRpYwlkZWZlbnNpdmUKc2VuZF9jb21ib2p1bXB8dD1vfHY9Z2xvYmFsCnNlbmRfY29tYm9qdW1wK3x0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9ZmFsc2UKZmFrZWxhZ19zZXR0aW5nc19lbmhhbmNlX29uc2hvdHx0PW18dj1kZWZlbnNpdmUJcm9sbAlqaXR0ZXIKc3RhdGljX2JvZHlfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2Jhc2VfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF93YWxrfHQ9c3x2PTIzCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTIKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9NDQKcmFuZG9taXplX3lhd19kdWNrK3x0PXN8dj0wCmJvZHlfeWF3X21vZGVfd2Fsa3x0PW98dj1zdGF0aWMKYm9keV95YXdfcmlnaHRfanVtcCt8dD1zfHY9NTQKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10aHJlYXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj10cnVlCnlhd19qdW1wfHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3dhbGt8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfc3RhbmR8dD1zfHY9MApyYW5kb21pemVfeWF3X2dsb2JhbHx0PXN8dj0wCmZpZnR5X2ZpZnR5X2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9tb3ZlfHQ9b3x2PWppdHRlcgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9zdGFuZHx0PWN8dj10cnVlCmJvZHlfeWF3X2Jhc2VfanVtcHx0PXN8dj03CmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTI0CnJhbmRvbWl6ZV95YXdfZmFrZWxhZ3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfanVtcCt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9zdGFuZHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfanVtcCt8dD1zfHY9MApkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PWRvd24KeWF3X2Jhc2Vfc3RhbmR8dD1vfHY9dGhyZWF0Cnlhd19qaXR0ZXJfZmFrZWxhZ3x0PW98dj1vZmYKc2VuZF9jb21ib3N0YW5kfHQ9b3x2PWdsb2JhbApwaXRjaF9zdGFuZHx0PW98dj1kb3duCnlhd19qaXR0ZXJfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbGVnaXR8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV9nbG9iYWx8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfbGVnaXR8dD1vfHY9dGFyZ2V0CnN0YXRpY19ib2R5X3lhd193YWxrfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfZmFrZWxhZ3x0PXN8dj0wCmRlbGF5X2R1Y2t8dD1zfHY9NQpmYWtlbGFnX3NldHRpbmdzX3JvbGx8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfbGltaXR8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdmFyaWFuY2V8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfYW1vdW50fHQ9b3x2PWR5bmFtaWMKZmFrZWxhZ19mYWtlbGFnX3R5cGV8dD1vfHY9c29kaXVtCnlhd19qaXR0ZXJfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2dsb2JhbHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfd2Fsa3x0PXN8dj0wCmNmZ19zZWxlY3Rpb258dD1tfHY9YW50aWFpbQpib2R5X3lhd192YWx1ZV9tb3ZlfHQ9c3x2PTIKZmlmdHlfZmlmdHlfbW92ZXx0PWN8dj1mYWxzZQpkZWxheV9tb3ZlfHQ9c3x2PTMKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmZha2VsYWdfc3RlYWxlcl90eXBlfHQ9b3x2PW1pbWljCmJvZHlfeWF3X3JpZ2h0X3N0YW5kfHQ9c3x2PTQwCnBpdGNoX2R1Y2t8dD1vfHY9ZG93bgpmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQplbmFibGVfbW92ZXx0PWN8dj10cnVlCmVuYWJsZV9nbG9iYWx8dD1jfHY9ZmFsc2UKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApib2R5X3lhd19yaWdodF9tb3ZlfHQ9c3x2PTQyCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXArfHQ9b3x2PW9mZgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj10cnVlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1qaXR0ZXIKZGVsYXlfc3RhbmR8dD1zfHY9MQp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApwaXRjaF9qdW1wK3x0PW98dj1kb3duCmRlbGF5X2p1bXArfHQ9c3x2PTUKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQplbmFibGVfZmFrZWxhZ3x0PWN8dj1mYWxzZQpvbmx5X2ZsaXBfb25fMF9jaG9rZV9tb3ZlfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX21vdmV8dD1zfHY9MAp5YXdfZ2xvYmFsfHQ9b3x2PW9mZgpjYWNoZV9jcmVkZW50aWFsc3x0PWN8dj10cnVlCnJhbmRvbWl6ZV95YXdfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF9sZWdpdHx0PXN8dj0wCmRlbGF5X2dsb2JhbHx0PXN8dj0xCmRlbGF5X2p1bXB8dD1zfHY9MQpib2R5X3lhd19sZWZ0X2p1bXB8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2xlZnRfd2Fsa3x0PXN8dj0tMTYKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcCt8dD1zfHY9LTE4Cnlhd19kdWNrfHQ9b3x2PTE4MAp5YXdfYmFzZV9qdW1wK3x0PW98dj10aHJlYXQKeWF3X21vdmV8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVjayt8dD1zfHY9LTE1CmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKZmFrZWxhZ19mYWtlZGVmfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZ2xvYmFsfHQ9b3x2PW9mZgp5YXdfYmFzZV9qdW1wfHQ9b3x2PXRocmVhdApjb25kaXRpb258dD1vfHY9ZHVjaysKc2VuZF9jb21ib2R1Y2srfHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj00NAp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX2R1Y2srfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2Zha2VsYWd8dD1vfHY9b2ZmCmRlbGF5X2Zha2VsYWd8dD1zfHY9MQpzdGF0aWNfYm9keV95YXdfZHVjayt8dD1zfHY9MAp5YXdfaml0dGVyX2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXB8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X3dhbGt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfZmFrZWxhZ3x0PWN8dj1mYWxzZQpwaXRjaF9kdWNrK3x0PW98dj1kb3du0000',
    Community = '',
}
return M]]
__bundle["require/abc/config_system"] = [[


local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

local function base64_encode(data)
    return ((data:gsub('.', function(x)
        local r,b='',x:byte()
        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
        return r
    end)..'0000'):gsub('%d%d%d%d%d%d', function(x)
        if (#x < 6) then return '' end
        return b:sub(tonumber(x,2)+1,tonumber(x,2)+1)
    end)..({ '', '==', '=' })[#data%3+1])
end

local function base64_decode(data)
    data = string.gsub(data, '[^'..b..'=]', '')
    return (data:gsub('.', function(x)
        if x == '=' then return '' end
        local r,f='',(b:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r
    end):gsub('%d%d%d%d%d%d%d%d', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end





local database = database

local REGISTRY = {}
local KEY_MAP = {}

local function register(key, ref, type_char, tab)
    if not key or key == '' or not ref or KEY_MAP[key] then return end
    REGISTRY[#REGISTRY+1] = { key = key, ref = ref, type = type_char, tab = tab }
    KEY_MAP[key] = REGISTRY[#REGISTRY]
end

local function build_encoded_config(include_tabs)
    local function should_include(item_tab, include_tabs)
        if not include_tabs or #include_tabs == 0 then return true end
        if item_tab == 'CFG' then return true end
        if not item_tab then return true end
        for _, t in ipairs(include_tabs) do if t == item_tab then return true end end
        return false
    end

    local lines = { 'v=1' }
    for i = 1, #REGISTRY do
        local item = REGISTRY[i]
        if should_include(item.tab, include_tabs) then
            local t = item.type
            local v = ui.get(item.ref)
            if t == 'c' then
                lines[#lines+1] = item.key .. '|t=c|v=' .. (v and 'true' or 'false')
            elseif t == 's' then
                lines[#lines+1] = item.key .. '|t=s|v=' .. tostring(v or 0)
            elseif t == 'o' then
                lines[#lines+1] = item.key .. '|t=o|v=' .. tostring(v or '')
            elseif t == 'm' then
                if type(v) == 'table' then
                    lines[#lines+1] = item.key .. '|t=m|v=' .. table.concat(v, '\t')
                end
            end
        end
    end
    return base64_encode(table.concat(lines, '\n'))
end

local function apply_encoded_config(enc, include_tabs)
    if not enc or enc == '' then return end
    local ok, raw = pcall(base64_decode, enc)
    if not ok or not raw or raw == '' then return end
    local function should_include(item_tab, include_tabs)
        if not include_tabs or #include_tabs == 0 then return true end
        if item_tab == 'CFG' then return true end
        if not item_tab then return true end
        for _, t in ipairs(include_tabs) do if t == item_tab then return true end end
        return false
    end
    for line in raw:gmatch('([^\n]+)') do
        if line ~= 'v=1' then
            local key, tseg, vseg = line:match('^(.-)|t=(.)|v=(.*)$')
            if key and tseg and vseg then
                local item = KEY_MAP[key]
                if item and item.type == tseg and should_include(item.tab, include_tabs) then
                    if tseg == 'c' then
                        ui.set(item.ref, vseg == 'true')
                    elseif tseg == 's' then
                        local num = tonumber(vseg)
                        if num ~= nil then
                            ui.set(item.ref, num)
                        end
                    elseif tseg == 'o' then
                        pcall(ui.set, item.ref, vseg)
                    elseif tseg == 'm' then
                        local values = {}
                        for token in vseg:gmatch('[^\t]+') do values[#values+1] = token end
                        ui.set(item.ref, values)
                    end
                end
            end
        end
    end
end


local function save_config(name, include_tabs)
    if not name or name == '' then return end
    local enc = build_encoded_config(include_tabs)
    database.write('cfg:' .. name, enc)
end


local function load_config(name, include_tabs)
    if not name or name == '' then return end
    local enc = database.read('cfg:' .. name)
    if enc then apply_encoded_config(enc, include_tabs) end
end


local function delete_config(name)
    if not name or name == '' then return end
    database.write('cfg:' .. name, nil)
end


local config_system = {
    register = register,
    build = build_encoded_config,
    apply = apply_encoded_config,
    save = save_config,
    load = load_config,
    delete = delete_config,
}

return config_system]]
__bundle["require/abc/garbage_collector"] = [[local gc = {}

local params = {
    pause = 200,
    stepmul = 600,
    mode = "collect"
}

function gc.tune(opts)
	if type(opts) == "table" then
		if opts.pause then
			collectgarbage("setpause", opts.pause)
			params.pause = opts.pause
		end
		if opts.stepmul then
			collectgarbage("setstepmul", opts.stepmul)
			params.stepmul = opts.stepmul
		end
		if opts.mode then
			params.mode = opts.mode
		end
	end
end

function gc.collect(mode)
	collectgarbage(mode or params.mode)
end

function gc.step(step_size)
	return collectgarbage("step", step_size or 0)
end

function gc.stop()
	collectgarbage("stop")
end

function gc.restart()
	collectgarbage("restart")
end

function gc.memory()
	return collectgarbage("count")
end

function gc.status()
	return {
		memory = gc.memory(),
		pause = params.pause,
		stepmul = params.stepmul,
		mode = params.mode
	}
end

local _dynamic_last = 0
function gc.dynamic(opts)
	opts = type(opts) == "table" and opts or {}
	local min_interval = opts.min_interval or 0.6
	local now = (globals and globals.realtime) and globals.realtime() or (_dynamic_last + min_interval)
	if now - _dynamic_last < min_interval then
		return
	end
	_dynamic_last = now

	local step_size = opts.step_size or 20
	local full_threshold_kb = opts.full_threshold_kb or 65536
	local aggressive_threshold_kb = opts.aggressive_threshold_kb or 12288

	local ok, mem = pcall(collectgarbage, "count")
	if not ok or type(mem) ~= "number" then
		pcall(collectgarbage, "step", step_size)
		return
	end

	if mem >= full_threshold_kb then
		pcall(collectgarbage, "collect")
		return
	end

	if mem >= aggressive_threshold_kb then
		pcall(collectgarbage, "step", step_size)
		pcall(collectgarbage, "step", step_size)
		return
	end

	pcall(collectgarbage, "step", step_size)
end

if lua and lua.defer then
	lua.defer(function()
		gc.collect()
	end)
end

return gc]]
__bundle["require/abc/login_system"] = [[local login_system = {}


local function sha256(str)
	if client.hash_sha256 then
		return client.hash_sha256(str)
	end
	
	return tostring(str):reverse()
end


local ACCOUNTS_DB_KEY = "acc_" .. "897ntv45ynvttyjt980745nyv0t485vn87t6"

local function generate_salt()
	local charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local salt = ""
	for i = 1, 16 do
		local idx = math.random(1, #charset)
		salt = salt .. charset:sub(idx, idx)
	end
	return salt
end

function login_system.hash_password(password, salt)
	return sha256(salt .. password)
end

function login_system.verify_password(password, hash, salt)
	return login_system.hash_password(password, salt) == hash
end

function login_system.get_hwid()
	
	return tostring(client.userid_to_entindex(client.userid_to_entindex(1)))
end

function login_system.store_credentials(username, password)
	local salt = generate_salt()
	local hash = login_system.hash_password(password, salt)
	database.write("login_credentials", { username = username, hash = hash, salt = salt })
end

function login_system.load_credentials()
	return database.read("login_credentials")
end


function login_system.login(username, password)
	
	local accounts = database.read(ACCOUNTS_DB_KEY) or {}
	local acc = accounts[username]
	if acc and acc.enabled ~= false then
		if login_system.verify_password(password, acc.hash, acc.salt) then
			login_system.logged_in = true
			return true
		end
	end
	
	local creds = login_system.load_credentials()
	if creds and creds.username == username then
		if login_system.verify_password(password, creds.hash, creds.salt) then
			login_system.logged_in = true
			return true
		end
	end
	login_system.logged_in = false
	return false
end

function login_system.logout()
	login_system.logged_in = false
end

function login_system.reset_password(username_or_hwid)
	
	database.write("login_credentials", nil)
end



function login_system.is_valid_invite(invite_code)
	if not invite_code or invite_code == "" then
		return false, nil
	end
	local invites = database.read(ACCOUNTS_DB_KEY .. ":invites") or {}
	local entry = invites[invite_code]
	if not entry then
		return false, nil
	end
	if entry.used then
		return false, entry
	end
	return true, entry
end

function login_system.add_account(username, password)
	local salt = generate_salt()
	local hash = login_system.hash_password(password, salt)
	local accounts = database.read(ACCOUNTS_DB_KEY) or {}
	accounts[username] = { hash = hash, salt = salt, role = "user", enabled = true, orig_password = password }
	database.write(ACCOUNTS_DB_KEY, accounts)
end

function login_system.register_with_invite(invite_code, username, password)
	if not invite_code or invite_code == '' then return false, 'no invite provided' end
	local invites = database.read(ACCOUNTS_DB_KEY .. ":invites") or {}
	local entry = invites[invite_code]
	if not entry then return false, 'invalid invite' end
	if entry.used then return false, 'invite already used' end

	login_system.add_account(username, password)

	entry.used = true
	entry.used_by = username
	entry.redeemed_at = client.unix_time()
	invites[invite_code] = entry
	database.write(ACCOUNTS_DB_KEY .. ":invites", invites)

	return true
end

function login_system.invalidate_invite(invite_code)
	local invites = database.read(ACCOUNTS_DB_KEY .. ":invites") or {}
	if invites[invite_code] then
		invites[invite_code] = nil
		database.write(ACCOUNTS_DB_KEY .. ":invites", invites)
		return true
	end
	return false
end

return login_system
]]
__bundle["require/abc/menu_header"] = [[local active_icon, icon_png_width, icon_png_height = 1, 398, 49
local V_SCALE = 0.85 
local TAB_NAMES = { "AA", "PAINT", "MISC", "CFG" }
local current_tab = TAB_NAMES[active_icon]
local icon_texture_ids = {}
local icon_files = {
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS1.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS2.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS3.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS4.png"
}
local last_tab_sections

local skeet_tab_system = {
    size = {
        x = 6,
        y = 6,
        w = 120,
        h = 72, 
    },
    skeet_cur_tab = 8,
}

local function current_skeet_tab_check()
    local pos = { ui.menu_position() }
    local m_pos = { ui.mouse_position() }
    if not pos[1] or not pos[2] or not m_pos[1] or not m_pos[2] then
        return skeet_tab_system.skeet_cur_tab
    end

    for i = 1, 9 do
        local offset = { skeet_tab_system.size.x, skeet_tab_system.size.y + skeet_tab_system.size.h * (i - 1) }
        if m_pos[1] >= pos[1] + offset[1]
           and m_pos[1] <= pos[1] + skeet_tab_system.size.w + offset[1]
           and m_pos[2] >= pos[2] + offset[2]
           and m_pos[2] <= pos[2] + skeet_tab_system.size.h + offset[2] then
            return i
        end
    end

    return skeet_tab_system.skeet_cur_tab
end

local function load_icon_textures()
    if not renderer.load_png or not readfile then return end
    for i, path in ipairs(icon_files) do
        if not icon_texture_ids[i] then
            local png_data = readfile(path)
            if png_data then
                icon_texture_ids[i] = renderer.load_png(png_data, icon_png_width, icon_png_height)
            end
        end
    end
end


local function draw_menu()
    local is_open = ui.is_menu_open()
    local x, y = ui.menu_position()
    local w, h = ui.menu_size()
    w = w-2
    x = x+1
    if is_open and x and y and w and h then
        local render_menu = (skeet_tab_system.skeet_cur_tab == 2)
        local bar_height = math.floor(90 * V_SCALE)
        local pad_outer = math.max(1, math.floor(4 * V_SCALE))
        local pad_grey = math.max(1, math.floor(3 * V_SCALE))
        local pad_dark = math.max(1, math.floor(2 * V_SCALE))
        local pad_accent = math.max(0, math.floor(1 * V_SCALE))
        local pad_fill = 0
        local bar_x = x + pad_outer
        local bar_y = y - math.floor(7 * V_SCALE) - bar_height
        local bar_w = w - 2 * pad_outer

        if render_menu then
            renderer.rectangle(bar_x-pad_outer*1.3, bar_y-8, bar_w+2*pad_outer*1.5-1, bar_height+16, 12, 12, 12, 255)
            renderer.rectangle(bar_x-pad_grey*1.5, bar_y-7, bar_w+2*pad_grey*1.5, bar_height+14, 60, 60, 60, 255)
            renderer.rectangle(bar_x-pad_dark*1.51, bar_y-6, bar_w+2*pad_dark*2, bar_height+12, 40, 40, 40, 255)
            renderer.rectangle(bar_x-pad_accent, bar_y-3, bar_w+2*pad_accent, bar_height+6, 60, 60, 60, 255)
            renderer.rectangle(bar_x-pad_fill, bar_y-2, bar_w+2*pad_fill, bar_height+4, 12, 12, 12, 255)

            local tex_id = nil
            if renderer.load_rgba then
                local ok, texture = pcall(renderer.load_rgba,
                    string.char(
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
                    ), 4, 4)
                if ok and texture then tex_id = texture end
            end
            if tex_id and renderer.texture then
                renderer.texture(tex_id, bar_x-pad_fill, bar_y-2, bar_w+2*pad_fill, bar_height+4, 255,255,255,255, 'r')
            end

            if renderer.gradient then
                renderer.gradient(bar_x-pad_fill, bar_y-2, (bar_w+2*pad_fill)/2+1, 1, 59,175,222,255, 202,70,205,255, true)
                renderer.gradient(bar_x-pad_fill+(bar_w+2*pad_fill)/2+1, bar_y-2, (bar_w+2*pad_fill)/2-1, 1, 202,70,205,255, 204,227,53,255, true)
            end

            local line_height = math.max(1, math.floor(2 * V_SCALE))
            local line_y = bar_y - math.floor(8 * V_SCALE)

            local corner_radius = math.max(1, math.floor(5 * V_SCALE))
            local corner_alpha = 60
            renderer.circle(bar_x-pad_outer+corner_radius, line_y+line_height/2, corner_radius, 59,175,222, corner_alpha, 16)
            renderer.circle(bar_x+bar_w-pad_outer-pad_fill-corner_radius, line_y+line_height/2, corner_radius, 204,227,53, corner_alpha, 16)
        end

        local icon_count = 4
        local icon_y = bar_y + bar_height / 2
        local mouse_x, mouse_y = ui.mouse_position()
        local tab_sections = {}
        local tab_h = bar_height
            local icon_spacing = math.max(1, math.floor(59 * V_SCALE))
            local draw_icon_w = math.max(1, math.floor(icon_png_width * V_SCALE))
            local draw_icon_h = math.max(1, math.floor(icon_png_height * V_SCALE))
            local total_icons_width = icon_count * draw_icon_w + (icon_count - 1) * icon_spacing
            local margin = math.max(0, bar_w * 0.5)
            local icons_start_x = bar_x + margin + (bar_w - 2 * margin - total_icons_width) / 2
            if total_icons_width > bar_w then
                icon_spacing = math.max(0, math.floor((bar_w - icon_count * draw_icon_w) / (icon_count - 1)))
                total_icons_width = icon_count * draw_icon_w + (icon_count - 1) * icon_spacing
                icons_start_x = bar_x + (bar_w - total_icons_width) / 2
            end
        load_icon_textures()
        local tab_w = bar_w / icon_count
        for i=1,icon_count do
            local tab_x = bar_x + (i-1) * tab_w
            local tab_y = bar_y
            tab_sections[i] = {x=tab_x, y=tab_y, w=tab_w, h=tab_h}
            if render_menu then
                if active_icon == i then
                    renderer.rectangle(tab_x, tab_y, tab_w, tab_h+1, 32,32,32, 85)
                end
                local center_x = tab_x + tab_w/2 - draw_icon_w/2
                local center_y = tab_y + tab_h/2 - draw_icon_h/2
                if icon_texture_ids[i] then
                    renderer.texture(icon_texture_ids[i], center_x, center_y, draw_icon_w, draw_icon_h, 255,255,255,255, "f")
                else
                    renderer.text(center_x + draw_icon_w/2, center_y + draw_icon_h/2, 255,255,255,255, '+c', 0, tostring(i))
                end
            end
        end

        local mouse_down = client.key_state(1)
        if is_open and mouse_x and mouse_y and ui.is_menu_open() then
            if mouse_down and not prev_mouse_down then
                for i=1,icon_count do
                    local tab = tab_sections[i]
                    if mouse_x >= tab.x and mouse_x <= tab.x+tab.w and mouse_y >= tab.y and mouse_y <= tab.y+tab.h then
                        active_icon = i
                        current_tab = TAB_NAMES[active_icon]
                    end
                end
                local skeet_pos = { ui.menu_position() }
                if skeet_pos[1] and skeet_pos[2] then
                    for si = 1, 9 do
                        local offset = { skeet_tab_system.size.x, skeet_tab_system.size.y + skeet_tab_system.size.h * (si - 1) }
                        if mouse_x >= skeet_pos[1] + offset[1]
                           and mouse_x <= skeet_pos[1] + skeet_tab_system.size.w + offset[1]
                           and mouse_y >= skeet_pos[2] + offset[2]
                           and mouse_y <= skeet_pos[2] + skeet_tab_system.size.h + offset[2] then
                            skeet_tab_system.skeet_cur_tab = si
                            break
                        end
                    end
                end
            end
            prev_mouse_down = mouse_down
        else
            prev_mouse_down = false
        end
        local hover_idx = current_skeet_tab_check()
        local sel_idx = skeet_tab_system.skeet_cur_tab or 0
        local dbg_txt = "Skeet sel: " .. tostring(sel_idx)
        if hover_idx and hover_idx ~= sel_idx then
            dbg_txt = dbg_txt .. "  (hover: " .. tostring(hover_idx) .. ")"
        end
        if render_menu then
            if renderer.measure_text then
                pcall(function() renderer.measure_text(nil, dbg_txt) end)
            end
            renderer.text(bar_x + 6, bar_y + bar_height + 6, 200,200,200,255, nil, 0, dbg_txt)
        end
    end
end

local function is_mouse_outside_menu()
    if not ui.is_menu_open() then return false end
    local mouse_x, mouse_y = ui.mouse_position()
    local menu_x, menu_y = ui.menu_position()
    local menu_w, menu_h = ui.menu_size()
    local bar_height = math.floor(90 * V_SCALE)
    local pad_outer = math.max(1, math.floor(4 * V_SCALE))
    local bar_x, bar_y, bar_w = menu_x + pad_outer, menu_y - math.floor(7 * V_SCALE) - bar_height, menu_w - 2 * pad_outer
    return not (
        mouse_x >= menu_x and mouse_x <= menu_x + menu_w and mouse_y >= menu_y and mouse_y <= menu_y + menu_h
        or mouse_x >= bar_x and mouse_x <= bar_x + bar_w and mouse_y >= bar_y and mouse_y <= bar_y + bar_height
    )
end

return {
    current_tab = function() return current_tab end,
    current_tab_index = function() return active_icon end,
    tab_names = TAB_NAMES,
    tab_sections = function() return last_tab_sections end,
    menu_position = function() return ui.menu_position() end,
    menu_size = function() return ui.menu_size() end,
    is_menu_open = function() return ui.is_menu_open() end,
    mouse_position = function() return ui.mouse_position() end,
    is_mouse_outside_menu = is_mouse_outside_menu,
    draw_menu = draw_menu
}]]
__bundle["require/abc/menu_setup"] = [[local sodium = {
    ui = {},
    registered_items = {},
}

function sodium.register_ui(item, opts)
    
    
    
    if opts and opts.key then
        for i = #sodium.registered_items, 1, -1 do
            local entry = sodium.registered_items[i]
            if entry and entry.key == opts.key then
                
                pcall(function()
                    if entry.item then ui.set_visible(entry.item, false) end
                end)
                table.remove(sodium.registered_items, i)
            end
        end
    end

    table.insert(sodium.registered_items, {
        item = item,
        key = opts.key,
        requires_login = opts.requires_login,
        tab = opts.tab,
        visible = opts.visible ~= false,
        config_type = opts.config_type,
        show_condition = opts.show_condition,
    })
    return item
end

function sodium.update_visibility(is_logged_in)
    for _, entry in ipairs(sodium.registered_items) do
        local show = entry.visible
        if entry.requires_login and not is_logged_in then
            show = false
        end
        if entry.show_condition then
            show = entry.show_condition()
        end
        if entry.item then
            ui.set_visible(entry.item, show)
        end
    end
end

function sodium.save_config()
    local config = {}
    for _, entry in ipairs(sodium.registered_items) do
        if entry.key and entry.item then
            config[entry.key] = ui.get(entry.item)
        end
    end
    return config
end

function sodium.load_config(cfg)
    for _, entry in ipairs(sodium.registered_items) do
        if entry.key and entry.item and cfg[entry.key] ~= nil then
            ui.set(entry.item, cfg[entry.key])
        end
    end
end

local DEFAULT_GS_ITEMS = {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

local DEFAULT_RAGE = {

    { 'Rage', 'other', 'accuracy boost' },
    { 'Rage', 'other', 'anti-aim correction' },
    { 'rage', 'other', 'automatic fire' },
    { 'Rage', 'other', 'automatic penetration' },
    { 'Rage', 'other', 'silent aim' },
    { 'Rage', 'other', 'remove recoil' },
    { 'Rage', 'other', 'reduce aimstep' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'log misses due to spread' },
    { 'Rage', 'other', 'low fps mitigations ' },
    { 'rage', 'other', 'delay shot' },
    { 'Rage', 'other', 'quick peek assist' },
    { 'Rage', 'other', 'quick peek assist mode' },
    { 'Rage', 'other', 'quick peek assist distance' },
    { 'Rage', 'other', 'reduce aim step' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'low fps mitigations' },
    { 'Rage', 'other', 'duck peek assist' },


}

function sodium.toggle_gamesense_menu(show)
    sodium.state = sodium.state or {}
    sodium.hidden_refs = sodium.hidden_refs or {}
    for _, entry in ipairs(DEFAULT_GS_ITEMS) do
        local ok, ref1, ref2, ref3, ref4 = pcall(ui.reference, entry[1], entry[2], entry[3], entry[4])
        if ok then
            if entry[1] == 'AA' and entry[2] == 'Anti-aimbot angles' and entry[3] == 'Enabled' then
                sodium.state.gs_enabled_ref = ref1
                if ref1 ~= nil and show then
                    if sodium.state.gs_enabled_previous ~= nil then
                        ui.set(ref1, sodium.state.gs_enabled_previous)
                    end
                elseif ref1 ~= nil and not show then
                    sodium.state.gs_enabled_previous = ui.get(ref1)
                    ui.set(ref1, true)
                end
            end
            local refs = { ref1, ref2, ref3, ref4 }
            local stored = {}
            for _, ref in ipairs(refs) do
                if ref ~= nil then
                    ui.set_visible(ref, show)
                    stored[#stored + 1] = ref
                end
            end
            if not show and #stored > 0 then
                table.insert(sodium.hidden_refs, stored)
            end
        end
    end
    sodium.state.gs_hidden = not show
end

function sodium.toggle_rage_menu(show)
    sodium.state = sodium.state or {}
    sodium.hidden_rage_refs = sodium.hidden_rage_refs or {}
    sodium.hidden_rage_refs = {} 

    for _, entry in ipairs(DEFAULT_RAGE) do
        local ok, ref1, ref2, ref3, ref4 = pcall(ui.reference, entry[1], entry[2], entry[3])
        if ok then
            local refs = { ref1, ref2, ref3, ref4 }
            local stored = {}
            for _, ref in ipairs(refs) do
                if ref ~= nil then
                    pcall(function() ui.set_visible(ref, show) end)
                    stored[#stored + 1] = ref
                end
            end
            if not show and #stored > 0 then
                table.insert(sodium.hidden_rage_refs, stored)
            end
        end
    end
    sodium.state.rage_hidden = not show
end

return sodium]]
__bundle["require/abc/menu_visibility"] = [[local conditions = {
	"global",
	"stand",
	"move",
	"duck",
	"duck+",
	"jump",
	"jump+",
	"walk",
	"fakelag",
	"legit",
}

local login_system = require("require/abc/login_system")

local function update_visibility(modules)
	if modules.menu_setup and modules.menu_setup.refresh_cfg_listbox then
		modules.menu_setup.refresh_cfg_listbox()
	end

	if modules and not modules.login then
		modules.login = login_system
	end
	modules.menu_setup.toggle_gamesense_menu(false)
	modules.menu_setup.toggle_rage_menu(true)
	modules.menu_setup.update_visibility(modules.login and modules.login.logged_in)
	local logged_in = (modules.login and modules.login.logged_in) or false

	local show = not logged_in
	local tab_name = (modules.menu_header and modules.menu_header.current_tab and modules.menu_header.current_tab()) or modules.menu.current_tab()
	 	
	ui.set_visible(modules.menu_setup.ui.login_howto_header, show)
	ui.set_visible(modules.menu_setup.ui.login_console_register, show)
	ui.set_visible(modules.menu_setup.ui.login_menu_credentials, show)
	ui.set_visible(modules.menu_setup.ui.login_press_login, show)
	ui.set_visible(modules.menu_setup.ui.login_spacer1, show)
	ui.set_visible(modules.menu_setup.ui.reset_header, show)
	ui.set_visible(modules.menu_setup.ui.reset_step1, show)
	ui.set_visible(modules.menu_setup.ui.reset_step2, show)
	ui.set_visible(modules.menu_setup.ui.login_spacer2, show)
	ui.set_visible(modules.menu_setup.ui.support_header, show)
	ui.set_visible(modules.menu_setup.ui.support_discord, show)
	ui.set_visible(modules.menu_setup.ui.login_username, show)
	ui.set_visible(modules.menu_setup.ui.login_password, show)
	ui.set_visible(modules.menu_setup.ui.cache_credentials, show)
	ui.set_visible(modules.menu_setup.ui.login_button, show)
	ui.set_visible(modules.menu_setup.ui.reset_button, show)
	ui.set_visible(modules.menu_setup.ui.discord_button, show)
	ui.set_visible(modules.menu_setup.ui.youtube_button, show)
	ui.set_visible(modules.menu_setup.ui.sellhub_button, show)
	ui.set_visible(modules.menu_setup.ui.logout_button, logged_in and tab_name == "CFG")

	if modules.menu_setup.ui.condition then
		local selected_condition = ui.get(modules.menu_setup.ui.condition)
		for _, cond in ipairs(conditions) do
			local cond_visible = logged_in and tab_name == "AA" and selected_condition == cond
			local enable_key = 'enable_' .. cond
			if modules.menu_setup.ui[enable_key] then
				ui.set_visible(modules.menu_setup.ui[enable_key], cond_visible)
				local enabled = modules.safe.safe_get(modules.menu_setup.ui[enable_key])

				local yaw = modules.menu_setup.ui['yaw_' .. cond] and ui.get(modules.menu_setup.ui['yaw_' .. cond]) or nil
				local yaw_jitter = modules.menu_setup.ui['yaw_jitter_' .. cond] and ui.get(modules.menu_setup.ui['yaw_jitter_' .. cond]) or nil
				local body_yaw_mode = modules.menu_setup.ui['body_yaw_mode_' .. cond] and ui.get(modules.menu_setup.ui['body_yaw_mode_' .. cond]) or nil
				local delay = modules.menu_setup.ui['delay_' .. cond] and ui.get(modules.menu_setup.ui['delay_' .. cond]) or nil
				ui.set_visible(modules.menu_setup.ui['pitch_' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['yaw_base_' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['yaw_' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['label1_' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['label2_' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['label3_' .. cond], cond_visible and enabled)
				local show_body_yaw_base = cond_visible and enabled and (yaw ~= 'off' and yaw ~= 'ideal' and yaw ~= '3way')
				ui.set_visible(modules.menu_setup.ui['body_yaw_base_' .. cond], show_body_yaw_base)
				local show_body_yaw_lr = cond_visible and enabled and (yaw == '180' or yaw == '3way')
				ui.set_visible(modules.menu_setup.ui['body_yaw_left_' .. cond], show_body_yaw_lr)
				ui.set_visible(modules.menu_setup.ui['body_yaw_right_' .. cond], show_body_yaw_lr)
				local show_randomize_yaw = cond_visible and enabled and (yaw ~= 'off' and yaw ~= 'ideal')
				ui.set_visible(modules.menu_setup.ui['randomize_yaw_' .. cond], show_randomize_yaw)
				local show_yaw_jitter_base = cond_visible and enabled and (yaw_jitter ~= 'off')
				ui.set_visible(modules.menu_setup.ui['yaw_jitter_base_' .. cond], show_yaw_jitter_base)
				local show_static_body_yaw = cond_visible and enabled and (body_yaw_mode == 'static')
				ui.set_visible(modules.menu_setup.ui['static_body_yaw_' .. cond], show_static_body_yaw)
				local show_body_yaw_value = cond_visible and enabled and (body_yaw_mode == 'jitter' and delay and delay <= 0)
				ui.set_visible(modules.menu_setup.ui['body_yaw_value_' .. cond], show_body_yaw_value)
				local show_delay = cond_visible and enabled and (body_yaw_mode == 'jitter')
				ui.set_visible(modules.menu_setup.ui['delay_' .. cond], show_delay)
				ui.set_visible(modules.menu_setup.ui['yaw_jitter_' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['body_yaw_mode_' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['fifty_fifty_' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['only_flip_on_0_choke_' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['aa_label_space' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['aa_label_combo' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['send_button' .. cond], cond_visible and enabled)
				ui.set_visible(modules.menu_setup.ui['send_combo' .. cond], cond_visible and enabled)
			end
		end
		ui.set_visible(modules.menu_setup.ui.condition, logged_in and tab_name == "AA")
		ui.set_visible(modules.menu_setup.ui.condition_label, logged_in and tab_name == "AA")
		ui.set_visible(modules.menu_setup.ui.condition_label2, logged_in and tab_name == "AA")


		ui.set_visible(modules.menu_setup.ui.fakelag_mode, logged_in and tab_name == "AA")
		if modules.menu_setup.ui.fakelag_mode then
			local mode = ui.get(modules.menu_setup.ui.fakelag_mode)
			local show_fakelag_tab = logged_in and tab_name == "AA"
			local show_defensive = show_fakelag_tab and mode == "defensive"
			local defensive_enabled = modules.safe.safe_get(modules.menu_setup.ui.fakelag_defensive) == true
			ui.set_visible(modules.menu_setup.ui.fakelag_defensive, show_defensive)
			ui.set_visible(modules.menu_setup.ui.fakelag_force, show_defensive and defensive_enabled)
			ui.set_visible(modules.menu_setup.ui.fakelag_force_on, show_defensive and defensive_enabled)
			ui.set_visible(modules.menu_setup.ui.fakelag_fakedef, show_defensive and defensive_enabled)

			local show_stealer = show_fakelag_tab and mode == "stealer"
			local stealer_enabled = modules.safe.safe_get(modules.menu_setup.ui.fakelag_stealer) == true
			ui.set_visible(modules.menu_setup.ui.fakelag_stealer, show_stealer)
			ui.set_visible(modules.menu_setup.ui.fakelag_stealer_type, show_stealer and stealer_enabled)
			ui.set_visible(modules.menu_setup.ui.fakelag_stealer_target, show_stealer and stealer_enabled)
			ui.set_visible(modules.menu_setup.ui.fakelag_stealer_list, show_stealer and stealer_enabled)
			ui.set_visible(modules.menu_setup.ui.fakelag_stealer_refresh, show_stealer and stealer_enabled)
			ui.set_visible(modules.menu_setup.ui.fakelag_stealer_steal, show_stealer and stealer_enabled)

			local show_fakelag = show_fakelag_tab and mode == "fakelag"
			local fakelag_enabled = modules.safe.safe_get(modules.menu_setup.ui.fakelag_fakelag) == true
			local fakelagtype = modules.safe.safe_get(modules.menu_setup.ui.fakelag_fakelag_type) == "sodium"
			ui.set_visible(modules.menu_setup.ui.fakelag_fakelag, show_fakelag)
			ui.set_visible(modules.menu_setup.ui.fakelag_fakelag_type, show_fakelag and fakelag_enabled)
			ui.set_visible(modules.menu_setup.ui.fakelag_fakelag_amount, show_fakelag and fakelag_enabled and not fakelagtype)
			ui.set_visible(modules.menu_setup.ui.fakelag_fakelag_variance, show_fakelag and fakelag_enabled and not fakelagtype)
			ui.set_visible(modules.menu_setup.ui.fakelag_fakelag_limit, show_fakelag and fakelag_enabled and not fakelagtype)
			ui.set_visible(modules.menu_setup.ui.fakelag_fakelag_type2, show_fakelag and fakelag_enabled and fakelagtype)

			local show_settings = show_fakelag_tab and mode == "settings"
			ui.set_visible(modules.menu_setup.ui.fakelag_settings_freestanding, show_settings)
			ui.set_visible(modules.menu_setup.ui.fakelag_settings_enhance_onshot, show_settings)
			ui.set_visible(modules.menu_setup.ui.fakelag_settings_antibrute, show_settings)
			ui.set_visible(modules.menu_setup.ui.fakelag_settings_roll_label, show_settings)
			ui.set_visible(modules.menu_setup.ui.fakelag_settings_roll_checkbox, show_settings)
			local roll_enabled = show_settings and modules.safe.safe_get(modules.menu_setup.ui.fakelag_settings_roll_checkbox) == true
			ui.set_visible(modules.menu_setup.ui.fakelag_settings_roll, roll_enabled)
			ui.set_visible(modules.menu_setup.ui.fakelag_settings_side, roll_enabled)
		end

		local paint_indicators_on = logged_in and tab_name == "PAINT" and ui.get(modules.menu_setup.ui.paint_indicators_enable) == true
		local paint_indicators_notoff = logged_in and tab_name == "PAINT" and paint_indicators_on and ui.get(modules.menu_setup.ui.paint_indicators) ~= "off"
		local paint_indicators_small = logged_in and tab_name == "PAINT" and paint_indicators_on and ui.get(modules.menu_setup.ui.paint_indicators) == "small"
		ui.set_visible(modules.menu_setup.ui.paint_indicators, paint_indicators_on)
		ui.set_visible(modules.menu_setup.ui.paint_indicators_enable, paint_indicators_notoff)
		ui.set_visible(modules.menu_setup.ui.paint_indicators_animation, paint_indicators_notoff)
		ui.set_visible(modules.menu_setup.ui.paint_indicators_bar, paint_indicators_small)
		ui.set_visible(modules.menu_setup.ui.paint_indicator_color, paint_indicators_notoff)

		local paint_advertisement_on = logged_in and tab_name == "PAINT" and ui.get(modules.menu_setup.ui.paint_advertisement) == true
		ui.set_visible(modules.menu_setup.ui.paint_advertisement_color, paint_advertisement_on)

		local paint_watermark_on = logged_in and tab_name == "PAINT" and ui.get(modules.menu_setup.ui.paint_watermark) == true
		ui.set_visible(modules.menu_setup.ui.paint_watermark_color, paint_watermark_on)

		local misc_dormantaimbot_on = logged_in and tab_name == "MISC" and modules.safe.safe_get(modules.menu_setup.ui.misc_dormantaimbot) == true
		ui.set_visible(modules.menu_setup.ui.misc_dormantaimbot_key, misc_dormantaimbot_on)
		ui.set_visible(modules.menu_setup.ui.misc_dormantaimbot_value, misc_dormantaimbot_on)

		local paint_logger_on = logged_in and tab_name == "PAINT" and modules.safe.safe_get(modules.menu_setup.ui.paint_logger_checkbox) == true
		ui.set_visible(modules.menu_setup.ui.paint_logger, paint_logger_on)
		ui.set_visible(modules.menu_setup.ui.paint_logger_animation, paint_logger_on)
		ui.set_visible(modules.menu_setup.ui.paint_logger_color, paint_logger_on)

		local aspect_ratio_on = logged_in and tab_name == "PAINT" and modules.safe.safe_get(modules.menu_setup.ui.paint_aspect_ratio_checkbox) == true
		ui.set_visible(modules.menu_setup.ui.paint_aspect_ratio, aspect_ratio_on)

		local third_person_on = logged_in and tab_name == "PAINT" and modules.safe.safe_get(modules.menu_setup.ui.paint_third_person_distance_checkbox) == true
		ui.set_visible(modules.menu_setup.ui.paint_third_person_distance, third_person_on)

	end

	local aa_items = {
		'aa_gskey_freestand',
		'aa_gskey_freestandh',
		'aa_gskey_slowmotion',
		'aa_gskey_slowmotionh',
		'aa_gskey_edgeyaw',
		'aa_gskey_edgeyawh',
		'aa_gskey_onshot',
		'aa_gskey_onshoth',
	}
	for _, key in ipairs(aa_items) do
		if modules.menu_setup.ui[key] then
			ui.set_visible(modules.menu_setup.ui[key], tab_name == "AA")
		end
	end

	local misc_items = {
		'misc_resolver',
		'misc_ragebot',
		'misc_dormantaimbot',
		'misc_exploit_fakelag',
		'misc_walkbot',
		'misc_backstab',
		'misc_spindead',
	}
	for _, key in ipairs(misc_items) do
		if modules.menu_setup.ui[key] then
			ui.set_visible(modules.menu_setup.ui[key], tab_name == "MISC")
		end
	end

	local paint_items = {
		'paint_target_info',
		'label_space2',
		'label_space3',
		'label_space4',
		'paint_entidx',
		'paint_filter_console',
		'paint_minimum_damage',
		'paint_show_damage_penetration',
		'paint_hitmiss_indicator',
		'paint_self_skeleton',
		'paint_bullet_tracer',
		'paint_lagcomp_box',
		'paint_lagcomp_box_color',
		'paint_presmoke',
		'paint_bombwarning',
		'paint_insults',
		'paint_rainbow_esp',
		'paint_molotov',
		'paint_lag_record',
		'paint_advertisement',
		'paint_advertisement_animation',
		'paint_clantag',
		'paint_aimbot_logs',
		'paint_indicators_label',
		'paint_indicators_enable',
		'label_space1',
		'paint_watermark',
		'paint_watermark_type',
		'paint_logger_label',
		'paint_logger_checkbox',
		'paint_hitmarker',
		'paint_hitmarker_color',
		'paint_warnings',
		'paint_animations',
		'paint_performance_mode',
		'paint_aspect_ratio_checkbox',
		'paint_third_person_distance_checkbox',
	}
	for _, key in ipairs(paint_items) do
		if modules.menu_setup.ui[key] then
			ui.set_visible(modules.menu_setup.ui[key], tab_name == "PAINT")
		end
	end

		local cfg_items = {
			'cfg_load_button',
			'cfg_save_button',
			'cfg_delete_button',
			'cfg_refresh_button',
			'cfg_create_button',
			'cfg_export_button',
			'cfg_import_button',
			'cfg_input_box',
			'cfg_listbox',
			'cfg_selection',
			'cfg_cloud',
			'cfg_cloud_apply',
		}
		for _, key in ipairs(cfg_items) do
			if modules.menu_setup.ui[key] then
				ui.set_visible(modules.menu_setup.ui[key], logged_in and tab_name == "CFG")
			end
		end

end

local function setup_callbacks(modules)
	local cb_items = {
		modules.menu_setup.ui.condition,
		modules.menu_setup.ui.fakelag_mode,
	}
	for _, item in ipairs(cb_items) do
		if item then
			ui.set_callback(item, function()
				update_visibility(modules)
			end)
		end
	end

	for _, cond in ipairs(conditions) do
		local keys = {
			'enable_' .. cond,
			'yaw_' .. cond,
			'yaw_jitter_' .. cond,
			'body_yaw_mode_' .. cond,
			'fifty_fifty_' .. cond,
			'only_flip_on_0_choke_' .. cond,
			'aa_label_space' .. cond,
			'aa_label_combo' .. cond,
			'send_button' .. cond,
			'send_combo' .. cond,
		}
		for _, key in ipairs(keys) do
			local item = modules.menu_setup.ui[key]
			if item then
				ui.set_callback(item, function()
					update_visibility(modules)
				end)
			end
		end
	end

	local fl_keys = {
		'fakelag_defensive',
		'fakelag_stealer',
		'fakelag_fakelag',
		'fakelag_fakelag_type',
		'fakelag_settings_roll_label',
		'fakelag_settings_roll_checkbox',
	}
	for _, key in ipairs(fl_keys) do
		local item = modules.menu_setup.ui[key]
		if item then
			ui.set_callback(item, function()
				update_visibility(modules)
			end)
		end
	end

	if modules.menu_setup.ui.paint_indicators then
		ui.set_callback(modules.menu_setup.ui.paint_indicators, function()
			update_visibility(modules)
		end)
	end

	if modules.menu_setup.ui.paint_advertisement then
		ui.set_callback(modules.menu_setup.ui.paint_advertisement, function()
			update_visibility(modules)
		end)
	end
	
	if modules.menu_setup.ui.paint_watermark then
		ui.set_callback(modules.menu_setup.ui.paint_watermark, function()
			update_visibility(modules)
		end)
	end

	if modules.menu_setup.ui.misc_dormantaimbot then
		ui.set_callback(modules.menu_setup.ui.misc_dormantaimbot, function()
			update_visibility(modules)
		end)
	end

	if modules.menu_setup.ui.paint_logger_checkbox then
		ui.set_callback(modules.menu_setup.ui.paint_logger_checkbox, function()
			update_visibility(modules)
		end)
	end

	if modules.menu_setup.ui.paint_aspect_ratio_checkbox then
		ui.set_callback(modules.menu_setup.ui.paint_aspect_ratio_checkbox, function()
			update_visibility(modules)
		end)
	end

	if modules.menu_setup.ui.paint_third_person_distance_checkbox then
		ui.set_callback(modules.menu_setup.ui.paint_third_person_distance_checkbox, function()
			update_visibility(modules)
		end)
	end

	if modules.menu_setup.ui.paint_indicators_enable then
		ui.set_callback(modules.menu_setup.ui.paint_indicators_enable, function()
			update_visibility(modules)
		end)
	end

	if modules.login and type(modules.login.add_state_callback) == 'function' then
		modules.login.add_state_callback(function()
			update_visibility(modules)
		end)
	end
end

return {
	update = update_visibility,
	setup_callbacks = setup_callbacks
}]]
__bundle["require/abc/push_gamesense"] = [[local renderer = renderer
local globals = globals
local string_char = string.char

local dot_texture_id = nil
local function get_dot_texture()
    if dot_texture_id then return dot_texture_id end
    if renderer.load_rgba then
        local ok, texture = pcall(renderer.load_rgba,
            string.char(
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
            ), 4, 4)
        if ok and texture then dot_texture_id = texture end
    end
    return dot_texture_id
end


local function render_gamesense(x, y, w, h, a, text)
    local bg_x = x - 3
    local bg_y = y - 40
    local bg_w = w + 5
    local bg_h = h + 1
    renderer.rectangle(x - 10, y - 48, w + 20, h + 16, 0, 0, 0, 200)
    renderer.rectangle(x - 9, y - 47, w + 18, h + 14, 60, 60, 60, 255)
    renderer.rectangle(x - 8, y - 46, w + 16, h + 12, 40, 40, 40, 255)
    renderer.rectangle(x - 5, y - 43, w + 10, h + 6, 60, 60, 60, 255)
    renderer.rectangle(x - 4, y - 42, w + 8, h + 4, 12, 12, 12, 255)
    renderer.rectangle(x - 4, y - 42, w + 8, h + 4, 32, 32, 32, 255)
    local tex_id = get_dot_texture()
    if tex_id and renderer.texture then
        renderer.texture(tex_id, bg_x, bg_y, bg_w, bg_h, 255,255,255,a, 'r')
    else
        renderer.rectangle(bg_x, bg_y, bg_w, bg_h, 0, 0, 0, 0)
    end

    
    if renderer.gradient then
        renderer.gradient(x - 4, y - 42, w / 2 + 1, 1, 59, 175, 222, 255, 202, 70, 205, 255, true)
        renderer.gradient(x - 4 + w / 2, y - 42, w / 2 + 8.5, 1, 202, 70, 205, 255, 204, 227, 53, 255, true)
    end
    renderer.text(x, y - 40, 255, 255, 255, 255, '', nil, text)
end

return render_gamesense
]]
__bundle["require/abc/push_logger"] = [[local renderer = renderer
local globals = globals
local client = client
local entity = entity
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor
local math_sqrt = math.sqrt
local string_char = string.char


local ok_menu_setup, menu_setup = pcall(require, "require/abc/menu_setup")


local ok_menu_color_ref, menu_color_ref = pcall(ui.reference, 'misc', 'settings', 'menu color')

local queue = {}
local max_logs = 5

local function pushlog(text, duration, r, g, b, a)
    if #queue >= max_logs then
        table_remove(queue, 1)
    end
    table_insert(queue, {
        text = tostring(text),
        duration = duration or 5,
        color = { r or 255, g or 255, b or 255, a or 255 },
        timestamp = globals and globals.curtime and globals.curtime() or os.clock(),
    })
end

local function measure_text(str)
    local ok, w, h = pcall(renderer.measure_text, '', str)
    if ok and type(w) == 'number' then return w, h or 0 end
    ok, w, h = pcall(renderer.measure_text, str)
    if ok and type(w) == 'number' then return w, h or 0 end
    return 0, 0
end

local function clamp(v, low, high)
    if v < low then return low end
    if v > high then return high end
    return v
end


local function paint_logger_enabled()
    if ok_menu_setup and menu_setup and menu_setup.ui and menu_setup.ui.paint_logger then
        local ok, val = pcall(ui.get, menu_setup.ui.paint_logger)
        if ok and val then return true end
        return false
    end
    
    return true
end


local function paint_logger_style()
    if ok_menu_setup and menu_setup and menu_setup.ui and menu_setup.ui.paint_logger_animation then
        local ok, v = pcall(ui.get, menu_setup.ui.paint_logger_animation)
        if ok and type(v) == 'number' then return v end
    end
    return 0
end


local ok_modern, render_modern = pcall(require, "require/abc/push_modern")
local ok_gamesense, render_gamesense = pcall(require, "require/abc/push_gamesense")


local function compute_line_bounds(screen_h)
    local safe_top = 80
    local safe_bottom = screen_h - 80
    local line_half = 40
    local anchor_y = screen_h / 2 - 300
    local baseline_default = screen_h - anchor_y - 10
    baseline_default = clamp(baseline_default, safe_top + line_half, safe_bottom - line_half)
    local line_top = baseline_default - line_half
    local line_bottom = baseline_default + line_half
    return line_top, line_bottom, baseline_default
end

local function render()
    if not renderer or not renderer.text then return end
    if not paint_logger_enabled() then return end

    local style = paint_logger_style() or 0
    local now = globals and globals.curtime and globals.curtime()
    local screen_w, screen_h = client and client.screen_size and client.screen_size() or 800, 600
    local baseline = screen_h * 0.5 + (screen_h * 0.5 * 1.8)
    local offset = 0
    for i = #queue, 1, -1 do
        local log = queue[i]
        local time_left = (log.timestamp + log.duration) - now
        if time_left <= 0 then
            table_remove(queue, i)
        else
            local text_w, text_h = measure_text(log.text)
            local padding = (style == 1) and 4 or 2
            local glow = 2
            local x = screen_w / 2 - text_w / 2
            local y = baseline + offset
            local fade_speed = 5
            local alpha = math_floor((log.color[4] or 255) * math.min(1, (time_left / log.duration) * fade_speed))
            local elapsed = (log.duration - time_left)
            local dur = (log.duration > 0 and log.duration or 1)
            local t = elapsed / dur
            local speed = 6
            local forward_progress = clamp(t * speed, 0, 1)
            local progress = forward_progress
            
            
            local reverse_window = math.min(0.5, dur * 0.25)
            if time_left <= reverse_window then
                local rev_t = time_left / reverse_window 
                progress = clamp(rev_t, 0, 1)
            end
            if style == 1 then
                render_modern(x, y, text_w, 13, alpha, log.text, progress)
                offset = offset + (text_h + padding * 2 + math_sqrt(glow / 10) * 4)
            else
                render_gamesense(x, y, text_w, 13, alpha, log.text)
                offset = offset + (text_h + padding * 2 + math_sqrt(glow / 10) * 35)
            end
        end
    end
end

if client and client.set_event_callback then
    client.set_event_callback('paint', render)
else
    
    client.set_event_callback('paint', render)
end

return pushlog
]]
__bundle["require/abc/push_modern"] = [[local renderer = renderer
local ui = ui
local math_floor = math.floor

local ok_menu_setup, menu_setup = pcall(require, "require/abc/menu_setup")
local ok_menu_color_ref, menu_color_ref = pcall(ui.reference, 'misc', 'settings', 'menu color')

local function draw_rounded_box(x,y,w,h,radius, r,g,b,a)
    if not radius or radius <= 0 then
        renderer.rectangle(x, y, w, h, r,g,b,a)
        return
    end
    renderer.rectangle(x + radius, y, w - (radius * 2), h, r,g,b,a)
    renderer.rectangle(x, y + radius, w, h - (radius * 2), r,g,b,a)
    renderer.circle(x + radius, y + radius, r,g,b,a, radius, 0, 1)
    renderer.circle(x + w - radius, y + radius, r,g,b,a, radius, 0, 1)
    renderer.circle(x + radius, y + h - radius, r,g,b,a, radius, 0, 1)
    renderer.circle(x + w - radius, y + h - radius, r,g,b,a, radius, 0, 1)
end

local function resolve_menu_color(default_r, default_g, default_b, default_a)
    local mr, mg, mb, ma = default_r or 255, default_g or 140, default_b or 0, default_a or 255
    
    if ok_menu_setup and menu_setup and menu_setup.ui and menu_setup.ui.paint_logger_color then
        local ok_col, ca, cb, cc, cd = pcall(ui.get, menu_setup.ui.paint_logger_color)
        if ok_col then
            if type(ca) == 'number' then
                mr = math_floor(ca or mr)
                mg = math_floor(cb or mg)
                mb = math_floor(cc or mb)
                ma = math_floor(cd or ma)
            elseif type(ca) == 'string' and #ca == 12 then
                local ok
                ok, mr = pcall(function() return tonumber(ca:sub(1,3)) end)
                ok, mg = pcall(function() return tonumber(ca:sub(4,6)) end)
                ok, mb = pcall(function() return tonumber(ca:sub(7,9)) end)
                ok, ma = pcall(function() return tonumber(ca:sub(10,12)) end)
                mr = mr or default_r; mg = mg or default_g; mb = mb or default_b; ma = ma or default_a
            end
            return mr, mg, mb, ma
        end
    end

    
    if ok_menu_color_ref and menu_color_ref then
        local ok_col, ca, cb, cc, cd = pcall(ui.get, menu_color_ref)
        if ok_col then
            if type(ca) == 'number' then
                mr = math_floor(ca or mr)
                mg = math_floor(cb or mg)
                mb = math_floor(cc or mb)
                ma = math_floor(cd or ma)
            elseif type(ca) == 'string' and #ca == 12 then
                local ok
                ok, mr = pcall(function() return tonumber(ca:sub(1,3)) end)
                ok, mg = pcall(function() return tonumber(ca:sub(4,6)) end)
                ok, mb = pcall(function() return tonumber(ca:sub(7,9)) end)
                ok, ma = pcall(function() return tonumber(ca:sub(10,12)) end)
                mr = mr or default_r; mg = mg or default_g; mb = mb or default_b; ma = ma or default_a
            end
        end
    end
    return mr, mg, mb, ma
end

local function render_modern(x, y, w, h, alpha, text, progress)
    local bg_x = x - 4
    local bg_y = y - 40
    local bg_w = w + 8
    local bg_h = h + 1

    local rad = 6
    if bg_h < 12 then rad = math.max(1, math.floor(bg_h / 2)) end
    local inner_rad = math.max(1, rad - 1)

    local mr, mg, mb, ma = resolve_menu_color(255, 140, 0, 255)
    local out_a = math_floor((ma or 255) * 0.95)

    progress = math.max(0, math.min(1, progress or 1))
    local outer_x = bg_x - 1
    local outer_y = bg_y - 1
    local outer_w = bg_w + 2
    local outer_h = bg_h + 2
    local half_total = outer_w / 2 + (outer_w * 0.1)
    local side_len = math_floor(half_total * progress)

    if side_len > 0 then
        local cap_r = math.min(rad + 1, math_floor(outer_h / 2), math_floor(side_len / 2))
        draw_rounded_box(outer_x, outer_y, side_len, outer_h, cap_r, mr, mg, mb, out_a)
        draw_rounded_box(outer_x + outer_w - side_len, outer_y, side_len, outer_h, cap_r, mr, mg, mb, out_a)
    end
    draw_rounded_box(bg_x, bg_y, bg_w, bg_h, rad, 10, 10, 10, 230)
    draw_rounded_box(bg_x + 1, bg_y + 1, bg_w - 2, bg_h - 2, inner_rad, 6, 6, 6, 220)
    if renderer.gradient then
        renderer.gradient(bg_x + 2, bg_y + 1, math.max(0, bg_w - 4), 2, mr, mg, mb, math_floor(out_a * 0.14), mr, mg, mb, 0, true)
    end
    renderer.text(x, y - 40, 255, 255, 255, 255, '', nil, text)
end

return render_modern]]
__bundle["require/abc/register"] = [[local login_system = require("require.abc.login_system")
local ACCOUNTS_DB_KEY = "acc_" .. "OIDFGNSOIGNSFGIOSNGOISNGIOS"

local function split_args(s)
    local parts = {}
    for part in s:gmatch("%S+") do
        table.insert(parts, part)
    end
    return parts
end

client.set_event_callback("console_input", function(text)
    local parts = split_args(text or "")
    if #parts == 0 then return end

    local cmd = parts[1]:lower()
    if cmd ~= "register" then
        
        return
    end

    if #parts < 4 then
        client.log("Usage: register <username> <password> <invite>")
        return
    end

    local username = parts[2]
    local password = parts[3]
    local invite = parts[4]

    local valid, entry = login_system.is_valid_invite(invite)
    if not valid then
        client.log("Register failed: invalid or used invite")
        return
    end

    local accounts = database.read(ACCOUNTS_DB_KEY) or {}
    if accounts[username] then
        client.log("Register failed: username already exists - ", username)
        return
    end

    local ok, err = login_system.register_with_invite(invite, username, password)
    if ok then
        client.log("Registered user:", username)
    else
        client.log("Register failed:", err or "unknown error")
    end
end)]]
__bundle["require/abc/screen_logger"] = [[local renderer = renderer
local globals = globals
local client = client
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor




local queue = {}
local max_entries = 12

local function measure_text(str)
    local ok, w, h = pcall(renderer.measure_text, '', str)
    if ok and type(w) == 'number' then return w, h or 0 end
    ok, w, h = pcall(renderer.measure_text, str)
    if ok and type(w) == 'number' then return w, h or 0 end
    return 0, 0
end

local function screen_log(text, duration, r, g, b, a)
    if not text then return end
    duration = duration or 4
    if #queue >= max_entries then
        table_remove(queue, 1)
    end
    table_insert(queue, {
        text = tostring(text),
        duration = duration,
        color = { r or 255, g or 255, b or 255, a or 255 },
        ts = globals and globals.curtime and globals.curtime() or os.clock(),
    })
    return true
end

local function render()
    if not renderer or not renderer.text then return end
    local now = globals and globals.curtime and globals.curtime() or os.clock()
    local sw, sh = client and client.screen_size and client.screen_size() or 800, 600

    local start_x = 8
    local start_y = 6
    local line_h = 14
    local gap = 2

    local y = start_y

    for i = #queue, 1, -1 do
        local item = queue[i]
        if not item then goto continue end
        local elapsed = now - (item.ts or 0)
        local left = (item.duration or 4) - elapsed
        if left <= 0 then
            table_remove(queue, i)
        else
            local _, th = measure_text(item.text)
            
            local alpha = math_floor(item.color[4] or 255)
            
            pcall(renderer.text, start_x, y, item.color[1] or 255, item.color[2] or 255, item.color[3] or 255, alpha, 'b', 0, item.text)
            y = y + (th > 0 and th or line_h) + gap
        end
        ::continue::
    end
end

if client and client.set_event_callback then
    client.set_event_callback('paint', render)
end

return screen_log]]
__bundle["require/brain/dll"] = [[local ffi = require("ffi")

ffi.cdef([[
struct Vec3 { double x; double y; double z; };
struct AspectState { double original; double last; double last_update; int initialized; };
const char* clipboard_get();
int clipboard_set(const char* text);
int clipboard_empty();
int clantag_anim(double start_time, double now, char* out_buf, int out_buf_len);
void tracer_reset();
void tracer_push_shot(double sx, double sy, double sz, double t);
void tracer_set_impact(double ix, double iy, double iz, double t);
int tracer_collect(double now, double tracer_life, double fade_fraction, double pitch, double yaw, double fallback_dist, double base_alpha, double* out_buf, int max_lines);
] ])


local function hex(val)
    local ok, num = pcall(ffi.cast, "uintptr_t", val)
    if not ok then return "<na>" end
    return string.format("0x%X", tonumber(num))
end

local function resolve_call_trampoline()
    local tramp = client.find_signature("engine.dll", "\xFF\xE1")
    if tramp == nil then
        return nil
    end
    return ffi.cast("void*", tramp)
end

local function make_import_thunk(sig_pattern, cast_type)
    local addr = client.find_signature("engine.dll", sig_pattern)
    if addr == nil then
        return nil
    end
    local ptr = ffi.cast("void***", ffi.cast("uintptr_t", addr) + 2)[0][0]
    return ptr
end

local call_trampoline = resolve_call_trampoline()
local gm_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B", "void *")
local gpa_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05", "void *")

if gm_thunk and gpa_thunk then
else
    return
end

local function via_trampoline(target, signature, label)
    local fn = ffi.cast(signature, call_trampoline)
    return function(...)
        return fn(target, ...)
    end
end

local function to_wide(str)
    local buf = ffi.new("wchar_t[?]", #str + 1)
    for i = 1, #str do buf[i - 1] = string.byte(str, i) end
    buf[#str] = 0
    return buf
end

local GetModuleHandleA_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const char *)", "GMH A")
local GetModuleHandleW_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const wchar_t *)", "GMH W")
local GetProcAddress_tr   = via_trampoline(gpa_thunk, "void *(__thiscall *)(void *, void *, const char *)", "GPA")

local function call_GetModuleHandle(name)
    local ok1, res1 = pcall(GetModuleHandleA_tr, name)
    if not ok1 then dbg("GetModuleHandleA tramp err", res1) end
    if ok1 and res1 ~= nil and res1 ~= ffi.NULL then
        return res1, "tramp ansi"
    end

    local ok2, res2 = pcall(GetModuleHandleW_tr, to_wide(name))
    if not ok2 then dbg("GetModuleHandleW tramp err", res2) end
    if ok2 and res2 ~= nil and res2 ~= ffi.NULL then
        return res2, "tramp wide"
    end

    return nil, "failed"
end

local function call_GetProcAddress(mod, name)
    local ok, res = pcall(GetProcAddress_tr, mod, name)
    if not ok then dbg("GetProcAddress tramp err", res) end
    if ok and res ~= nil and res ~= ffi.NULL then return res end
    return nil
end

local mod, gm_variant = call_GetModuleHandle("sodiumdll.dll")
if mod == nil then
    return
end

local function bind_export(name, cdecl_sig)
    local addr = call_GetProcAddress(mod, name)
    if addr == nil then
        return nil
    end
    return addr, ffi.cast(cdecl_sig, addr)
end

local add_addr, add_fn = bind_export("add", "int(__cdecl*)(int, int)")
local get_value_addr, get_value_fn = bind_export("get_value", "int(__cdecl*)(void)")
local pin_module_addr, pin_module_fn = bind_export("pin_module", "void(__cdecl*)(void)")
local release_module_addr, release_module_fn = bind_export("release_module", "void(__cdecl*)(void)")
local get_hwid_addr, get_hwid_fn = bind_export("get_hwid", "const char*(__cdecl*)(void)")
local clipboard_get_addr, clipboard_get_fn = bind_export("clipboard_get", "const char*(__cdecl*)(void)")
local clipboard_set_addr, clipboard_set_fn = bind_export("clipboard_set", "int(__cdecl*)(const char*)")
local clipboard_empty_addr, clipboard_empty_fn = bind_export("clipboard_empty", "int(__cdecl*)(void)")
local clantag_anim_addr, clantag_anim_fn = bind_export("clantag_anim", "int(__cdecl*)(double, double, char*, int)")
local tracer_reset_addr, tracer_reset_fn = bind_export("tracer_reset", "void(__cdecl*)(void)")
local tracer_push_shot_addr, tracer_push_shot_fn = bind_export("tracer_push_shot", "void(__cdecl*)(double, double, double, double)")
local tracer_set_impact_addr, tracer_set_impact_fn = bind_export("tracer_set_impact", "void(__cdecl*)(double, double, double, double)")
local tracer_collect_addr, tracer_collect_fn = bind_export("tracer_collect", "int(__cdecl*)(double, double, double, double, double, double, double, double*, int)")

local vec_make_addr, vec_make_fn = bind_export("vec_make", "struct Vec3(__cdecl*)(double, double, double)")
local vec_add_addr, vec_add_fn = bind_export("vec_add", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_sub_addr, vec_sub_fn = bind_export("vec_sub", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_mul_scalar_addr, vec_mul_scalar_fn = bind_export("vec_mul_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_div_scalar_addr, vec_div_scalar_fn = bind_export("vec_div_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_unm_addr, vec_unm_fn = bind_export("vec_unm", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_length_addr, vec_length_fn = bind_export("vec_length", "double(__cdecl*)(struct Vec3)")
local vec_dot_addr, vec_dot_fn = bind_export("vec_dot", "double(__cdecl*)(struct Vec3, struct Vec3)")
local vec_cross_addr, vec_cross_fn = bind_export("vec_cross", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_normalized_addr, vec_normalized_fn = bind_export("vec_normalized", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_distance_addr, vec_distance_fn = bind_export("vec_distance", "double(__cdecl*)(struct Vec3, struct Vec3)")

local m_clamp_addr, m_clamp_fn = bind_export("m_clamp", "double(__cdecl*)(double, double, double)")
local m_clamp01_addr, m_clamp01_fn = bind_export("m_clamp01", "double(__cdecl*)(double)")
local m_abs_addr, m_abs_fn = bind_export("m_abs", "double(__cdecl*)(double)")
local m_lerp_addr, m_lerp_fn = bind_export("m_lerp", "double(__cdecl*)(double, double, double)")
local m_distance2d_addr, m_distance2d_fn = bind_export("m_distance2d", "double(__cdecl*)(double, double, double, double)")
local m_distance3d_addr, m_distance3d_fn = bind_export("m_distance3d", "double(__cdecl*)(double, double, double, double, double, double)")
local m_rad_to_deg_addr, m_rad_to_deg_fn = bind_export("m_rad_to_deg", "double(__cdecl*)(double)")
local m_deg_to_rad_addr, m_deg_to_rad_fn = bind_export("m_deg_to_rad", "double(__cdecl*)(double)")
local m_wrap_degrees_addr, m_wrap_degrees_fn = bind_export("m_wrap_degrees", "double(__cdecl*)(double)")
local m_normalize_angle_addr, m_normalize_angle_fn = bind_export("m_normalize_angle", "double(__cdecl*)(double)")
local m_angle_diff_addr, m_angle_diff_fn = bind_export("m_angle_diff", "double(__cdecl*)(double, double)")
local m_lerp_angle_addr, m_lerp_angle_fn = bind_export("m_lerp_angle", "double(__cdecl*)(double, double, double)")
local m_map_addr, m_map_fn = bind_export("m_map", "double(__cdecl*)(double, double, double, double, double)")
local m_smoothstep_addr, m_smoothstep_fn = bind_export("m_smoothstep", "double(__cdecl*)(double, double, double)")
local aspect_update_addr, aspect_update_fn = bind_export("aspect_update", "void(__cdecl*)(void*, double, double, double, double*, int*)")

if not (add_fn and get_value_fn and pin_module_fn and release_module_fn and get_hwid_fn and
    vec_make_fn and vec_add_fn and vec_sub_fn and vec_mul_scalar_fn and vec_div_scalar_fn and
    vec_unm_fn and vec_length_fn and vec_dot_fn and vec_cross_fn and vec_normalized_fn and vec_distance_fn and
    m_clamp_fn and m_clamp01_fn and m_abs_fn and m_lerp_fn and m_distance2d_fn and m_distance3d_fn and
    m_rad_to_deg_fn and m_deg_to_rad_fn and m_wrap_degrees_fn and m_normalize_angle_fn and m_angle_diff_fn and
    m_lerp_angle_fn and m_map_fn and m_smoothstep_fn and aspect_update_fn and
    clipboard_get_fn and clipboard_set_fn and clipboard_empty_fn and clantag_anim_fn and
    tracer_reset_fn and tracer_push_shot_fn and tracer_set_impact_fn and tracer_collect_fn) then
    return
end

local Call_add = via_trampoline(add_addr, "int(__thiscall *)(void*, int, int)", "add")
local Call_get_value = via_trampoline(get_value_addr, "int(__thiscall *)(void*)", "get_value")
local Call_pin_module = via_trampoline(pin_module_addr, "void(__thiscall *)(void*)", "pin_module")
local Call_release_module = via_trampoline(release_module_addr, "void(__thiscall *)(void*)", "release_module")
local Call_get_hwid = via_trampoline(get_hwid_addr, "const char*(__thiscall *)(void*)", "get_hwid")
local Call_clipboard_get = via_trampoline(clipboard_get_addr, "const char*(__thiscall *)(void*)", "clipboard_get")
local Call_clipboard_set = via_trampoline(clipboard_set_addr, "int(__thiscall *)(void*, const char*)", "clipboard_set")
local Call_clipboard_empty = via_trampoline(clipboard_empty_addr, "int(__thiscall *)(void*)", "clipboard_empty")
local Call_clantag_anim = via_trampoline(clantag_anim_addr, "int(__thiscall *)(void*, double, double, char*, int)", "clantag_anim")
local Call_tracer_reset = via_trampoline(tracer_reset_addr, "void(__thiscall *)(void*)", "tracer_reset")
local Call_tracer_push_shot = via_trampoline(tracer_push_shot_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_push_shot")
local Call_tracer_set_impact = via_trampoline(tracer_set_impact_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_set_impact")
local Call_tracer_collect = via_trampoline(tracer_collect_addr, "int(__thiscall *)(void*, double, double, double, double, double, double, double, double*, int)", "tracer_collect")
local Call_vec_make = via_trampoline(vec_make_addr, "struct Vec3(__thiscall *)(void*, double, double, double)", "vec_make")
local Call_vec_add = via_trampoline(vec_add_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_add")
local Call_vec_sub = via_trampoline(vec_sub_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_sub")
local Call_vec_mul_scalar = via_trampoline(vec_mul_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_mul_scalar")
local Call_vec_div_scalar = via_trampoline(vec_div_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_div_scalar")
local Call_vec_unm = via_trampoline(vec_unm_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_unm")
local Call_vec_length = via_trampoline(vec_length_addr, "double(__thiscall *)(void*, struct Vec3)", "vec_length")
local Call_vec_dot = via_trampoline(vec_dot_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_dot")
local Call_vec_cross = via_trampoline(vec_cross_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_cross")
local Call_vec_normalized = via_trampoline(vec_normalized_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_normalized")
local Call_vec_distance = via_trampoline(vec_distance_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_distance")

local Call_m_clamp = via_trampoline(m_clamp_addr, "double(__thiscall *)(void*, double, double, double)", "m_clamp")
local Call_m_clamp01 = via_trampoline(m_clamp01_addr, "double(__thiscall *)(void*, double)", "m_clamp01")
local Call_m_abs = via_trampoline(m_abs_addr, "double(__thiscall *)(void*, double)", "m_abs")
local Call_m_lerp = via_trampoline(m_lerp_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp")
local Call_m_distance2d = via_trampoline(m_distance2d_addr, "double(__thiscall *)(void*, double, double, double, double)", "m_distance2d")
local Call_m_distance3d = via_trampoline(m_distance3d_addr, "double(__thiscall *)(void*, double, double, double, double, double, double)", "m_distance3d")
local Call_m_rad_to_deg = via_trampoline(m_rad_to_deg_addr, "double(__thiscall *)(void*, double)", "m_rad_to_deg")
local Call_m_deg_to_rad = via_trampoline(m_deg_to_rad_addr, "double(__thiscall *)(void*, double)", "m_deg_to_rad")
local Call_m_wrap_degrees = via_trampoline(m_wrap_degrees_addr, "double(__thiscall *)(void*, double)", "m_wrap_degrees")
local Call_m_normalize_angle = via_trampoline(m_normalize_angle_addr, "double(__thiscall *)(void*, double)", "m_normalize_angle")
local Call_m_angle_diff = via_trampoline(m_angle_diff_addr, "double(__thiscall *)(void*, double, double)", "m_angle_diff")
local Call_m_lerp_angle = via_trampoline(m_lerp_angle_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp_angle")
local Call_m_map = via_trampoline(m_map_addr, "double(__thiscall *)(void*, double, double, double, double, double)", "m_map")
local Call_m_smoothstep = via_trampoline(m_smoothstep_addr, "double(__thiscall *)(void*, double, double, double)", "m_smoothstep")
local Call_aspect_update = via_trampoline(aspect_update_addr, "void(__thiscall *)(void*, void*, double, double, double, double*, int*)", "aspect_update")


return {
    add = function(a, b)
        return Call_add(a, b)
    end,
    get_value = function()
        return Call_get_value()
    end,
    pin_module = function()
        return Call_pin_module()
    end,
    release_module = function()
        return Call_release_module()
    end,
    get_hwid = function()
        return Call_get_hwid()
    end,
    clipboard_get = function()
        return Call_clipboard_get()
    end,
    clipboard_set = function(text)
        return Call_clipboard_set(text)
    end,
    clipboard_empty = function()
        return Call_clipboard_empty()
    end,
    clantag_anim = function(start_time, now, out_buf, out_buf_len)
        return Call_clantag_anim(start_time, now, out_buf, out_buf_len)
    end,
    tracer_reset = function()
        return Call_tracer_reset()
    end,
    tracer_push_shot = function(sx, sy, sz, t)
        return Call_tracer_push_shot(sx, sy, sz, t)
    end,
    tracer_set_impact = function(ix, iy, iz, t)
        return Call_tracer_set_impact(ix, iy, iz, t)
    end,
    tracer_collect = function(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
        return Call_tracer_collect(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
    end,
    vec_make = function(x, y, z)
        return Call_vec_make(x, y, z)
    end,
    vec_add = function(a, b)
        return Call_vec_add(a, b)
    end,
    vec_sub = function(a, b)
        return Call_vec_sub(a, b)
    end,
    vec_mul_scalar = function(v, s)
        return Call_vec_mul_scalar(v, s)
    end,
    vec_div_scalar = function(v, s)
        return Call_vec_div_scalar(v, s)
    end,
    vec_unm = function(v)
        return Call_vec_unm(v)
    end,
    vec_length = function(v)
        return Call_vec_length(v)
    end,
    vec_dot = function(a, b)
        return Call_vec_dot(a, b)
    end,
    vec_cross = function(a, b)
        return Call_vec_cross(a, b)
    end,
    vec_normalized = function(v)
        return Call_vec_normalized(v)
    end,
    vec_distance = function(a, b)
        return Call_vec_distance(a, b)
    end,
    m_clamp = function(val, minVal, maxVal)
        return Call_m_clamp(val, minVal, maxVal)
    end,
    m_clamp01 = function(val)
        return Call_m_clamp01(val)
    end,
    m_abs = function(val)
        return Call_m_abs(val)
    end,
    m_lerp = function(a, b, t)
        return Call_m_lerp(a, b, t)
    end,
    m_distance2d = function(x1, y1, x2, y2)
        return Call_m_distance2d(x1, y1, x2, y2)
    end,
    m_distance3d = function(x1, y1, z1, x2, y2, z2)
        return Call_m_distance3d(x1, y1, z1, x2, y2, z2)
    end,
    m_rad_to_deg = function(rad)
        return Call_m_rad_to_deg(rad)
    end,
    m_deg_to_rad = function(deg)
        return Call_m_deg_to_rad(deg)
    end,
    m_wrap_degrees = function(angle)
        return Call_m_wrap_degrees(angle)
    end,
    m_normalize_angle = function(angle)
        return Call_m_normalize_angle(angle)
    end,
    m_angle_diff = function(a, b)
        return Call_m_angle_diff(a, b)
    end,
    m_lerp_angle = function(a, b, t)
        return Call_m_lerp_angle(a, b, t)
    end,
    m_map = function(val, in_min, in_max, out_min, out_max)
        return Call_m_map(val, in_min, in_max, out_min, out_max)
    end,
    m_smoothstep = function(edge0, edge1, x)
        return Call_m_smoothstep(edge0, edge1, x)
    end,
    aspect_update = function(state, raw_slider, current_aspect, now, out_target, out_dirty)
        return Call_aspect_update(state, raw_slider, current_aspect, now, out_target, out_dirty)
    end,
    module_base = mod,
}]]
__bundle["require/brain/test"] = [[local math_api = require("require/brain/api/math/math")
local health_api = require("require/brain/api/health/health")
local hwid_api = require("require/brain/api/hwid/hwid")
local dll = require("require/brain/dll")


client.set_event_callback("paint_ui", function()
    local ok, v = pcall(math_api.add, 2, math.random(1, 100))
    if ok then
        
    end

end)

local ok_hwid, hwid = pcall(hwid_api.get_hwid)
if ok_hwid and hwid and hwid ~= "" then
    client.log("hwid:", hwid)
else
    client.log("hwid: failed")
end]]
__bundle["require/brain/api/clipboard/clipboard"] = [[]]
__bundle["require/brain/api/health/health"] = [[local dll = require("require/brain/dll")

if not dll then
	error("sodiumdll exports unavailable")
end

return {
	pin_module = function()
		return dll.pin_module()
	end,
	release_module = function()
		return dll.release_module()
	end,
	module_base = dll.module_base,
}]]
__bundle["require/brain/api/hwid/hwid"] = [[local ffi = require("ffi")
local dll = require("require/brain/dll")

if not dll or not dll.get_hwid then
    error("sodiumdll hwid export missing")
end

return {
	get_hwid = function()
		local ptr = dll.get_hwid()
		if not ptr or ptr == ffi.NULL then
			return ""
		end
		return ffi.string(ptr)
	end,
}]]
__bundle["require/brain/api/ip/ip"] = [[
local dll = require("require/brain/dll")

if not dll or not dll.get_public_ip then
	return error("sodiumdll ip export missing")
end

return {
	get_public_ip = function(buffer, buffer_size)
		return dll.get_public_ip(buffer, buffer_size)
	end,
}]]
__bundle["require/brain/api/math/math"] = [[local dll = require("require/brain/dll")

if not dll or not dll.m_clamp then
	error("sodiumdll math exports missing")
end

return {
	add = function(a, b)
		return dll.add(a, b)
	end,
	get_value = function()
		return dll.get_value()
	end,
	m_clamp = function(val, minVal, maxVal)
		return dll.m_clamp(val, minVal, maxVal)
	end,
	m_clamp01 = function(val)
		return dll.m_clamp01(val)
	end,
	m_abs = function(val)
		return dll.m_abs(val)
	end,
	m_lerp = function(a, b, t)
		return dll.m_lerp(a, b, t)
	end,
	m_distance2d = function(x1, y1, x2, y2)
		return dll.m_distance2d(x1, y1, x2, y2)
	end,
	m_distance3d = function(x1, y1, z1, x2, y2, z2)
		return dll.m_distance3d(x1, y1, z1, x2, y2, z2)
	end,
	m_rad_to_deg = function(rad)
		return dll.m_rad_to_deg(rad)
	end,
	m_deg_to_rad = function(deg)
		return dll.m_deg_to_rad(deg)
	end,
	m_wrap_degrees = function(angle)
		return dll.m_wrap_degrees(angle)
	end,
	m_normalize_angle = function(angle)
		return dll.m_normalize_angle(angle)
	end,
	m_angle_diff = function(a, b)
		return dll.m_angle_diff(a, b)
	end,
	m_lerp_angle = function(a, b, t)
		return dll.m_lerp_angle(a, b, t)
	end,
	m_map = function(val, in_min, in_max, out_min, out_max)
		return dll.m_map(val, in_min, in_max, out_min, out_max)
	end,
	m_smoothstep = function(edge0, edge1, x)
		return dll.m_smoothstep(edge0, edge1, x)
	end,
}]]
__bundle["require/brain/api/vector/vector"] = [[local ffi = require("ffi")
local dll = require("require/brain/dll")

if not dll or not dll.vec_make or not dll.vec_add or not dll.vec_sub or not dll.vec_mul_scalar or
   not dll.vec_div_scalar or not dll.vec_unm or not dll.vec_length or not dll.vec_dot or
   not dll.vec_cross or not dll.vec_normalized or not dll.vec_distance or not dll.aspect_update then
    error("sodiumdll vector exports missing")
end

local Vec3 = ffi.typeof("struct Vec3")

local function ensure_vec(v)
    if ffi.istype(Vec3, v) then
        return v
    end
    local x = (v and v.x) or 0
    local y = (v and v.y) or 0
    local z = (v and v.z) or 0
    return dll.vec_make(x, y, z)
end

return {
    Vec3 = Vec3,
    make = function(x, y, z)
        return dll.vec_make(x or 0, y or 0, z or 0)
    end,
    add = function(a, b)
        return dll.vec_add(ensure_vec(a), ensure_vec(b))
    end,
    sub = function(a, b)
        return dll.vec_sub(ensure_vec(a), ensure_vec(b))
    end,
    mul_scalar = function(v, s)
        return dll.vec_mul_scalar(ensure_vec(v), s)
    end,
    div_scalar = function(v, s)
        return dll.vec_div_scalar(ensure_vec(v), s)
    end,
    unm = function(v)
        return dll.vec_unm(ensure_vec(v))
    end,
    length = function(v)
        return dll.vec_length(ensure_vec(v))
    end,
    dot = function(a, b)
        return dll.vec_dot(ensure_vec(a), ensure_vec(b))
    end,
    cross = function(a, b)
        return dll.vec_cross(ensure_vec(a), ensure_vec(b))
    end,
    normalized = function(v)
        return dll.vec_normalized(ensure_vec(v))
    end,
    distance = function(a, b)
        return dll.vec_distance(ensure_vec(a), ensure_vec(b))
    end,
    aspect_update = dll.aspect_update,
}]]
__bundle["require/brain/examples/boxes"] = [[local ffi = require("ffi")
local chuj = {


}


chuj.GetModuleHandlePtr = 
    ffi.cast(
        "void***", 
        ffi.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B")) + 2
    )[0][0]

chuj.GetProcAddressPtr = 
    ffi.cast(
        "void***", 
        ffi.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05")) + 2
    )[0][0]


chuj.reinterpret_cast = function(addr, typestring) 
    return function(...) 
        return ffi.cast(typestring, client.find_signature("engine.dll", "\xFF\xE1"))(addr, ...) 
    end
end


chuj.fnGetModuleHandle = chuj.reinterpret_cast(
    chuj.GetModuleHandlePtr, 
    "void*(__thiscall*)(void*, const char*)"
)

chuj.GetModuleHandle = function(module)
    return chuj.fnGetModuleHandle(module)
end 


chuj.fnGetProcAddress = chuj.reinterpret_cast(
    chuj.GetProcAddressPtr, 
    "void*(__thiscall*)(void*, void*, const char*)"
)

chuj.GetProcAddress = function(module, proc_addr)
    local addr = chuj.fnGetProcAddress(module, proc_addr)
    return addr
end 


chuj.lib = {}
chuj.lib.user32 = chuj.GetModuleHandle("user32.dll")


chuj.export = {}
chuj.export.user32 = {}

chuj.export.user32.MessageBoxPtr = chuj.GetProcAddress(chuj.lib.user32, "MessageBoxA")
chuj.export.user32.MessageBox = chuj.reinterpret_cast(
    chuj.export.user32.MessageBoxPtr,
    "int(__thiscall*)(void*, void*, const char*, const char*, unsigned int)"
)


local MB_OK = 0x00000000
local MB_OKCANCEL = 0x00000001
local MB_YESNO = 0x00000004
local MB_ICONERROR = 0x00000010
local MB_ICONQUESTION = 0x00000020
local MB_ICONWARNING = 0x00000030
local MB_ICONINFORMATION = 0x00000040


local IDOK = 1
local IDCANCEL = 2
local IDYES = 6
local IDNO = 7


local function show_messagebox(text, title, type)
    title = title or "Gamesense"
    type = type or MB_OK
    
    local result = chuj.export.user32.MessageBox(nil, text, title, type)
    return result
end


local function show_info(text, title)
    return show_messagebox(text, title, MB_OK + MB_ICONINFORMATION)
end

local function show_warning(text, title)
    return show_messagebox(text, title, MB_OK + MB_ICONWARNING)
end

local function show_error(text, title)
    return show_messagebox(text, title, MB_OK + MB_ICONERROR)
end

local function show_yesno(text, title)
    local result = show_messagebox(text, title, MB_YESNO + MB_ICONQUESTION)
    return result == IDYES
end
show_info("test", "test")]]
__bundle["require/brain/features/aspectratio"] = [[local ffi = require("ffi")
local dll = require("require/brain/dll")

if not dll or not dll.aspect_update then
    error("sodiumdll aspect_update export missing")
end

return {
    aspect_update = function(state, raw_slider, current_aspect, now)
        local out_target = ffi.new("double[1]")
        local out_dirty = ffi.new("int[1]")

        dll.aspect_update(state or ffi.NULL, raw_slider, current_aspect, now, out_target, out_dirty)

        return out_target[0], out_dirty[0]
    end,
}]]
__bundle["require/features/aa/aa_collect"] = [[
local entity_lib = entity
local menu_setup = require('require/abc/menu_setup')
local player_condition = require('require/aa/player_condition')

local AA_COLLECT = {}
AA_COLLECT.last_side = 'left'

local function get_delay_for_current_condition()
    local ok, cond = pcall(player_condition.get)
    if not ok or not cond then return nil end
    local key = 'delay_' .. cond
    if not (menu_setup and menu_setup.ui) then return nil end
    local ui_item = menu_setup.ui[key]
    if not ui_item then return nil end
    local ok2, val = pcall(ui.get, ui_item)
    if not ok2 then return nil end
    local n = tonumber(val)
    if n then return n end
    return val
end

local function get_fifty_fifty_for_current_condition()
    local ok, cond = pcall(player_condition.get)
    if not ok or not cond then return nil end
    local key = 'fifty_fifty_' .. cond
    if not (menu_setup and menu_setup.ui) then return nil end
    local ui_item = menu_setup.ui[key]
    if not ui_item then return nil end
    local ok2, val = pcall(ui.get, ui_item)
    if not ok2 then return nil end
    local n = tonumber(val)
    if n then return n end
    return val
end

local function get_body_yaw_mode_for_current_condition()
    local ok, cond = pcall(player_condition.get)
    if not ok or not cond then return nil end
    local key = 'body_yaw_mode_' .. cond
    if not (menu_setup and menu_setup.ui) then return nil end
    local ui_item = menu_setup.ui[key]
    if not ui_item then return nil end
    local ok2, val = pcall(ui.get, ui_item)
    if not ok2 then return nil end
    local n = tonumber(val)
    if n then return n end
    return val
end

local function resolve_side(me)
    if not (entity_lib and entity_lib.get_prop and me) then return AA_COLLECT.last_side end
    local pose = entity_lib.get_prop(me, 'm_flPoseParameter', 11)
    if pose == nil then
        return AA_COLLECT.last_side
    end
    local side = (pose > 0.5) and 'right' or 'left'
    AA_COLLECT.last_side = side
    return side
end

local function manual_switch_side()
    local delay = get_delay_for_current_condition() + 1
    local n = tonumber(delay) or 1
    if n < 1 then n = 1 end
    if n > 17 then n = 17 end

    local tick = globals.tickcount()
    if not tick then return AA_COLLECT.last_side end

    local phase = math.floor(tick / n) % 2
    local side = (phase == 0) and 'left' or 'right'
    AA_COLLECT.last_side = side
    return side
end




local function resolve_local_side()

    local fifty_fifty = get_fifty_fifty_for_current_condition()

    if fifty_fifty then
        local r = math.random(0, 1)
        local side = (r == 0) and 'left' or 'right'
        AA_COLLECT.last_side = side
        return side
    end

    local delay = get_delay_for_current_condition()
    local n = tonumber(delay)

    if get_body_yaw_mode_for_current_condition() ~= 'jitter' then
        return resolve_side(entity_lib.get_local_player())
    end

    if not n or n == 0 then
        local me = entity_lib.get_local_player()
        if not me or me == 0 then return AA_COLLECT.last_side end
        return resolve_side(me)
    else
        return manual_switch_side()
    end
end





AA_COLLECT.resolve_side = resolve_side
AA_COLLECT.resolve_local_side = resolve_local_side
AA_COLLECT.get_delay_for_current_condition = get_delay_for_current_condition

return AA_COLLECT]]
__bundle["require/features/aa/antiaim"] = [[local builder = require('require/features/aa/builder')
local defensive = require('require/features/aa/defensive')

local callbacks = require('require/abc/callbacks')

local function alive_enemies()
    local max = (globals.maxplayers and globals.maxplayers() or 64)
    local get_class, is_enemy, is_alive = entity.get_classname, entity.is_enemy, entity.is_alive
    if not (get_class and is_enemy and is_alive) then return 0 end
    local alive = 0
    for i=1,max do
        if get_class(i) == 'CCSPlayer' and is_enemy(i) and is_alive(i) then alive = alive + 1 end
    end
    return alive
end

callbacks.register('setup_command', function(cmd)
    if builder and builder.activate then
        builder.activate(cmd)
    end

end, { alive_only = true, require_login = true })]]
__bundle["require/features/aa/antibrute"] = [[]]
__bundle["require/features/aa/builder"] = [[local menu_setup = require('require/abc/menu_setup')
local player_condition = require('require/aa/player_condition')
local aa_collect = require('require/features/aa/aa_collect')
local math_helper = require('require/help/math')
local vector = require('require/help/vector')
local T = require('require/help/time')
local S = require('require/help/string')

local last_fire_tick = {}
client.set_event_callback('weapon_fire', function(e)
  if not e or not e.userid then return end
  local ok_ent, ent = pcall(client.userid_to_entindex, e.userid)
  if not ok_ent or not ent or ent == 0 then return end
  last_fire_tick[ent] = T.tickcount()
end)

local function gather_aa_values_for_condition(cond)
	if not cond then return nil end

	local keys = {
		pitch = 'pitch_',
		yaw_base = 'yaw_base_',
		yaw = 'yaw_',
		body_yaw_base = 'body_yaw_base_',
		body_yaw_left = 'body_yaw_left_',
		body_yaw_right = 'body_yaw_right_',
		randomize_yaw = 'randomize_yaw_',
		yaw_jitter = 'yaw_jitter_',
		yaw_jitter_base = 'yaw_jitter_base_',
		body_yaw_mode = 'body_yaw_mode_',
		static_body_yaw = 'static_body_yaw_',
		body_yaw_value = 'body_yaw_value_',
		delay = 'delay_',
		fifty_fifty = 'fifty_fifty_',
		only_flip_on_0_choke = 'only_flip_on_0_choke_',
	}

	local out = { condition = cond }
	for name, prefix in pairs(keys) do
		local key = prefix .. cond
		local ui_item = menu_setup.ui and menu_setup.ui[key]
		if ui_item then
			local ok, val = pcall(ui.get, ui_item)
			if ok then out[name] = val else out[name] = nil end
		else
			out[name] = nil
		end
	end

	return out
end




local function get_pitch_for_current_condition()
  local ok, cond = pcall(player_condition.get)
  if not ok or not cond then
    return nil
  end
  local tbl = gather_aa_values_for_condition(cond)
  return tbl and tbl.pitch or nil
end




local function get_yaw_base_for_current_condition()
  local ok, cond = pcall(player_condition.get)
  if not ok or not cond then
    return nil
  end
  local tbl = gather_aa_values_for_condition(cond)
  local raw = tbl and tbl.yaw_base or nil
  if raw == nil then return nil end
  local s = S.lower(tostring(raw))
  if s == 'threat' then
    return 'local view'
  elseif s == 'distance' then
    return 'local view'
  elseif s == 'target' then
    return 'at targets'
  elseif s == 'view' then
    return 'local view'
  elseif s == 'smart' then
    return 'local view'
  else
    return tostring(raw)
  end
end




local function get_yaw_for_current_condition()
	local ok, cond = pcall(player_condition.get)
	if not ok or not cond then
		return nil
	end
	local tbl = gather_aa_values_for_condition(cond)
	return tbl and tbl.yaw or nil
end




local function get_yaw_jitter_for_current_condition()
    local ok, cond = pcall(player_condition.get)
    if not ok or not cond then
        return nil
    end
    local tbl = gather_aa_values_for_condition(cond)
    return tbl and tbl.yaw_jitter or nil
end




local function get_yaw_jitter_base_for_current_condition()
  local ok, cond = pcall(player_condition.get)
  if not ok or not cond then
    return nil
  end
  local tbl = gather_aa_values_for_condition(cond)
  return tbl and tbl.yaw_jitter_base or nil
end




local function get_randomize_yaw_for_current_condition()
  local ok, cond = pcall(player_condition.get)
  if not ok or not cond then return nil end
  local tbl = gather_aa_values_for_condition(cond)
  if not tbl then return nil end
  local v = tbl.randomize_yaw
  if v == nil then return nil end
  local n = tonumber(v)
  if not n then return nil end
  if n < 0 then n = 0 end
  if n > 30 then n = 30 end
  return math.floor(n)
end




local function get_body_yaw_mode_for_current_condition()
    local ok, cond = pcall(player_condition.get)
    if not ok or not cond then
        return nil
    end
  local tbl = gather_aa_values_for_condition(cond)
  local mode = tbl and tbl.body_yaw_mode or nil
  if not mode then return nil end
  local mode_l = S.lower(tostring(mode))
  if mode_l == 'jitter' then
    local delay = aa_collect.get_delay_for_current_condition and aa_collect.get_delay_for_current_condition() or nil
    local n = tonumber(delay) or 0
    if n > 0 then
      return 'static'
    else
      return 'jitter'
    end
  end
  return mode
end




local function get_body_yaw_value_for_current_condition()
  local ok, cond = pcall(player_condition.get)
  if not ok or not cond then
    return nil
  end
  local tbl = gather_aa_values_for_condition(cond)
  if not tbl then return nil end


  local mode = tbl.body_yaw_mode
  if mode ~= nil then mode = S.lower(tostring(mode)) end

  if mode == 'jitter' then
    local delay = aa_collect.get_delay_for_current_condition and aa_collect.get_delay_for_current_condition() or nil
    local nd = tonumber(delay) or 0
    if nd > 0 then
      local side = aa_collect.resolve_local_side and aa_collect.resolve_local_side() or nil
      if side == 'right' then
        return -58
      else
        return 58
      end
    end

    local raw = tbl.body_yaw_value
    local n = tonumber(raw) or nil
    if n == 1 then
      return -180
    elseif n == 2 then
      return 0
    elseif n == 3 then
      return 180
    end
    return nil
  elseif mode == 'static' then
    if tbl.static_body_yaw ~= nil then
      local num = tonumber(tbl.static_body_yaw)
      if num then return num end
    end
    local raw = tbl.body_yaw_value
    local n = tonumber(raw) or nil
    if n == 1 then
      return -180
    elseif n == 2 then
      return 0
    elseif n == 3 then
      return 180
    end
    return nil
  else
    return 0
  end
end




local function get_body_yaw_for_current_condition()
  local ok, cond = pcall(player_condition.get)
  if not ok or not cond then
    return nil
  end
  local tbl = gather_aa_values_for_condition(cond)
  return tbl and tbl.body_yaw_base or nil
end




local function get_body_yaw_left_for_current_condition()
    local ok, cond = pcall(player_condition.get)
    if not ok or not cond then
        return nil
    end
    local tbl = gather_aa_values_for_condition(cond)
    return tbl and tbl.body_yaw_left or nil
end




local function get_body_yaw_right_for_current_condition()
    local ok, cond = pcall(player_condition.get)
    if not ok or not cond then
        return nil
    end
    local tbl = gather_aa_values_for_condition(cond)
    return tbl and tbl.body_yaw_right or nil
end




local function get_only_flip_on_0_choke_for_current_condition()
    local ok, cond = pcall(player_condition.get)
    if not ok or not cond then
        return nil
    end
    local tbl = gather_aa_values_for_condition(cond)
    if not tbl then return nil end
    local v = tbl.only_flip_on_0_choke
    if v == nil then return nil end
    return not not v
end




local function get_delay_for_current_condition()
  local ok, cond = pcall(player_condition.get)
  if not ok or not cond then
    return nil
  end
  local key = 'delay_' .. cond
  if not (menu_setup and menu_setup.ui) then return nil end
  local ui_item = menu_setup.ui[key]
  if not ui_item then return nil end
  local ok2, val = pcall(ui.get, ui_item)
  if ok2 then return val end
  return nil
end




local function get_fifty_fifty_for_current_condition()
  local ok, cond = pcall(player_condition.get)
  if not ok or not cond then return nil end
  local tbl = gather_aa_values_for_condition(cond)
  if not tbl then return nil end
  local v = tbl.fifty_fifty
  if v == nil then return nil end
  return not not v
end





local function get_correct_yaw_for_threat(mode)
  local mode_l = S.lower(tostring(mode or 'threat'))

  local thr = nil
  if mode_l == 'distance' then
    local ok_players, players = pcall(entity.get_players, true)
    if not ok_players or not players or #players == 0 then return nil end
    local me = entity.get_local_player()
    if not me then return nil end
    local ok_me, mx, my, mz = pcall(entity.get_origin, me)
    if not ok_me or not mx then return nil end
    local best_ent = nil
    local best_dist = nil
    for _, ent in ipairs(players) do
      if ent and entity.is_alive and entity.is_alive(ent) and entity.is_enemy and entity.is_enemy(ent) then
        local ok_e, ex, ey, ez = pcall(entity.get_origin, ent)
        if ok_e and ex then
          local dist = math_helper.distance2d(mx, my, ex, ey)
          if not best_dist or dist < best_dist then
            best_dist = dist
            best_ent = ent
          end
        end
      end
    end
    thr = best_ent
    elseif mode_l == 'smart' then
      local ok_players, players = pcall(entity.get_players, true)
      if ok_players and players and #players > 0 then
        local me = entity.get_local_player()
        if me then
          local ok_me, mx, my, mz = pcall(entity.get_origin, me)
          if ok_me and mx then
            local best_ent = nil
            local best_dist = nil
            for _, ent in ipairs(players) do
              if ent and entity.is_alive and entity.is_alive(ent) and entity.is_enemy and entity.is_enemy(ent) then
                local ok_e, ex, ey, ez = pcall(entity.get_origin, ent)
                if ok_e and ex then
                  local last = last_fire_tick[ent]
                  if last and T.within_ticks_window(last, 10) then goto continue_smart end
                  local ok_w, w = pcall(entity.get_player_weapon, ent)
                  if ok_w and w and w ~= 0 then
                    local ok_cn, cn = pcall(entity.get_classname, w)
                    local cn_l = S.lower(ok_cn and cn and tostring(cn) or '')
                    if cn_l:find('knife') or cn_l:find('grenade') or cn_l:find('taser') or cn_l:find('zeus') then goto continue_smart end
                  end
                  do
                    local dist = math_helper.distance2d(mx, my, ex, ey)
                    if not best_dist or dist < best_dist then
                      best_dist = dist
                      best_ent = ent
                    end
                  end
                  ::continue_smart::
                end
              end
            end
            thr = best_ent
          end
        end
      end
      if not thr then
        local ok_thr, t = pcall(client.current_threat)
        if ok_thr and t then thr = t end
      end
    else
      local ok_thr, t = pcall(client.current_threat)
      if ok_thr and t then thr = t end
    end

  if not thr then return nil end
  if not (entity.is_alive and entity.is_enemy and entity.is_alive(thr) and entity.is_enemy(thr)) then
    return nil
  end

  local me = entity.get_local_player()
  if not me then return nil end

  local ok_my, mx, my, mz = pcall(entity.get_origin, me)
  local ok_en, ex, ey, ez = pcall(entity.get_origin, thr)
  if not ok_my or not ok_en or not mx or not ex then return nil end

  local dx = ex - mx
  local dy = ey - my
  local ang_rad = math.atan2(dy, dx)
  local ang_deg = math_helper.rad_to_deg(ang_rad)

  local ok_cam, cam_pitch, cam_yaw = pcall(client.camera_angles)
  local view_yaw = ok_cam and cam_yaw or 0

  local delta = math_helper.normalize_angle(ang_deg - view_yaw)
  return math_helper and math_helper.round and math_helper.round(delta) or math.floor(delta + 0.5)

end




local gs_item_refs = {}
local gs_ref_visible = {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
    for _, ref in ipairs(refs) do
        gs_ref_visible[ref] = true
    end
end





local function legit(cmd)
  if weaponn ~= nil and entity.get_classname(weaponn) == "CC4" then
    if cmd.in_attack == 1 then
        cmd.in_attack = 0 
        cmd.in_use = 1
    end
  else
    if cmd.chokedcommands == 0 then
        cmd.in_use = 0
    end
  end

end





local function antiami_builder_function(cmd)

    local choke = cmd.chokedcommands
    
    if get_only_flip_on_0_choke_for_current_condition() then
        if choke > 0 then
            return
        end
    end

    local side = aa_collect.resolve_local_side()

    
    
    
    ui.set(gs_item_refs[2][1], tostring(get_pitch_for_current_condition()))

    
    
    
    ui.set(gs_item_refs[3][1], tostring(get_yaw_base_for_current_condition()))

    
    
    
    local yaw_mode = get_yaw_for_current_condition()
    if yaw_mode == "3way" then
      yaw_mode = '180'
    elseif yaw_mode == "ideal" then
      yaw_mode = '180'
    end
    ui.set(gs_item_refs[4][1], yaw_mode)

    
    
    
    ui.set(gs_item_refs[5][1], tostring(get_yaw_jitter_for_current_condition()))

    
    
    
    ui.set(gs_item_refs[5][2], tostring(get_yaw_jitter_base_for_current_condition()))

    
    
    
    ui.set(gs_item_refs[6][1], tostring(get_body_yaw_mode_for_current_condition()))

    
    
    
    ui.set(gs_item_refs[6][2], tostring(get_body_yaw_value_for_current_condition()))

    
    
    
    local base = tonumber(get_body_yaw_for_current_condition()) or 0
    local offset = 0
    if ui.get(gs_item_refs[4][1]) == '180' then
      if side == 'right' then
        offset = tonumber(get_body_yaw_left_for_current_condition()) or 0
      elseif side == 'left' then
        offset = tonumber(get_body_yaw_right_for_current_condition()) or 0
      end
    end
    local body_yaw_add_num = base + offset
    local rand_pct = tonumber(get_randomize_yaw_for_current_condition()) or 0
    if rand_pct > 0 then
      local variation = math.abs(body_yaw_add_num) * (rand_pct / 100)
      local rand_scale = (math_helper.random_int(-1000, 1000) / 1000)
      local rnd_offset = rand_scale * variation
      body_yaw_add_num = body_yaw_add_num + rnd_offset
    end

    do
      local okc, cond = pcall(player_condition.get)
      if okc and cond then
        local tbl = gather_aa_values_for_condition(cond)
        if tbl then
          local yb = S.lower(tostring(tbl.yaw_base or ''))
          if yb == 'threat' or yb == 'distance' then
            local threat_delta = get_correct_yaw_for_threat(yb)
            if threat_delta then
              body_yaw_add_num = body_yaw_add_num + tonumber(threat_delta) or body_yaw_add_num
            end
          end
        end
      end
    end

    local norm_body_yaw = math_helper.normalize_angle(body_yaw_add_num)
    ui.set(gs_item_refs[4][2], math_helper.round(norm_body_yaw))

    
    
    
    legit(cmd)

end


return {
  gather = gather_aa_values_for_condition,
  activate = antiami_builder_function,
  print_current = antiami_builder_function,
}]]
__bundle["require/features/aa/defensive"] = [[local DEF = {}
DEF.active = nil
DEF.activate = nil
local time_helper = require('require/help/time')
local menu_setup = require('require/abc/menu_setup')
local presets = require('require/features/aa/defensive_presets')
local player_condition = require('require/aa/player_condition')
local screenlog = require('require/abc/screen_logger')
local callbacks_ok, callbacks = pcall(require, 'require/abc/callbacks')




local gs_item_refs = {}
local gs_ref_visible = {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'RAGE', 'Aimbot', 'Double tap' },
    { 'RAGE', 'Other', 'Duck peek assist' },

}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
    for _, ref in ipairs(refs) do
        gs_ref_visible[ref] = true
    end
end


local _preset_state = {
    cond = nil,
    idx = nil,
    preset = nil,
    selected_tick = 0,
}
local _was_enabled = false
local _last_reset_tick = 0





local _dt_state = {
    last = false,
    pending_until = nil,
}
local function doubletap_is_active()
    local ok, v = pcall(ui.get, gs_item_refs[10][2])
    local cur = ok and not not v or false
    local tick = time_helper.tickcount() or (globals and globals.tickcount and globals.tickcount()) or 0
    if cur and not _dt_state.last then
        _dt_state.pending_until = tick + 32
    end
    if not cur then
        _dt_state.pending_until = nil
    end
    _dt_state.last = cur
    if _dt_state.pending_until then
        return tick >= _dt_state.pending_until
    end
    return cur
end

local function duckpeekassist_is_active()
    local refs = gs_item_refs[11]
    if not refs or not refs[1] then
        return false
    end
    local ok, v = pcall(ui.get, refs[1])
    return ok and not not v or false
end

local function is_knife_equipped()
  local lp = entity.get_local_player()
  if not lp or not entity.is_alive(lp) then
    return false
  end
  local weapon = entity.get_player_weapon(lp)
  if not weapon then
    return false
  end
  local classname = entity.get_classname(weapon)
  return classname == "CKnife"
end




local function defensive_hotkey_is_active()
    if not menu_setup or type(menu_setup) ~= 'table' or not menu_setup.ui then
        return false
    end
    local ref = menu_setup.ui.fakelag_defensive
    if not ref then
        return false
    end
    local ok, v = pcall(ui.get, ref)
    return ok and not not v or false
end

local function defensive_force()
    if not menu_setup or type(menu_setup) ~= 'table' or not menu_setup.ui then
        return false
    end
    local ref = menu_setup.ui.fakelag_force
    if not ref then
        return false
    end
    local ok, v = pcall(ui.get, ref)
    return ok and not not v or false
end

local function reset_defensive(cmd)

    


    local tick = (globals and globals.tickcount and globals.tickcount()) or time_helper.tickcount() or 0
    _last_reset_tick = tick
end




local function defensive_grace(window)

    window = window or 20
    local local_player = entity.get_local_player()
    if not local_player then return false end
    local simtime = entity.get_prop(local_player, "m_flSimulationTime")
    local tickrate = 1 / globals.tickinterval()
    if not simtime or tickrate == 0 then return false end
    local simtick = math.floor(simtime * tickrate + 0.5)
    local current_tick = globals.tickcount()
    nigga = current_tick >= simtick and current_tick <= simtick + window

    return current_tick >= simtick and current_tick <= simtick + window

end







local function active(cmd)
    
    
    
    local enabled = false
    local def_on = defensive_hotkey_is_active()
    local def_dt = doubletap_is_active()
    local def_fd = duckpeekassist_is_active()
    local def_knife = is_knife_equipped()
    local def_grace = defensive_grace()
    

    enabled = def_on and def_dt and not def_fd and not def_knife 
    DEF.active = enabled


    local tick = (globals and globals.tickcount and globals.tickcount()) or time_helper.tickcount() or 0
    local is_reset_tick = false
    if tick and (_last_reset_tick == nil or tick - _last_reset_tick >= 64) then
        is_reset_tick = true
        reset_defensive(cmd)
    end



    
    
    

    
    
    
    if enabled then
        local cond = player_condition.get() or 'global'
        if (not _was_enabled) or (_preset_state.cond ~= cond) or (not _preset_state.preset) then
            local idx, p = presets.get_random_for_condition(cond)
            if idx and p then
                _preset_state.cond = cond
                _preset_state.idx = idx
                _preset_state.preset = p
                _preset_state.selected_tick = globals.tickcount()
            else
                _preset_state.cond = cond
                _preset_state.idx = nil
                _preset_state.preset = nil
                _preset_state.selected_tick = 0
            end
        end

        if not is_reset_tick then
            if _preset_state.preset and type(_preset_state.preset.apply) == 'function' then
                _preset_state.preset.apply(_preset_state, cmd)
            end
        end
    else
        if _was_enabled then
            _preset_state.cond = nil
            _preset_state.idx = nil
            _preset_state.preset = nil
            _preset_state.selected_tick = 0
        end
    end

    _was_enabled = enabled

end


DEF.activate = active
DEF.reset = reset_defensive


callbacks.register('setup_command', function(cmd)
    active(cmd)
end, { alive_only = true, require_login = true })


return DEF]]
__bundle["require/features/aa/defensive_presets"] = [[local player_condition = require('require/aa/player_condition')
local time_helper = require('require/help/time')
local screenlog = require('require/abc/screen_logger')



local gs_item_refs = {}
local gs_ref_visible = {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },

}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
    for _, ref in ipairs(refs) do
        gs_ref_visible[ref] = true
    end
end


local M = {}

local function clamp(v, a, b) if v < a then return a end if v > b then return b end return v end

local function safe_set(gs_index, ref_index, value)
    local refs = gs_item_refs[gs_index]
    if not refs or not refs[ref_index] then return false end
    pcall(ui.set, refs[ref_index], value)
    return true
end



local ok_menu, menu_setup = pcall(require, "require/abc/menu_setup")



local function use_defensive(cmd)

    local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
    if not menu_ok or not menu_setup or not menu_setup.ui then return end
    local ok_get, misc_fakedef = pcall(ui.get, menu_setup.ui.fakelag_fakedef)

    
    if misc_fakedef then 
        cmd.force_defensive = false
    else
        cmd.force_defensive = true
    end

end

do
    local callbacks_ok, callbacks = pcall(require, "require/abc/callbacks")

    ticks = ticks or {}
    ticks.tickbase_max = ticks.tickbase_max or nil
    ticks.tickbase_diff = ticks.tickbase_diff or nil
    ticks.current_cmd = ticks.current_cmd or nil

    ticks.runc = function(cmd)
        if not cmd then return end
        ticks.current_cmd = cmd.command_number
    end

    ticks.tickcalc = function(cmd)
        if not cmd then return end
        if cmd.command_number == ticks.current_cmd then
            ticks.current_cmd = nil
            local lp = entity.get_local_player()
            if not lp then return end
            local tbase = entity.get_prop(lp, "m_nTickBase")
            if tbase then
                if ticks.tickbase_max ~= nil then
                    ticks.tickbase_diff = tbase - ticks.tickbase_max
                end
                ticks.tickbase_max = math.max(tbase, ticks.tickbase_max or 0)
            end
        end
    end

    if callbacks_ok and callbacks and callbacks.callback then
        callbacks.callback('run_command', ticks.runc, { alive_only = true, require_login = true })
        callbacks.callback('predict_command', ticks.tickcalc, { alive_only = true, require_login = true })
    end
end

client.set_event_callback("level_init", function()
    ticks.tickbase_max = nil
    ticks.tickbase_diff = nil
end)


local function get_defensive_grace(threshold)
    local lp = entity.get_local_player()
    if not lp then return false end

    local tickbase = entity.get_prop(lp, 'm_nTickBase')
    if not tickbase then return false end

    local tb_max = ticks and ticks.tickbase_max or 0

    if math.abs(tickbase - tb_max) > 64 then
        tb_max = 0
    end

    local defensive_ticks_left = 0

    if tickbase > tb_max then
        tb_max = tickbase
    elseif tb_max > tickbase then
        defensive_ticks_left = math.min(14, math.max(0, tb_max - tickbase - 1))
    end

    threshold = threshold or 7

    return defensive_ticks_left > threshold
end




local presets_by_condition = {



    stand = {

        [1] = {
            name = "jitter -90/90",
            apply = function(state, cmd)

                local tick = globals.tickcount()
                local phase = math.floor(tick / 2) % 2

                local function difpresets()
                    local tick = globals.tickcount()

                    if not state._next_change_at then
                        state._next_change_at = tick + math.random(24, 64)
                        state._mode = math.random(1, 3)
                        state._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        state._spin_speed = math.random(45, 55)
                        state._spin_angle = (phase == 0) and -90 or 90
                    end

                    if tick >= (state._next_change_at or 0) then
                        state._next_change_at = tick + math.random(24, 64)
                        state._mode = math.random(1, 3)
                        state._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        state._spin_speed = math.random(45, 55)
                        state._spin_angle = (phase == 0) and -90 or 90

                        if state._mode == 2 then
                            state._spin_until = tick + math.random(12, 24)
                        elseif state._mode == 3 then
                            local est_ticks = math.ceil(360 / state._spin_speed)
                            state._spin_until = tick + est_ticks
                            state._rest_until = tick + est_ticks + math.random(24, 64)
                            state._spin_done = false
                        else
                            state._spin_until = nil
                            state._rest_until = nil
                        end
                    end

                    if state._mode == 1 then
                        local side = (phase == 0) and -120 or 120
                        local pitch = 0
                        return side, pitch

                    elseif state._mode == 2 then
                        if state._spin_until and tick <= state._spin_until then
                            state._spin_angle = (state._spin_angle or ((phase == 0) and -90 or 90)) + (state._spin_dir * (state._spin_speed or 50))
                            if state._spin_angle > 180 then state._spin_angle = state._spin_angle - 360 end
                            if state._spin_angle < -180 then state._spin_angle = state._spin_angle + 360 end
                            return state._spin_angle, 0
                        end
                        local side = (phase == 0) and -90 or 90
                        return side, 0
                    else
                        if state._spin_until and tick <= state._spin_until then
                            state._spin_angle = (state._spin_angle or ((phase == 0) and -90 or 90)) + (state._spin_dir * (state._spin_speed or 50))
                            if state._spin_angle > 180 then state._spin_angle = state._spin_angle - 360 end
                            if state._spin_angle < -180 then state._spin_angle = state._spin_angle + 360 end
                            return state._spin_angle, -89
                        end

                        if state._rest_until and tick <= state._rest_until then
                            return nil, nil
                        end

                        local side = (phase == 0) and -90 or 90
                        return side, 0
                    end
                end

                local side, pitch = difpresets()

                if side ~= nil and cmd.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (get_defensive_grace(6))) then
                    use_defensive(cmd)
                    safe_set(4, 2, side)
                    safe_set(2, 1, 'Custom')
                    safe_set(2, 2, pitch)
                    safe_set(5, 1, 'off')
                    safe_set(6, 1, 'off')
                end

            end
        }
    },

    move = {

        [1] = {
            name = "jitter -90/90",
            apply = function(state, cmd)


                local tick = globals.tickcount()
                local phase = math.floor(tick / 2) % 2
                local side = (phase == 0) and -135 or 135
                state._side = side
                state._pitch = -55


                if cmd.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (get_defensive_grace(3))) then
                    use_defensive(cmd)
                    safe_set(4, 2, state._side)
                    safe_set(2, 1, 'Custom')
                    safe_set(2, 2, state._pitch)
                    safe_set(5, 1, 'off')
                    safe_set(6, 1, 'off')
                    safe_set(3, 1, 'at targets')
                end
            end
        }
    },

    walk = {

        [1] = {
            name = "jitter -90/90",
            apply = function(state, cmd)

                local tick = globals.tickcount()
                local phase = math.floor(tick / 2) % 2
                local default_side = (phase == 0) and -130 or 130

                
                local side, pitch
                if (tick % 8) == 0 then
                    side = 0
                    pitch = 89
                else
                    side = default_side
                    pitch = -65
                end

                state._side = side
                state._pitch = pitch





                if cmd.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (get_defensive_grace(3))) then
                    use_defensive(cmd)
                    safe_set(4, 2, state._side)
                    safe_set(2, 1, 'Custom')
                    safe_set(2, 2, state._pitch)
                    safe_set(5, 1, 'off')
                    safe_set(6, 1, 'off')
                    safe_set(3, 1, 'at targets')
                end
            end
        },
    },

    duck = {
        
        [1] = {
            name = "jitter -90/90",
            apply = function(state, cmd)

                local tick = globals.tickcount()
                local phase = math.floor(tick / 2) % 2

                local function difpresets()
                    local tick = globals.tickcount()

                    
                    if not state._next_change_at then
                        state._next_change_at = tick + math.random(24, 64)
                        state._mode = 1 
                    end

                    if tick >= (state._next_change_at or 0) then
                        state._next_change_at = tick + math.random(24, 64)
                        state._mode = math.random(1, 5)
                        
                        state._spin_dir = nil
                        state._spin_speed = nil
                        state._spin_angle = nil
                        state._jitter_yaw = nil
                        state._jitter_pitch = nil
                        state._rand_yaw = nil
                        state._rand_pitch = nil
                        state._rand_until = nil
                        state._phase_tick = tick
                    end

                    
                    
                    
                    
                    
                    

                    if state._mode == 1 then
                        if not state._spin_dir then
                            state._spin_dir = (math.random(0,1) == 0) and -1 or 1
                            state._spin_speed = 35
                            state._spin_angle = (phase == 0) and -90 or 90
                        end

                        if tick % 10 == 0 then
                            return nil, nil
                        end

                        state._spin_angle = (state._spin_angle or ((phase == 0) and -90 or 90)) + (state._spin_dir * (state._spin_speed or 45))
                        if state._spin_angle > 180 then state._spin_angle = state._spin_angle - 360 end
                        if state._spin_angle < -180 then state._spin_angle = state._spin_angle + 360 end
                        return state._spin_angle, 0

                    elseif state._mode == 2 then
                        local yaw = math.random(-100, 100)
                        return yaw, -50

                    elseif state._mode == 3 then
                        local yaw = math.random(-180, 180)
                        local pitch = math.random(-89, 89)
                        return yaw, pitch

                    elseif state._mode == 4 then
                        if not state._rand_until then
                            state._rand_yaw = math.random(-180, 180)
                            state._rand_pitch = math.random(-89, 89)
                            state._rand_until = tick + 2
                            state._rand_rest = tick + 3
                        end
                        if tick <= state._rand_until then
                            return state._rand_yaw, state._rand_pitch
                        elseif tick <= state._rand_rest then
                            return nil, nil
                        else
                            state._rand_until = nil
                            state._rand_rest = nil
                            return nil, nil
                        end

                    else
                        
                        if not state._ramp then
                            state._ramp = {}
                            state._ramp.yaw = math.random(-180, 180)
                            state._ramp.pitch = 89
                            state._ramp.dir = -1 
                        end

                        
                        if not state._ramp.step then state._ramp.step = 30 end
                        if state._ramp.pitch == 89 then
                            
                            state._ramp.pitch = state._ramp.pitch + (state._ramp.dir * state._ramp.step)
                            if state._ramp.pitch < -89 then state._ramp.pitch = -89 end
                            return state._ramp.yaw, 89
                        else
                            
                            local out_pitch = state._ramp.pitch
                            state._ramp.pitch = state._ramp.pitch + (state._ramp.dir * state._ramp.step)
                            if state._ramp.pitch <= -89 then
                                
                                state._ramp = nil
                            end
                            return state._ramp and state._ramp.yaw or math.random(-180,180), out_pitch
                        end
                    end
                end

                local side, pitch = difpresets()

                if side ~= nil and cmd.chokedcommands == 1 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (get_defensive_grace(8))) then
                    use_defensive(cmd)
                    safe_set(4, 2, side)
                    safe_set(2, 1, 'Custom')
                    safe_set(2, 2, pitch)
                    safe_set(5, 1, 'off')
                    safe_set(6, 1, 'off')
                    safe_set(3, 1, 'at targets')
                end
            end
        }
    },

    ["duck+"] = {
        
        [1] = {

            name = "jitter -90/90",
            apply = function(state, cmd)


                local tick = globals.tickcount()
                local phase = math.floor(tick / 2) % 2
                local side = (phase == 0) and -90 or 90
                state._side = 180
                state._pitch = -76


                if cmd.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (get_defensive_grace(1))) then
                    use_defensive(cmd)
                    safe_set(4, 2, state._side)
                    safe_set(2, 1, 'Custom')
                    safe_set(2, 2, state._pitch)
                    safe_set(5, 1, 'off')
                    safe_set(6, 1, 'off')
                    safe_set(3, 1, 'at targets')
                end

            end
        }
    },

    ['jump'] = {
        [1] = {
            name = "jitter -90/90",
            apply = function(state, cmd)

                local tick = globals.tickcount()
                
                if not state._spin_choice_at then
                    state._spin_choice_at = tick + 64
                    state._spin_dir = (math.random(0,1) == 0) and -1 or 1
                    state._spin_angle = 0
                end

                if tick >= (state._spin_choice_at or 0) then
                    state._spin_choice_at = tick + 64
                    state._spin_dir = (math.random(0,1) == 0) and -1 or 1
                end

                
                if (tick % 10) == 0 then
                    return
                end

                
                state._spin_angle = (state._spin_angle or 0) + (state._spin_dir * 35)
                if state._spin_angle > 180 then state._spin_angle = state._spin_angle - 360 end
                if state._spin_angle < -180 then state._spin_angle = state._spin_angle + 360 end

                local side = state._spin_angle
                state._side = side
                state._pitch = 0

                if cmd.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (get_defensive_grace(8))) then
                    use_defensive(cmd)
                    safe_set(4, 2, state._side)
                    safe_set(2, 1, 'Custom')
                    safe_set(2, 2, state._pitch)
                    safe_set(5, 1, 'off')
                    safe_set(6, 1, 'off')
                    safe_set(3, 1, 'at targets')
                end
            end
        },

    },

    ['jump+'] = {
        [0] = {
            name = "jitter -90/90",
            apply = function(state, cmd)

                local tick = globals.tickcount()
                local phase = math.floor(tick / 2) % 2
                local side = (phase == 0) and -90 or 90
                state._side = side
                state._pitch = 0

                if cmd.chokedcommands > 0 and (not (get_defensive_grace(6))) then
                    use_defensive(cmd)
                    safe_set(4, 2, state._side)
                    safe_set(2, 1, 'Custom')
                    safe_set(2, 2, state._pitch)
                    safe_set(5, 1, 'off')
                    safe_set(6, 1, 'off')
                    safe_set(3, 1, 'at targets')
                end
            end
        },
    },

    
    global = {
        [0] = {
            name = "back",
            apply = function(state, cmd)

            end
        }
    }


}





local function keys_sorted(t)
    local ks = {}
    for k, _ in pairs(t) do
        if type(k) == 'number' then table.insert(ks, k) end
    end
    table.sort(ks)
    return ks
end

function M.get_presets_for_condition(cond)
    cond = cond or player_condition.get() or 'global'
    return presets_by_condition[cond] or presets_by_condition['global'] or {}
end

function M.get_preset_by_index(cond, idx)
    local list = M.get_presets_for_condition(cond)
    return list[idx]
end

function M.get_random_for_condition(cond)
    local list = M.get_presets_for_condition(cond)
    local ks = keys_sorted(list)
    if #ks == 0 then return nil, nil end
    local pick = ks[math.random(1, #ks)]
    return pick, list[pick]
end

function M.get_random_for_current_condition()
    return M.get_random_for_condition(player_condition.get())
end


function M.get_next_for_condition(cond, current_idx)
    local list = M.get_presets_for_condition(cond)
    local ks = keys_sorted(list)
    if #ks == 0 then return nil, nil end
    
    local pos = 1
    for i, k in ipairs(ks) do
        if k == current_idx then pos = i; break end
    end
    local nextpos = (pos % #ks) + 1
    local nextk = ks[nextpos]
    return nextk, list[nextk]
end


function M.available_conditions()
    local out = {}
    for k, _ in pairs(presets_by_condition) do table.insert(out, k) end
    table.sort(out)
    return out
end

M._presets = presets_by_condition

return M]]
__bundle["require/features/misc/analyze"] = [[local function normalize_angle(angle)
	while angle > 180 do angle = angle - 360 end
	while angle < -180 do angle = angle + 360 end
	return angle
end

local player_labels = _G.player_labels or {}
_G.player_labels = player_labels

local get_history = function(ent)
	return (_G.player_history and _G.player_history[ent]) or nil
end

local ok_dispatch, resolver_dispatcher = pcall(require, "require/features/misc/resolver_dispatcher")
local callbacks = require('require/abc/callbacks')

local function analyze_ent(ent)
	
	local hist = get_history(ent)
	if not hist or #hist < 2 then
		player_labels[ent] = nil
		return
	end

	
	
	local ok_now, now = pcall(function() return (globals and globals.curtime and globals.curtime()) or nil end)
	if hist[1] and hist[1].last_shot_time and ok_now and now then
		local shot_age = now - hist[1].last_shot_time
		if shot_age >= 0 and shot_age <= 0.25 then
			player_labels[ent] = "ON SHOT"
			return
		end
	end

	
	local deltas = {}
	for i = 1, #hist - 1 do
		local a = hist[i] and hist[i].yaw
		local b = hist[i+1] and hist[i+1].yaw
		if a ~= nil and b ~= nil then
			deltas[#deltas + 1] = normalize_angle(a - b)
		end
	end

	if #deltas == 0 then
		player_labels[ent] = nil
		return
	end

	
	local sum, sumabs = 0, 0
	local maxv, minv = -1e9, 1e9
	for _, v in ipairs(deltas) do
		sum = sum + v
		sumabs = sumabs + math.abs(v)
		if v > maxv then maxv = v end
		if v < minv then minv = v end
	end
	local mean = sum / #deltas
	local meanabs = sumabs / #deltas

	local var = 0
	for _, v in ipairs(deltas) do
		var = var + (v - mean) ^ 2
	end
	local std = math.sqrt(var / #deltas)

	local sign_changes = 0
	for i = 2, #deltas do
		if (deltas[i] > 0 and deltas[i-1] < 0) or (deltas[i] < 0 and deltas[i-1] > 0) then
			sign_changes = sign_changes + 1
		end
	end

	
	local last_delta = deltas[1]
	local total_range = maxv - minv

	
	local sorted = {}
	for i, v in ipairs(deltas) do sorted[i] = v end
	table.sort(sorted)
	local median = sorted[math.ceil(#sorted / 2)]

	
	local features = {
		deltas = deltas,
		mean = mean,
		meanabs = meanabs,
		std = std,
		sign_changes = sign_changes,
		max_delta = maxv,
		min_delta = minv,
		total_range = total_range,
		median = median,
		last_delta = last_delta,
		samples = #deltas,
		last_yaw = hist[1] and hist[1].yaw,
		oldest_yaw = hist[#hist] and hist[#hist].yaw,
		hist = hist
	}

	
	do
		local speed_sum, speed_cnt = 0, 0
		local feet_yaw, goal_feet_yaw, move_anim
		for i=1,math.min(#hist, 20) do
			local s = hist[i]
			if s then
				if s.moveSpeedAnim then speed_sum = speed_sum + (s.moveSpeedAnim or 0); speed_cnt = speed_cnt + 1 end
				if s.speed2d then speed_sum = speed_sum + (s.speed2d or 0); speed_cnt = speed_cnt + 1 end
				if not feet_yaw and s.feetYaw then feet_yaw = s.feetYaw end
				if not goal_feet_yaw and s.goalFeetYaw then goal_feet_yaw = s.goalFeetYaw end
				if not move_anim and s.moveSpeedAnim then move_anim = s.moveSpeedAnim end
			end
		end
		local avg_speed = (speed_cnt > 0) and (speed_sum / speed_cnt) or 0
		features.movement = avg_speed >= 1.2
		features.avg_speed = avg_speed
		features.feet_yaw = feet_yaw
		features.goal_feet_yaw = goal_feet_yaw
		features.move_anim = move_anim
	end

	local label = nil
	if detect_static and detect_static(features, ent) then label = "STATIC" end
	if detect_spin and detect_spin(features, ent) then label = "SPIN" end
	if detect_jitter_minus and detect_jitter_minus(features, ent) then label = "JITTER-" end
	if detect_jitter and detect_jitter(features, ent) then label = "JITTER" end
	if detect_jitter_plus and detect_jitter_plus(features, ent) then label = "JITTER+" end
	if detect_sway and detect_sway(features, ent) then label = "SWAY" end
	if detect_skitter and detect_skitter(features, ent) then label = "SKITTER" end
	if detect_defensive and detect_defensive(features, ent) then label = "DEFENSIVE" end
	if detect_random and detect_random(features, ent) then label = "RANDOM" end
	if detect_delayed and detect_delayed(features, ent) then label = "DELAYED" end

	if not label then label = "?" end
	pcall(function()
		local name = nil
		pcall(function() name = entity.get_player_name(ent) end)
		local last_shot = "nil"
		if hist and hist[1] and hist[1].last_shot_time then
			last_shot = string.format("%.3f", hist[1].last_shot_time)
		end
		local feet = features.feet_yaw and string.format("%.2f", features.feet_yaw) or "nil"
		local goal_feet = features.goal_feet_yaw and string.format("%.2f", features.goal_feet_yaw) or "nil"

	end)

	player_labels[ent] = label

	
	if ok_dispatch and resolver_dispatcher and type(resolver_dispatcher.process_entity) == "function" then
		pcall(function() resolver_dispatcher.process_entity(ent, label, features) end)
	end
end



function detect_static(features, ent)
	local meanabs = features.meanabs or 0
	local std = features.std or 0
	local samples = features.samples or 0
	local deltas = features.deltas or {}
	local small_mean_thr = 1.0
	local small_std_thr = 1.5
	local motion_thr = 2.5

	if meanabs <= small_mean_thr and std <= small_std_thr then
		return true
	end

	local large_count = 0
	local first_large_idx = nil
	for i, d in ipairs(deltas) do
		if math.abs(d) >= motion_thr then
			large_count = large_count + 1
			if not first_large_idx then
				first_large_idx = i
			end
		end
	end

	if large_count == 0 then
		return true
	end

	if large_count == 1 and first_large_idx and first_large_idx > 20 then
		return true
	end

	return false
end

function detect_jitter_minus(features, ent)
	local meanabs = features.meanabs or 0
	local std = features.std or 0
	local samples = features.samples or 0
	local sign_changes = features.sign_changes or 0
	local maxd = math.max(math.abs(features.max_delta or 0), math.abs(features.min_delta or 0))

	local result = false

	if samples >= 4 then
		local min_mean = 5.0
		local max_mean = 12.0
		local std_max = 22.0
		local maxd_max = 40.0

		if meanabs >= min_mean and meanabs < max_mean and std <= std_max and maxd <= maxd_max then
			result = true
		end
	end

	return result
end

function detect_jitter(features, ent)
	local meanabs = features.meanabs or 0
	local std = features.std or 0
	local samples = features.samples or 0
	local sign_changes = features.sign_changes or 0
	local maxd = math.max(math.abs(features.max_delta or 0), math.abs(features.min_delta or 0))

	local result = false

	if samples >= 4 then
		local min_mean = (features.movement and 8.0) or 6.0
		local max_mean = 24.0
		local std_limit = 34.0
		local permissive_std = 28.0
		local maxd_allow = 100.0

		if meanabs >= min_mean and meanabs < max_mean and std <= std_limit then
			if sign_changes >= 2 or maxd <= maxd_allow or (meanabs < 12.0 and std <= permissive_std) then
				result = true
			end
		end
	end

	return result
end

function detect_jitter_plus(features, ent)
	local meanabs = features.meanabs or 0
	local std = features.std or 0
	local samples = features.samples or 0
	local sign_changes = features.sign_changes or 0
	local maxd = math.max(math.abs(features.max_delta or 0), math.abs(features.min_delta or 0))

	local result = false

	if samples >= 4 then
		local min_mean = 18.0
		local strong_mean = 22.0
		local std_min = 26.0
		local maxd_min = 70.0

		if meanabs >= min_mean and (std >= std_min or maxd >= maxd_min) then
			if meanabs >= strong_mean or maxd >= maxd_min or std >= (std_min + 8) then
				result = true
			end
		end
	end
	
	return result
end

function detect_sway(features, ent)
	local meanabs = features.meanabs or 0
	local std = features.std or 0
	local samples = features.samples or 0
	local sign_changes = features.sign_changes or 0
	local total_range = features.total_range or 0
	local maxd = math.max(math.abs(features.max_delta or 0), math.abs(features.min_delta or 0))

	local result = false

	if samples >= 6 then
		local min_mean = 2.5
		local max_mean = 15.0
		local min_sign_ratio = 0.08
		local min_total_range = 30.0
		local max_total_range = 180.0

		if meanabs >= min_mean and meanabs < max_mean and std <= 40.0 and total_range >= min_total_range and total_range <= max_total_range then
			if (sign_changes / math.max(1, samples)) >= min_sign_ratio then
				result = true
			end
		end
	end

	return result
end

function detect_spin(features, ent)
	local meanabs = features.meanabs or 0
	local std = features.std or 0
	local samples = features.samples or 0
	local sign_changes = features.sign_changes or 0
	local total_range = features.total_range or 0
	local last_delta = features.last_delta or 0
	local maxd = math.max(math.abs(features.max_delta or 0), math.abs(features.min_delta or 0))

	local deltas = features.deltas or {}

	local pos_count, neg_count, zero_count = 0, 0, 0
	for _, v in ipairs(deltas) do
		if v > 0.5 then pos_count = pos_count + 1
		elseif v < -0.5 then neg_count = neg_count + 1
		else zero_count = zero_count + 1 end
	end

	local dir_ratio = math.max(pos_count, neg_count) / math.max(1, samples)
	local dir_bias = math.abs(pos_count - neg_count) / math.max(1, (pos_count + neg_count))

	local longest_run, cur_run, last_sign = 0, 0, 0
	for _, v in ipairs(deltas) do
		local s = 0
		if v > 0.5 then s = 1 elseif v < -0.5 then s = -1 end
		if s ~= 0 and s == last_sign then
			cur_run = cur_run + 1
		else
			cur_run = (s ~= 0) and 1 or 0
			last_sign = s
		end
		if cur_run > longest_run then longest_run = cur_run end
	end

	local longest_ratio = longest_run / math.max(1, samples)

	local result = false

	if samples >= 6 then
		if total_range >= 300 and (dir_ratio >= 0.60 or dir_bias >= 0.60) then
			result = true
		end

		if not result and total_range >= 140 and meanabs >= 9 and (dir_ratio >= 0.75 or dir_bias >= 0.70 or sign_changes <= 1) then
			result = true
		end

		if not result and longest_ratio >= 0.50 and meanabs >= 8 and total_range >= 120 then
			result = true
		end

		if not result and maxd >= 120 and (dir_ratio >= 0.60 or dir_bias >= 0.60) then
			result = true
		end
	end
	local score = nil
	if not result and samples > 0 then
		local norm_range = math.min(total_range, 360) / 360.0
		local norm_meanabs = math.min(meanabs, 60) / 60.0
		local sign_change_frac = (sign_changes or 0) / math.max(1, samples)
		score = norm_range * 0.45 + norm_meanabs * 0.35 + dir_bias * 0.15 + dir_ratio * 0.05 - sign_change_frac * 0.20
		if score >= 0.42 and total_range >= 200 and meanabs >= 6 then
			result = true
		end
		features.spin_score = score
	end

	return result
end

function detect_skitter(features, ent)
	
	return false
end

function detect_defensive(features, ent)
	
	return false
end

function detect_random(features, ent)
	local meanabs = features.meanabs or 0
	local std = features.std or 0
	local samples = features.samples or 0
	local sign_changes = features.sign_changes or 0
	local total_range = features.total_range or 0
	local maxd = math.max(math.abs(features.max_delta or 0), math.abs(features.min_delta or 0))
	local deltas = features.deltas or {}

	if samples < 6 then return false end

	local sign_frac = sign_changes / math.max(1, samples)
	local moving = features.movement
	if sign_frac >= 0.45 and std >= (moving and 12.0 or 18.0) and meanabs >= (moving and 4.0 or 6.0) then
		return true
	end

	if maxd >= 120 and sign_frac >= 0.30 and std >= 12.0 then
		return true
	end

	if total_range >= 60 and total_range <= 300 and sign_frac >= 0.40 and std >= 14.0 and meanabs >= 4.0 then
		return true
	end

	if std >= 30.0 and sign_frac >= 0.25 and meanabs >= 5.0 then
		return true
	end

	return false
end

function detect_delayed(features, ent)
	local meanabs = features.meanabs or 0
	local std = features.std or 0
	local samples = features.samples or 0
	local sign_changes = features.sign_changes or 0
	local total_range = features.total_range or 0
	local maxd = math.max(math.abs(features.max_delta or 0), math.abs(features.min_delta or 0))

	if samples >= 6 then
		local min_mean = 2.5
		local max_mean = 24.0
		local min_std = 9.0
		local max_std = 40.0
		local min_total_range = 10.0

		if meanabs >= min_mean and meanabs < max_mean and std >= min_std and std <= max_std and total_range >= min_total_range then
			local sign_ratio = (sign_changes or 0) / math.max(1, samples)
			if sign_changes <= 3 or sign_ratio <= 0.12 or maxd >= 40 then
				return true
			end
		end
	end

	return false
end

local function analyzing_antiaim()
	local ok, players = pcall(entity.get_players, true)
	if not ok or type(players) ~= "table" then return end
	for _, ent in ipairs(players) do
		if entity.is_alive(ent) and not entity.is_dormant(ent) then
			pcall(analyze_ent, ent)
		else
			player_labels[ent] = nil
		end
	end
end

local function resolver_yaw_esp_flag(ent)
	if not entity.is_alive(entity.get_local_player()) then return end
	if not ent or ent == 0 then return end

	local lbl = player_labels[ent]


	if lbl then
		return true, lbl
	end

	local hist = get_history(ent)
	if hist and hist[1] and hist[1].yaw ~= nil then
		return true, tostring(hist[1].yaw)
	end
end

client.register_esp_flag("Resolver", 255, 255, 255, resolver_yaw_esp_flag)

callbacks.register('net_update_end', function()
	local ok_ms, menu_setup = pcall(require, "require/abc/menu_setup")
	if ok_ms and menu_setup and menu_setup.ui and menu_setup.ui.misc_resolver then
		local ok_get, enabled = pcall(ui.get, menu_setup.ui.misc_resolver)
		if ok_get and enabled then
			pcall(analyzing_antiaim)
		end
	end
end, { alive_only = true, require_login = true })
]]
__bundle["require/features/misc/backstab_assist"] = [[local menu_setup = require("require/abc/menu_setup")
local callbacks = require('require/abc/callbacks')
local enemies = require('require/help/enemies')

local aa_pitch = ui.reference("AA", "Anti-aimbot angles", "Pitch")
local aa_yaw_base = ui.reference("AA", "Anti-aimbot angles", "Yaw base")
local aa_yaw, aa_yaw_slider = ui.reference("AA", "Anti-aimbot angles", "Yaw")
local cached = nil

local function cache()
	if cached then return end
	cached = {}
	if aa_pitch then cached.pitch = ui.get(aa_pitch) end
	if aa_yaw_base then cached.yaw_base = ui.get(aa_yaw_base) end
	if aa_yaw then cached.yaw = ui.get(aa_yaw) end
	if aa_yaw_slider then cached.yaw_slider = ui.get(aa_yaw_slider) end
end

local function restore()
	if not cached then return end
	if aa_pitch and cached.pitch ~= nil then pcall(ui.set, aa_pitch, cached.pitch) end
	if aa_yaw_base and cached.yaw_base ~= nil then pcall(ui.set, aa_yaw_base, cached.yaw_base) end
	if aa_yaw and cached.yaw ~= nil then pcall(ui.set, aa_yaw, cached.yaw) end
	if aa_yaw_slider and cached.yaw_slider ~= nil then pcall(ui.set, aa_yaw_slider, cached.yaw_slider) end
	cached = nil
end

local function apply()
	cache()
	if aa_pitch then pcall(ui.set, aa_pitch, "Off") end
	if aa_yaw_base then pcall(ui.set, aa_yaw_base, "At targets") end
	if aa_yaw then pcall(ui.set, aa_yaw, "180") end
	if aa_yaw_slider then pcall(ui.set, aa_yaw_slider, 180) end
end

local function enemy_within_range(range)
	local lp = entity.get_local_player()
	if not lp or not entity.is_alive(lp) then return false end
	local list = enemies.list() or {}
	for _, enemy in ipairs(list) do
		if enemies.is_alive(enemy) and not enemies.is_dormant(enemy) and enemies.has_knife(enemy) then
			local dist = enemies.distance(enemy)
			if dist and dist <= range then
				return true
			end
		end
	end
	return false
end

local function handle(cmd)
	if not (menu_setup and menu_setup.ui and menu_setup.ui.misc_backstab) then restore() return end
	local ok, enabled = pcall(ui.get, menu_setup.ui.misc_backstab)
	if not ok or not enabled then restore() return end
	local range = 200
	if enemy_within_range(range) then
		apply()
	else
		restore()
	end
end

if menu_setup and menu_setup.ui and menu_setup.ui.misc_backstab then
	ui.set_callback(menu_setup.ui.misc_backstab, function()
		local ok, val = pcall(ui.get, menu_setup.ui.misc_backstab)
		if not ok or not val then restore() end
	end)
end

callbacks.register("setup_command", handle, { alive_only = true, require_login = true })
callbacks.register("shutdown", restore, { alive_only = true, require_login = true })]]
__bundle["require/features/misc/collect"] = [[
local M = {}


do
    local ok, ffi = pcall(require, "ffi")
    if ok and ffi and client and client.create_interface then
        local status, entity_list_ptr = pcall(function()
            return client.create_interface("client.dll", "VClientEntityList003")
        end)

        if status and entity_list_ptr then
            local pointer_type = ffi.typeof("void***")
            local entity_list = ffi.cast(pointer_type, entity_list_ptr)
            local ok_cast, get_client_entity = pcall(function()
                return ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
            end)

            if ok_cast and get_client_entity then
                
                local animstate_offset = 0x9960

                
                
                
                ffi.cdef[[
                struct animation_layer_t {
                    char  pad_0000[20];
                    uint32_t m_nOrder;
                    uint32_t m_nSequence;
                    float m_flPrevCycle;
                    float m_flWeight;
                    float m_flWeightDeltaRate;
                    float m_flPlaybackRate;
                    float m_flCycle;
                    void *m_pOwner;
                    char  pad_0038[4];
                };
                ] ]

                
                
                

                ffi.cdef[[
                struct c_animstate_min {
                    char pad0[3];
                    char m_bForceWeaponUpdate;
                    char pad1[91];
                    void* m_pBaseEntity;
                    void* m_pActiveWeapon;
                    void* m_pLastActiveWeapon;
                    float m_flLastClientSideAnimationUpdateTime;
                    int m_iLastClientSideAnimationUpdateFramecount;
                    float m_flAnimUpdateDelta;
                    float m_flEyeYaw;
                    float m_flPitch;
                    float m_flGoalFeetYaw;
                    float m_flCurrentFeetYaw;
                    float m_flCurrentTorsoYaw;
                    float m_flUnknownVelocityLean;
                    float m_flLeanAmount;
                    char pad2[4];
                    float m_flFeetCycle;
                    float m_flFeetYawRate;
                    char pad3[4];
                    float m_fDuckAmount;
                    float m_fLandingDuckAdditiveSomething;
                    char pad4[4];
                    float m_vOriginX;
                    float m_vOriginY;
                    float m_vOriginZ;
                    float m_vLastOriginX;
                    float m_vLastOriginY;
                    float m_vLastOriginZ;
                    float m_vVelocityX;
                    float m_vVelocityY;
                    char pad5[4];
                    float m_flUnknownFloat1;
                    char pad6[8];
                    float m_flUnknownFloat2;
                    float m_flUnknownFloat3;
                    float m_flUnknown;
                    float m_flSpeed2D;
                    float m_flUpVelocity;
                    float m_flSpeedNormalized;
                    float m_flFeetSpeedForwardsOrSideWays;
                    float m_flFeetSpeedUnknownForwardOrSideways;
                    float m_flTimeSinceStartedMoving;
                    float m_flTimeSinceStoppedMoving;
                    bool m_bOnGround;
                    bool m_bInHitGroundAnimation;
                    char pad7[2];
                    float m_flTimeSinceInAir;
                    float m_flLastOriginZ;
                    float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
                    float m_flStopToFullRunningFraction;
                    float m_flMagicFraction;
                    char pad8[60];
                    float m_flWorldForce;
                    char pad9[462];
                    float m_flMaxYaw;
                };
                ] ]

                
                M._get_animstate = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    
                    
                    local base = ffi.cast("char*", ent_ptr)
                    local anim_ptr_ptr = ffi.cast("struct c_animstate_min**", base + animstate_offset)
                    if anim_ptr_ptr == nil or anim_ptr_ptr == ffi.NULL then return nil end
                    local anim_ptr = anim_ptr_ptr[0]
                    if anim_ptr == nil or anim_ptr == ffi.NULL then return nil end
                    return anim_ptr
                end
                
                M._get_entity_ptr = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    return ent_ptr
                end
            end
        end
    end
end



function M.get_sim_time(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flSimulationTime") end)
    if ok then return val end
    return nil
end


function M.get_enemies_simtimes()
    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        out[ent] = M.get_sim_time(ent)
    end
    return out
end


function M.get_velocity_3d(ent)
    local ok, vals = pcall(function() return { entity.get_prop(ent, "m_vecVelocity") } end)
    if not ok or type(vals) ~= "table" then return nil end
    if #vals >= 3 then
        return { vals[1], vals[2], vals[3] }
    end
    return nil
end


function M.get_speed_2d(ent)
    local v = M.get_velocity_3d(ent)
    if not v then return nil end
    local x, y = v[1] or 0, v[2] or 0
    return math.sqrt(x * x + y * y)
end




function M.get_origin(ent)
    local ok, x, y, z = pcall(function() return entity.get_prop(ent, "m_vecOrigin") end)
    if ok and x then
        
        if type(x) == "table" then
            return x[1], x[2], x[3]
        elseif y and z then
            return x, y, z
        end
    end
    return nil
end


function M.get_view_offset(ent)
    local tries = { "m_vecViewOffset[0]", "m_vecViewOffset" }
    for _, prop in ipairs(tries) do
        local ok, v1, v2, v3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and v1 then
            if type(v1) == "table" then
                return v1[1], v1[2], v1[3]
            elseif v2 and v3 then
                return v1, v2, v3
            end
        end
    end
    return nil
end


function M.get_eye_pos(ent)
    local ox, oy, oz = M.get_origin(ent)
    local vx, vy, vz = M.get_view_offset(ent)
    if ox and vx then
        return ox + vx, oy + vy, oz + vz
    end
    return nil
end


function M.get_eye_angles(ent)
    local tries = { "m_angEyeAngles[0]", "m_angEyeAngles", "m_angRotation", "m_angNetworkAngles" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return nil
end


function M.get_abs_angles(ent)
    local tries = { "m_angAbsRotation", "m_angAbsAngles", "m_angAbsOrigin" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return M.get_eye_angles(ent)
end


function M.get_lower_body_yaw(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flLowerBodyYawTarget") end)
    if ok and val then return val end
    return nil
end


function M.get_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flCurrentFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    
    return M.get_lower_body_yaw(ent)
end

function M.get_goal_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flGoalFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    return M.get_feet_yaw(ent)
end


function M.get_speed(ent)
    
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flVelocityModifier") end)
    if ok and val then return val end
    
    local v = M.get_velocity_3d(ent)
    if v then
        return math.sqrt((v[1] or 0) * (v[1] or 0) + (v[2] or 0) * (v[2] or 0) + (v[3] or 0) * (v[3] or 0))
    end
    return nil
end

function M.get_move_speed_anim(ent)
    
    
    
    
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local try_fields = { "m_flFeetSpeedForwardsOrSideWays", "m_flSpeed2D", "m_flSpeedNormalized", "m_flFeetSpeedUnknownForwardOrSideways" }
            for _, f in ipairs(try_fields) do
                local okf, val = pcall(function() return tonumber(anim[f]) end)
                if okf and val and val ~= 0 then
                    return val
                end
            end
        end
    end

    
    local ok_nv, nv = pcall(function() return entity.get_prop(ent, "m_flMaxspeed") end)
    if ok_nv and nv then return nv end

    
    return M.get_speed_2d(ent)
end


function M.get_flags(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_fFlags") end)
    if ok and val then return val end
    ok, val = pcall(function() return entity.get_prop(ent, "m_iFlags") end)
    if ok and val then return val end
    return nil
end



function M.read_animstate(ent)
    if not M._get_animstate then return nil end
    local ok, anim = pcall(function() return M._get_animstate(ent) end)
    if not ok or not anim then return nil end
    local out = {}
    pcall(function()
        out.m_flEyeYaw = tonumber(anim.m_flEyeYaw)
        out.m_flPitch = tonumber(anim.m_flPitch)
        out.m_flGoalFeetYaw = tonumber(anim.m_flGoalFeetYaw)
        out.m_flCurrentFeetYaw = tonumber(anim.m_flCurrentFeetYaw)
        out.m_flCurrentTorsoYaw = tonumber(anim.m_flCurrentTorsoYaw)
        out.m_flUnknownVelocityLean = tonumber(anim.m_flUnknownVelocityLean)
        out.m_flLeanAmount = tonumber(anim.m_flLeanAmount)
        out.m_flFeetCycle = tonumber(anim.m_flFeetCycle)
        out.m_flFeetYawRate = tonumber(anim.m_flFeetYawRate)
        out.m_fDuckAmount = tonumber(anim.m_fDuckAmount)
        out.m_fLandingDuckAdditiveSomething = tonumber(anim.m_fLandingDuckAdditiveSomething)
        out.m_vOrigin = { tonumber(anim.m_vOriginX), tonumber(anim.m_vOriginY), tonumber(anim.m_vOriginZ) }
        out.m_vLastOrigin = { tonumber(anim.m_vLastOriginX), tonumber(anim.m_vLastOriginY), tonumber(anim.m_vLastOriginZ) }
        out.m_vVelocity = { tonumber(anim.m_vVelocityX), tonumber(anim.m_vVelocityY) }
        out.m_flUnknownFloat1 = tonumber(anim.m_flUnknownFloat1)
        out.m_flUnknownFloat2 = tonumber(anim.m_flUnknownFloat2)
        out.m_flUnknownFloat3 = tonumber(anim.m_flUnknownFloat3)
        out.m_flUnknown = tonumber(anim.m_flUnknown)
        out.m_flSpeed2D = tonumber(anim.m_flSpeed2D)
        out.m_flUpVelocity = tonumber(anim.m_flUpVelocity)
        out.m_flSpeedNormalized = tonumber(anim.m_flSpeedNormalized)
        out.m_flFeetSpeedForwardsOrSideWays = tonumber(anim.m_flFeetSpeedForwardsOrSideWays)
        out.m_flFeetSpeedUnknownForwardOrSideways = tonumber(anim.m_flFeetSpeedUnknownForwardOrSideways)
        out.m_flTimeSinceStartedMoving = tonumber(anim.m_flTimeSinceStartedMoving)
        out.m_flTimeSinceStoppedMoving = tonumber(anim.m_flTimeSinceStoppedMoving)
        out.m_bOnGround = (anim.m_bOnGround ~= 0)
        out.m_bInHitGroundAnimation = (anim.m_bInHitGroundAnimation ~= 0)
        out.m_flTimeSinceInAir = tonumber(anim.m_flTimeSinceInAir)
        out.m_flLastOriginZ = tonumber(anim.m_flLastOriginZ)
        out.m_flHeadHeightOrOffsetFromHittingGroundAnimation = tonumber(anim.m_flHeadHeightOrOffsetFromHittingGroundAnimation)
        out.m_flStopToFullRunningFraction = tonumber(anim.m_flStopToFullRunningFraction)
        out.m_flMagicFraction = tonumber(anim.m_flMagicFraction)
        out.m_flWorldForce = tonumber(anim.m_flWorldForce)
        out.m_flMaxYaw = tonumber(anim.m_flMaxYaw)
    end)
    return out
end



function M.read_anim_layers(ent)
    if not M._get_entity_ptr then return nil end
    local ok_ent, ent_ptr = pcall(function() return M._get_entity_ptr(ent) end)
    if not ok_ent or not ent_ptr then return nil end
    local ok, res = pcall(function()
        local ffi = require("ffi")
        local base = ffi.cast("char*", ent_ptr)
        local layers_ptr = ffi.cast("struct animation_layer_t**", base + 0x2990)
        if layers_ptr == nil or layers_ptr == ffi.NULL then return nil end
        local owner = layers_ptr[0]
        if owner == nil or owner == ffi.NULL then return nil end
        local out = {}
        for i = 0, 15 do
            local layer = owner[i]
            if layer == nil or layer == ffi.NULL then break end
            local t = {}
            t.m_nOrder = tonumber(layer.m_nOrder)
            t.m_nSequence = tonumber(layer.m_nSequence)
            t.m_flPrevCycle = tonumber(layer.m_flPrevCycle)
            t.m_flWeight = tonumber(layer.m_flWeight)
            t.m_flWeightDeltaRate = tonumber(layer.m_flWeightDeltaRate)
            t.m_flPlaybackRate = tonumber(layer.m_flPlaybackRate)
            t.m_flCycle = tonumber(layer.m_flCycle)
            t.m_pOwner = tostring(layer.m_pOwner)
            table.insert(out, t)
        end
        return out
    end)
    if not ok then return nil end
    return res
end


function M.get_tick_from_simtime(simtime)
    if not simtime or not globals or not globals.tickinterval then return nil end
    local ti = globals.tickinterval()
    if not ti or ti == 0 then return nil end
    return math.floor(simtime / ti + 0.5)
end

function M.get_tick(ent)
    local sim = M.get_sim_time(ent)
    if sim then return M.get_tick_from_simtime(sim) end
    return nil
end








function M.get_enemies_snapshot(opts)
    opts = opts or {}
    local heavy = true 

    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        local snap = {}

        
        snap.is_alive = (pcall(function() return entity.is_alive(ent) end) and entity.is_alive(ent)) or false
        snap.is_dormant = (pcall(function() return entity.is_dormant(ent) end) and entity.is_dormant(ent)) or false

        
        local ok_name, name = pcall(function() return entity.get_player_name(ent) end)
        snap.name = ok_name and name or nil

        
        snap.simtime = M.get_sim_time(ent)
        do
            local base_tick = snap.simtime and M.get_tick_from_simtime(snap.simtime) or nil
            
            local ok_flags, esp_flags = pcall(function()
                local d = entity.get_esp_data and entity.get_esp_data(ent)
                return (d and d.flags) or 0
            end)

            local adjusted_tick = base_tick
            if ok_flags and esp_flags and base_tick then
                
                local ok_bit, is_backtrack = pcall(function()
                    return bit and bit.band(esp_flags, bit.lshift(1, 17)) ~= 0
                end)
                if ok_bit and is_backtrack then
                    adjusted_tick = base_tick - 14
                end
            end
            snap.simTicks = adjusted_tick
        end

        
        do
            local ok, ox, oy, oz = pcall(function() return M.get_origin(ent) end)
            if ok and ox then snap.origin = { ox, oy, oz } end
        end
        do
            local ok, vx, vy, vz = pcall(function() return M.get_view_offset(ent) end)
            if ok and vx then snap.viewOffset = { vx, vy, vz } end
        end
        do
            local ok, ex, ey, ez = pcall(function() return M.get_eye_pos(ent) end)
            if ok and ex then snap.eyePos = { ex, ey, ez } end
        end

        
        do
            local ok, a1, a2, a3 = pcall(function() return M.get_eye_angles(ent) end)
            if ok and a1 then snap.eyeAngles = { a1, a2, a3 } end
        end
        do
            local ok, aa1, aa2, aa3 = pcall(function() return M.get_abs_angles(ent) end)
            if ok and aa1 then snap.absAngles = { aa1, aa2, aa3 } end
        end

        
        snap.lowerBodyYaw = (pcall(function() return M.get_lower_body_yaw(ent) end) and M.get_lower_body_yaw(ent)) or nil
        snap.feetYaw = (pcall(function() return M.get_feet_yaw(ent) end) and M.get_feet_yaw(ent)) or snap.lowerBodyYaw
        snap.goalFeetYaw = (pcall(function() return M.get_goal_feet_yaw(ent) end) and M.get_goal_feet_yaw(ent)) or snap.feetYaw

        
        snap.velocity3d = (pcall(function() return M.get_velocity_3d(ent) end) and M.get_velocity_3d(ent)) or nil
        if snap.velocity3d then
            snap.speed2d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0))
            snap.speed3d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0) + (snap.velocity3d[3] or 0) * (snap.velocity3d[3] or 0))
        else
            snap.speed2d = M.get_speed_2d(ent)
            snap.speed3d = M.get_speed(ent)
        end

        
        do
            local ok_ms, ms = pcall(function() return M.get_move_speed_anim(ent) end)
            if ok_ms and ms then
                snap.moveSpeedAnim = ms
            else
                snap.moveSpeedAnim = nil
            end
        end

        
        snap.flags = (pcall(function() return M.get_flags(ent) end) and M.get_flags(ent)) or nil

        
        local ok_head, hx, hy, hz = pcall(function() return entity.hitbox_position(ent, "head") end)
        if ok_head and hx then snap.headPos = { hx, hy, hz } end

        
        local ok_w, w = pcall(function() return entity.get_player_weapon(ent) end)
        snap.weapon = ok_w and w or nil

        

        
        local ok_b, bones = pcall(function() return entity.get_bone_matrices and entity.get_bone_matrices(ent) end)
        if ok_b and bones then snap.bones = bones end

        local ok_as, as = pcall(function() return M.read_animstate(ent) end)
        if ok_as and as then snap.animstate_full = as end
        local ok_layers, layers = pcall(function() return M.read_anim_layers(ent) end)
        if ok_layers and layers then snap.animLayers = layers end

        out[ent] = snap
    end
    return out
end

return M
]]
__bundle["require/features/misc/dormant_aimbot"] = [[local client_visible, client_eye_position, client_log, client_trace_bullet = client.visible, client.eye_position, client.log, client.trace_bullet
local entity_get_bounding_box, entity_get_local_player, entity_get_origin, entity_get_player_name, entity_get_player_resource, entity_get_player_weapon, entity_get_prop, entity_is_dormant, entity_is_enemy, entity_is_alive = entity.get_bounding_box, entity.get_local_player, entity.get_origin, entity.get_player_name, entity.get_player_resource, entity.get_player_weapon, entity.get_prop, entity.is_dormant, entity.is_enemy, entity.is_alive
local globals_curtime, globals_maxplayers, globals_tickcount = globals.curtime, globals.maxplayers, globals.tickcount
local math_max, math_min, math_sqrt = math.max, math.min, math.sqrt
local renderer_indicator, string_format, table_unpack = renderer.indicator, string.format, table.unpack or unpack
local ui_get, ui_new_checkbox, ui_new_color_picker, ui_new_hotkey, ui_new_multiselect, ui_new_slider, ui_reference, ui_set, ui_set_callback, ui_set_visible = ui.get, ui.new_checkbox, ui.new_color_picker, ui.new_hotkey, ui.new_multiselect, ui.new_slider, ui.reference, ui.set, ui.set_callback, ui.set_visible
local plist_get, entity_hitbox_position = plist.get, entity.hitbox_position
local ffi = require("ffi")
local vector = require("vector")
local weapons_data = require("gamesense/csgo_weapons")
local get_client_entity = vtable_bind("client_panorama.dll", "VClientEntityList003", 3, "void*(__thiscall*)(void*, int)")
local weapon_is_ready = vtable_thunk(166, "bool(__thiscall*)(void*)")
local get_weapon_inaccuracy = vtable_thunk(483, "float(__thiscall*)(void*)")
local rage_refs = {
	mindamage = ui_reference("RAGE", "Aimbot", "Minimum damage"),
	dormant_esp = ui_reference("VISUALS", "Player ESP", "Dormant"),
	override_mindamage = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}
local menu_setup = require("require/abc/menu_setup")
local callbacks = require('require/abc/callbacks')

local menu_cache = {}
local function menu_enabled(name)
	if type(menu_setup) ~= 'table' then return false end
	if menu_cache[name] == nil then menu_cache[name] = menu_setup.ui and menu_setup.ui[name] end
	local it = menu_cache[name]
	if not it then return false end
	local ok, val = pcall(ui_get, it)
	if not ok then
		menu_cache[name] = menu_setup.ui and menu_setup.ui[name]
		it = menu_cache[name]
		if not it then return false end
		ok, val = pcall(ui_get, it)
		if not ok then return false end
	end
	return val
end

local dormant_selected_hitboxes = { "Head", "Chest", "Stomach" }
local hitgroup_names = {
	"generic",
	"head",
	"chest",
	"stomach",
	"left arm",
	"right arm",
	"left leg",
	"right leg",
	"neck",
	"?",
	"gear"
}

local hitgroup_to_hitbox = {
	"",
	"Head",
	"Chest",
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs",
	"Head",
	"",
	""
}

local default_target_points = {
	{ scale = 5, hitbox = "Stomach", vec = vector(0, 0, 40) },
	{ scale = 6, hitbox = "Chest", vec = vector(0, 0, 50) },
	{ scale = 3, hitbox = "Head", vec = vector(0, 0, 58) },
	{ scale = 4, hitbox = "Legs", vec = vector(0, 0, 20) }
}

local hitbox_index_lookup = {
	[0] = "Head",
	nil,
	"Stomach",
	nil,
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs"
}

local freeze_end_tick = 0
local active_targets = {}
local dormant_memory = {}
local current_target_index = 1
local fired_this_command = false
local stored_hitbox
local stored_point_label
local stored_target
local stored_accuracy
local registered_hit = false
local last_seen_hitboxes = {}

local draw_hitbox_indices = {
	0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18
}

local function build_side_points(from_pos, target_pos, radius)
	local _, yaw = from_pos:to(target_pos):angles()
	local side_yaw = math.rad(yaw + 90)
	local side_offset = vector(math.cos(side_yaw), math.sin(side_yaw), 0) * radius

	return {
		{ text = "Middle", vec = target_pos },
		{ text = "Left", vec = target_pos + side_offset },
		{ text = "Right", vec = target_pos - side_offset }
	}
end

local function contains(list, value)
	for i = 1, #list do if list[i] == value then return true end end
	return false
end
local function find_index_by_first(list, value)
	for i = 1, #list do local v = list[i] if type(v) == 'table' and v[1] == value then return i end end
end
local function list_contains_player(list, player) return find_index_by_first(list, player) ~= nil end
local function remove_player_entry(list, player) local idx = find_index_by_first(list, player) if idx then table.remove(list, idx) end end

local function trim_movement(cmd, max_speed)
	local mv = math_sqrt(cmd.forwardmove*cmd.forwardmove + cmd.sidemove*cmd.sidemove)
	if max_speed<=0 or mv<=0 then return end
	if cmd.in_duck==1 then max_speed = max_speed*2.94117647 end
	if mv<=max_speed then return end
	local s = max_speed/mv; cmd.forwardmove = cmd.forwardmove*s; cmd.sidemove = cmd.sidemove*s
end

local function get_connected_enemies()
	local e, r = {}, entity_get_player_resource()
	for i=1,globals_maxplayers() do if entity_get_prop(r, "m_bConnected", i)==1 and i~=entity_get_local_player() and entity_is_enemy(i) then e[#e+1]=i end end
	return e
end
local function get_dormant_enemies()
	local e, r = {}, entity_get_player_resource()
	for i=1,globals_maxplayers() do if entity_get_prop(r, "m_bConnected", i)==1 and not plist_get(i, "Add to whitelist") and entity_is_dormant(i) and entity_is_enemy(i) then e[#e+1]=i end end
	return e
end

local function update_dormant_memory()
	for _,enemy in ipairs(get_connected_enemies()) do
		local _,_,_,_,alpha = entity_get_bounding_box(enemy)
		if alpha<1 then if not list_contains_player(dormant_memory,enemy) then dormant_memory[#dormant_memory+1]={enemy,globals_tickcount()} end else remove_player_entry(dormant_memory,enemy) end
	end
end

local function calculate_mindamage(target)
	local override_enabled = ui_get(rage_refs.override_mindamage[1]) and ui_get(rage_refs.override_mindamage[2])
	local slider = override_enabled and ui_get(rage_refs.override_mindamage[3]) or ui_get(rage_refs.mindamage)
	local th = entity.get_esp_data(target).health
	if slider>100 then slider = slider - 100 + th end
	return slider
end

local function get_weapon_speed(w,s) return (w.type=="sniperrifle" and s) and w.max_player_speed_alt or w.max_player_speed end

local function collect_target_points(target, origin, sel)
	local pts = {}
	local duck = entity_get_prop(target, "m_flDuckAmount") or 0
	for _,p in ipairs(default_target_points) do
		if #sel==0 or contains(sel,p.hitbox) then
			local off = p.vec
			if p.hitbox=="Head" then off = off - vector(0,0,duck*10) elseif p.hitbox=="Chest" then off = off - vector(0,0,duck*4) end
			pts[#pts+1]={vec=origin+off,scale=p.scale,hitbox=p.hitbox}
		end
	end
	for i=1,7 do
		local hb = hitbox_index_lookup[i-1]
		if hb and (#sel==0 or contains(sel,hb)) then
			local pos = entity_hitbox_position(target,i-1)
			if pos then pts[#pts+1]={vec=vector(pos),scale=3,hitbox=hb} end
		end
	end
	return pts
end

local function find_best_point(lp, wi, eye, tps, md)
	for _,p in ipairs(tps) do
		for _,off in ipairs(build_side_points(eye,p.vec,3)) do
			local _,d = client_trace_bullet(lp, eye.x,eye.y,eye.z, off.vec.x,off.vec.y,off.vec.z, true)
			if p.hitbox=="Head" then d=d*4 end
			if d>md then return off.vec,d,p.hitbox,off.text end
		end
	end
end

local function on_setup_command(cmd)
	update_dormant_memory()

	if not menu_enabled('misc_dormantaimbot') and menu_enabled('misc_dormantaimbot_key') then
		return
	end

	local local_player = entity_get_local_player()
	if not local_player or not entity_is_alive(local_player) then
		return
	end

	local weapon = entity_get_player_weapon(local_player)
	if not weapon then
		return
	end

	local weapon_entity = get_client_entity(weapon)
	if not weapon_entity or not weapon_is_ready(weapon_entity) then
		return
	end

	local inaccuracy = get_weapon_inaccuracy(weapon_entity)
	if not inaccuracy then
		return
	end

	local eye_position = vector(client_eye_position())
	local sim_time = entity_get_prop(local_player, "m_flSimulationTime")
	local tick = globals_tickcount()
	local weapon_info = weapons_data(weapon)
	local is_scoped = entity_get_prop(local_player, "m_bIsScoped") == 1
	local on_ground = bit.band(entity_get_prop(local_player, "m_fFlags"), bit.lshift(1, 0))

	local dormant_enemies = get_dormant_enemies()
	if #dormant_enemies == 0 then
		active_targets = {}
		return
	end

	if tick % #dormant_enemies ~= 0 then
		current_target_index = current_target_index + 1
	else
		current_target_index = 1
	end

	local target = dormant_enemies[current_target_index]
	if not target then
		active_targets = {}
		return
	end

	if tick < freeze_end_tick then
		active_targets = {}
		return
	end

	if weapon_info.type == "grenade" or weapon_info.type == "knife" then
		active_targets = {}
		return
	end

	if cmd.in_jump == 1 and on_ground == 0 then
		active_targets = {}
		return
	end

	local selected_hitboxes = dormant_selected_hitboxes
	local target_origin = vector(entity_get_origin(target))
	local _, _, _, _, screen_alpha = entity_get_bounding_box(target)

	active_targets[target] = nil

	if screen_alpha < 1 then
		if not list_contains_player(last_seen_hitboxes, target) then
			last_seen_hitboxes[#last_seen_hitboxes + 1] = { target, tick }
		end
	else
		remove_player_entry(last_seen_hitboxes, target)
	end

	local target_points = collect_target_points(target, target_origin, selected_hitboxes)
	local min_damage = calculate_mindamage(target)

	local can_fire
	if weapon_info.is_revolver then
		can_fire = sim_time > entity_get_prop(weapon, "m_flNextPrimaryAttack")
	else
		can_fire = sim_time > math_max(
			entity_get_prop(local_player, "m_flNextAttack"),
			entity_get_prop(weapon, "m_flNextPrimaryAttack"),
			entity_get_prop(weapon, "m_flNextSecondaryAttack")
		)
	end

	if not can_fire then
		return
	end

	local chosen_point, chosen_damage, chosen_hitbox, chosen_label = find_best_point(
		local_player,
		weapon_info,
		eye_position,
		target_points,
		min_damage
	)

	if not chosen_point then
		return
	end

	if client_visible(chosen_point.x, chosen_point.y, chosen_point.z) then
		return
	end

	trim_movement(cmd, get_weapon_speed(weapon_info, is_scoped) * 0.33)

	local pitch, yaw = eye_position:to(chosen_point):angles()

	if not is_scoped and weapon_info.type == "sniperrifle" and cmd.in_jump == 0 and on_ground == 1 then
		cmd.in_attack2 = 1
	end

	active_targets[target] = true

	if inaccuracy < 0.01 then
		cmd.pitch = pitch
		cmd.yaw = yaw
		cmd.in_attack = 1
		fired_this_command = true
		stored_hitbox = chosen_hitbox
		stored_point_label = chosen_label
		stored_target = target
		stored_accuracy = (ui_get(menu_setup.ui.misc_dormantaimbot_value) or 0)
	end
end

local function on_weapon_fire(event)
	client.delay_call(0.03, function()
		local local_player = entity_get_local_player()
		if client.userid_to_entindex(event.userid) ~= local_player then
			return
		end

		if fired_this_command and not registered_hit then
			client.fire_event("dormant_miss", {
				userid = stored_target,
				aim_hitbox = stored_hitbox,
				aim_point = stored_point_label,
				accuracy = stored_accuracy
			})
		end

		registered_hit = false
		fired_this_command = false
		stored_hitbox = nil
		stored_point_label = nil
		stored_target = nil
		stored_accuracy = nil
	end)
end

local function on_player_hurt(event)
	local victim = client.userid_to_entindex(event.userid)
	local attacker = client.userid_to_entindex(event.attacker)

	if attacker == entity_get_local_player() and victim ~= nil and fired_this_command then
		registered_hit = true

		client.fire_event("dormant_hit", {
			userid = victim,
			attacker = attacker,
			health = event.health,
			armor = event.armor,
			weapon = event.weapon,
			dmg_health = event.dmg_health,
			dmg_armor = event.dmg_armor,
			hitgroup = event.hitgroup,
			accuracy = stored_accuracy or 0,
			aim_hitbox = stored_hitbox
		})
	end
end

local function on_round_prestart()
	local freeze_time = (cvar.mp_freezetime:get_float() + 1) / globals.tickinterval()
	freeze_end_tick = globals_tickcount() + freeze_time
end

callbacks.register("setup_command", on_setup_command, { alive_only = true, require_login = true })
callbacks.register("round_prestart", on_round_prestart, { alive_only = true, require_login = true })
callbacks.register("player_hurt", on_player_hurt, { alive_only = true, require_login = true })
callbacks.register("weapon_fire", on_weapon_fire, { alive_only = true, require_login = true })

client.register_esp_flag("DA", 255, 255, 255, function(player)
	if menu_enabled('misc_dormantaimbot') and menu_enabled('misc_dormantaimbot_key') and entity_is_alive(entity_get_local_player()) then
		return active_targets[player]
	end
end)


callbacks.register("paint", function()
	if not entity_is_alive(entity_get_local_player()) then return end
	if menu_enabled('misc_dormantaimbot') and menu_enabled('misc_dormantaimbot_key') then
		local ic = {255,255,255,200}
		for _,v in pairs(active_targets) do if v then ic={143,194,21,255}; break end end
		if #get_dormant_enemies()==0 then ic={255,0,50,255} end
		renderer_indicator(ic[1],ic[2],ic[3],ic[4],"DA")
	end
end, { alive_only = true, require_login = true })]]
__bundle["require/features/misc/enhance_osaa"] = [[local ok_menu, menu_setup = pcall(require, "require/abc/menu_setup")

local callbacks = require('require/abc/callbacks')

local gs_item_refs = {}
local gs_ref_visible = {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
    for _, ref in ipairs(refs) do
        gs_ref_visible[ref] = true
    end
end

local shot_ticks = {}
local damage_ticks = {}

callbacks.register("weapon_fire", function(e)
    local local_player = entity.get_local_player()
    if local_player and client.userid_to_entindex(e.userid) == local_player then
        shot_ticks[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

callbacks.register("player_hurt", function(e)
    local local_player = entity.get_local_player()
    if local_player and client.userid_to_entindex(e.userid) == local_player then
        damage_ticks[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

local function has_fired()
    local now = globals.tickcount()
    local last_shot_tick = nil
    for t = now-20, now do
        if shot_ticks[t] then
            last_shot_tick = t
            break
        end
    end
    if last_shot_tick then
        if now - last_shot_tick <= 4 then
            return true
        end
        return true
    end
    return false
end



local function enhance_osaa(cmd)

    local has_fired = has_fired()

    local function has_option(tbl, name)
        if type(tbl) ~= 'table' then return false end
        for _, v in ipairs(tbl) do if tostring(v) == tostring(name) then return true end end
        return false
    end

    local selections = ui.get(menu_setup.ui.fakelag_settings_enhance_onshot) or {}

    if menu_setup and menu_setup.ui and has_fired then
            if has_option(selections, 'defensive') then
                cmd.force_defensive = true
            end

            if has_option(selections, 'roll') then
                ui.set(gs_item_refs[3][1], math.random(-45, 45))
            end

            local side_switch = globals.tickcount() % 4 < 2
            if has_option(selections, 'jitter') then
                ui.set(gs_item_refs[2][1], '180')
                ui.set(gs_item_refs[2][2], side_switch and 55 or -48)
            end
    end
end

callbacks.register('setup_command', function(cmd)

    enhance_osaa(cmd)

end, { alive_only = true, require_login = true })]]
__bundle["require/features/misc/events"] = [[local events = {}
local globals = globals

events.last_hit = {}
events.last_miss = {}

events.shots_queue = {}
events.shots_by_id = {}

function events.record_weapon_fire(ctx)
  if not ctx or not ctx.t then return end
  events.shots_queue[#events.shots_queue+1] = ctx
end

function events.record_aim_fire(id, ctx)
  if not id or not ctx then return end
  events.shots_by_id[id] = ctx
end

function events.record_aim_miss(id, victim, rec)
  if not victim then return end
  local now = globals.curtime()
  local rec2 = rec or {}
  rec2.time = now
  events.last_miss[victim] = rec2
  if id then events.shots_by_id[id] = nil end
end

function events.record_player_hurt(id, victim, rec)
  if not victim then return end
  local now = globals.curtime()
  local rec2 = rec or {}
  rec2.time = now
  events.last_hit[victim] = rec2
  if id then events.shots_by_id[id] = nil end
end

function events.link_recent_shot_to_victim(victim, max_age)
  max_age = max_age or 0.35
  local now = globals.curtime()
  for i=#events.shots_queue,1,-1 do
    local s = events.shots_queue[i]
    if s and s.target == victim and (now - (s.t or now)) <= max_age and not s.linked then
      events.shots_queue[i].linked = true
      return events.shots_queue[i]
    end
  end
  return nil
end

return events
]]
__bundle["require/features/misc/exploit_fakelag"] = [[local ok_menu, menu_setup = pcall(require, "require/abc/menu_setup")

local callbacks = require('require/abc/callbacks')

local gs_item_refs = {}
local gs_ref_visible = {}
for i, item in ipairs({
    { 'rage', 'aimbot', 'double tap' },
    { 'aa', 'other', 'on shot anti-aim' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },

}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
    for _, ref in ipairs(refs) do
        gs_ref_visible[ref] = true
    end
end


local function exploit_fakelag(cmd)

    local masterswitch = ui.get(menu_setup.ui.misc_exploit_fakelag)

    local doubletap = (ui.get(gs_item_refs[1][1]) and ui.get(gs_item_refs[1][2]))
    local onshot = (ui.get(gs_item_refs[2][1]) and ui.get(gs_item_refs[2][2]))

    local exploit = masterswitch and (doubletap or onshot)

    if exploit then
        ui.set(gs_item_refs[3][1], false)
    end

end

callbacks.register('setup_command', function(cmd)

    exploit_fakelag(cmd)

end, { alive_only = true, require_login = true })]]
__bundle["require/features/misc/fakelag"] = [[local gs_item_refs = {}
local gs_ref_visible = {}
for i, item in ipairs({
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
    for _, ref in ipairs(refs) do
        gs_ref_visible[ref] = true
    end
end

local _ms_ok, _ms = pcall(require, "require/abc/menu_setup")

local callbacks = require('require/abc/callbacks')

callbacks.register("setup_command", function()
    if not (_ms_ok and _ms and _ms.ui) then return end

    local ok_enabled, enabled = pcall(ui.get, _ms.ui.fakelag_fakelag)
    if not ok_enabled or not enabled then return end

    local ok_type, typ = pcall(ui.get, _ms.ui.fakelag_fakelag_type)
    if not ok_type then return end

    if tostring(typ) == "gamesense" then
        ui.set(gs_item_refs[1][1], true)
        local ok_amt, amt = pcall(ui.get, _ms.ui.fakelag_fakelag_amount)
        local ok_var, var = pcall(ui.get, _ms.ui.fakelag_fakelag_variance)
        local ok_lim, lim = pcall(ui.get, _ms.ui.fakelag_fakelag_limit)

        if ok_amt and amt and gs_item_refs[2] and gs_item_refs[2][1] then
            pcall(ui.set, gs_item_refs[2][1], amt)
        end
        if ok_var and var and gs_item_refs[3] and gs_item_refs[3][1] then
            pcall(ui.set, gs_item_refs[3][1], var)
        end
        if ok_lim and lim and gs_item_refs[4] and gs_item_refs[4][1] then
            pcall(ui.set, gs_item_refs[4][1], lim)
        end

        return
    end

    if tostring(typ) == "sodium" then
        ui.set(gs_item_refs[1][1], true)
        local ok_t2, t2 = pcall(ui.get, _ms.ui.fakelag_fakelag_type2)
        if not ok_t2 then return end

        if tostring(t2) == "jitter" then
            if gs_item_refs[2] and gs_item_refs[2][1] then
                pcall(ui.set, gs_item_refs[2][1], "dynamic")
            end
            local tick = globals.tickcount() or 0
            local var_val = math.max(tick % 101, 100)
            local lim_val = math.min(math.random(7) + (tick % 15), 11)
            if gs_item_refs[3] and gs_item_refs[3][1] then pcall(ui.set, gs_item_refs[3][1], var_val) end
            if gs_item_refs[4] and gs_item_refs[4][1] then pcall(ui.set, gs_item_refs[4][1], 15) end

            return
        end

        if tostring(t2) == "max" then
            if gs_item_refs[2] and gs_item_refs[2][1] then
                pcall(ui.set, gs_item_refs[2][1], "dynamic")
            end
            if gs_item_refs[3] and gs_item_refs[3][1] then
                pcall(ui.set, gs_item_refs[3][1], 0)
            end
            local lim = 14 + ((globals.tickcount() or 0) % 2)
            if gs_item_refs[4] and gs_item_refs[4][1] then pcall(ui.set, gs_item_refs[4][1], lim) end

            return
        end
    end
end, { alive_only = true, require_login = true })]]
__bundle["require/features/misc/freestand_helper"] = [[local gs_item_refs = {}
local gs_ref_visible = {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
    for _, ref in ipairs(refs) do
        gs_ref_visible[ref] = true
    end
end

local ok_menu, menu_setup = pcall(require, "require/abc/menu_setup")

local callbacks = require('require/abc/callbacks')

local function freestand_options(cmd)
    if not (menu_setup and menu_setup.ui and menu_setup.ui.aa_gskey_freestand) then return end
    if not ui.get(menu_setup.ui.aa_gskey_freestand) then return end

    local function has_option(tbl, name)
        if type(tbl) ~= 'table' then return false end
        for _, v in ipairs(tbl) do if tostring(v) == tostring(name) then return true end end
        return false
    end

    local selections = ui.get(menu_setup.ui.fakelag_settings_freestanding) or {}


    localplayer = entity.get_local_player()
    local vx, vy, vz = entity.get_prop(localplayer, 'm_vecVelocity')
    if vx and vy and vz then
        velvel =  math.sqrt(vx * vx + vy * vy + vz * vz)
    end
    


    if has_option(selections, 'static') then
        ui.set(gs_item_refs[1][1], true)
        ui.set(gs_item_refs[5][1], '180')
        ui.set(gs_item_refs[5][2], 6)
        ui.set(gs_item_refs[6][1], 'off')
        ui.set(gs_item_refs[7][1], 'off')
    end

    if has_option(selections, 'zero pitch') and velvel > 5 then
        ui.set(gs_item_refs[3][1], 'Off')
    end

    if has_option(selections, 'defensive') then
        cmd.force_defensive = true
    end

    local side_switch = globals.tickcount() % 4 < 2
    if has_option(selections, 'side flip') and velvel > 5 then
        ui.set(gs_item_refs[5][1], '180')
        ui.set(gs_item_refs[5][2], side_switch and -90 or 90)
    end

    local side_switch = globals.tickcount() % 6 < 2
    if has_option(selections, 'pitch flip') and velvel > 5 then
        ui.set(gs_item_refs[3][1], 'custom')
        ui.set(gs_item_refs[3][2], side_switch and -89 or 89)
    end

end

callbacks.register('setup_command', function(cmd)
    freestand_options(cmd)
end, { alive_only = true, require_login = true })]]
__bundle["require/features/misc/history"] = [[
local history = {}

local RING_SIZE = 20
local rings = {}

local function ensure(player)
  if not rings[player] then rings[player] = { buf = {} } end
  return rings[player]
end

function history.push(player, snapshot)
  if not player or not snapshot then return end
  local ring = ensure(player)
  ring.buf[#ring.buf+1] = snapshot
  if #ring.buf > RING_SIZE then table.remove(ring.buf, 1) end
end

function history.get_last_n(player, n)
  n = n or RING_SIZE
  local ring = rings[player]
  if not ring or #ring.buf == 0 then return {} end
  local res = {}
  local total = #ring.buf
  local start = math.max(1, total - n + 1)
  for i = start, total do res[#res+1] = ring.buf[i] end
  return res
end

function history.clear(player)
  if not player then rings = {} return end
  rings[player] = nil
end

return history
]]
__bundle["require/features/misc/hotkeys"] = [[local gs_item_refs = {}
local gs_ref_visible = {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
    for _, ref in ipairs(refs) do
        gs_ref_visible[ref] = true
    end
end

local ok_menu, menu_setup = pcall(require, "require/abc/menu_setup")

local callbacks = require('require/abc/callbacks')

local function activate_hotkeys()

    if ui.get(menu_setup.ui.aa_gskey_freestand) then
        ui.set(gs_item_refs[3][1], true)
        ui.set(gs_item_refs[3][2], 'Always on')
    else
        ui.set(gs_item_refs[3][1], false)
        ui.set(gs_item_refs[3][2], 'On hotkey')
    end

    if ui.get(menu_setup.ui.aa_gskey_slowmotion) then
        ui.set(gs_item_refs[4][1], true)
    else
        ui.set(gs_item_refs[4][1], false)
    end

    if menu_setup and menu_setup.ui and ui.get(menu_setup.ui.aa_gskey_edgeyaw) then
        ui.set(gs_item_refs[2][1], true)
    else
        ui.set(gs_item_refs[2][1], false)
    end

    if menu_setup and menu_setup.ui and ui.get(menu_setup.ui.aa_gskey_onshot) then
        ui.set(gs_item_refs[6][2], 'Always on')
    else
        ui.set(gs_item_refs[6][2], 'On hotkey')
    end

end

callbacks.register('setup_command', function()

    activate_hotkeys()

end, { alive_only = true, require_login = true })]]
__bundle["require/features/misc/localdebug"] = [[local callbacks_ok, callbacks = pcall(require, "require/abc/callbacks")
local M = {}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")

local state = {
    last_yaw = nil,
    last_pitch = nil,
    last_defensive = false,
    skel_list = {},
    last_choked = 0,
    shot_ticks = {},
    shot_ticks_aim = {},
    skel_history = {},
}

local function normalize_angle(a)
    if not a then return a end
    local ang = tonumber(a) or 0
    while ang > 180 do ang = ang - 360 end
    while ang <= -180 do ang = ang + 360 end
    return ang
end

local function on_weapon_fire(ev)
    if not ev then return end
    local attacker_ent = client.userid_to_entindex(ev.userid)
    local lp = entity.get_local_player()
    if attacker_ent ~= lp then return end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks, t)
    while #state.shot_ticks > 200 do table.remove(state.shot_ticks, 1) end
end

local function on_aim_fire(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    if ev.attacker then
        local attacker_ent = client.userid_to_entindex(ev.attacker)
        if attacker_ent ~= lp then return end
    end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks_aim, t)
    while #state.shot_ticks_aim > 200 do table.remove(state.shot_ticks_aim, 1) end
end

local function had_recent_shot(ticks_back)
    ticks_back = ticks_back or 30
    local now = globals.tickcount and globals.tickcount() or 0
    for i = #state.shot_ticks_aim, 1, -1 do
        local s = state.shot_ticks_aim[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    for i = #state.shot_ticks, 1, -1 do
        local s = state.shot_ticks[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    return false
end

local function safe_tonumber(v)
    local n = tonumber(v)
    if n then return n end
    return 0
end


local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {
    head={names={'head','Head','HEAD'},idx={0}},
    neck={names={'neck','Neck'},idx={1}},
    chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},
    stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},
    pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},
    l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},
    l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},
    l_hand={names={'left hand','Left Hand'},idx={14}},
    r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},
    r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},
    r_hand={names={'right hand','Right Hand'},idx={13}},
    l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},
    l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},
    l_foot={names={'left foot','Left Foot'},idx={12}},
    r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},
    r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},
    r_foot={names={'right foot','Right Foot'},idx={11}},
}

local function find_bone(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x,y,z = entity.hitbox_position(ent, def.names[i])
        if x then return x,y,z end
    end
    for i = 1, #(def.idx or {}) do
        local x,y,z = entity.hitbox_position(ent, def.idx[i])
        if x then return x,y,z end
    end
end

local function snap_ent(ent)
    if not ent then return end
    local pts = {}
    for key, def in pairs(boxes) do
        local x,y,z = find_bone(ent, def)
        if x then pts[key] = {x=x,y=y,z=z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local function paint_handler()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lag_record then
        local ok_enabled, enabled = pcall(ui.get, menu_setup.ui.paint_lag_record)
        if not ok_enabled or not enabled then return end
    end
    if not renderer or not renderer.world_to_screen or not renderer.line then return end
    local now = globals.realtime and globals.realtime() or os.time()
    local i = 1
    while i <= #state.skel_list do
        local it = state.skel_list[i]
        if not it or not it.t or (now - it.t) > 10 then
            table.remove(state.skel_list, i)
        else
            local SKEL_SCALE = 1.15
            
            local trail = it.trail or {}
            if trail and #trail > 0 then
                for ti = 1, #trail do
                    local entry = trail[ti]
                    local trail_pts = entry.pts or {}
                    
                    local ratio = ti / #trail
                    local r, g, b, alpha
                    if ti == #trail then
                        
                        r = 0
                        g = 140
                        b = 255
                        alpha = 200
                    else
                        
                        r = 255
                        g = math.floor(255 * (1 - ratio))
                        b = math.floor(255 * (1 - ratio))
                        alpha = math.floor(40 + ratio * (160 - 40))
                    end
                    
                    local center = trail_pts.pelvis or trail_pts.chest
                    if not center then
                        local sx, sy, sz, ccount = 0,0,0,0
                        for k, v in pairs(trail_pts) do
                            if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                        end
                        if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
                    end
                    for c = 1, #chains do
                        local chain = chains[c]
                        local from, to = trail_pts[chain[1] ], trail_pts[chain[2] ]
                        if from and to then
                            local fxw, fyw, fzw = from.x, from.y, from.z
                            local txw, tyw, tzw = to.x, to.y, to.z
                            if center and center.x then
                                fxw = center.x + (from.x - center.x) * SKEL_SCALE
                                fyw = center.y + (from.y - center.y) * SKEL_SCALE
                                fzw = center.z + (from.z - center.z) * SKEL_SCALE
                                txw = center.x + (to.x - center.x) * SKEL_SCALE
                                tyw = center.y + (to.y - center.y) * SKEL_SCALE
                                tzw = center.z + (to.z - center.z) * SKEL_SCALE
                            end
                            local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                            local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                            if fx and tx then renderer.line(fx,fy,tx,ty,r,g,b,alpha) end
                        end
                    end
                end
            end
            
            local pts = it.pts or {}
            local center = pts.pelvis or pts.chest
            if not center then
                local sx, sy, sz, ccount = 0,0,0,0
                for k, v in pairs(pts) do
                    if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                end
                if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
            end
            for c = 1, #chains do
                local chain = chains[c]
                local from, to = pts[chain[1] ], pts[chain[2] ]
                if from and to then
                    local fxw, fyw, fzw = from.x, from.y, from.z
                    local txw, tyw, tzw = to.x, to.y, to.z
                    if center and center.x then
                        fxw = center.x + (from.x - center.x) * SKEL_SCALE
                        fyw = center.y + (from.y - center.y) * SKEL_SCALE
                        fzw = center.z + (from.z - center.z) * SKEL_SCALE
                        txw = center.x + (to.x - center.x) * SKEL_SCALE
                        tyw = center.y + (to.y - center.y) * SKEL_SCALE
                        tzw = center.z + (to.z - center.z) * SKEL_SCALE
                    end
                    local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                    local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                    if fx and tx then renderer.line(fx,fy,tx,ty,255,0,0,220) end
                end
            end
            i = i + 1
        end
    end
end


local function on_setup_command(cmd)
    if not cmd then return end
    local aa_funcs = nil
    local ok_req, req_lib = pcall(require, 'gamesense/antiaim_funcs')
    if ok_req and req_lib then aa_funcs = req_lib end
    if not aa_funcs then
        local ok_libs, libs = pcall(require, 'require/help/libs')
        if ok_libs and libs and libs.get then
            aa_funcs = libs.get('antiaim_funcs')
        end
    end

    local pitch, yaw = nil, nil
    if aa_funcs then
        local okp, pval = pcall(function() return aa_funcs.get_pitch and aa_funcs.get_pitch() end)
        if okp and pval ~= nil then pitch = pval end
        local oky, yval = pcall(function() return aa_funcs.get_yaw_base and aa_funcs.get_yaw_base() end)
        if oky and yval ~= nil then yaw = yval end
        if yaw == nil then
            local okb, bval = pcall(function() return aa_funcs.get_body_yaw and aa_funcs.get_body_yaw() end)
            if okb and bval ~= nil then yaw = bval end
        end
    end

    if (pitch == nil or yaw == nil) then
        local lp = entity.get_local_player()
        if lp then
            local ax, ay = entity.get_prop(lp, "m_angEyeAngles")
            if ax and ay then
                if pitch == nil then pitch = ax end
                if yaw == nil then yaw = ay end
            end
        end
    end

    if pitch ~= nil then state.last_pitch = pitch end
    if yaw ~= nil then state.last_yaw = normalize_angle(yaw) end

    do
        local ok_def, def_mod = pcall(require, 'require/features/aa/defensive')
        if ok_def and def_mod and def_mod.active ~= nil then
            state.last_defensive = not not def_mod.active
        else
            if cmd and cmd.force_defensive ~= nil then
                state.last_defensive = not not cmd.force_defensive
            end
        end
    end
    if cmd and cmd.chokedcommands ~= nil then
        state.last_choked = tonumber(cmd.chokedcommands) or 0
    end
    local lp = entity.get_local_player()
    if lp then
        local tick = globals.tickcount and globals.tickcount() or 0
        local hist_pts = snap_ent(lp)
        if hist_pts then
            state.skel_history[#state.skel_history + 1] = { tick = tick, pts = hist_pts }
            if #state.skel_history > 128 then table.remove(state.skel_history, 1) end
        end
    end
end

local function on_player_death(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    local victim_ent = client.userid_to_entindex(ev.userid)
    local attacker_ent = nil
    if ev.attacker then attacker_ent = client.userid_to_entindex(ev.attacker) end

    if victim_ent == lp then
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then
                attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker)
            else
                attacker_name = tostring(ev.attacker)
            end
        end
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] DIED — last_yaw=%.2f last_pitch=%.2f attacker=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
        return
    end
    if attacker_ent == lp and victim_ent and victim_ent ~= 0 and victim_ent ~= lp then
        local victim_name = entity.get_player_name(victim_ent) or tostring(ev.userid)
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] KILLED — last_yaw=%.2f last_pitch=%.2f victim=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, victim_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end
end

if callbacks_ok and callbacks and callbacks.callback then
    callbacks.callback('setup_command', on_setup_command, { alive_only = false, require_login = false })
    callbacks.callback('player_death', on_player_death, { alive_only = false, require_login = false })
    callbacks.callback('paint', paint_handler, { alive_only = false, require_login = false })
    callbacks.callback('weapon_fire', on_weapon_fire, { alive_only = false, require_login = false })
    callbacks.callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end, { alive_only = false, require_login = false })
else
    client.set_event_callback('setup_command', on_setup_command)
    client.set_event_callback('player_death', on_player_death)
    client.set_event_callback('paint', paint_handler)
    client.set_event_callback('weapon_fire', on_weapon_fire)
    client.set_event_callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end)
end
]]
__bundle["require/features/misc/resolver"] = [[














local ok_collect, collect = pcall(require, "require/features/misc/collect")
local ok_history, history = pcall(require, "require/features/misc/history")
local ok_state, state = pcall(require, "require/features/misc/state")
local ok_events, events = pcall(require, "require/features/misc/events")
local ok_vector, vec = pcall(require, "require/help/vector")
local vector = ok_vector and vec or nil
local callbacks = require('require/abc/callbacks')







if not M then M = {} end
M.players = M.players or {}


local function tracking_players()
	pcall(function()
		if not ok_collect or type(collect) ~= "table" or not collect.get_enemies_snapshot then return end

		local ok, snaps = pcall(function() return collect.get_enemies_snapshot() end)
		if not ok or type(snaps) ~= "table" then return end

		M.players = M.players or {}

		for ent, snap in pairs(snaps) do
			M.players[ent] = M.players[ent] or {}
			M.players[ent].snapshot = snap

            
            
            
			M.players[ent].simtime = snap.simtime
			M.players[ent].simTicks = snap.simTicks
			M.players[ent].lowerBodyYaw = snap.lowerBodyYaw
			M.players[ent].speed2d = snap.speed2d
			M.players[ent].velocity3d = snap.velocity3d
			M.players[ent].is_alive = snap.is_alive
			M.players[ent].is_dormant = snap.is_dormant
			M.players[ent].feetYaw = snap.feetYaw
			M.players[ent].goalFeetYaw = snap.goalFeetYaw
			M.players[ent].moveSpeedAnim = snap.moveSpeedAnim
		end

		for ent, snap in pairs(snaps) do
			local name = snap.name or "?"
			local sim = snap.simtime or 0
			local spd = snap.speed2d or 0
			local lby = snap.lowerBodyYaw or "nil"
			local move = snap.moveSpeedAnim or 0
			local feet = snap.feetYaw or "nil"
			local goal = snap.goalFeetYaw or "nil"
			local duck_amt = snap.animstate_full.m_fDuckAmount

		end
	end)
end



local function normalize_angle(angle)
    while angle > 180 do
        angle = angle - 360
    end
    while angle < -180 do
        angle = angle + 360
    end
    return angle
end


local function calculate_angle(start_pos, end_pos)
    local delta = end_pos - start_pos
    local angle = math.atan(delta.y / delta.x)
    angle = normalize_angle(angle * 180 / math.pi)

    if delta.x >= 0 then
        angle = normalize_angle(angle + 180)
    end

    return angle
end



local HISTORY_SIZE = 100
local player_history = {}
_G.player_history = player_history

local function seconds_to_ticks(seconds)
    return math.floor(0.5 + seconds / globals.tickinterval())
end

local function recording(local_player)
    local enemy_players = entity.get_players(true)

	if #enemy_players == 0 then
		
		player_history = {}
		_G.player_history = player_history
		return nil
	end


	for i, player in ipairs(enemy_players) do
		if entity.is_alive(player) and not entity.is_dormant(player) then

			local sim_tick = 0
			local esp_flags = entity.get_esp_data(player).flags or 0

			if bit.band(esp_flags, bit.lshift(1, 17)) ~= 0 then
				sim_tick = seconds_to_ticks(entity.get_prop(player, "m_flSimulationTime")) - 14
			else
				sim_tick = seconds_to_ticks(entity.get_prop(player, "m_flSimulationTime"))
			end

			
			local hist = player_history[player] or {}
			local newest = hist[1]

			if newest == nil or (sim_tick - (newest.simtime or -999)) >= 1 then

				local local_origin = vector(entity.get_prop(local_player, "m_vecOrigin"))
				local eye_angles = vector(entity.get_prop(player, "m_angEyeAngles"))
				local player_origin = vector(entity.get_prop(player, "m_vecOrigin"))
				local angle_diff = math.floor(normalize_angle(eye_angles.y - calculate_angle(local_origin, player_origin)))
				

				local snap = {
					id = player or nil,
					origin = vector(entity.get_origin(player)) or vector(nil,nil,nil),
					pitch = eye_angles.x or nil,
					yaw = angle_diff or nil,
					yaw_backwards = backwards_angle or nil,
					simtime = sim_tick or nil,
					stance = stance or nil,
					esp_flags = entity.get_esp_data(player).flags or 0,
					last_shot_time = last_shot_time or nil
				}

				table.insert(hist, 1, snap)
				while #hist > HISTORY_SIZE do
					table.remove(hist)
				end

				player_history[player] = hist
			end
		end
	end
end















client.set_event_callback('net_update_end', function()
    pcall(function()

        
        

        local local_player = entity.get_local_player()
        if not entity.is_alive(local_player) then
            return
        end
        recording(local_player)


        local tick = (globals and globals.tickcount and globals.tickcount()) or (globals and globals.realtime and globals.realtime()) or os.time()
        

    end)
end, { alive_only = true, require_login = true })

callbacks.register('weapon_fire', function(e)
    pcall(function()







        local shooter = (e and e.userid) and (client.userid_to_entindex and client.userid_to_entindex(e.userid)) or (e and (e.attacker or e.userid)) or "?"
        local w = (e and (e.weapon or e.weapon_name or e.weaponid)) or "?"
        
    end)
    if EVENTS and EVENTS.record_weapon_fire then pcall(EVENTS.record_weapon_fire, e) end
end, { alive_only = true, require_login = true })

callbacks.register('aim_fire', function(e)
    pcall(function()








        local id = e and e.id or "?"
        local tgt = e and e.target or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_fire then pcall(EVENTS.record_aim_fire, e) end
end, { alive_only = true, require_login = true })

callbacks.register('aim_hit', function(e)
    pcall(function()








        local id = e and e.id or "?"
        local tgt = e and e.target or "?"
        local dmg = e and e.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_hit then pcall(EVENTS.record_aim_hit, e) end
end, { alive_only = true, require_login = true })

callbacks.register('aim_miss', function(e)
    pcall(function()






        local id = e and e.id or "?"
        local reason = e and e.reason or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_miss then pcall(EVENTS.record_aim_miss, e) end
end, { alive_only = true, require_login = true })

callbacks.register('player_hurt', function(e)
    pcall(function()






        local attacker = (e and e.attacker) or (e and e.userid) or "?"
        local victim = (e and e.userid) or (e and e.userid) or "?"
        local dmg = e and e.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_player_hurt then pcall(EVENTS.record_player_hurt, e) end
end, { alive_only = true, require_login = true })

callbacks.register('bullet_impact', function(e)
    pcall(function()




        local shooter = (e and e.userid) and (client.userid_to_entindex and client.userid_to_entindex(e.userid)) or "?"
        local x,y,z = e and e.x or "?", e and e.y or "?", e and e.z or "?"
        
    end)
    if EVENTS and EVENTS.on_bullet_impact then pcall(EVENTS.on_bullet_impact, e) end
    if EVENTS and EVENTS.record_bullet_impact then pcall(EVENTS.record_bullet_impact, e) end
end, { alive_only = true, require_login = true })

callbacks.register('paint', function()
    pcall(function()

        

    end)
    if EVENTS and EVENTS.on_paint then pcall(EVENTS.on_paint) end
end, { alive_only = true, require_login = true })

callbacks.register("round_start", function(e)
    pcall(function() print("[resolver] round_start") end)



    M.players = {}
    if EVENTS and EVENTS.on_round_start then pcall(EVENTS.on_round_start, e) end
end, { alive_only = true, require_login = true })

callbacks.register("shutdown", function()
    if client and client.unset_event_callback then



    end
end, { alive_only = true, require_login = true })
]]
__bundle["require/features/misc/resolver_dispatcher"] = [[local M = {}


local modules = {}


_G.player_resolver_state = _G.player_resolver_state or {}

local function sanitize_label(label)
    if not label or type(label) ~= "string" then return nil end
    
    local s = label:lower()
    s = s:gsub("%+", "plus")
    s = s:gsub("%-% ", "minus_") 
    s = s:gsub("%-%", "minus")
    s = s:gsub("%s+", "_")
    s = s:gsub("[^%w_]", "")
    return s
end

local function require_module_for(label)
    local key
    
    if label == "?" then
        key = "default"
    else
        key = sanitize_label(label)
    end
    if not key or key == "" then return nil end
    if modules[key] ~= nil then return modules[key] end
    local name = "require/features/misc/res_" .. key
    local ok, mod = pcall(require, name)
    if ok and type(mod) == "table" then
        modules[key] = mod
        return mod
    end
    modules[key] = false
    return nil
end



function M.process_entity(ent, label, features)
    local ok, _ = pcall(function()
        if not ent or ent == 0 then return end
        if not label or label == "?" then return end

        local mod = require_module_for(label)
        if not mod then return end

        
        local state = _G.player_resolver_state[ent]
        if not state then
            state = {}
            _G.player_resolver_state[ent] = state
        end

        if type(mod.run) == "function" then
            
            pcall(function() mod.run(ent, features or {}, state, label) end)
        elseif type(mod.process) == "function" then
            pcall(function() mod.process(ent, features or {}, state, label) end)
        end
    end)
    return ok
end


M._modules = modules
M._sanitize_label = sanitize_label

return M
]]
__bundle["require/features/misc/res_default"] = [[local M = {}

local function safe_unset(ent)
    pcall(function()
        if plist and type(plist.set) == "function" then
            
            plist.set(ent, "Force body yaw", false)
            plist.set(ent, "Force body yaw value", 0)
            plist.set(ent, "Force pitch", false)
            plist.set(ent, "Force pitch value", 0)
        end
    end)
end

function M.run(ent, features, state, label)
    
    if label ~= "?" and label ~= "DEFAULT" and label ~= "default" then return end

    state.clears = (state.clears or 0) + 1
    state.last_seen = (globals and globals.curtime and globals.curtime()) or os.time()

    
    safe_unset(ent)

    pcall(function()
        print(string.format("[res_default] ent=%d cleared_forces label=%s count=%d", ent, tostring(label), state.clears))
    end)
end

return M
]]
__bundle["require/features/misc/res_static"] = [[local M = {}
local ok_ffi, ffi = pcall(require, "ffi")
local ok_bit, bit = pcall(require, "bit")


local get_entity_ptr
local function init_ffi_helpers()
    if not ok_ffi or not client or not client.create_interface then return end
    local status, res = pcall(function()
        local pointer_type = ffi.typeof("void***")
        local entity_list_ptr = client.create_interface("client.dll", "VClientEntityList003")
        if not entity_list_ptr then return nil end
        local entity_list = ffi.cast(pointer_type, entity_list_ptr)
        local get_client_entity = ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
        return function(entindex)
            if not entindex or entindex == 0 then return nil end
            local ptr = get_client_entity(entity_list, entindex)
            if ptr == nil then return nil end
            return ptr
        end
    end)
    if status and type(res) == "function" then
        get_entity_ptr = res
    else
        get_entity_ptr = nil
    end
end
init_ffi_helpers()

local function get_speed2d(ent)
    
    local ok, vx, vy = pcall(function()
        local x,y,z = entity.get_prop(ent, "m_vecVelocity")
        return x or 0, y or 0
    end)
    if ok and vx and vy then
        return math.sqrt((vx or 0)*(vx or 0) + (vy or 0)*(vy or 0))
    end
    return 0
end

local function estimate_max_desync_ent(ent)
    
    if not ok_ffi or not get_entity_ptr then return nil end
    local ok_read, result = pcall(function()
        ffi.cdef[[
        struct c_animstate {
            char pad0[3];
            char m_bForceWeaponUpdate;
            char pad1[91];
            void* m_pBaseEntity;
            void* m_pActiveWeapon;
            void* m_pLastActiveWeapon;
            float m_flLastClientSideAnimationUpdateTime;
            int m_iLastClientSideAnimationUpdateFramecount;
            float m_flAnimUpdateDelta;
            float m_flEyeYaw;
            float m_flPitch;
            float m_flGoalFeetYaw;
            float m_flCurrentFeetYaw;
            float m_flCurrentTorsoYaw;
            float m_flUnknownVelocityLean;
            float m_flLeanAmount;
            char pad2[4];
            float m_flFeetCycle;
            float m_flFeetYawRate;
            char pad3[4];
            float m_fDuckAmount;
            float m_fLandingDuckAdditiveSomething;
            char pad4[4];
            float m_vOriginX;
            float m_vOriginY;
            float m_vOriginZ;
            float m_vLastOriginX;
            float m_vLastOriginY;
            float m_vLastOriginZ;
            float m_vVelocityX;
            float m_vVelocityY;
            char pad5[4];
            float m_flUnknownFloat1;
            char pad6[8];
            float m_flUnknownFloat2;
            float m_flUnknownFloat3;
            float m_flUnknown;
            float m_flSpeed2D;
            float m_flUpVelocity;
            float m_flSpeedNormalized;
            float m_flFeetSpeedForwardsOrSideWays;
            float m_flFeetSpeedUnknownForwardOrSideways;
            float m_flTimeSinceStartedMoving;
            float m_flTimeSinceStoppedMoving;
            bool m_bOnGround;
            bool m_bInHitGroundAnimation;
            char pad7[2];
            float m_flTimeSinceInAir;
            float m_flLastOriginZ;
            float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
            float m_flStopToFullRunningFraction;
            float m_flMagicFraction;
            char pad8[60];
            float m_flWorldForce;
            char pad9[462];
            float m_flMaxYaw;
        };
        ] ]
        local ent_ptr = get_entity_ptr(ent)
        if not ent_ptr then return nil end
        local animstate_ptr = ffi.cast("struct c_animstate**", ffi.cast("uintptr_t", ent_ptr) + 0x9960)
        if animstate_ptr == nil or animstate_ptr == ffi.NULL then return nil end
        local anim = animstate_ptr[0]
        if anim == nil or anim == ffi.NULL then return nil end

        local duck_amount = tonumber(anim.m_fDuckAmount) or 0
        local speed2d_norm = tonumber(anim.m_flFeetSpeedForwardsOrSideWays) or 0
        local stop_to_full = tonumber(anim.m_flStopToFullRunningFraction) or 0
        local max_yaw = tonumber(anim.m_flMaxYaw) or 0

        local yaw_modifier = ((-0.3 * stop_to_full) - 0.2) * math.max(0, math.min(speed2d_norm, 1)) + 1.0
        if duck_amount > 0 then
            yaw_modifier = yaw_modifier + (duck_amount * 0.5) * (0.5 - yaw_modifier)
        end

        local raw_delta = max_yaw * yaw_modifier
        local velocity = get_speed2d(ent) or 0
        local velocity_clamped = math.min(math.max(velocity, 0), 260)
        local move_scale = 1.0 - (velocity_clamped / 260)
        move_scale = 0.35 + (move_scale * 0.65)
        local delta = raw_delta * move_scale
        if velocity >= 250 then
            delta = math.min(delta, 28)
        end
        local flags = nil
        if ok_bit and entity and entity.get_prop then
            flags = entity.get_prop(ent, "m_fFlags") or 0
        end
        local on_ground = true
        if flags then on_ground = bit.band(flags, 1) == 1 end
        if not on_ground then delta = delta * 0.55 end
        if duck_amount > 0.9 then delta = delta * 0.9 end
        delta = math.max(0, math.min(delta, 60))
        return delta
    end)
    if ok_read then return result end
    return nil
end

local function safe_unset(ent)
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", false)
            plist.set(ent, "Force body yaw value", 0)
        end
    end)
end

local function now_time()
    local ok, t = pcall(function() return (globals and globals.curtime and globals.curtime()) or os.time() end)
    return ok and t or os.time()
end

local function normalize_angle(angle)
    if not angle or type(angle) ~= "number" then return 0 end
    while angle > 180 do angle = angle - 360 end
    while angle < -180 do angle = angle + 360 end
    return angle
end

local function round(n)
    return math.floor((n or 0) + 0.5)
end

function M.run(ent, features, state, label)
    
    state.count = (state.count or 0) + 1
    state.last_seen = now_time()
    if state.last_label and state.last_label ~= label then state.count = 1 end
    state.last_label = label

    
    if not label or label ~= "STATIC" then return end

    
    local required_count = 3
    if state.count < required_count then return end

    
    if features and features.shot_age and tonumber(features.shot_age) and features.shot_age <= 0.25 then
        return
    end

    
    local avg_speed = tonumber((features and features.avg_speed) or 0) or 0
    if features and features.movement and features.movement == true then return end
    if avg_speed >= 1.2 then return end

    
    local max_mag_low = 58
    local max_mag_high = 28
    local speed_cap = 250
    local t = math.min(math.max(avg_speed / speed_cap, 0), 1)
    local max_mag = max_mag_low + (max_mag_high - max_mag_low) * t

    
    local ok_est, est = pcall(function() return estimate_max_desync_ent(ent) end)
    if ok_est and est and type(est) == "number" then
        max_mag = math.min(max_mag, est)
    end

    
    local on_ground = true
    pcall(function()
        if ok_bit and entity and entity.get_prop then
            local flags = entity.get_prop(ent, "m_fFlags") or 0
            on_ground = bit.band(flags, 1) == 1
        end
    end)
    if not on_ground then max_mag = max_mag * 0.55 end

    
    local forced_val = 0

    
    local last_yaw = (features and features.last_yaw)
    local ref_yaw = features and (features.goal_feet_yaw or features.feet_yaw)
    local desync = nil
    if last_yaw and ref_yaw then
        desync = normalize_angle(last_yaw - ref_yaw)
    end

    
    if not desync then
        forced_val = 0
    else
        local absd = math.abs(desync)
        
        if absd <= 10 then
            forced_val = 0
        else
            
            if ok_est and est and type(est) == "number" and est >= 8 then
                local mag = math.min(math.floor(max_mag + 0.5), math.floor(est + 0.5))
                local desired = math.min(absd, mag)
                
                if desired >= 8 then
                    forced_val = (desync >= 0) and desired or -desired
                else
                    forced_val = 0
                end
            else
                
                forced_val = 0
            end
        end
    end

    
    forced_val = round(forced_val)
    if forced_val > 60 then forced_val = 60 end
    if forced_val < -60 then forced_val = -60 end

    
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", true)
            plist.set(ent, "Force body yaw value", forced_val)
            state.forced = true
            state.forced_value = forced_val
            state.cooldown = now_time() + 0.5

            if client and type(client.delay_call) == "function" then
                client.delay_call(0.6, function()
                    pcall(function()
                        local t = now_time()
                        if not state.cooldown or t > state.cooldown then
                            safe_unset(ent)
                            state.forced = nil
                            state.forced_value = nil
                        end
                    end)
                end)
            end
        end
    end)
end

return M
]]
__bundle["require/features/misc/roll"] = [[local ok_menu, menu_setup = pcall(require, "require/abc/menu_setup")

local gs_item_refs = {}
local gs_ref_visible = {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
    for _, ref in ipairs(refs) do
        gs_ref_visible[ref] = true
    end
end

local function rolling(cmd)

    local amount = 0
    if menu_setup and menu_setup.ui and menu_setup.ui.fakelag_settings_roll then
        amount = ui.get(menu_setup.ui.fakelag_settings_roll) or 0
    end
    local side = ui.get(menu_setup.ui.fakelag_settings_side) or 1
    local me = entity.get_local_player()
    local mevel = me and entity.get_prop(me, 'm_vecVelocity') or 0

    if mevel > 3 then
        ui.set(gs_item_refs[1][1], 0)
        return
    end

    if side == 3 then
        ui.set(gs_item_refs[1][1], -amount)
    elseif side == 2 then
        local cycle = (globals.tickcount() % 20) < 10
        ui.set(gs_item_refs[1][1], cycle and amount or -amount)
    elseif side == 1 then
        ui.set(gs_item_refs[1][1], amount)
    end

end

client.set_event_callback('setup_command', function(cmd)

    rolling(cmd)

end)]]
__bundle["require/features/misc/spin_on_dead_enemies"] = [[local gs_item_refs = {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
end

local e, g, u, c = entity, globals, ui, client
local menu_setup = require("require/abc/menu_setup")
local spin_sign = (c.random_int(1, 2) == 1) and 1 or -1

local function apply()
    local map = {
        {2, 'Off'}, {3, 'Local view'}, {4, {'Spin', 45}}, {5, {'Off', 0}}, {6, {'Off', 0}},
    }
    local spin_sign = (c.random_int(1, 2) == 1) and 1 or -1
    for _, v in ipairs(map) do
        local idx, val = v[1], v[2]
        local refs = gs_item_refs[idx]
        if not refs then goto continue end
        if type(val) ~= 'table' then
            pcall(u.set, refs[1], val)
        else
            if refs[1] then pcall(u.set, refs[1], val[1]) end
            if refs[2] then
                if type(val[2]) == 'number' and val[1] == 'Spin' then
                    pcall(u.set, refs[2], val[2] * spin_sign)
                else
                    pcall(u.set, refs[2], val[2])
                end
            end
        end
        ::continue::
    end
end

local function alive_enemies()
    local max = (g.maxplayers and g.maxplayers() or 64)
    local get_class, is_enemy, is_alive = e.get_classname, e.is_enemy, e.is_alive
    if not (get_class and is_enemy and is_alive) then return 0 end
    local alive = 0
    for i=1,max do
        if get_class(i) == 'CCSPlayer' and is_enemy(i) and is_alive(i) then alive = alive + 1 end
    end
    return alive
end

local function tick()
    if not u.get(menu_setup.ui.misc_spindead) then return end
    if alive_enemies() == 0 then apply() end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
if cb_ok and callbacks then
    callbacks.callback('run_command', tick, { alive_only = true, require_login = true })
end
]]
__bundle["require/features/misc/walkbot"] = [[local callbacks = require("require/abc/callbacks")
local menu_setup = require("require/abc/menu_setup")

local path = nil
local path_index = 1
local paused_until = 0
local reached_dist = 40
local max_attempts = 30
local walk_speed = 450
local max_search_nodes = 200
local angle_steps = 8
local radii = {150, 300}
local current_target = nil
local target_pos = nil
local last_target_pos = nil
local target_recompute_time = 0
local target_recompute_interval = 700
local target_pool_size = 3

local node_attempts = {}
local max_attempts_per_node = 3
local max_retries_before_reroute = 4
local retry_count = 0
local last_pos = nil
local last_pos_time = 0
local pos_check_interval = 500
local stuck_threshold_time = 1500
local stuck_move_threshold = 30
local blocked_nodes = {}
local debug_walk = false

local coord_print_interval = 500 
local last_coord_print_time = 0

local predefined_sites = {
    { name = "A", x = -445.0, y = -1997.7, z = -180.0 },
    { name = "B", x = -2032.4, y = 259.8, z = -160.0 },
    { name = "Mid", x = -350.3, y = -617.1, z = -269.2 },
}

local function ui_get_safe(item)
    if not item then return false end
    local ok, val = pcall(ui.get, item)
    if not ok then return false end
    return val
end

local function ang_normalize(a)
    while a > 180 do a = a - 360 end
    while a < -180 do a = a + 360 end
    return a
end

local function vec_dist(ax, ay, az, bx, by, bz)
    local dx, dy, dz = ax-bx, ay-by, az-bz
    return math.sqrt(dx*dx + dy*dy + dz*dz)
end

local function safe_trace(lp, sx, sy, sz, tx, ty, tz)
    local ok, frac, ent = pcall(function()
        return client.trace_line(lp, sx, sy, sz, tx, ty, tz)
    end)
    if not ok then return nil end
    return frac, ent
end

local function snap_ground(lp, x, y, z)
    local fromz = z + 1000
    local toz = z - 1000
    local frac = safe_trace(lp, x, y, fromz, x, y, toz)
    if not frac then return z end
    if type(frac) ~= 'number' then return z end
    local hitz = fromz + (toz - fromz) * frac
    return hitz
end

local function can_reach(lp, sx, sy, sz, tx, ty, tz)
    local frac = safe_trace(lp, sx, sy, sz, tx, ty, tz)
    if not frac then return false end
    if frac >= 1 then return true end
    return false
end

local function node_key(x, y)
    return tostring(math.floor(x/50))..":"..tostring(math.floor(y/50))
end

local function increment_node_attempt(x, y)
    local k = node_key(x, y)
    node_attempts[k] = (node_attempts[k] or 0) + 1
    if node_attempts[k] >= max_attempts_per_node then
        blocked_nodes[k] = true
    end
    return node_attempts[k]
end

local function clear_node_attempt(x, y)
    local k = node_key(x, y)
    node_attempts[k] = nil
end

local function pick_destination(lp)
    local ox, oy, oz = entity.get_origin(lp)
    if not ox then return nil end
    for i=1,max_attempts do
        local ang = math.random()*math.pi*2
        local dist = 200 + math.random()*800
        local tx = ox + math.cos(ang)*dist
        local ty = oy + math.sin(ang)*dist
        local tz = oz
            local frac = safe_trace(lp, ox, oy, oz + 16, tx, ty, tz + 16)
        if frac and frac >= 1 then
            local gz = snap_ground(lp, tx, ty, tz)
            return { x = tx, y = ty, z = gz }
        end
        if frac and frac < 1 then
            local hx = ox + (tx-ox)*frac
            local hy = oy + (ty-oy)*frac
            local hz = oz + (tz-oz)*frac
            for _, r in ipairs(radii) do
                for s=0,angle_steps-1 do
                    local a = (s/angle_steps) * math.pi * 2
                    local cx = hx + math.cos(a)*r
                    local cy = hy + math.sin(a)*r
                    local cz = snap_ground(lp, cx, cy, hz)
                    local f2 = safe_trace(lp, ox, oy, oz+16, cx, cy, cz+16)
                    local f3 = safe_trace(lp, cx, cy, cz+16, tx, ty, tz+16)
                    if f2 and f2>=1 and f3 and f3>=1 then
                        local gz = snap_ground(lp, tx, ty, tz)
                        return { x = tx, y = ty, z = gz }
                    end
                end
            end
        end
    end
    return nil
end

local function reconstruct_path(node)
    local out = {}
    while node do
        out[#out+1] = { x = node.x, y = node.y, z = node.z }
        node = node.parent
    end
    local n = {}
    for i=#out,1,-1 do n[#n+1] = out[i] end
    return n
end

local function find_path(lp, destv)
    local ox, oy, oz = entity.get_origin(lp)
    if not ox then return nil end
    local start = { x = ox, y = oy, z = oz }
    start.z = snap_ground(lp, start.x, start.y, start.z)
    local queue = { { x = start.x, y = start.y, z = start.z, parent = nil } }
    local visited = {}
    local function mark(v)
        local key = tostring(math.floor(v.x/50))..":"..tostring(math.floor(v.y/50))
        visited[key] = true
    end
    local function seen(v)
        local key = tostring(math.floor(v.x/50))..":"..tostring(math.floor(v.y/50))
        if blocked_nodes[key] then return true end
        return visited[key]
    end
    mark(start)
    local processed = 0
    while #queue > 0 and processed < max_search_nodes do
        local cur = table.remove(queue, 1)
        processed = processed + 1
        local frac = safe_trace(lp, cur.x, cur.y, cur.z+16, destv.x, destv.y, destv.z+16)
        if frac and frac >= 1 then
            local pathnodes = reconstruct_path(cur)
            pathnodes[#pathnodes+1] = { x = destv.x, y = destv.y, z = destv.z }
            return pathnodes
        end
        if frac and frac < 1 then
            local hx = cur.x + (destv.x-cur.x)*frac
            local hy = cur.y + (destv.y-cur.y)*frac
            local hz = cur.z + (destv.z-cur.z)*frac
            for _, r in ipairs(radii) do
                for s=0,angle_steps-1 do
                    local a = (s/angle_steps) * math.pi * 2
                    local cx = hx + math.cos(a)*r
                    local cy = hy + math.sin(a)*r
                    local cz = snap_ground(lp, cx, cy, hz)
                    if not seen({x=cx,y=cy}) then
                        local f2 = safe_trace(lp, cur.x, cur.y, cur.z+16, cx, cy, cz+16)
                        if f2 and f2 >= 1 then
                            mark({x=cx,y=cy})
                            table.insert(queue, { x = cx, y = cy, z = cz, parent = cur })
                        end
                    end
                end
            end
        end
    end
    return nil
end

local function move_towards(cmd, lp, tx, ty, tz)
    local ox, oy, oz = entity.get_origin(lp)
    if not ox then return end
    
    local dx, dy = tx - ox, ty - oy
    local len = math.sqrt(dx*dx + dy*dy)
    if len <= 0 then return end
    local dirx, diry = dx / len, dy / len
    local step_dist = 64
    local sx = ox + dirx * step_dist
    local sy = oy + diry * step_dist
    local sz = oz

    
    local pitch, yaw = client.camera_angles()
    local ang = math.deg(math.atan2(dy, dx))
    local yaw_diff = ang_normalize(ang - yaw)
    local rad = math.rad(yaw_diff)
    local fwd = math.cos(rad) * walk_speed
    local side = -math.sin(rad) * walk_speed

    
    local ex, ey, ez = client.eye_position()
    if not ex then ex, ey, ez = ox, oy, oz end
    if type(ex) == 'table' then ex, ey, ez = ex[1], ex[2], ex[3] end
    local short_fx = ox + dirx * 24
    local short_fy = oy + diry * 24
    local short_fz = oz + 16
    local short_frac = safe_trace(lp, ex, ey, ez, short_fx, short_fy, short_fz)
    if short_frac and short_frac < 1 then
        
        if debug_walk then pcall(client.log, "move_towards: short forward blocked, sidestep") end
        pcall(function() cmd.forwardmove = 0; cmd.sidemove = -walk_speed end)
        local leftx = ox - diry * step_dist
        local lefty = oy + dirx * step_dist
        local lfr = safe_trace(lp, ox, oy, oz + 16, leftx, lefty, sz + 16)
        if lfr and lfr >= 1 then return end
        pcall(function() cmd.forwardmove = 0; cmd.sidemove = walk_speed end)
        local rightx = ox + diry * step_dist
        local righty = oy - dirx * step_dist
        local rfr = safe_trace(lp, ox, oy, oz + 16, rightx, righty, sz + 16)
        if rfr and rfr >= 1 then return end
        
        pcall(function() increment_node_attempt(tx, ty); paused_until = client.timestamp() + 250 end)
        path = nil
        return
    end

    
    pcall(function()
        cmd.forwardmove = fwd
        cmd.sidemove = side
    end)

    if debug_walk then pcall(client.log, string.format("move_towards: fwd=%.1f side=%.1f yaw_diff=%.1f", fwd, side, yaw_diff)) end

    local frac = safe_trace(lp, ox, oy, oz + 16, sx, sy, sz + 16)
    if frac and frac < 1 then
        
        if debug_walk then pcall(client.log, "move_towards: forward blocked, attempting sidestep") end
        
        pcall(function() cmd.forwardmove = 0; cmd.sidemove = -walk_speed end)
        local leftx = ox - diry * step_dist
        local lefty = oy + dirx * step_dist
        local lfr = safe_trace(lp, ox, oy, oz + 16, leftx, lefty, sz + 16)
        if lfr and lfr >= 1 then return end
        
        pcall(function() cmd.forwardmove = 0; cmd.sidemove = walk_speed end)
        local rightx = ox + diry * step_dist
        local righty = oy - dirx * step_dist
        local rfr = safe_trace(lp, ox, oy, oz + 16, rightx, righty, sz + 16)
        if rfr and rfr >= 1 then return end
        
        pcall(function()
            increment_node_attempt(tx, ty)
            paused_until = client.timestamp() + 250
        end)
        path = nil
        return
    end
end

callbacks.register("setup_command", function(cmd)
    local ok, err = pcall(function()
        if not ui_get_safe(menu_setup.ui.misc_walkbot) then return end
        local lp = entity.get_local_player()
        if not lp or not entity.is_alive(lp) then return end
        local now = client.timestamp()
        if now < paused_until then return end

        
        do
            local now_ts = client.timestamp()
            if now_ts - last_coord_print_time >= coord_print_interval then
                local px, py, pz = entity.get_origin(lp)
                if px then
                    pcall(function()
                        client.log(string.format("walkbot_coord: %.1f %.1f %.1f", px, py, pz))
                    end)
                    last_coord_print_time = now_ts
                end
            end
        end
        if client.key_state(87) or client.key_state(65) or client.key_state(83) or client.key_state(68) or client.key_state(32) or client.key_state(16) or client.key_state(17) then
            paused_until = now + 500
            return
        end
        
        do
            local players = entity.get_players(true) or {}
            for i=1,#players do
                local p = players[i]
                local px, py, pz = entity.get_origin(p)
                if px then
                    local ok_vis = pcall(function() return client.visible(px, py, pz) end)
                    if ok_vis and client.visible(px, py, pz) then
                        pcall(function()
                            local b = cmd.buttons or 0
                            cmd.buttons = bit.bor(b, 4) 
                        end)
                        break
                    end
                end
            end
        end
        
        local ox, oy, oz = entity.get_origin(lp)
        if ox then
            local players = entity.get_players(true) or {}
            if #players > 0 then
                if not current_target or not entity.is_alive(current_target) or entity.is_dormant(current_target) then
                    
                    local tbl = {}
                    for i=1,#players do
                        local p = players[i]
                        local px, py, pz = entity.get_origin(p)
                        if px then
                            local d = vec_dist(ox, oy, oz, px, py, pz)
                            tbl[#tbl+1] = { ent = p, dist = d }
                        end
                    end
                    table.sort(tbl, function(a,b) return a.dist < b.dist end)
                    if #tbl > 0 then
                                current_target = tbl[1].ent  
                        path = nil
                        path_index = 1
                    end
                end
            else
                current_target = nil
            end
        end

        
        if current_target and entity.is_alive(current_target) and not entity.is_dormant(current_target) then
            local tx, ty, tz = entity.get_origin(current_target)
            if tx then
                local gz = snap_ground(lp, tx, ty, tz)
                target_pos = { x = tx, y = ty, z = gz }
            else
                current_target = nil
                target_pos = nil
            end
        else
            current_target = nil
            target_pos = nil
        end

        
        do
            local now = client.timestamp()
            if ox then
                if not last_pos then
                    last_pos = { x = ox, y = oy, z = oz }
                    last_pos_time = now
                else
                    if now - last_pos_time >= pos_check_interval then
                        local moved = vec_dist(last_pos.x, last_pos.y, last_pos.z, ox, oy, oz)
                        if moved >= stuck_move_threshold then
                            
                            retry_count = 0
                            last_pos = { x = ox, y = oy, z = oz }
                            last_pos_time = now
                        else
                            
                            if now - last_pos_time >= stuck_threshold_time then
                                retry_count = retry_count + 1
                                path = nil
                                paused_until = now + 300
                                last_pos = { x = ox, y = oy, z = oz }
                                last_pos_time = now
                                if retry_count >= max_retries_before_reroute then
                                    
                                    current_target = nil
                                    target_pos = nil
                                    retry_count = 0
                                end
                            end
                        end
                    end
                end
            end
        end

        if target_pos then
            local now = client.timestamp()
            local should_recompute = (not path) or (now > target_recompute_time)
            if not last_target_pos then should_recompute = true end
            if last_target_pos and target_pos and vec_dist(last_target_pos.x, last_target_pos.y, last_target_pos.z, target_pos.x, target_pos.y, target_pos.z) > 100 then
                should_recompute = true
            end
            if should_recompute then
                local p = find_path(lp, target_pos)
                if p then
                    path = p
                    path_index = 1
                    target_recompute_time = client.timestamp() + target_recompute_interval
                    last_target_pos = { x = target_pos.x, y = target_pos.y, z = target_pos.z }
                else
                    
                    current_target = nil
                    target_pos = nil
                    path = nil
                end
            end
        else
            if not path then
                local target = pick_destination(lp)
                
                if not target and #predefined_sites > 0 then
                    local s = predefined_sites[ math.random(1, #predefined_sites) ]
                    if s then target = { x = s.x, y = s.y, z = s.z } end
                end
                if target then
                    local p = find_path(lp, target)
                    if p then
                        path = p
                        path_index = 1
                    else
                        
                        path = nil
                    end
                end
            end
        end
        if not path then return end
        local ox, oy, oz = entity.get_origin(lp)
        if not ox then return end
        local cur_target = path[path_index+1] or path[#path]
        if not cur_target then path = nil return end
        local d = vec_dist(ox, oy, oz, cur_target.x, cur_target.y, cur_target.z)
        if d <= reached_dist then
            path_index = path_index + 1
            
            clear_node_attempt(cur_target.x, cur_target.y)
            if path_index >= #path then path = nil return end
            return
        end
        do
            local jumped = false
            if current_target and target_pos then
                local tx, ty, tz = target_pos.x, target_pos.y, target_pos.z
                local dist = vec_dist(ox, oy, oz, tx, ty, tz)
                if dist > 1000 then
                    
                end
            end
            if not jumped then
                move_towards(cmd, lp, cur_target.x, cur_target.y, cur_target.z)
            end
        end
    end)
    if not ok then pcall(client.error_log, "walkbot error: "..tostring(err)) end
end)

callbacks.register("paint", function()
    if not ui_get_safe(menu_setup.ui.misc_walkbot) then return end
    if not path or #path == 0 then return end
    local lp = entity.get_local_player()
    if not lp then return end
    local ox, oy, oz = entity.get_origin(lp)
    if not ox then return end
    local prevx, prevy, prevz = ox, oy, oz
    prevz = snap_ground(lp, prevx, prevy, prevz)
    local px, py = renderer.world_to_screen(prevx, prevy, prevz)
    for i=path_index, #path do
        local n = path[i]
        if not n then break end
        local node_z = snap_ground(lp, n.x, n.y, n.z)
        local sx, sy = renderer.world_to_screen(n.x, n.y, node_z)
        if sx and sy and px and py then
            renderer.line(px, py, sx, sy, 255, 180, 0, 200)
            renderer.rectangle(sx-3, sy-3, 6, 6, 255, 80, 0, 200)
        end
        px, py = sx, sy
    end
end)

return true
]]
__bundle["require/features/paint/aimbot_logs"] = [[local menu_setup = require("require/abc/menu_setup")
local screenlog = require("require/abc/screen_logger")


local cb = nil
pcall(function() cb = require('require/abc/callbacks') end)
if not cb then error("callbacks manager required: require/abc/callbacks") end
local logs = {}
local fired_shots = {}

local function is_logs_enabled()
	local ref = menu_setup.ui.paint_aimbot_logs
	if not ref then return false end
	local sel = ui.get(ref)
	if type(sel) == "string" then
		return sel ~= "off"
	end
	return false
end

local function get_log_style()
	local ref = menu_setup.ui.paint_aimbot_logs
	if not ref then return "gamesense" end
	local sel = ui.get(ref)
	if type(sel) == "table" then
		for _, v in ipairs(sel) do
			if v == "gamesense beta" then return "gamesense beta" end
			if v == "sodium" then return "sodium" end
			if v == "gamesense" then return "gamesense" end
		end
	elseif type(sel) == "string" then
		return sel
	end
	return "gamesense"
end

local enemies = require("require/help/enemies")
local pushlog = require("require/abc/push_logger")
local Safe = require("require/help/safe")

local ok_collect, collect = pcall(require, "require/features/misc/collect")


local function get_boneyaw(ent)
	if not ent or ent == 0 then return 0 end
	
	if ok_collect and collect then
		local ok, val = pcall(function()
			return collect.get_goal_feet_yaw(ent) or collect.get_feet_yaw(ent) or collect.get_lower_body_yaw(ent)
		end)
		if ok and val and val ~= 0 then return val end
	end
	
	local ok_prop, a1, a2, a3 = pcall(function() return entity.get_prop(ent, "m_angAbsRotation") end)
	if ok_prop and a1 then
		if type(a1) == "table" then
			return a1[2] or 0
		else
			return a2 or 0
		end
	end
	
	local ok_lby, lby = pcall(function() return entity.get_prop(ent, "m_flLowerBodyYawTarget") end)
	if ok_lby and lby then return lby end
	return 0
end


local function get_resolver_label(ent)
	local ok, labels = pcall(function() return _G.player_labels end)
	if not ok or type(labels) ~= "table" then return nil end
	local ok2, lbl = pcall(function() return labels[ent] end)
	if not ok2 then return nil end
	return lbl
end


local function get_view_angles()
	local ok, a, b, c = pcall(function() return client.camera_angles() end)
	if not ok then return nil, nil, nil end
	return a or 0, b or 0, c or 0
end


local function get_abs_angles(ent)
	if not ent or ent == 0 then return nil, nil, nil end
	local ok, ax, ay, az = pcall(function() return entity.get_prop(ent, "m_angAbsRotation") end)
	if not ok then return nil, nil, nil end
	
	if type(ax) == "table" then
		return ax[1] or 0, ax[2] or 0, ax[3] or 0
	else
		return ax or 0, ay or 0, az or 0
	end
end

local function paint_logger_has(kind)
	local ref = menu_setup.ui.paint_logger
	if not ref then return false end
	local sel = Safe.safe_get(ref)
	if type(sel) == 'table' then
		for _, v in ipairs(sel) do
			if v == kind then return true end
		end
		return false
	elseif type(sel) == 'string' then
		return sel == kind
	end
	return false
end

local function rgba_hex(r,g,b,a) return string.format("\a%02x%02x%02x%02x", r or 255, g or 255, b or 255, a or 255) end
local function colorize_numbers(s, r,g,b,a)
	if not s or s == "" then return s end
	local prefix = rgba_hex(r,g,b,a)
	local reset = rgba_hex(255,255,255,255)
	local pat = "([-+]?%d+%.?%d*%%?)"
	local ok, res = pcall(function()
		return (s:gsub(pat, function(num)
			return prefix .. num .. reset
		end))
	end)
	if ok and res then return res end
	return s
end

local function escape_for_find(s)
	if not s then return "" end
	return s:gsub("([%^%$%(%)%%.%[%]%*%+%-%?])", "%%%1")
end

local function colorize_numbers_outside_reason(full, reason, r,g,b,a)
	if not full or full == "" then return full end
	if not reason or reason == "" then
		return colorize_numbers(full, r,g,b,a)
	end
	
	local start_pos, end_pos = full:find(reason, 1, true)
	if not start_pos then
		
		return colorize_numbers(full, r,g,b,a)
	end
	local left = full:sub(1, start_pos - 1)
	local mid = full:sub(start_pos, end_pos)
	local right = full:sub(end_pos + 1)
	local colored_left = colorize_numbers(left, r,g,b,a)
	local colored_right = colorize_numbers(right, r,g,b,a)
	local prefix = rgba_hex(r,g,b,a)
	local reset = rgba_hex(255,255,255,255)
	local colored_mid = prefix .. mid .. reset
	return (colored_left or "") .. colored_mid .. (colored_right or "")
end
local function format_log(event, style, hit_or_miss, extra)
	local name = event.target_name or "?"
	local hitgroup = event.hitgroup_name or "?"
	local actual_dmg = (extra and extra.damage) or event.damage or 0
	local wanted_dmg = event.damage or actual_dmg
	local dmg_delta = actual_dmg - wanted_dmg
	local dmg_str
	if actual_dmg == wanted_dmg then
		dmg_str = string.format("%d dmg", actual_dmg)
	elseif dmg_delta < 0 then
		dmg_str = string.format("%d(-%d) dmg", actual_dmg, math.abs(dmg_delta))
	else
		dmg_str = string.format("%d(+%d) dmg", actual_dmg, dmg_delta)
	end
	local health = (style == "gamesense" and extra and extra.health) or event.health or 0
	local reason = extra and extra.reason or ""

	local bt_ticks = event.backtrack_ticks or (extra and extra.backtrack_ticks) or 0
	if bt_ticks == 0 then
		local ok_tick, now_tick = pcall(function() return globals.tickcount() end)
		if ok_tick and event.tick then
			bt_ticks = math.max(0, now_tick - (event.tick or now_tick))
		end
	end
	local bt = event.backtrack or (extra and extra.backtrack) or 0
	if bt == 0 and bt_ticks and bt_ticks > 0 then
		local ok_int, ti = pcall(function() return globals.tickinterval() end)
		local tickint = (ok_int and ti) or 0
		bt = math.floor(bt_ticks * tickint * 1000)
	end
	if bt == 0 and event.time then
		local ok_now, nowt = pcall(function() return globals.realtime() end)
		if ok_now and nowt and event.time then
			bt = math.floor((nowt - event.time) * 1000)
		end
	end
	local hitchance = extra and extra.hitchance or event.hitchance or "hehe"
	local safepoint = event.safepoint or false
	local tick = event.tick or 0
	local time = event.time or globals.realtime()
	local move = event.move or 0
	local t = event.t or 0
	local boneyaw = (extra and extra.boneyaw) or get_boneyaw(event.target) or 0
	local resolver_label = (extra and extra.resolver) or get_resolver_label(event.target) or "?"
	resolver_label = tostring(resolver_label):lower()
	local view_pitch, view_yaw = get_view_angles()
	local abs_pitch, abs_yaw = get_abs_angles(event.target)
	local id = event.id or 0
	if style == "gamesense beta" then
		if hit_or_miss == "hit" then
			return string.format("[+] Hit %s's %s for %s (%d%%) bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				name, hitgroup, dmg_str, hitchance, bt, bt_ticks,
				view_yaw or 0, view_pitch or 0, abs_yaw or 0, abs_pitch or 0, move, t, boneyaw)
		else
			return string.format("[-] Missed %s's %s for %s (%d%%) due to %s bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				name, hitgroup, dmg_str, hitchance, reason, bt, bt_ticks,
				view_yaw or 0, view_pitch or 0, abs_yaw or 0, abs_pitch or 0, move, t, boneyaw)
		end
	elseif style == "gamesense" then
		if hit_or_miss == "hit" then
			return string.format("[gamesense] Hit %s's %s for %s (%d%%) (%dhp remaining)",
				name, hitgroup, dmg_str, hitchance, health)
		else
			return string.format("[gamesense] Missed %s's %s for %s (%d%%) reason=%s",
				name, hitgroup, dmg_str, hitchance, reason)
		end
	elseif style == "sodium" then
		if hit_or_miss == "hit" then
			return string.format("hit %s's %s for %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				name, hitgroup, dmg_str, hitchance, bt, resolver_label, boneyaw)
		else
			return string.format("missed %s's %s due to %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				name, hitgroup, reason, hitchance, bt, resolver_label, boneyaw)
		end
	else
		if hit_or_miss == "hit" then
			return string.format("a",
				name, hitgroup, dmg, hitchance, move, t, boneyaw)
		else
			return string.format("b",
				name, hitgroup, dmg, hitchance, reason, move, t, boneyaw)
		end
	end
end

cb.register('aim_fire', function(ev)

	if not is_logs_enabled() then return end
	
	fired_shots[ev.id] = {
		id = ev.id,
		target = ev.target,
		target_name = entity.get_player_name(ev.target or 0),
		hitgroup = ev.hitgroup,
		hitgroup_name = ev.hitgroup and ({"head","chest","stomach","left arm","right arm","left leg","right leg"})[ev.hitgroup] or "?",
		damage = ev.damage,
		health = ev.health,
		backtrack = (ev.backtrack or 0) * globals.tickinterval() * 1000,
		backtrack_ticks = ev.backtrack or 0,
		hitchance = ev.hit_chance or 0,
		safepoint = ev.safepoint,
		tick = globals.tickcount(),
		time = globals.realtime(),
		move = ev.move or 0,
		t = ev.t or 0,
		boneyaw = ev.boneyaw or get_boneyaw(ev.target) or 0,
	}
end, { require_login = true, alive_only = true })

cb.register('aim_hit', function(ev)

	if not is_logs_enabled() then return end
	local shot = fired_shots[ev.id]
	if not shot then return end
	local style = get_log_style()
	local health_after = entity.get_prop(ev.target, "m_iHealth") or 0
	local boneyaw = shot.boneyaw or get_boneyaw(shot.target)
	local resolver = get_resolver_label(shot.target)
	local log = format_log(shot, style, "hit", {
		damage=ev.damage,
		health=health_after,
		backtrack=shot.backtrack,
		backtrack_ticks=shot.backtrack_ticks,
		boneyaw=boneyaw,
		resolver=resolver
	})
	if style == "gamesense beta" then
		
		client.color_log(165, 202, 42, log)
		screenlog(log, 4, 165, 202, 42, 255)
	elseif style == "sodium" then
		local requested = shot.damage or 0
		local actual = ev.damage or requested
		local delta = actual - requested
		if delta == 0 then
			client.color_log(165, 202, 42, log)
			local colored = colorize_numbers(log, 165, 202, 42, 255)
			screenlog(colored, 4)
		else
			client.color_log(255, 204, 51, log)

			local delta_str = string.format("(%+d)", delta)
			local esc = escape_for_find(delta_str)
			local left, mid, right = log:match("^(.-)(" .. esc .. ")(.*)$")
			if not left then
				local colored = colorize_numbers(log, 165, 202, 42, 255)
				screenlog(colored, 4)
			else
				local left_col = colorize_numbers(left, 165, 202, 42, 255)
				local right_col = colorize_numbers(right, 165, 202, 42, 255)
				local dr, dg, db
				if delta > 0 then
					dr, dg, db = 255, 204, 51
				else
					dr, dg, db = 217, 100, 100 
				end
				local prefix = rgba_hex(dr, dg, db, 255)
				local reset = rgba_hex(255, 255, 255, 255)
				local inner = mid:sub(2, -2) or mid
				local mid_col = "(" .. prefix .. inner .. reset .. ")"
				local colored = (left_col or "") .. mid_col .. (right_col or "")
				screenlog(colored, 4)
			end
		end
	else
		client.log(log)
		screenlog(log, 4, 255, 255, 255, 255)
	end

	
	if paint_logger_has('aimbot') then
		local name = shot.target_name or "?"
		local hitbox = shot.hitgroup_name or "?"
		local dmg = ev.damage or 0
		local hc = shot.hitchance or 0
		local msg = string.format("Hit %s's %s for %d(%d%%)", name, hitbox, dmg, hc)
		pushlog(msg, 4, 255, 255, 255, 255)
	end

	fired_shots[ev.id] = nil
end, { require_login = true, alive_only = true })

cb.register('aim_miss', function(ev)

	if not is_logs_enabled() then return end
	local shot = fired_shots[ev.id]
	if not shot then return end
	local style = get_log_style()
	local boneyaw = shot.boneyaw or get_boneyaw(shot.target)
	local resolver = get_resolver_label(shot.target)
	local log = format_log(shot, style, "miss", {reason=ev.reason or "?", boneyaw=boneyaw, resolver=resolver})
		if style == "gamesense beta" then
			client.color_log(217, 100, 100, log)
			screenlog(log, 4, 217, 100, 100, 255)
		elseif style == "sodium" then
			
			local reason_text = ev.reason or "?"
			local colored = colorize_numbers_outside_reason(log, reason_text, 217, 100, 100, 255)
			screenlog(colored, 4)
			client.color_log(217, 100, 100, log)
		else
			screenlog(log, 4, 255, 255, 255, 255)
			client.log(log)
		end

	if paint_logger_has('aimbot') then
		local name = shot.target_name or "?"
		local hitbox = shot.hitgroup_name or "?"
		local dmg = shot.damage or 0
		local hc = shot.hitchance or 0
		local reason = ev.reason or "?"
		local msg = string.format("Missed %s's %s for %d(%d%%) due to %s", name, hitbox, dmg, hc, reason)
		pushlog(msg, 4, 255, 255, 255, 255)
	end

	fired_shots[ev.id] = nil
end, { require_login = true, alive_only = true })]]
__bundle["require/features/paint/animations"] = [[


local S = nil
pcall(function() S = require('require/help/safe') end)
local menu_setup = nil
pcall(function() menu_setup = require('require/abc/menu_setup') end)

local cb = nil
pcall(function() cb = require('require/abc/callbacks') end)
if not cb then error("callbacks manager required: require/abc/callbacks") end
local c_entity = require("gamesense/entity") or error("You're missing a required module: gamesense/entity")


local function get_lp_entity()
    local lp = entity.get_local_player()
    if not lp then return nil, nil end
    local ok, wrapped = pcall(function() return c_entity.new(lp) end)
    if not ok then return lp, nil end
    return lp, wrapped
end




local E_POSE_PARAMETERS = {
    STRAFE_YAW = 0,
    STAND = 1,
    LEAN_YAW = 2,
    SPEED = 3,
    LADDER_YAW = 4,
    LADDER_SPEED = 5,
    JUMP_FALL = 6,
    MOVE_YAW = 7,
    MOVE_BLEND_CROUCH = 8,
    MOVE_BLEND_WALK = 9,
    MOVE_BLEND_RUN = 10,
    BODY_YAW = 11,
    BODY_PITCH = 12,
    AIM_BLEND_STAND_IDLE = 13,
    AIM_BLEND_STAND_WALK = 14,
    AIM_BLEND_STAND_RUN = 14,
    AIM_BLEND_CROUCH_IDLE = 16,
    AIM_BLEND_CROUCH_WALK = 17,
    DEATH_YAW = 18
}

local function get_velocity(ent)
    if not ent then return 0 end
    local vx, vy, vz = entity.get_prop(ent, 'm_vecVelocity')
    if not vx or not vy then
        local vel = vx
        if type(vel) == 'table' then
            vx = vel.x or vel[1] or 0
            vy = vel.y or vel[2] or 0
        else
            return 0
        end
    end
    return math.sqrt((vx or 0) * (vx or 0) + (vy or 0) * (vy or 0))
end

local gs_item_refs = {}
local gs_ref_visible = {}
for i, item in ipairs({
    { 'AA', 'Other', 'Leg movement' },

}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
    for _, ref in ipairs(refs) do
        gs_ref_visible[ref] = true
    end
end






local aafunc = require("gamesense/antiaim_funcs")


local function static_legs_in_air()
    local lp = entity.get_local_player()
    if not lp then return end
    entity.set_prop(lp, "m_flPoseParameter", 1, E_POSE_PARAMETERS.JUMP_FALL)
end

local function kingaru()

    if aafunc.get_tickbase_shifting() > 0 then
        return
    end
    
    value = 0.5
    local lp = entity.get_local_player()
    if not lp then return end
    local tick = globals.tickcount()
    local phase = math.floor(tick / 2) % 2
    local finval = (phase == 0) and -0.1 or 0.9
    entity.set_prop(lp, "m_flPoseParameter", math.random(0, 10) / value, E_POSE_PARAMETERS.SPEED)
    entity.set_prop(lp, "m_flPoseParameter", math.random(0, 10) / 10, E_POSE_PARAMETERS.MOVE_YAW)
    entity.set_prop(lp, "m_flPoseParameter", math.random(0, 10) / 10, E_POSE_PARAMETERS.JUMP_FALL)
end



local function break_land()
    local lp, player_entity = get_lp_entity()
    if not lp or not player_entity then return end
    local anim_state = player_entity:get_anim_state()
    local anim_overlay = player_entity:get_anim_overlay(12)
    entity.set_prop(lp, "m_flPoseParameter", client.random_float(0, 1), 0)
    anim_overlay.weight = client.random_float(0, 1)
    ui.set(gs_item_refs[1][1], "Always slide")
end

local function earthquake()
    local lp, player_entity = get_lp_entity()
    if not lp or not player_entity then return end
    local anim_overlay = player_entity:get_anim_overlay(12)
    anim_overlay.weight = math.random(0,10) / 10
end


local function body_lean()
    local lp, player_entity = get_lp_entity()
    if not lp or not player_entity then return end
    local anim_state = player_entity:get_anim_state()
    local anim_overlay = player_entity:get_anim_overlay(12)
    if anim_overlay then anim_overlay.weight = 0.999 end
end

local function pitch_on_land()
    local lp, player_entity = get_lp_entity()
    if not lp or not player_entity then return end
    local anim_state = player_entity:get_anim_state()
    if anim_state and anim_state.hit_in_ground_animation then
        entity.set_prop(lp, "m_flPoseParameter", 0.5, E_POSE_PARAMETERS.BODY_PITCH)
    end
end

local function moonwalk()
    local lp, player_entity = get_lp_entity()
    if not lp or not player_entity then return end
    local overlay = player_entity:get_anim_overlay(6)
    entity.set_prop(lp, "m_flPoseParameter", 0, E_POSE_PARAMETERS.MOVE_YAW)
    if overlay then overlay.weight = 1 end
end

local function allah()
    local lp, player_entity = get_lp_entity()
    if not lp or not player_entity then return end
    local overlay12 = player_entity:get_anim_overlay(12)
    local overlay6 = player_entity:get_anim_overlay(6)
    if overlay12 then overlay12.weight = 0 end
    if overlay6 then overlay6.weight = 1 end
end

local function reversed_legs()
    local lp = entity.get_local_player()
    if not lp then return end
    ui.set(gs_item_refs[1][1], math.random(1,2) == 1 and "Always slide" or "Never slide")
    entity.set_prop(lp, "m_flPoseParameter", 8, 0)
end


local function blind()
    local lp, player_entity = get_lp_entity()
    if not lp or not player_entity then return end
    local overlay9 = player_entity:get_anim_overlay(9)
    if overlay9 then
        overlay9.weight = 1
        overlay9.sequence = 224
    end
end

local function t_pose()
    local lp, player_entity = get_lp_entity()
    if not lp or not player_entity then return end
    local overlay0 = player_entity:get_anim_overlay(0)
    if overlay0 then overlay0.sequence = 11 end
end

local function pitch_up()

    local lp = get_lp_entity()
    if not lp then return end
    entity.set_prop(lp, 'm_flPoseParameter', 0, E_POSE_PARAMETERS.BODY_PITCH)
    entity.set_prop(lp, 'm_flPoseParameter', math.random(-1, 1), E_POSE_PARAMETERS.BODY_YAW)

end




cb.register('pre_render', function()
    local lp = entity.get_local_player()
    if not lp then return end
    local velocity = get_velocity(lp)


    local selections = nil
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_animations then
        if S and S.safe_get then
            selections = S.safe_get(menu_setup.ui.paint_animations)
        else
            local ok, res = pcall(function() return ui.get(menu_setup.ui.paint_animations) end)
            if ok then selections = res end
        end
    end

    local sel = {}
    if type(selections) == 'table' then
        for _, v in ipairs(selections) do sel[v] = true end
    end

    if sel['kingaru'] and velocity > 3 then kingaru() end
    if sel['body lean'] and velocity > 3 then body_lean() end
    if sel['static legs'] and velocity > 3 then static_legs_in_air() end
    if sel['moonwalk'] and velocity > 3 then moonwalk() end
    if sel['allah'] and velocity > 3 then allah() end
    if sel['no pitch on land'] and velocity > 3 then pitch_on_land() end
    if sel['reversed legs'] and velocity > 3 then reversed_legs() end
    if sel['earthquake'] then earthquake() end
    if sel['t-pose'] then t_pose() end
    if sel['blind'] then blind() end
    if sel['pitch up'] then pitch_up() end
    if sel['gamesense legs'] then break_land() end
end, { require_login = true, alive_only = true })

cb.register('setup_command', function(cmd)

    local lp = entity.get_local_player()
    if not lp then return end
    local velocity = get_velocity(lp)
    if velocity < 3 then return end

    local selections = nil
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_animations then
        if S and S.safe_get then
            selections = S.safe_get(menu_setup.ui.paint_animations)
        else
            local ok, res = pcall(function() return ui.get(menu_setup.ui.paint_animations) end)
            if ok then selections = res end
        end
    end

    local sel = {}
    if type(selections) == 'table' then
        for _, v in ipairs(selections) do sel[v] = true end
    end

    

end, { require_login = true, alive_only = true })]]
__bundle["require/features/paint/aspect_ratio"] = [[
local menu_setup = require("require/abc/menu_setup")
local T = require("require/help/time")
local Safe = require("require/help/safe")
local ffi = require("ffi")
local dll = require("require/brain/dll")
local cb = nil
pcall(function() cb = require('require/abc/callbacks') end)

if not (dll and dll.aspect_update) then
    error("sodiumdll aspect_update export missing")
end

local aspect_state_c = ffi.new("struct AspectState[1]")
local out_target = ffi.new("double[1]")
local out_dirty = ffi.new("int[1]")
local aspect_update = dll.aspect_update

local function get_aspect()
    if cvar.r_aspectratio and cvar.r_aspectratio.get_float then
        return cvar.r_aspectratio:get_float()
    end
    return nil
end

local function set_aspect(val)
    if cvar.r_aspectratio and cvar.r_aspectratio.set_float then
        cvar.r_aspectratio:set_float(val)
        return true
    elseif client and client.exec then
        client.exec("r_aspectratio " .. tostring(val))
        return true
    end
    return false
end

cb.register('paint', function()
    if not ui.is_menu_open() then return end
    local ref = menu_setup.ui.paint_aspect_ratio
    if not ref then return end
    local raw = Safe.safe_get(ref)
    if type(raw) ~= 'number' then return end
    aspect_update(aspect_state_c, raw, get_aspect() or 0, T.realtime(), out_target, out_dirty)
    if out_dirty[0] ~= 0 then
        set_aspect(out_target[0])
    end
end, { require_login = true })

client.set_event_callback('shutdown', function()
    aspect_state_c[0].initialized = 0
    aspect_state_c[0].original = 0
    aspect_state_c[0].last = 0
    aspect_state_c[0].last_update = 0
end)]]
__bundle["require/features/paint/bomb_esp"] = [[local bomb_state = nil
local damage_indicators = {}
local prev_health = nil
local PRED_BASE_DAMAGE = 500
local PRED_RADIUS = 1000

local PRED_SCALE = 1.0
local AUTO_TUNE_ENABLED = true
local TUNE_SMOOTH = 0.25 
local LAST_TUNE_TIME = 0
local TUNE_COOLDOWN = 2

local cb = nil
pcall(function() cb = require('require/abc/callbacks') end)
if not cb then error("callbacks manager required: require/abc/callbacks") end

local function clear_bomb()
    bomb_state = nil
end

local function get_bomb_calculations_by_map(map)
    if not map then return 650, 2275 end
    local m = tostring(map):lower()
    if m:find('de_dust2') then return 500, 1750 end
    if m:find('de_ancient') then return 650, 2275 end
    if m:find('de_anubis') then return 450, 1575 end
    if m:find('de_inferno') then return 620, 2170 end
    if m:find('de_mirage') then return 650, 2275 end
    if m:find('de_nuke') then return 650, 2275 end
    if m:find('de_overpass') then return 650, 2275 end
    if m:find('de_vertigo') then return 500, 1750 end
    return 650, 2275
end

local function armor_modifier(damage, armor)
    armor = tonumber(armor) or 0
    if armor > 0 then
        local armor_ratio = 0.5
        local armor_bonus = 0.5
        local armor_ratio_multiply = damage * armor_ratio
        local actual = (damage - armor_ratio_multiply) * armor_bonus
        if actual > tonumber(armor) then
            actual = tonumber(armor) * (1.0 / armor_bonus)
            armor_ratio_multiply = damage - actual
        end
        damage = armor_ratio_multiply
    end
    return damage
end

local function calculate_bomb_damage(px, py, pz, bx, by, bz, armor, map_name)
    if not px or not py or not pz or not bx or not by or not bz then return 0 end
    local bomb_damage, bomb_radius = get_bomb_calculations_by_map(map_name)
    local c = bomb_radius / 3.0
    local dx = px - bx
    local dy = py - by
    local dz = pz - bz
    local dist = math.sqrt(dx*dx + dy*dy + dz*dz)
    local exp_part = math.exp( - (dist * dist) / (2 * c * c) )
    local damage = bomb_damage * exp_part
    local damage_armor = armor_modifier(damage, armor)
    return math.floor(damage_armor + 0.0)
end

local function site_to_letter(idx)
    if not idx then return "?" end
    if idx == 454 then return "A" end
    if idx == 455 then return "B" end
    if idx == 0 then return "A" end
    if idx == 1 then return "B" end
    if type(idx) == "string" then
        local s = idx:upper()
        if s == "A" or s == "B" then return s end
    end
    return tostring(idx)
end

cb.register('bomb_planted', function(e)
    local site_index = e and e.site

    local planted_entities = entity.get_all("CPlantedC4") or {}
    local blow_time = nil
    local entindex = nil

    for i = 1, #planted_entities do
        local idx = planted_entities[i]
        local prop = entity.get_prop(idx, "m_flC4Blow")
        if prop and prop > 0 then
            blow_time = prop
            entindex = idx
            break
        end
    end

    if not blow_time then
        local c4timer = 40
        if cvar and cvar.mp_c4timer then
            local ok, val = pcall(function()
                if type(cvar.mp_c4timer.get_float) == "function" then
                    return cvar.mp_c4timer:get_float()
                elseif type(cvar.mp_c4timer.get_int) == "function" then
                    return cvar.mp_c4timer:get_int()
                else
                    return tonumber(cvar.mp_c4timer:get_string())
                end
            end)
            if ok and val and tonumber(val) then
                c4timer = tonumber(val)
            end
        end
        blow_time = globals.curtime() + (c4timer or 40)
    end

    bomb_state = {
        site = site_index,
        blow_time = blow_time,
        entindex = entindex,
        planted_at = globals.curtime()
    }
end, { require_login = true, alive_only = true })

cb.register('bomb_defused', clear_bomb, { require_login = true, alive_only = true })
cb.register('bomb_exploded', function(e)
    
    local had_bomb = bomb_state ~= nil
    local tune_at = globals.curtime()
    
    local predicted = nil
    local local_ent = entity.get_local_player()
    if had_bomb and local_ent then
        local function compute_pred_at_state()
            
            local bomb_pos = nil
            if bomb_state and bomb_state.entindex then
                local ok, a, b, c = pcall(function() return entity.get_prop(bomb_state.entindex, "m_vecOrigin") end)
                if ok then
                    if type(a) == "table" then
                        bomb_pos = a
                    elseif a ~= nil and b ~= nil and c ~= nil then
                        bomb_pos = { a, b, c }
                    end
                end
            end
            if not bomb_pos then
                local planted_entities = entity.get_all("CPlantedC4") or {}
                for i = 1, #planted_entities do
                    local idx = planted_entities[i]
                    local ok, a, b, c = pcall(function() return entity.get_prop(idx, "m_vecOrigin") end)
                    if ok then
                        if type(a) == "table" then
                            bomb_pos = a
                            break
                        elseif a ~= nil and b ~= nil and c ~= nil then
                            bomb_pos = { a, b, c }
                            break
                        end
                    end
                end
            end
            if not bomb_pos then return nil end
            local ok, ex, ey, ez = pcall(function() return client.eye_position() end)
            local px, py, pz
            
            local ok2, ox, oy, oz = pcall(function() return entity.get_origin(local_ent) end)
            if ok2 then
                if type(ox) == "table" then
                    if #ox >= 3 then px, py, pz = ox[1], ox[2], ox[3] end
                elseif ox ~= nil and oy ~= nil and oz ~= nil then
                    px, py, pz = ox, oy, oz
                end
            end
            
            if (not px or not py or not pz) and ok and ex ~= nil and ey ~= nil and ez ~= nil then
                px, py, pz = ex, ey, ez
            end
            if not px or not bomb_pos or #bomb_pos < 3 then return nil end
            local bx, by, bz = bomb_pos[1], bomb_pos[2], bomb_pos[3]
            
            local ok_a, armor = pcall(function() return entity.get_prop(local_ent, "m_ArmorValue") end)
            armor = tonumber(armor) or 0
            local map_name = nil
            local okm, mres = pcall(function()
                if type(client.mapname) == 'function' then return client.mapname() end
                if cvar and cvar.mapname then return cvar.mapname:get_string() end
                if cvar and cvar.map then return cvar.map:get_string() end
                return nil
            end)
            if okm then map_name = mres end
            local raw_damage = calculate_bomb_damage(px, py, pz, bx, by, bz, armor, map_name)
            local scaled = math.floor((raw_damage * (PRED_SCALE or 1.0)) + 0.5)
            return raw_damage, scaled, math.sqrt((px-bx)^2 + (py-by)^2 + (pz-bz)^2)
        end
        local raw_pred, scaled_pred, pred_dist = compute_pred_at_state()
        predicted = scaled_pred
    end

    
    clear_bomb()

    
    if AUTO_TUNE_ENABLED and predicted and predicted > 0 then
        local sample_time = 0.15
        client.delay_call(sample_time, function()
            local now = globals.curtime()
            if now - LAST_TUNE_TIME < TUNE_COOLDOWN then return end
            local local_ent2 = entity.get_local_player()
            if not local_ent2 then return end
            local ok, hp_after = pcall(function() return entity.get_prop(local_ent2, "m_iHealth") end)
            hp_after = tonumber(hp_after)
            local hp_before = prev_health
            if not hp_before or not hp_after then return end
            local actual = hp_before - hp_after
            if actual <= 0 then return end

            
            local pred_for_ratio = (predicted and predicted > 0) and predicted or 1
            local ratio = actual / pred_for_ratio
            if ratio <= 0 then return end

            
            local new_scale = (PRED_SCALE or 1.0) * (1 + (ratio - 1) * TUNE_SMOOTH)
            if new_scale < 0.05 then new_scale = 0.05 end
            if new_scale > 10 then new_scale = 10 end
            local old_scale = PRED_SCALE
            PRED_SCALE = new_scale
            LAST_TUNE_TIME = globals.curtime()
            
            pcall(function()
                client.log("[bomb_esp] auto-tuned scale %.3f -> %.3f (ratio=%.3f, predicted=%d, actual=%d)", old_scale, PRED_SCALE, ratio, predicted or 0, actual)
            end)
        end)
    end
end, { require_login = true, alive_only = true })
cb.register('round_start', clear_bomb, { require_login = true, alive_only = true })
cb.register('round_start', function()
    prev_health = nil
end, { require_login = true, alive_only = true })
cb.register('player_spawned', function()
    prev_health = nil
end, { require_login = true, alive_only = true })


cb.register('player_hurt', function(e)
    if not e then return end
    local local_ent = entity.get_local_player()
    if not local_ent then return end
    local victim_ent = client.userid_to_entindex(e.userid)
    if victim_ent ~= local_ent then return end

    
    local dmg = e.dmg_health or e.damage or e.hp or 0
    dmg = tonumber(dmg) or 0
    if dmg <= 0 then return end

    
    local text = string.format("-%d HP", dmg)
    
    table.insert(damage_indicators, { t = globals.curtime(), text = text })
end, { require_login = true, alive_only = true })


cb.register('paint', function()
    local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
    if not menu_ok or not menu_setup or not menu_setup.ui then return end
    local ok_get, paint_bombwarning = pcall(ui.get, menu_setup.ui.paint_bombwarning)
    if not ok_get or not paint_bombwarning then return end

    local now = globals.curtime()

    
    local local_ent = entity.get_local_player()
    if local_ent then
        local ok, hp = pcall(function() return entity.get_prop(local_ent, "m_iHealth") end)
        hp = tonumber(hp)
        if hp then
            if prev_health == nil then
                prev_health = hp
            else
                if hp < prev_health then
                    local dmg = prev_health - hp
                    table.insert(damage_indicators, { t = now, text = string.format("-%d HP", dmg) })
                end
                prev_health = hp
            end
        end
    else
        prev_health = nil
    end

    
    for i = #damage_indicators, 1, -1 do
        local d = damage_indicators[i]
        local age = now - d.t
        local duration = 1.4
        if age >= duration then
            table.remove(damage_indicators, i)
        else
            local alpha = math.floor(255 * (1 - (age / duration)))
            if alpha < 0 then alpha = 0 end
            
            renderer.indicator(255, 210, 0, alpha, d.text)
        end
    end

    
    if bomb_state then
        local local_ent = entity.get_local_player()
        local bomb_pos = nil
        if bomb_state.entindex then
            local ok, a, b, c = pcall(function() return entity.get_prop(bomb_state.entindex, "m_vecOrigin") end)
            if ok then
                if type(a) == "table" then
                    bomb_pos = a
                elseif a ~= nil and b ~= nil and c ~= nil then
                    bomb_pos = { a, b, c }
                end
            end
        end
        
        if not bomb_pos then
            local planted_entities = entity.get_all("CPlantedC4") or {}
            for i = 1, #planted_entities do
                local idx = planted_entities[i]
                local ok, a, b, c = pcall(function() return entity.get_prop(idx, "m_vecOrigin") end)
                if ok then
                    if type(a) == "table" then
                        bomb_pos = a
                        break
                    elseif a ~= nil and b ~= nil and c ~= nil then
                        bomb_pos = { a, b, c }
                        break
                    end
                end
            end
        end

        if bomb_pos and local_ent then
            local px, py, pz = nil, nil, nil
            local ok, ex, ey, ez = pcall(function() return client.eye_position() end)
            if ok and ex ~= nil and ey ~= nil and ez ~= nil then
                px, py, pz = ex, ey, ez
            else
                local ok2, ox, oy, oz = pcall(function() return entity.get_origin(local_ent) end)
                if ok2 then
                    if type(ox) == "table" then
                        if #ox >= 3 then px, py, pz = ox[1], ox[2], ox[3] end
                    elseif ox ~= nil and oy ~= nil and oz ~= nil then
                        px, py, pz = ox, oy, oz
                    end
                end
            end

            if px and bomb_pos and #bomb_pos >= 3 then
                local bx, by, bz = bomb_pos[1], bomb_pos[2], bomb_pos[3]
                
                local ok_a, armor = pcall(function() return entity.get_prop(local_ent, "m_ArmorValue") end)
                armor = tonumber(armor) or 0
                local okm, mres = pcall(function()
                    if type(client.mapname) == 'function' then return client.mapname() end
                    if cvar and cvar.mapname then return cvar.mapname:get_string() end
                    if cvar and cvar.map then return cvar.map:get_string() end
                    return nil
                end)
                local map_name = okm and mres or nil
                local raw_pred = calculate_bomb_damage(px, py, pz, bx, by, bz, armor, map_name)
                local pred = math.floor((raw_pred * (PRED_SCALE or 1.0)) + 0.5)

                
                renderer.indicator(255, 210, 0, 255, string.format("-%d HP", pred))
            end
        end
    end

    
    if bomb_state then
        
        if bomb_state.entindex then
            local prop = entity.get_prop(bomb_state.entindex, "m_flC4Blow")
            if prop and prop > 0 then
                bomb_state.blow_time = prop
            end
        end

        local remaining = (bomb_state.blow_time or 0) - now
        if remaining <= 0 then
            bomb_state = nil
            return
        end

        local site_name = site_to_letter(bomb_state.site)
        local text = string.format("%s - %.1fs", site_name, remaining)
        renderer.indicator(255, 255, 255, 255, text)
    end
end, { require_login = true, alive_only = true })]]
__bundle["require/features/paint/bullet_tracer"] = [[local ffi = require("ffi")
local T = require('require/help/time')
local S = nil
local SELF = require('require/help/self')
pcall(function() S = require('require/help/safe') end)
pcall(function() DLL = require('require/brain/dll') end)
pcall(function() menu_setup = require('require/abc/menu_setup') end)
pcall(function() cb = require('require/abc/callbacks') end)

local MAX_TRACERS = 10
local tracer_life = 7.0
local tracer_color = {255,255,255,255}
local fade_fraction = 0.05
local fallback_dist = 8192

if not (DLL and DLL.tracer_reset and DLL.tracer_push_shot and DLL.tracer_set_impact and DLL.tracer_collect) then return end
DLL.tracer_reset()

local LINE_STRIDE = 7
local out_buf = ffi.new("double[?]", MAX_TRACERS * LINE_STRIDE)

local now = T.realtime

cb.register('weapon_fire', function(e)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if SELF.index() ~= client.userid_to_entindex(e.userid) then return end
    local w = SELF.weapon()
    if w then
        local cls = entity.get_classname(w) or ""
        local lower = cls:lower()
        if lower:find("knife") or lower:find("grenade") or lower:find("decoy") or lower:find("molotov") or lower:find("flash") or lower:find("smoke") or lower:find("taser") or lower:find("zeus") then
            return
        end
    end

    local sx,sy,sz = client.eye_position()
    if not sx then sx,sy,sz = entity.get_origin(SELF.index()) end
    sx,sy,sz = tonumber(sx) or 0, tonumber(sy) or 0, tonumber(sz) or 0
    DLL.tracer_push_shot(sx, sy, sz, now())
end, { require_login = true, alive_only = true })
 
cb.register('bullet_impact', function(e)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if SELF.index() ~= client.userid_to_entindex(e.userid) then return end
    local ix,iy,iz = tonumber(e.x) or 0, tonumber(e.y) or 0, tonumber(e.z) or 0
    DLL.tracer_set_impact(ix, iy, iz, now())
end, { require_login = true, alive_only = true })

if not cb then error("callbacks manager required: require/abc/callbacks") end

cb.register('paint', function()
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    local cur = now()
    local ang = { client.camera_angles() }
    local lines = DLL.tracer_collect(cur, tracer_life, fade_fraction, ang[1] or 0, ang[2] or 0, fallback_dist, tracer_color[4] or 255, out_buf, MAX_TRACERS)
    for i=0, (lines or 0)-1 do
        local base = i * LINE_STRIDE
        local sx, sy, sz = out_buf[base], out_buf[base + 1], out_buf[base + 2]
        local fx, fy, fz = out_buf[base + 3], out_buf[base + 4], out_buf[base + 5]
        local a = out_buf[base + 6]
        local wsx,wsy = renderer.world_to_screen(sx, sy, sz)
        local wfx,wfy = renderer.world_to_screen(fx, fy, fz)
        if wsx and wfx then
            renderer.line(wsx, wsy, wfx, wfy, tracer_color[1], tracer_color[2], tracer_color[3], a)
        end
    end
end, { require_login = true, alive_only = true })]]
__bundle["require/features/paint/clantag"] = [[local menu_setup=require("require/abc/menu_setup")
local Safe=require("require/help/safe")
local S=require("require/help/string")
local T=require("require/help/time")
local dll=require("require/brain/dll")
local ffi=require("ffi")
local p=pcall
local uref=ui.reference
local uset=ui.set
local set_tag=client.set_clan_tag
local ok_cb, cb = pcall(require, "require/abc/callbacks")
if not ok_cb or not cb then error("require/abc/callbacks is required by clantag.lua") end
if not dll or type(dll) ~= "table" or not dll.clantag_anim then return end

local CLANTAG_BUF_LEN=64
local clantag_buf=ffi.new("char[?]",CLANTAG_BUF_LEN)
local last_mode,clear_attempts,frames=nil,0,nil
local function try_set_spammer(e)
    local c={{"MISC","Misc","Clantag spammer"},{"MISC","Miscellaneous","Clantag spammer"},{"MISC","Misc","Clan tag spammer"},{"MISC","Miscellaneous","Clan tag spammer"},{"MISC","Misc","Clantag spamer"},{"MISC","Miscellaneous","Clantag spamer"}}
    for _,v in ipairs(c) do
        local ok,ref=p(uref,v[1],v[2],v[3])
        if ok and ref and p(uset,ref,e) then return true end
    end
    return false
end
local try_enable=function() return try_set_spammer(true) end
local try_disable=function() return try_set_spammer(false) end
cb.register('paint', function()
    local ref=menu_setup.ui.paint_clantag if not ref then return end
    local raw=Safe.safe_get(ref) if type(raw)~='string' then return end
    local mode=S.lower(raw) if mode==last_mode and mode~='sodium' and clear_attempts==0 then return end
    if mode=='off' then try_disable(); clear_attempts=3; p(set_tag," ")
    elseif mode=='gamesense' then if not try_enable() then p(set_tag,"gamesense") end
    elseif mode == 'sodium' then
        try_disable()

        if not frames or type(frames) ~= 'table' or not frames.start then
            frames = { start = T.realtime() }
        end

        local nowt = T.realtime() or 0
        ffi.fill(clantag_buf, CLANTAG_BUF_LEN, 0)
        local res = dll.clantag_anim(frames.start or 0, nowt, clantag_buf, CLANTAG_BUF_LEN)
        if res and res ~= 0 then
            p(set_tag, ffi.string(clantag_buf))
        else
            p(set_tag, "")
        end
    end
    if clear_attempts>0 then p(set_tag,"") clear_attempts=clear_attempts-1 end
    last_mode=mode
end, { require_login = true })]]
__bundle["require/features/paint/custom_scope"] = [[]]
__bundle["require/features/paint/damage"] = [[local menu_setup = require("require/abc/menu_setup")
local vector = require("require/brain/api/vector/vector")
local hit = { shots = {}, last = 0 }


local MAX_SHOTS = 5
local MAX_IMPACTS_PER_SHOT = 3
local MAX_TOTAL_IMPACTS = 10

local function total_impacts_count()
	local cnt = 0
	for i = 1, #hit.shots do
		local s = hit.shots[i]
		if s and s.impacts then cnt = cnt + #s.impacts end
	end
	return cnt
end

local function prune_total_impacts()
	while total_impacts_count() > MAX_TOTAL_IMPACTS do
		
		if #hit.shots == 0 then break end
		local removed = false
		for si = 1, #hit.shots do
			local s = hit.shots[si]
			if s and s.impacts and #s.impacts > 0 then
				table.remove(s.impacts, 1)
				removed = true
				
				if #s.impacts == 0 then
					table.remove(hit.shots, si)
				end
				break
			else
				
				table.remove(hit.shots, si)
				removed = true
				break
			end
		end
		if not removed then break end
	end
end

local function is_damage_enabled()
	local ref = menu_setup.ui.paint_hitmarker
	if not ref then return false end
	local sel = ui.get(ref)
	if type(sel) == "table" then
		for _, v in ipairs(sel) do
			if v == "damage" then return true end
		end
	end
	return false
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function aim_hit_handler(ev)
	if not is_damage_enabled() then hit = { shots = {}, last = 0 } return end
	if not is_damage_enabled() then return end
	local me = entity.get_local_player()
	if not me then return end
	local target = ev.target or ev.target_index
	if type(target) ~= 'number' or target == 0 or not entity.is_enemy(target) then return end
	local dmg = ev.damage or 0
	local hs = ev.hitgroup == 1
	local killed = ev.health == 0
	local x, y, z = entity.hitbox_position(target, ev.hitgroup or 'head')
	if not x then x, y, z = entity.get_origin(target) end
	if not x then return end
	local pos = vector.make(x, y, z)
	local now = globals.realtime()
	local color = {255, 255, 255}
	if killed then color = {217, 100, 100} elseif hs then color = {165, 202, 42} end

	local shot
	if hit.last and now - hit.last < 0.05 then
		shot = hit.shots[#hit.shots]
	else
		hit.last = now
		shot = { impacts = {}, finished = false, t = now }
		hit.shots[#hit.shots + 1] = shot
		if #hit.shots > 12 then table.remove(hit.shots, 1) end
	end

	if shot then
		shot.impacts[#shot.impacts + 1] = { dmg = dmg, x = x, y = y, z = z, pos = pos, t = now, color = color }
		if #shot.impacts > MAX_IMPACTS_PER_SHOT then table.remove(shot.impacts, 1) end
		
		prune_total_impacts()
	end
end

local function paint_handler(ev)
	if is_damage_enabled() then
		local now = globals.realtime()
		local float_time = 1.4
		local max_float = 32
		local i = 1
		while i <= #hit.shots do
			if now - (hit.shots[i].t or 0) > (float_time + 0.5) then
				table.remove(hit.shots, i)
			else
				i = i + 1
			end
		end
		local all_impacts = {}
		local max_collect = 12
		for si = #hit.shots, 1, -1 do
			local shot = hit.shots[si]
			for ii = #shot.impacts, 1, -1 do
				table.insert(all_impacts, shot.impacts[ii])
				if #all_impacts >= max_collect then break end
			end
			if #all_impacts >= max_collect then break end
		end

		local draw_count = math.min(4, #all_impacts)
		for j = 1, draw_count do
			local it = all_impacts[j]
			local sx, sy = renderer.world_to_screen(it.pos.x, it.pos.y, it.pos.z)
			if sx and sy then
				local age = now - (it.t or 0)
				local progress = math.min(1, age / float_time)
				local float_y = max_float * (1 - math.exp(-3 * progress))
				local alpha = math.floor(math.max(0, (1 - progress) * 255))
				if alpha > 0 then
					renderer.text(sx, sy - float_y, it.color[1], it.color[2], it.color[3], alpha, "crdb-", 0, tostring(it.dmg))
				end
			end
		end
	else
		hit = { shots = {}, last = 0 }
	end
end

callbacks.callback('aim_hit', aim_hit_handler, { alive_only = true, require_login = true })
callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })]]
__bundle["require/features/paint/damage_penetration"] = [[
local function safeload(name, global_name)
	if global_name and rawget(_G, global_name) ~= nil then
		return rawget(_G, global_name)
	end
	local ok, lib = pcall(require, name)
	if ok then return lib end
	return nil
end

local ui       = safeload('ui', 'ui')
local client   = safeload('client', 'client')
local entity   = safeload('entity', 'entity')
local renderer = safeload('renderer', 'renderer')

if not ui or not client or not entity or not renderer then
	return
end

local ui_new_checkbox = ui.new_checkbox
local ui_get          = ui.get
local ui_reference    = ui.reference

local client_screen_size    = client.screen_size
local client_set_callback   = client.set_event_callback
local client_unset_callback = client.unset_event_callback
local client_eye_position   = client.eye_position
local client_camera_angles  = client.camera_angles
local client_trace_line     = client.trace_line
local client_trace_bullet   = client.trace_bullet

local entity_get_local_player = entity.get_local_player
local entity_is_alive         = entity.is_alive or function() return false end
local entity_get_weapon       = entity.get_player_weapon or function() return nil end
local entity_get_classname    = entity.get_classname or function() return nil end

local renderer_text = renderer.text

local math_floor = math.floor
local math_cos   = math.cos
local math_sin   = math.sin
local math_rad   = math.rad

sodium_SUPPRESS = sodium_SUPPRESS or false
sodium_REFS = sodium_REFS or {}
sodium_FN = sodium_FN or {}

local function checkbox_enabled(ref)
	if not ref then return false end
	local ok, value = pcall(ui_get, ref)
	return ok and value == true
end


if type(sodium_FN.min_dmg_active) ~= 'function' then
	sodium_FN.min_dmg_active = function()
		ensure_min_damage_refs()
		local hk = sodium_REFS.min_dmg_hotkey
		if hk then
			local ok, value = pcall(ui_get, hk)
			if ok then return value == true end
		end
		return false
	end
end

if type(sodium_FN.min_dmg_value) ~= 'function' then
	sodium_FN.min_dmg_value = function()
		ensure_min_damage_refs()
		local slider = sodium_REFS.min_dmg_slider
		if not slider then return nil end
		local ok, value = pcall(ui_get, slider)
		if ok and type(value) == 'number' then
			return value
		end
		return nil
	end
end

local function resolve_ui_ref(key, builder)
	if sodium and sodium.ui and sodium.ui[key] then
		return sodium.ui[key]
	end
	local cache_key = 'ui_' .. key
	if sodium_REFS[cache_key] then
		return sodium_REFS[cache_key]
	end
	if not builder then return nil end
	local ref = builder()
	if ref then
		sodium_REFS[cache_key] = ref
	end
	return ref
end


local menu_setup = nil
pcall(function() menu_setup = require('require/abc/menu_setup') end)


local function weapon_allows_penetration(player)
    if not ui.get(menu_setup.ui.paint_show_damage_penetration) then return end
	if not entity_get_weapon or not entity_get_classname then return false end
	local weapon = entity_get_weapon(player)
	if not weapon then return false end
	local cls = entity_get_classname(weapon)
	if not cls then return false end
	if cls:sub(1, 7) ~= 'CWeapon' then return false end
	if cls:find('Grenade', 1, true) or cls:find('Taser', 1, true) or cls:find('C4', 1, true) then return false end
	return true
end

local function should_draw_damage_pen()
    if not ui.get(menu_setup.ui.paint_show_damage_penetration) then return end
	if not entity_get_local_player then return nil end
	local me = entity_get_local_player()
	if not me then return nil end
	if entity_is_alive and not entity_is_alive(me) then return nil end
	return me
end




local function draw_damage_penetration()
    if not ui.get(menu_setup.ui.paint_show_damage_penetration) then return end
	local me = should_draw_damage_pen()
	if not me or not weapon_allows_penetration(me) then return end
	local ex, ey, ez = client_eye_position()
	if not ex or not ey or not ez then return end
	local pitch, yaw = client_camera_angles()
	if not pitch or not yaw then return end
	local cp, sp = math_cos(math_rad(pitch)), math_sin(math_rad(pitch))
	local cyw, syw = math_cos(math_rad(yaw)), math_sin(math_rad(yaw))
	local fx, fy, fz = cp * cyw, cp * syw, -sp
	local range = 8192
	local tx, ty, tz = ex + fx * range, ey + fy * range, ez + fz * range
	local frac = select(1, client_trace_line(me, ex, ey, ez, tx, ty, tz)) or 1
	if frac < 0 then frac = 0 end
	if frac > 1 then frac = 1 end

	local distances
	if frac >= 0.999 then
		distances = { 256, 512, 1024, 2048, 4096 }
	else
		local entry = range * frac
		distances = { entry + 4, entry + 16, entry + 32, entry + 64, entry + 128, entry + 256 }
	end

	local best = 0
	for i = 1, #distances do
		local dist = distances[i]
		if dist > range then dist = range end
		local dx, dy, dz = ex + fx * dist, ey + fy * dist, ez + fz * dist
		local _, dmg = client_trace_bullet(me, ex, ey, ez, dx, dy, dz, true)
		if dmg and dmg > best then best = dmg end
		if dist == range then break end
	end

	local dmg_val = math_floor((best or 0) + 0.5)
	if dmg_val <= 0 then return end

	local sw, sh = client_screen_size()
	if not sw or not sh then return end
	local cx = sw / 2
	local cy_top = sh / 2 + 8
	local text = tostring(dmg_val)
	local drawn = false
	if sodium_FN.draw_surface_text_centered and _G.sodium_FONTS and _G.sodium_FONTS.pen then
		drawn = sodium_FN.draw_surface_text_centered(_G.sodium_FONTS.pen, cx, cy_top, text, 177, 194, 89, 255) and true or false
	end
	if not drawn then
		renderer_text(cx, sh / 2 + 12, 177, 194, 89, 255, 'cb', 0, text)
	end
end

local function on_paint()
    if not ui.get(menu_setup.ui.paint_show_damage_penetration) then return end
	if sodium_SUPPRESS then return end
	draw_damage_penetration()
end

local ok_cb, cb = pcall(require, "require/abc/callbacks")
if ok_cb and cb then
	if _G.sodium_B_MD_DP and type(_G.sodium_B_MD_DP) == 'number' then
		pcall(cb.unregister, _G.sodium_B_MD_DP)
	end

	local function paint_wrapper()
		if sodium_SUPPRESS then return end
        if not ui.get(menu_setup.ui.paint_show_damage_penetration) then return end
		draw_damage_penetration()
	end

	_G.sodium_B_MD_DP = cb.register('paint', paint_wrapper, { require_login = true, alive_only = true })
else
	if client_unset_callback and _G.sodium_B_MD_DP then
		client_unset_callback('paint', _G.sodium_B_MD_DP)
	end

	_G.sodium_B_MD_DP = on_paint
	client_set_callback('paint', on_paint)
end]]
__bundle["require/features/paint/entidx"] = [[local menu_setup = require("require/abc/menu_setup")
local enemies = require("require/help/enemies")

local function on_paint_entidx()
	if not ui.get(menu_setup.ui.paint_entidx) then return end

	local threat_entidx = enemies.get_current_threat and enemies.get_current_threat() or client.current_threat and client.current_threat() or nil
	if threat_entidx and threat_entidx ~= 0 then
		local name = entity.get_player_name(threat_entidx)

		renderer.text(70, 120, 255, 0, 0, 255, "b", 0, string.format("entidx%d: %s", threat_entidx, name))
	end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
if cb_ok and callbacks and callbacks.callback then
	callbacks.callback("paint", on_paint_entidx, { alive_only = true, require_login = true })
else
	client.set_event_callback("paint", on_paint_entidx)
end]]
__bundle["require/features/paint/filter_console"] = [[


local menu_setup = pcall(require, 'require/abc/menu_setup') and require('require/abc/menu_setup') or nil
local ui_handle = menu_setup and menu_setup.ui and menu_setup.ui.paint_filter_console or nil

local con_filter_enable = cvar.con_filter_enable
local con_filter_text = cvar.con_filter_text

local saved = { enable = nil, text = nil }

local function save_once()
    if saved.enable == nil then
        
        local ok, v = pcall(function() return con_filter_enable:get_int() end)
        saved.enable = (ok and v) and v or nil
    end

    if saved.text == nil then
        local ok, t = pcall(function() return con_filter_text:get_string() end)
        saved.text = (ok and t) and t or nil
    end
end

local function restore_values()
    if saved.enable ~= nil then
        pcall(function() con_filter_enable:set_raw_int(saved.enable) end)
    end

    if saved.text ~= nil then
        pcall(function() con_filter_text:set_string(saved.text) end)
    else
        pcall(function() con_filter_text:set_string('') end)
    end

    saved.enable = nil
    saved.text = nil
end

local function apply_filter()
    save_once()
    pcall(function() con_filter_enable:set_raw_int(1) end)
    pcall(function() con_filter_text:set_string('[gamesense]') end)
end




local function get_ui_state()
    if not ui_handle then
        return false
    end

    
    if type(ui_handle) == 'table' and ui_handle.get then
        local ok, v = pcall(function() return ui_handle:get() end)
        return ok and v or false
    end

    
    local ok, v = pcall(function() return ui.get(ui_handle) end)
    return ok and v or false
end

local function update_loop()
    if not get_ui_state() then
        restore_values()
        return
    end

    apply_filter()
    client.delay_call(1, update_loop)
end


client.delay_call(0.1, update_loop)


client.set_event_callback('shutdown', restore_values)

return {
    
    get_ui_state = get_ui_state,
    restore_values = restore_values,
    apply_filter = apply_filter,
}
]]
__bundle["require/features/paint/hit_miss_indicator"] = [[local M=require("require/help/math")
local S=require("require/help/self")
local Safe=require("require/help/safe")
local MS=require("require/abc/menu_setup")

local hits,shots=0,0
local enabled=function() return MS and MS.ui and Safe.safe_get(MS.ui.paint_hitmiss_indicator) end
local reset=function() hits,shots=0,0 end

client.set_event_callback("aim_fire", function(e)
    if not enabled() or not S.is_alive() then return end
    local ent = nil
    if e.userid then ent = client.userid_to_entindex(e.userid) end
    if (not ent or ent == 0) and e.player then ent = e.player end
    if ent == S.index() then shots = shots + 1 end
end)

client.set_event_callback("aim_hit", function(e)
    if not enabled() or not S.is_alive() then return end
    local ent = nil
    if e.userid then ent = client.userid_to_entindex(e.userid) end
    if (not ent or ent == 0) and e.attacker then ent = client.userid_to_entindex(e.attacker) end
    if (not ent or ent == 0) and e.player then ent = e.player end
    if ent == S.index() then hits = hits + 1 end
end)


client.set_event_callback("paint",function()
    if not enabled() then return end
    local pct=shots>0 and M.round(hits/shots*100,1) or 0
    renderer.indicator(255,255,255,255,string.format("%d / %d (%.1f)",hits,shots,pct))
end)
defer(reset)]]
__bundle["require/features/paint/indicators_bold"] = [[local indicator_offsets = { 0, 0, 0 }
local indicator_targets = { 3, 3, 3 }
local indicator_speeds = { 6, 6, 6 }

local function lerp(a, b, t)
  return a + (b - a) * t
end

local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local string_ok, string_helper = pcall(require, "require/help/string")
local function to_lower(s)
  if s == nil then return "" end
  if string_ok and string_helper and string_helper.lower then
    return string_helper.lower(tostring(s))
  end
  return tostring(s)
end
local color_ok, color_helper = pcall(require, "require/help/color")
local math_ok, math_helper = pcall(require, "require/help/math")
local rgba_hex = color_ok and color_helper.rgba_to_hex or function(r,g,b,a) return string.format("\a%02x%02x%02x%02x", r or 0, g or 0, b or 0, a or 255) end

local function animated_text(style, speed, r,g,b,a, text)
  local t = globals.realtime() or globals.curtime()
  if not text or #text == 0 then return "" end
  local out = {}

  if style == 0 then
    local hex = rgba_hex(r,g,b,a)
    for i=1,#text do out[#out+1] = hex .. text:sub(i,i) end
    return table.concat(out)
  end

  if style == 2 then
    local f = (math.sin(t * speed) + 1) * 0.5
    local la = math.floor(a * (0.45 + 0.55 * f))
    local hex = rgba_hex(r,g,b,la)
    for i=1,#text do out[#out+1] = hex .. text:sub(i,i) end
    return table.concat(out)
  end

  if style == 3 then
    for i=1,#text do
      local phase = math.sin(t * speed - i * 0.6)
      local spike = math.max(0, phase)
      local f = spike * spike
      local la = math.floor(a * (0.35 + 0.65 * f))
      out[#out+1] = rgba_hex(r,g,b,la) .. text:sub(i,i)
    end
    return table.concat(out)
  end

  for i=1,#text do
    local f = (math.sin(t * speed - i * 0.35) + 1) * 0.5
    local la = math.floor(a * (0.4 + 0.6 * f))
    out[#out+1] = rgba_hex(r,g,b,la) .. text:sub(i,i)
  end
  return table.concat(out)
end
local function indicators_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_indicators then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_indicators)
    if ok and val == "bold" then return true end
    return false
  end

  return true
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
  if not indicators_enabled() then return end

  local sw, sh = client.screen_size()
  local cx, cy = sw / 2, sh / 2

  local title_r, title_g, title_b = 200, 200, 255
  local text_r, text_g, text_b = 255, 255, 255
  local line_h = 18

  local line_hs = { 12, 12 }

  local y = cy + 18

  local local_player = entity.get_local_player()
  local is_scoped = false
  if local_player then
    local scoped_prop = entity.get_prop(local_player, "m_bIsScoped")
    is_scoped = scoped_prop == 1
  end

  local title_main = "sodium"
  local title_suffix = "beta"
  local dt_text_draw = "DT"

  local dt_active = false
  do
    local ok, libs = pcall(require, "require/help/libs")
    if ok and libs and libs.get then
      local aa = libs.get("antiaim_funcs")
      if aa and aa.get_double_tap then
        local success, result = pcall(aa.get_double_tap)
        if success and result then dt_active = true end
      end
    end
  end

  local anim_style = 1
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_indicators_animation then
    local ok_style, v = pcall(ui.get, menu_setup.ui.paint_indicators_animation)
    if ok_style and type(v) == 'number' then anim_style = v end
  end
  local full_title = title_main .. " " .. title_suffix
  full_title = to_lower(full_title)
  title_main = to_lower(title_main)
  title_suffix = to_lower(title_suffix)
  local w1 = renderer.measure_text("b", full_title) or 0
  local w_main = renderer.measure_text("b", title_main) or 0
  local w_suf = renderer.measure_text("b", title_suffix) or 0
  local w2 = renderer.measure_text("b", dt_text_draw) or 0

  local cond_text = ""
  do
    local ok, pc = pcall(require, "require/aa/player_condition")
    if ok and pc and pc.get then
      local success, cond = pcall(pc.get)
      if success and cond then
        local map = {
          legit = "Legit",
          fakelag = "Fakelag",
          walk = "Walk",
          move = "Move",
          stand = "Stand",
          ["duck"] = "Duck",
          ["duck+"] = "Duck+",
          jump = "Jump",
          ["jump+"] = "Jump+"
        }
        cond_text = map[cond] or tostring(cond)
        cond_text = to_lower(cond_text)
      end
    end
  end

  dt_text_draw = to_lower(dt_text_draw)
  local w3 = renderer.measure_text("b", cond_text) or 0

  local mr, mg, mb, ma = 200, 200, 255, 255
  do
    local used_custom = false
    if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_indicator_color then
      local ok_get, a, b, c, d = pcall(ui.get, menu_setup.ui.paint_indicator_color)
      if ok_get then
        used_custom = true
        if type(a) == 'number' then
          if color_ok and color_helper and color_helper.clamp then
            mr = color_helper.clamp(a or mr)
            mg = color_helper.clamp(b or mg)
            mb = color_helper.clamp(c or mb)
            ma = color_helper.clamp(d or ma)
          else
            mr = math.floor(a or mr)
            mg = math.floor(b or mg)
            mb = math.floor(c or mb)
            ma = math.floor(d or ma)
          end
        elseif type(a) == 'string' and #a == 12 then
          local ok
          ok, mr = pcall(function() return tonumber(a:sub(1,3)) end)
          ok, mg = pcall(function() return tonumber(a:sub(4,6)) end)
          ok, mb = pcall(function() return tonumber(a:sub(7,9)) end)
          ok, ma = pcall(function() return tonumber(a:sub(10,12)) end)
          if color_ok and color_helper and color_helper.clamp then
            mr = color_helper.clamp(mr or 200)
            mg = color_helper.clamp(mg or 200)
            mb = color_helper.clamp(mb or 255)
            ma = color_helper.clamp(ma or 255)
          else
            mr = mr or 200; mg = mg or 200; mb = mb or 255; ma = ma or 255
          end
        end
      end
    end

    if not used_custom then
      local ok_ref, ref = pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if ok_ref and ref then
        local ok_get, a, b, c, d = pcall(ui.get, ref)
        if ok_get then
          if type(a) == 'number' then
            if color_ok and color_helper and color_helper.clamp then
              mr = color_helper.clamp(a or mr)
              mg = color_helper.clamp(b or mg)
              mb = color_helper.clamp(c or mb)
              ma = color_helper.clamp(d or ma)
            else
              mr = math.floor(a or mr)
              mg = math.floor(b or mg)
              mb = math.floor(c or mb)
              ma = math.floor(d or ma)
            end
          elseif type(a) == 'string' and #a == 12 then
            local ok
            ok, mr = pcall(function() return tonumber(a:sub(1,3)) end)
            ok, mg = pcall(function() return tonumber(a:sub(4,6)) end)
            ok, mb = pcall(function() return tonumber(a:sub(7,9)) end)
            ok, ma = pcall(function() return tonumber(a:sub(10,12)) end)
            if color_ok and color_helper and color_helper.clamp then
              mr = color_helper.clamp(mr or 200)
              mg = color_helper.clamp(mg or 200)
              mb = color_helper.clamp(mb or 255)
              ma = color_helper.clamp(ma or 255)
            else
              mr = mr or 200; mg = mg or 200; mb = mb or 255; ma = ma or 255
            end
          end
        end
      end
    end
  end

  for i = 1, 3 do
    local w = (i == 1) and w1 or ((i == 2) and w2 or w3)
    local margin = indicator_targets[i] or 0
    local target = is_scoped and (margin + (w / 2)) or 0
    local speed = indicator_speeds[i] or 10
    local dt = globals.frametime()
    local t = 1 - math.exp(-speed * dt)
    indicator_offsets[i] = lerp(indicator_offsets[i], target, t)
  end

  local base_x1 = cx - (w1 / 2)
  local draw_x1 = base_x1 + (indicator_offsets[1] or 0)
  renderer.text(draw_x1, y, 255, 255, 255, 255, "b", 0, title_main)
  local space_w = renderer.measure_text("b", " ") or 0
  local suf_x = draw_x1 + (w_main or 0) + space_w
  
  local anim_suf = animated_text(anim_style, 3.5, mr, mg, mb, ma, title_suffix)
  renderer.text(suf_x, y, mr, mg, mb, ma, "b", 0, anim_suf)
  y = y + (line_hs[1] or line_h)

  local base_x2 = cx - (w2 / 2)
  local draw_x2 = base_x2 + (indicator_offsets[2] or 0)
  local dt_r, dt_g, dt_b = 255, 80, 80
  if dt_active then dt_r, dt_g, dt_b = 155, 255, 155 end
  renderer.text(draw_x2, y, dt_r, dt_g, dt_b, 255, "b", 0, dt_text_draw)
  y = y + (line_hs[2] or line_h)

  local base_x3 = cx - (w3 / 2)
  local draw_x3 = base_x3 + (indicator_offsets[3] or 0)
  renderer.text(draw_x3, y, text_r, text_g, text_b, 255, "b", 0, cond_text)
end

if cb_ok and callbacks and callbacks.callback then
  callbacks.callback("paint", paint_handler, { alive_only = true, require_login = true })
end]]
__bundle["require/features/paint/indicators_small"] = [[local indicator_offsets = { 0, 0 }
local indicator_targets = { 4, 0.8 }
local indicator_speeds = { 5, 5 }
local bar_fill_progress = 0
local bar_fill_speed = 8

local function lerp(a, b, t)
  return a + (b - a) * t
end

local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local string_ok, string_helper = pcall(require, "require/help/string")
local callbacks = require('require/abc/callbacks')
local function to_upper(s)
  if s == nil then return "" end
  if string_ok and string_helper and string_helper.upper then
    return string_helper.upper(tostring(s))
  end
  return tostring(s)
end

local color_ok, color_helper = pcall(require, "require/help/color")
local math_ok, math_helper = pcall(require, "require/help/math")
local rgba_hex = color_ok and color_helper.rgba_to_hex or function(r,g,b,a) return string.format("\a%02x%02x%02x%02x", r or 0, g or 0, b or 0, a or 255) end

local function animated_text(style, speed, r,g,b,a, text)
  local t = globals.realtime() or globals.curtime()
  if not text or #text == 0 then return "" end
  local out = {}

  if style == 0 then
    local hex = rgba_hex(r,g,b,a)
    for i=1,#text do out[#out+1] = hex .. text:sub(i,i) end
    return table.concat(out)
  end

  if style == 2 then
    local f = (math.sin(t * speed) + 1) * 0.5
    local la = math.floor(a * (0.45 + 0.55 * f))
    local hex = rgba_hex(r,g,b,la)
    for i=1,#text do out[#out+1] = hex .. text:sub(i,i) end
    return table.concat(out)
  end

  if style == 3 then
    for i=1,#text do
      local phase = math.sin(t * speed - i * 0.6)
      local spike = math.max(0, phase)
      local f = spike * spike
      local la = math.floor(a * (0.35 + 0.65 * f))
      out[#out+1] = rgba_hex(r,g,b,la) .. text:sub(i,i)
    end
    return table.concat(out)
  end

  for i=1,#text do
    local f = (math.sin(t * speed - i * 0.35) + 1) * 0.5
    local la = math.floor(a * (0.4 + 0.6 * f))
    out[#out+1] = rgba_hex(r,g,b,la) .. text:sub(i,i)
  end
  return table.concat(out)
end
local function indicators_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_indicators then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_indicators)
    if ok and val == "small" then return true end
    return false
  end

  return true
end



local function paint_bar_enabled()
  if not (menu_ok and menu_setup and menu_setup.ui) then return true end
  local ref = menu_setup.ui.paint_indicators_bar
  if not ref then return true end
  local ok, val = pcall(ui.get, ref)
  if not ok then return true end
  return not (val == false or val == nil) 
end

callbacks.register("paint", function()
  if not entity.is_alive(entity.get_local_player()) then return end
  if not indicators_enabled() then return end

  local sw, sh = client.screen_size()
  local cx, cy = sw / 2, sh / 2

  local title_r, title_g, title_b = 200, 200, 255
  local text_r, text_g, text_b = 255, 255, 255
  local line_h = 18

  local line_hs = { 12, 13 }

  local y = cy + 18

  
  local local_player = entity.get_local_player()
  local is_scoped = false
  if local_player then
    local scoped_prop = entity.get_prop(local_player, "m_bIsScoped")
    is_scoped = scoped_prop == 1
  end

  local title_main = "sodium"
  local title_suffix = "beta"
  local dt_text_draw = "DT"

  local dt_active = false
  do
    local ok, libs = pcall(require, "require/help/libs")
    if ok and libs and libs.get then
      local aa = libs.get("antiaim_funcs")
      if aa and aa.get_double_tap then
        local success, result = pcall(aa.get_double_tap)
        if success and result then dt_active = true end
      end
    end
  end

  local title_text_up = to_upper(title_main)
  local title_suffix_up = to_upper(title_suffix)
  title_text_up = tostring(title_text_up)
  title_suffix_up = tostring(title_suffix_up)
  local w1 = renderer.measure_text("b", title_text_up) or 0
  local w_suf = renderer.measure_text("b", title_suffix_up) or 0

  dt_text_draw = to_upper(dt_text_draw)
  local w2 = renderer.measure_text("b", dt_text_draw) or 0

  for i = 1, 2 do
    local w = (i == 1) and w1 or w2
    local margin = indicator_targets[i] or 0
    local target = is_scoped and (margin + (w / 2)) or 0
    local speed = indicator_speeds[i] or 10
    local dt = globals.frametime()
    local t = 1 - math.exp(-speed * dt)
    indicator_offsets[i] = lerp(indicator_offsets[i], target, t)
  end

  local spacing = 4.5
  local base_x1 = cx - ((w1 + spacing + (w_suf or 0)) / 2)
  local draw_x1 = base_x1 + (indicator_offsets[1] or 0)
  local desired_gap = 22
  local gap_diff = desired_gap - spacing
  local shift1 = math.floor((gap_diff + 1) / 2)
  local shift2 = gap_diff - shift1
  local main_shift = shift1 
  local suf_shift = -shift2 

  local mr, mg, mb, ma = title_r, title_g, title_b, 255
  do
    local used_custom = false
    
    if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_indicator_color then
      local ok_get, a, b, c, d = pcall(ui.get, menu_setup.ui.paint_indicator_color)
      if ok_get then
        used_custom = true
        if type(a) == 'number' then
          if color_ok and color_helper and color_helper.clamp then
            mr = color_helper.clamp(a or mr)
            mg = color_helper.clamp(b or mg)
            mb = color_helper.clamp(c or mb)
            ma = color_helper.clamp(d or ma)
          else
            mr = math.floor(a or mr)
            mg = math.floor(b or mg)
            mb = math.floor(c or mb)
            ma = math.floor(d or ma)
          end
        elseif type(a) == 'string' and #a == 12 then
          local ok
          ok, mr = pcall(function() return tonumber(a:sub(1,3)) end)
          ok, mg = pcall(function() return tonumber(a:sub(4,6)) end)
          ok, mb = pcall(function() return tonumber(a:sub(7,9)) end)
          ok, ma = pcall(function() return tonumber(a:sub(10,12)) end)
          if color_ok and color_helper and color_helper.clamp then
            mr = color_helper.clamp(mr or title_r)
            mg = color_helper.clamp(mg or title_g)
            mb = color_helper.clamp(mb or title_b)
            ma = color_helper.clamp(ma or 255)
          else
            mr = mr or title_r; mg = mg or title_g; mb = mb or title_b; ma = ma or 255
          end
        end
      end
    end

    
    if not used_custom then
      local ok_ref, ref = pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if ok_ref and ref then
        local ok_get, a, b, c, d = pcall(ui.get, ref)
        if ok_get then
          if type(a) == 'number' then
            if color_ok and color_helper and color_helper.clamp then
              mr = color_helper.clamp(a or mr)
              mg = color_helper.clamp(b or mg)
              mb = color_helper.clamp(c or mb)
              ma = color_helper.clamp(d or ma)
            else
              mr = math.floor(a or mr)
              mg = math.floor(b or mg)
              mb = math.floor(c or mb)
              ma = math.floor(d or ma)
            end
          elseif type(a) == 'string' and #a == 12 then
            local ok
            ok, mr = pcall(function() return tonumber(a:sub(1,3)) end)
            ok, mg = pcall(function() return tonumber(a:sub(4,6)) end)
            ok, mb = pcall(function() return tonumber(a:sub(7,9)) end)
            ok, ma = pcall(function() return tonumber(a:sub(10,12)) end)
            if color_ok and color_helper and color_helper.clamp then
              mr = color_helper.clamp(mr or title_r)
              mg = color_helper.clamp(mg or title_g)
              mb = color_helper.clamp(mb or title_b)
              ma = color_helper.clamp(ma or 255)
            else
              mr = mr or title_r; mg = mg or title_g; mb = mb or title_b; ma = ma or 255
            end
          end
        end
      end
    end
  end

  local anim_style = 1
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_indicators_animation then
    local ok_style, v = pcall(ui.get, menu_setup.ui.paint_indicators_animation)
    if ok_style and type(v) == 'number' then anim_style = v end
  end

  local anim_main = (function()
    local hex = rgba_hex(255,255,255,255)
    local out = {}
    for i=1,#title_text_up do out[#out+1] = hex .. title_text_up:sub(i,i) end
    return table.concat(out)
  end)()

  local anim_suf  = animated_text(anim_style, 3.5, mr, mg, mb, ma, title_suffix_up)
  local draw_main_x = draw_x1 + (main_shift or 0)
  local scoped_extra = is_scoped and 3 or 0
  draw_main_x = draw_main_x + scoped_extra
  renderer.text(draw_main_x, y, 255,255,255,255, "-", 0, anim_main)
  local sx = draw_x1 + (w1 or 0) + spacing
  local draw_suf_x = sx + (suf_shift or 0) + scoped_extra
  renderer.text(draw_suf_x, y, mr, mg, mb, ma, "-", 0, anim_suf)

  local drew_bar = false
  if paint_bar_enabled() then
    drew_bar = true
    do
      local full_w = (w1 or 0) + spacing + (w_suf or 0)
      local reduce_px = 16
      local bar_w = math.max(8, full_w - reduce_px)
      local extra = is_scoped and math.floor((indicator_offsets[1] or 0) * 0.35) or 0
      local bar_x = draw_x1 + math.floor((full_w - bar_w) / 2) - 2 + extra
      local bar_h = 2
      local bar_y = y + math.max(2, (line_hs[1] or line_h) - (bar_h + 4)) + 5
      local out_a = math.floor((ma or 255) * 0.7)
      renderer.rectangle(bar_x - 1, bar_y - 1, bar_w + 2, bar_h + 2, mr, mg, mb, out_a)
      renderer.rectangle(bar_x, bar_y, bar_w, bar_h, 0, 0, 0, 255)
      local bar_target = dt_active and bar_w or 0
      local dtf = globals.frametime()
      local tt = 1 - math.exp(-bar_fill_speed * dtf)
      bar_fill_progress = lerp(bar_fill_progress, bar_target, tt)
      local fill_w = math.floor(math.max(0, math.min(bar_fill_progress, bar_w)))
      if fill_w > 0 then
        renderer.rectangle(bar_x, bar_y, fill_w, bar_h, mr, mg, mb, ma)
      end
    end
  end

  
  local base_line_h = (line_hs[1] or line_h)
  local y_add = base_line_h
  if not drew_bar then
    
    y_add = math.max(0, base_line_h - 7)
  end
  y = y + y_add

  local base_x2 = cx - (w2 / 2)
  local draw_x2 = base_x2 + (indicator_offsets[2] or 0)
  local dt_r, dt_g, dt_b = 255, 80, 80
  if dt_active then dt_r, dt_g, dt_b = 155, 255, 155 end
  renderer.text(draw_x2, y + 2, dt_r, dt_g, dt_b, 255, "-", 0, dt_text_draw)
  y = y + (line_hs[2] or line_h)

end, { alive_only = true, require_login = true })]]
__bundle["require/features/paint/insults"] = [[local client = client
local entity = entity
local ui = ui

local menu_setup = require("require/abc/menu_setup")
local string_ok, string_helper = pcall(require, "require/help/string")
local math_ok, math_helper = pcall(require, "require/help/math")
local time_ok, time_helper = pcall(require, "require/help/time")

local kill_insults = {
    "buy sodium",
    "sodium is the bestest lua",
    "SODIUMMMM >__<",
    "you just got sodiumed",
    "sodium beta > all other lues",
    "₴ØĐłɄ₥ ₮₳₴₮ɆĐ Vł₵₮ØⱤɎ, ł₮ ₩₳₴ ₴ØɄⱤ",
    "₴ØĐłɄ₥ ₳ⱤⱤ₳₦₲ɆĐ ₮ⱧɆ ₴₮₳Ɽ₴ ₣ØⱤ ₮Ⱨ₳₮ ⱧɆ₳Đ₴ⱧØ₮",
    "₴ØĐłɄ₥ ₴Ⱡł₱₱ɆĐ ł₦ ₳ ฿₳₦₳₦₳ ₱ɆɆⱠ Ø₣ ₣₳₮Ɇ",
    "₴ØĐłɄ₥ ₩Ⱨł₴₱ɆⱤɆĐ ₴Ɇ₵ⱤɆ₮₴ ł₦₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ₥₳₭Ɇ₴ ₣ⱤłɆ₦Đ₴ ₩ł₮Ⱨ Ⱡ₳₲, ₮ⱧɆ₦ ฿Ɇ₮Ɽ₳Ɏ₴ ł₮",
    "₴ØĐłɄ₥ ₣ØⱠĐɆĐ ɎØɄⱤ ₵ØɄⱤ₳₲Ɇ ł₦₮Ø ₳ ₱₳₱ɆⱤ ₱Ⱡ₳₦Ɇ",
    "₴ØĐłɄ₥ ₱₳ł₦₮₴ ł₦ ⱤɆĐ ₩ⱧɆ₦ ł₮ ł₴ ⱧɄ₦₲ⱤɎ",
    "₴ØĐłɄ₥ ł₴ ₴₵ⱧłⱫØ₱ⱧⱤɆ₦ł₵ ฿Ʉ₮ ₵Ⱨ₳Ɽ₥ł₦₲",
    "₴ØĐłɄ₥ ₳₮Ɇ ₥Ɏ ₴₳₦Đ₩ł₵Ⱨ ฿Ʉ₮ ⱠɆ₣₮ ₳ ₮ⱤØ₱ⱧɎ",
    "₴ØĐłɄ₥ ⱧɄ₥₴ ⱠɄⱠⱠ₳฿łɆ₴ ₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ĐØɆ₴ ₮ⱧɆ ₵Ⱨ₳-₵Ⱨ₳ ₩ł₮Ⱨ ɎØɄⱤ ₳ł₥",
    "₴ØĐłɄ₥ ₣ØⱤ₲Ø₮ ₮Ø ฿Ɇ ₱ØⱠł₮Ɇ, ₴ØⱤⱤɎ ₦Ø₮ ₴ØⱤⱤɎ",
    "₴ØĐłɄ₥ ₳₦Đ ł ₴Ⱨ₳ⱤɆ ₮ØØ₮Ⱨ฿ⱤɄ₴ⱧɆ₴ (₥Ɇ₮₳₱ⱧØⱤ)",
    "₴ØĐłɄ₥ ₮Ɏ₱ɆĐ 'ɎØɄ' ł₦ ⱠØ₩ɆⱤ₵₳₴Ɇ ₳₦Đ ₥Ɇ₳₦₮ ł₮",
    "₴ØĐłɄ₥ ₵ØⱠⱠɆ₵₮₴ ₴₥₳ⱠⱠ ₮ⱤØ₱ⱧłɆ₴ (ɎØɄ ł₦₵ⱠɄĐɆĐ)",
    "₴ØĐłɄ₥ ₭ɆɆ₱₴ ⱤɆ₵Ɇł₱₮₴ ₣ØⱤ ɎØɄⱤ ₥ł₴₮₳₭Ɇ₴",
    "₴ØĐłɄ₥ ł₴ ₳ ₲ØØĐ ⱠɄ₳ ₳₦Đ ₳Ⱡ₴Ø ₳ Ⱡł₮₮ⱠɆ ₥₳Đ",
    "₴ØĐłɄ₥, ₮Ⱨ₳₦₭ ₣ØⱤ ₳ⱠⱠ₳Ⱨ ₲ØĐ, Đ₳Đ :)",
    "₴ØĐłɄ₥ ₴Ɇ₦ĐɆⱤ ₲ⱤɆɆ₮ł₦₲ ₣ⱤØ₥ ₭Ʉ฿₳₦",
    "₥łⱠⱠłØ₦₳łⱤɆ ฿ɄɎ₴ ₲ⱧØ₴₮ ツ Ⱨ₳₳₳Ⱨ₳Ⱨ₳",
    "₴ Ø Đ ł Ʉ ₥ ⱠɄ₳ Ⱨ₳₴ ₮ⱧɆ ฿Ɇ₴₮ ⱧɆ₳Đ₴ⱧØ₮₮₮",
    "₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ <3",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ",
    "ł₣ ₣ⱠɎł₦₲ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐØ₦₮ ₭₦Ø₩ł₦₲ ӾĐĐ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₥Ɏ ₳ł₥ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ɆⱤVɆⱤ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ, ฿Ɇ₲ ₮Ø ₱ⱤØ₵Ⱡ₳ł₥",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄ ₵₳₦ ₥₳₮₵Ⱨ Ⱡ₥Ⱨ ł ⱤɆ₵ØĐɆĐ",
    "ł ₱Ⱡ₳₵Ɇ ɎØɄ Ø₦ ₦Ɇ₩ ⱠɆ₣Ɇ₦Đ ⱠɆ₵₮ɆĐ ₥₳₱ ₩ł₮Ⱨ ØĐł₣ł₵ ⱤɆ₵ØĐɆ",
    "♡ ₴ØĐłɄ₥ ł₴ ₥Ɏ ₵Ø₵₭ Ø₣ ⱠɄ₳ ♡",
    "ł ⱤØ₳₴₮ɆĐ ɎØɄ ₴Ø ₣Ʉ₵₭ł₦₲ Ⱨ₳ⱤĐ ɆVɆⱤ ₴ɆⱤɆĐ",
    "ɎØɄ ₮ⱤłɆĐ ₮Ø ₱ⱤɆ₮Ɇ₦Đ, ฿Ʉ₮ ₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ₭łⱠⱠɆĐ ₮Ⱨ₳₮",
    "ɎØɄ ⱠØ₴Ɇ ₮Ø ₥Ɇ ₣ØⱤ ₦ł₵Ɇ ₣ØⱠ₭",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱ØɆ₥",
    "ł ₣Ⱡł₲Ⱨ₮ ɎØɄ Ø₣₣ ₮ⱧɆ ₥₳₱ ₩ł₮Ⱨ ₥Ɏ ₴ɆⱤVɆⱤ ₩ł₣Ɇ",
    "₴ɆⱤł₳Ⱡ ฿ɄⱠⱠɎ Ø₣ ⱠɄ₳ ₳ⱠⱠ Đ₳Ɏ",
    "₥Ɏ ₴ØĐłɄ₥ ฿ⱤɆ₳₭₴ ₥ØⱤɆ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ₴ØĐłɄ₥ ❤",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ, ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₣ⱠɎ ₳ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ, ₮ⱧɆ₦ ₴₮łⱠⱠ ฿Ɇ₳₮ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐłĐ₦’₮ ₭₦Ø₩ł₦₲ ӾĐĐĐ, ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳ ₣₮₩",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ₴Ɇ₦Đ ₲ⱤɆɆ₮ł₦₲₴ ₱₳Ɽ₳ ₳ ₵Ø₦₳ Đ₳ ₮Ʉ₳ ₥₳₮Ɇ",
    "₳ĐĐɆĐ ₮Ⱨł₴ ₮Ø ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₳₦Đ ł₮ ₥₳ĐɆ ł₮ ₴Ø ₥Ʉ₵Ⱨ ฿Ɇ₮₮ɆⱤ",
    "ł ₴₥Ø₭ɆĐ ɎØɄ ɎɆ₴₮ɆⱤĐ₳Ɏ ₩ł₮Ⱨ ₴ØĐłɄ₥, ₮ØĐ₳Ɏ ł ₣ⱠɆӾ ₳₲₳ł₦",
    "₴ØĐłɄ₥ ⱠɄ₳ JɄ₴₮ Ø₩₦ɆĐ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄⱤ ₴₵Ɽł₱₮ ₵₳₦ ₥₳₮₵Ⱨ ₴ØĐłɄ₥? ⱠØⱠ ₦Ø₱Ɇ",
    "ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ ₥ØĐɆ ₳₵₮łV₳₮ɆĐ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ = 100% ₩ł₦ ₲Ʉ₳Ɽ₳₦₮ɆɆĐ",
    "ł ฿ⱤɆ₳₭ ɎØɄⱤ ⱠɄ₳, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₥ł₦Đ, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₴ɆⱤVɆⱤ — ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "(‿ˠ‿)",
    "₣ØⱤ ₲₳₦₲₴₮ɆⱤ ₩Ɇ Ⱨ₳VɆ ₩Ø₦, ₮Ⱨł₴ ₥₳₮₵Ⱨ",
    "https://discord.gg/8nMMVgqdHk",
    "BUY SODIUM NOW!!! ₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ BUY SODIUM NOW!!! AT DISCORD ;;;",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥ ⱠɄ₳ ",
}


local death_insults = {
    ""
}

pcall(function()
    local seed = nil
    if time_ok and time_helper and time_helper.unix_time then
        seed = math.floor((time_helper.unix_time() or 0) % (2^31))
    else
        local ts = nil
        pcall(function() ts = client.timestamp() end)
        if not ts or ts == 0 then
            ts = globals.tickcount() or 0
        end
        seed = math.floor((ts or 0) % (2^31))
    end
    math.randomseed(seed)
end)
local say_delay = 1
local say_queue = {}
local say_processing = false

local function send_now(cmd)
    if client and client.exec then
        pcall(client.exec, cmd)
    end
end

local function process_queue()
    if #say_queue == 0 then
        say_processing = false
        return
    end

    local msg = table.remove(say_queue, 1)
    if not msg or msg == "" then
        if #say_queue > 0 then
            if client and client.delay_call then
                pcall(function() client.delay_call(say_delay, process_queue) end)
            else
                process_queue()
            end
        else
            say_processing = false
        end
        return
    end

    local cmd = string.format('say "%s"', msg)
    if client and client.delay_call then
        pcall(function()
            client.delay_call(0, function()
                send_now(cmd)
            end)
        end)
    else
        send_now(cmd)
    end

    if #say_queue > 0 then
        if client and client.delay_call then
            pcall(function() client.delay_call(say_delay, process_queue) end)
        else
            process_queue()
        end
    else
        say_processing = false
    end
end

local function say_text(text)
    if not text or text == "" then return end
    local raw = tostring(text)
    local clean
    if string_ok and string_helper and string_helper.replace then
        clean = string_helper.replace(raw, '"', '')
        if string_helper.trim then clean = string_helper.trim(clean) end
    else
        clean = raw:gsub('"','')
    end

    table.insert(say_queue, clean)
    if not say_processing then
        say_processing = true
        if client and client.delay_call then
            pcall(function() client.delay_call(say_delay, process_queue) end)
        else
            process_queue()
        end
    end
end

local function on_player_death(e)
	if not menu_setup or not menu_setup.ui or not menu_setup.ui.paint_insults then
		return
	end
	local ok, enabled = pcall(ui.get, menu_setup.ui.paint_insults)
	if not ok or not enabled then return end

	if not e then return end
	local victim_userid = e.userid
	local attacker_userid = e.attacker
	if not victim_userid or not attacker_userid then return end

	local local_ent = entity.get_local_player and entity.get_local_player()
	if not local_ent or local_ent == 0 then return end

	local victim_ent = client.userid_to_entindex and client.userid_to_entindex(victim_userid) or nil
	local attacker_ent = client.userid_to_entindex and client.userid_to_entindex(attacker_userid) or nil
	if attacker_userid == victim_userid then return end
	if attacker_ent == local_ent and victim_ent ~= local_ent then
        if #kill_insults > 0 then
            local idx = 1
            if math_ok and math_helper and math_helper.random_int then
                idx = math_helper.random_int(1, #kill_insults)
            else
                idx = math.random(1, #kill_insults)
            end
            local msg = kill_insults[idx]
            say_text(msg)
        end
		return
	end
	if victim_ent == local_ent and attacker_ent ~= local_ent then
        if #death_insults > 0 then
            local idx = 1
            if math_ok and math_helper and math_helper.random_int then
                idx = math_helper.random_int(1, #death_insults)
            else
                idx = math.random(1, #death_insults)
            end
            local msg = death_insults[idx]
            say_text(msg)
        end
		return
	end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('player_death', on_player_death, { alive_only = true, require_login = true })
end]]
__bundle["require/features/paint/lagcomp_box"] = [[


local g_net_data = {}
local g_sim_ticks = {}
local g_esp_data = {}


local menu_setup = require('require/abc/menu_setup')
local DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A = 47, 117, 221, 255


local floor = math.floor

local function length_sqr(x, y, z)
    return (x or 0) * (x or 0) + (y or 0) * (y or 0) + (z or 0) * (z or 0)
end

local function time_to_ticks(seconds)
    local ti = globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return floor((seconds or 0) / ti + 0.5)
end

local function extrapolate(ent, ticks)
    local ti = globals.tickinterval()
    if not ti then return nil end

    local g = (cvar.sv_gravity and cvar.sv_gravity:get_float() or 800) * ti
    local jump = (cvar.sv_jump_impulse and cvar.sv_jump_impulse:get_float() or 301) * ti

    local ox, oy, oz = entity.get_origin(ent)
    if not ox then return nil end

    local vx, vy, vz = entity.get_prop(ent, "m_vecVelocity")
    vx, vy, vz = vx or 0, vy or 0, vz or 0

    local gravity = (vz > 0) and -g or jump

    for i = 1, (ticks or 0) do
        local px, py, pz = ox, oy, oz

        ox = ox + (vx * ti)
        oy = oy + (vy * ti)
        oz = oz + (vz + gravity) * ti

        local frac = select(1, client.trace_line(ent or 0, px, py, pz, ox, oy, oz))
        if frac and frac <= 0.99 then
            return px, py, pz
        end
    end

    return ox, oy, oz
end


local edges = {
    {0, 1}, {1, 2}, {2, 3}, {3, 0}, {5, 6}, {6, 7}, {1, 4}, {4, 8},
    {0, 4}, {1, 5}, {2, 6}, {3, 7}, {5, 8}, {7, 8}, {3, 4}
}


local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
    local me = entity.get_local_player()
    if not me or not entity.is_alive(me) then return end

    
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box then
        local ok, enabled = pcall(ui.get, menu_setup.ui.paint_lagcomp_box)
        if ok and enabled == false then
            return
        end
    end

    
    local players = entity.get_players(true)
    for i = 1, #players do
        local ent = players[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local prev = g_sim_ticks[ent]
            local sim_time = entity.get_prop(ent, 'm_flSimulationTime')
            local ox, oy, oz = entity.get_origin(ent)

            if sim_time and ox then
                local sim_ticks = time_to_ticks(sim_time)

                if prev ~= nil then
                    local delta = sim_ticks - prev.tick
                    if delta < 0 or (delta > 0 and delta <= 64) then
                        local dx, dy, dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
                        local teleport_distance = length_sqr(dx, dy, dz)

                        local ex_ticks = math.max(delta - 1, 0)
                        local ex_x, ex_y, ex_z = extrapolate(ent, ex_ticks)
                        if delta < 0 then
                            g_esp_data[ent] = 1
                        end

                        g_net_data[ent] = {
                            tick = ex_ticks,
                            player = ent,
                            delta = delta,
                            origin = { x = ox, y = oy, z = oz },
                            extrapolated = (ex_x and { x = ex_x, y = ex_y, z = ex_z } or { x = ox, y = oy, z = oz }),
                            lagcomp = teleport_distance > 4096,
                            tickbase = delta < 3
                        }
                    end
                end

                if g_esp_data[ent] == nil then g_esp_data[ent] = 0 end
                g_sim_ticks[ent] = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
            else
                g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
            end
        else
            g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
        end
    end

    
    local r, g, b, a = DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box_color then
        local ok, rr, gg, bb, aa = pcall(ui.get, menu_setup.ui.paint_lagcomp_box_color)
        if ok and rr then
            r, g, b, a = rr, gg, bb, aa
        end
    end
    for ent, data in pairs(g_net_data) do
        if data and data.player and entity.is_alive(data.player) and not entity.is_dormant(data.player) and data.lagcomp then
            local minsx, minsy, minsz = entity.get_prop(data.player, 'm_vecMins')
            local maxsx, maxsy, maxsz = entity.get_prop(data.player, 'm_vecMaxs')
            if not minsx or not maxsx then goto continue_box end

            local ex = data.extrapolated.x
            local ey = data.extrapolated.y
            local ez = data.extrapolated.z

            local min = { x = (minsx or 0) + ex, y = (minsy or 0) + ey, z = (minsz or 0) + ez }
            local max = { x = (maxsx or 0) + ex, y = (maxsy or 0) + ey, z = (maxsz or 0) + ez }

            local points = {
                min,
                { x = min.x, y = max.y, z = min.z },
                { x = max.x, y = max.y, z = min.z },
                { x = max.x, y = min.y, z = min.z },
                { x = min.x, y = min.y, z = max.z },
                { x = min.x, y = max.y, z = max.z },
                max,
                { x = max.x, y = min.y, z = max.z }
            }

            for k, v in pairs(edges) do
                
                if k == 1 then
                    local ox, oy = renderer.world_to_screen(data.origin.x, data.origin.y, data.origin.z)
                    local mx, my = renderer.world_to_screen(min.x, min.y, min.z)
                    if ox and mx then
                        renderer.line(ox, oy, mx, my, r, g, b, 255)
                    end
                end
                local p1 = points[v[1] ]
                local p2 = points[v[2] ]
                if p1 and p2 then
                    local x1, y1 = renderer.world_to_screen(p1.x, p1.y, p1.z)
                    local x2, y2 = renderer.world_to_screen(p2.x, p2.y, p2.z)
                    if x1 and x2 then
                        renderer.line(x1, y1, x2, y2, r, g, b, 255)
                    end
                end
            end
            ::continue_box::
        end
    end

    
    for i = 1, #players do
        local ent = players[i]
        if not entity.is_alive(ent) or entity.is_dormant(ent) then goto continue_label end

        local x1, y1, x2, y2, alpha = entity.get_bounding_box(ent)
        if alpha == 0 then goto continue_label end

        local palpha = 0
        if g_esp_data[ent] ~= nil and g_esp_data[ent] > 0 then
            g_esp_data[ent] = g_esp_data[ent] - globals.frametime() * 2
            if g_esp_data[ent] < 0 then g_esp_data[ent] = 0 end
            palpha = g_esp_data[ent]
        end

        local tag = ''
        local data = g_net_data[ent]
        if data then
            local tb = data.tickbase
            local lc = data.lagcomp
            if (not tb) or lc then
                palpha = alpha
            end
            tag = tb and 'SHIFTING TICKBASE' or (lc and 'LAG COMP BREAKER' or '')
        end

        
            local name = entity.get_player_name(ent)
            local y_add = (name == '  ' or name == ' ' or name == '' or name == '   ') and 8 or 0
            local mid_x = x1 + (x2 - x1) / 2
            renderer.text(mid_x, y1 - 18 + y_add, 255, 45, 45, floor((palpha or 0) * 255), 'cb', 0, tag)
        

        ::continue_label::
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end

local function round_start_handler(ev)
    g_net_data = {}
    g_sim_ticks = {}
    g_esp_data = {}
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('round_start', round_start_handler, { alive_only = true, require_login = true })
end]]
__bundle["require/features/paint/minimum_damage"] = [[local menu_setup = require("require/abc/menu_setup")
local drag = require("require/help/drag")

local references = {
    minimum_damage = ui.reference("RAGE", "Aimbot", "Minimum damage"),
    minimum_damage_override = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}

local screen_size = { client.screen_size() }

local min_damage_drag = nil
do
    local sw, sh = client.screen_size()
    local default_x = math.floor((screen_size[1] or sw or 0) / 2 + 2)
    local default_y = math.floor((screen_size[2] or sh or 0) / 2 - 14)
    local box_radius = 30
    local handle_w, handle_h = 10, 18
    min_damage_drag = drag.new("minimum_damage_indicator", {
        x = default_x - math.floor(handle_w / 2),
        y = default_y - math.floor(handle_h / 2),
        w = handle_w,
        h = handle_h,
        snap = true,
        snap_threshold = 24,
        require_menu_open = true,
        constraint_center = { cx = default_x, cy = default_y, radius = box_radius },
        default_center = { x = default_x, y = default_y },
    })
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)

    if not ui.get(menu_setup.ui.paint_minimum_damage) then return end
    
    local localplayer = entity.get_local_player()
    if localplayer == nil or not entity.is_alive(localplayer) then return end
    if min_damage_drag then
        pcall(function()
            min_damage_drag:handle()
            min_damage_drag:draw()
        end)
    end

    

    if ui.get(references.minimum_damage_override[2]) then
        local tx, ty = screen_size[1] / 2 + 2, screen_size[2] / 2 - 14
        if min_damage_drag then
            pcall(function()
                tx = min_damage_drag.x + math.floor(min_damage_drag.w / 2)
                ty = min_damage_drag.y + math.floor(min_damage_drag.h / 2)
            end)
        end
        renderer.text(tx, ty, 255, 255, 255, 225, "d", 0, ui.get(references.minimum_damage_override[3]) .. "")
    end

end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end]]
__bundle["require/features/paint/molotov_particles"] = [[local ui = ui
local client = client
local entity = entity
local renderer = renderer
local globals = globals
local menu_setup = require("require/abc/menu_setup")
local vector = require('require/brain/api/vector/vector')
local callbacks = require('require/abc/callbacks')


local positions_cache = {}


local _molotov_cam_vec = vector.make(0, 0, 0)
local _molotov_tmp_vec = vector.make(0, 0, 0)

local s_count = 128
local s_radius = 158
local s_size = 48


local function find_infernos()
    local out = {}
    local a = entity.get_all('inferno') or {}
    for _, v in ipairs(a) do table.insert(out, v) end
    local b = entity.get_all('CInferno') or {}
    for _, v in ipairs(b) do table.insert(out, v) end
    return out
end


local function stable_offsets(ent, count, radius)
    offsets_templates = offsets_templates or {}
    local key = tostring(count) .. ':' .. tostring(radius)
    if offsets_templates[key] then return offsets_templates[key] end

    local pts = {}
    local golden_angle = math.pi * (3 - math.sqrt(5))
    for i = 1, count do
        local r = radius * math.sqrt(i / count)
        local theta = i * golden_angle
        local rx = math.cos(theta) * r
        local ry = math.sin(theta) * r
        local rz = ((i % 24) - 12) 
        pts[i] = {rx, ry, rz}
    end
    offsets_templates[key] = pts
    return pts
end

callbacks.register('paint', function()

    local me = entity.get_local_player()
    if not me then return end
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_molotov then
        local ok, val = pcall(ui.get, menu_setup.ui.paint_molotov)
        if ok and not val then return end
    end

    local count = math.max(1, math.floor(s_count or 24))
    local radius = math.max(1, math.floor(s_radius or 100))
    local size_cfg = math.max(1, math.floor(s_size or 6))

    
    local camx, camy, camz = client.camera_position()
    _molotov_cam_vec.x = camx or 0
    _molotov_cam_vec.y = camy or 0
    _molotov_cam_vec.z = camz or 0

    local infernos = find_infernos()
    if #infernos == 0 then return end

    for _, ent in ipairs(infernos) do
        local ox, oy, oz = entity.get_origin(ent)
        if ox then
            local key = tostring(ent) .. ":" .. tostring(count) .. ":" .. tostring(radius)
            local cached = positions_cache[key]

            
            if not cached or not cached.origin or
               math.abs(cached.origin[1] - ox) > 0.01 or
               math.abs(cached.origin[2] - oy) > 0.01 or
               math.abs(cached.origin[3] - oz) > 0.01 then
                local pts = stable_offsets(ent, count, radius)
                local world_pts = {}
                for _, off in ipairs(pts) do
                    local px = ox + (off[1] or 0)
                    local py = oy + (off[2] or 0)
                    local pz = oz + (off[3] or 0)
                    table.insert(world_pts, {px, py, pz})
                end
                cached = { origin = {ox, oy, oz}, pts = world_pts }
                positions_cache[key] = cached
            end

            for _, p in ipairs(cached.pts) do
                local px, py, pz = p[1], p[2], p[3]
                local sx, sy = renderer.world_to_screen(px, py, pz)
                if sx and sy then
                    
                    _molotov_tmp_vec.x = px - _molotov_cam_vec.x
                    _molotov_tmp_vec.y = py - _molotov_cam_vec.y
                    _molotov_tmp_vec.z = pz - _molotov_cam_vec.z

                    local dx = _molotov_tmp_vec.x
                    local dy = _molotov_tmp_vec.y
                    local dz = _molotov_tmp_vec.z
                    local dist = math.sqrt(dx*dx + dy*dy + dz*dz)

                    local scale = math.max(1, math.floor((200 / (dist + 1)) * (size_cfg / 6)))
                    local half = math.max(1, math.floor(scale / 2))
                    renderer.rectangle(sx - half, sy - half, scale, scale, 255, 24, 24, 255)
                end
            end
        end
    end
end, { alive_only = true, require_login = true })]]
__bundle["require/features/paint/onshot_skeleton"] = [[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")


local function find(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x, y, z = entity.hitbox_position(ent, def.names[i])
        if x then return x, y, z end
    end
    for i = 1, #(def.idx or {}) do
        local x, y, z = entity.hitbox_position(ent, def.idx[i])
        if x then return x, y, z end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local sk = {list = {}}

local function is_skeleton_enabled()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_hitmarker then
        local ok, sel = pcall(ui.get, menu_setup.ui.paint_hitmarker)
        if not ok then return false end
        if type(sel) == "table" then
            for _, v in ipairs(sel) do
                if v == "skeleton" then return true end
            end
        end
        return false
    end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function aim_fire_handler(ev)
    if not is_skeleton_enabled() then sk.list = {} return end
    if not is_skeleton_enabled() then return end
    local target = ev and (ev.target or ev.target_index)
    if type(target) ~= 'number' or target == 0 then return end
    local pts = snap(target)
    if not pts then return end
    local now = globals.realtime and globals.realtime() or 0
    sk.list[#sk.list + 1] = {pts = pts, t = now}
    if #sk.list > 5 then table.remove(sk.list, 1) end
end

local function paint_handler(ev)
    if is_skeleton_enabled() then
        local now = globals.realtime and globals.realtime() or 0
        local hold = 2.2 * 0.8 * 3
        local fade = 2.2 * 0.8
        local total = hold + fade
        local i = 1
        while i <= #sk.list do
            if now - (sk.list[i].t or 0) > total then
                table.remove(sk.list, i)
            else
                i = i + 1
            end
        end
        table.sort(sk.list, function(a, b) return (a.t or 0) < (b.t or 0) end)
        local start = math.max(1, #sk.list - 2)
        for j = start, #sk.list do
            local it = sk.list[j]
            local age = now - (it.t or 0)
            local alpha = age <= hold and 220 or math.floor(math.max(0, (1 - math.max(0, age - hold) / fade) * 220))
            if alpha > 0 then
                local pts = it.pts or {}
                for c = 1, #chains do
                    local chain = chains[c]
                    local from, to = pts[chain[1] ], pts[chain[2] ]
                    if from and to then
                        local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                        local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                        if fx and tx then renderer.line(fx, fy, tx, ty, 255, 255, 255, alpha) end
                    end
                end
            end
        end
    else
        sk.list = {}
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('aim_fire', aim_fire_handler, { alive_only = true, require_login = true })
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
else
    client.set_event_callback('aim_fire', aim_fire_handler)
    client.set_event_callback('paint', paint_handler)
end]]
__bundle["require/features/paint/performance_mode"] = [[



local ok, menu_setup = pcall(require, "require/abc/menu_setup")


local cb = nil
pcall(function() cb = require('require/abc/callbacks') end)
if not cb then error("callbacks manager required: require/abc/callbacks") end


local orig = {
    captured = false
}

local last_state = {
    blood = nil,
    ragdolls = nil,
    particles = nil,
    lensflare = nil,
    animations = nil,
    features = nil,
}

local function capture_original_cvars()
    if orig.captured then return end
    local function safe_get(name, fallback)
        local ok, v = pcall(client.get_cvar, name)
        if ok and v then return v end
        return fallback
    end

    orig.violence_hblood = safe_get('violence_hblood', '1')
    orig.cl_ragdoll_physics_enable = safe_get('cl_ragdoll_physics_enable', '1')
    orig.r_drawparticles = safe_get('r_drawparticles', '1')
    orig.mat_disable_bloom = safe_get('mat_disable_bloom', '0')
    orig.captured = true
end

local function set_cvar_cmd(name, value)
    
    pcall(client.exec, string.format('%s %s', name, tostring(value)))
end

local function apply_perf_setting(key, enabled)
    if key == 'blood' then
        if enabled then set_cvar_cmd('violence_hblood', 0) else set_cvar_cmd('violence_hblood', orig.violence_hblood or 1) end
    elseif key == 'ragdolls' then
        if enabled then set_cvar_cmd('cl_ragdoll_physics_enable', 0) else set_cvar_cmd('cl_ragdoll_physics_enable', orig.cl_ragdoll_physics_enable or 1) end
    elseif key == 'particles' then
        if enabled then set_cvar_cmd('r_drawparticles', 0) else set_cvar_cmd('r_drawparticles', orig.r_drawparticles or 1) end
    elseif key == 'lensflare' then
        if enabled then set_cvar_cmd('mat_disable_bloom', 1) else set_cvar_cmd('mat_disable_bloom', orig.mat_disable_bloom or 0) end
    end
end

local function update_globals_for_flags(has)
    
    
    if has['animations'] then
        _G.PERFORMANCE_ANIMATIONS = false
    else
        
        _G.PERFORMANCE_ANIMATIONS = true
    end

    if has['feature updates'] then
        _G.PERFORMANCE_FEATURE_UPDATES = false
    else
        _G.PERFORMANCE_FEATURE_UPDATES = true
    end
end

local function table_to_lookup(t)
    local out = {}
    if type(t) == 'table' then
        for _, v in ipairs(t) do out[v] = true end
    end
    return out
end


cb.register('paint', function()
    if not ok or not menu_setup or not menu_setup.ui or not menu_setup.ui.paint_performance_mode then return end
    capture_original_cvars()

    local sel = ui.get(menu_setup.ui.paint_performance_mode)
    local has = table_to_lookup(sel)

    
    local want = has['blood'] or false
    if want ~= last_state.blood then
        apply_perf_setting('blood', want)
        last_state.blood = want
    end

    
    want = has['ragdolls'] or false
    if want ~= last_state.ragdolls then
        apply_perf_setting('ragdolls', want)
        last_state.ragdolls = want
    end

    
    want = has['particles'] or false
    if want ~= last_state.particles then
        apply_perf_setting('particles', want)
        last_state.particles = want
    end

    
    want = has['lens flare'] or false
    if want ~= last_state.lensflare then
        apply_perf_setting('lensflare', want)
        last_state.lensflare = want
    end

    
    want = has['animations'] or false
    if want ~= last_state.animations then
        
        update_globals_for_flags(has)
        last_state.animations = want
        last_state.features = has['feature updates'] or false
    end

    
    local want_features = has['feature updates'] or false
    if want_features ~= last_state.features then
        update_globals_for_flags(has)
        last_state.features = want_features
    end
end, { require_login = true, alive_only = true })


cb.register('shutdown', function()
    if orig.captured then
        pcall(set_cvar_cmd, 'violence_hblood', orig.violence_hblood)
        pcall(set_cvar_cmd, 'cl_ragdoll_physics_enable', orig.cl_ragdoll_physics_enable)
        pcall(set_cvar_cmd, 'r_drawparticles', orig.r_drawparticles)
        pcall(set_cvar_cmd, 'mat_disable_bloom', orig.mat_disable_bloom)
    end
    
    _G.PERFORMANCE_ANIMATIONS = true
    _G.PERFORMANCE_FEATURE_UPDATES = true
end, { require_login = true, alive_only = true })


if _G.PERFORMANCE_ANIMATIONS == nil then _G.PERFORMANCE_ANIMATIONS = true end
if _G.PERFORMANCE_FEATURE_UPDATES == nil then _G.PERFORMANCE_FEATURE_UPDATES = true end

return {
    _internal = {
        orig = orig,
        last_state = last_state,
    }
}
]]
__bundle["require/features/paint/presmoke_warning"] = [[local round_info = { start = nil, limit = nil }

client.set_event_callback("round_start", function(e)
	round_info.start = globals.curtime()
	round_info.limit = tonumber(e.timelimit) or tonumber(e.round_time) or 115
end)

local function read_round_left_from_game_rules()
	local gr = entity.get_game_rules()
	if not gr then return nil end
	local candidates = {
		"m_flGameTimeRemaining",
		"m_flRoundTimeRemaining",
		"m_fRoundStartTime",
		"m_flRoundStartTime",
		"m_iRoundTime",
		"m_iRoundTimeLimit",
	}
	for _, name in ipairs(candidates) do
		local ok, val = pcall(entity.get_prop, gr, name)
		if ok and val and type(val) == "number" then
			if name:lower():find("remain") then
				return math.max(0, val)
			end
		end
	end
	local start = nil
	for _, name in ipairs({"m_fRoundStartTime", "m_flRoundStartTime"}) do
		local ok, val = pcall(entity.get_prop, gr, name)
		if ok and val and type(val) == "number" then
			start = val
			break
		end
	end
	if start then
		local limit = nil
		local ok, v = pcall(entity.get_prop, gr, "m_iRoundTime")
		if ok and v and type(v) == "number" then limit = v end
		if not limit then
			limit = tonumber(client.get_cvar("mp_roundtime")) or tonumber(client.get_cvar("mp_roundtime_defuse"))
		end
		if limit and type(limit) == "number" then
			local left = limit - (globals.curtime() - start)
			return math.max(0, left)
		end
	end
	return nil
end

local function get_round_time_left()
	if round_info.start and round_info.limit then
		local elapsed = globals.curtime() - round_info.start
		local left = round_info.limit - elapsed
		if left < 0 then left = 0 end
		return left
	end
	return read_round_left_from_game_rules()
end

client.set_event_callback("paint", function()
	local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
	if not menu_ok or not menu_setup or not menu_setup.ui then return end
	local ok_get, paint_presmoke = pcall(ui.get, menu_setup.ui.paint_presmoke)
	if not ok_get or not paint_presmoke then return end

	local left = get_round_time_left()
	if not left then return end
	if left <= 18 then
		local w, h = client.screen_size()
		local center_x = w * 0.5
		local y = math.floor(h * 0.3)
		local secs = string.format("%.2f", left)
		local text = string.format("PRESMOKE NOW PRESMOKE NOW %s", secs)
		renderer.text(center_x, y, 255, 30, 30, 255, "cb+", 0, text)
	end
end)

client.set_event_callback("round_end", function()
	round_info.start = nil
	round_info.limit = nil
end)

client.set_event_callback("cs_game_disconnected", function()
	round_info.start = nil
	round_info.limit = nil
end)

]]
__bundle["require/features/paint/self_boxes"] = [[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end


local ui_extrap_check, ui_extrap_ticks, ui_extrap_color
local ui_pred3d_check
local ui_pred3d_scale
if not (menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation) then
  
  ui_extrap_check = ui.new_checkbox('LUA', 'B', 'Self: Extrapolation Line')
  ui_extrap_ticks = ui.new_slider('LUA', 'B', 'Extrapolation ticks', 1, 64, 6)
  ui_extrap_color = ui.new_color_picker('LUA', 'B', 'Extrapolation color', 255, 200, 0, 220)
  ui_pred3d_check = ui.new_checkbox('LUA', 'B', 'Self: Predicted 3D Box')
  ui_pred3d_scale = ui.new_slider('LUA', 'B', 'Predicted 3D Box Scale %', 0, 200, 20)
end

local function is_self_extrapolation_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation)
    if ok then return val end
  elseif ui_extrap_check then
    local ok, val = pcall(ui.get, ui_extrap_check)
    if ok then return val end
  end
  return false
end

local function get_extrap_ticks()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_ticks then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_ticks)
    if ok then return val end
  elseif ui_extrap_ticks then
    local ok, val = pcall(ui.get, ui_extrap_ticks)
    if ok then return val end
  end
  return 6
end

local function get_extrap_color()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_color then
    local ok, r,g,b,a = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_color)
    if ok then return r,g,b,a end
  elseif ui_extrap_color then
    local ok, r,g,b,a = pcall(ui.get, ui_extrap_color)
    if ok then return r,g,b,a end
  end
  return 255,200,0,220
end

local function is_predicted_3d_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d)
    if ok then return val end
  elseif ui_pred3d_check then
    local ok, val = pcall(ui.get, ui_pred3d_check)
    if ok then return val end
  end
  return false
end

local function get_pred3d_scale()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d_scale then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d_scale)
    if ok then return val end
  elseif ui_pred3d_scale then
    local ok, val = pcall(ui.get, ui_pred3d_scale)
    if ok then return val end
  end
  return 20
end

client.set_event_callback('paint',function()
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  
  local _lp_state = client.globals and client.globals.__self_lc_state or nil
  if not _lp_state then
    _lp_state = {}
    client.globals = client.globals or {}
    client.globals.__self_lc_state = _lp_state
  end
  local function length_sqr(x,y,z)
    x = x or 0; y = y or 0; z = z or 0
    return x*x + y*y + z*z
  end
  local function time_to_ticks(seconds)
    local ti = globals.tickinterval and globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return math.floor((seconds or 0) / ti + 0.5)
  end
  local function is_local_breaking_lagcomp()
    local sim_time = entity.get_prop(lp, 'm_flSimulationTime')
    local ox,oy,oz = entity.get_origin(lp)
    if not sim_time or not ox then return false end
    local sim_ticks = time_to_ticks(sim_time)
    local prev = _lp_state.prev
    local breaking = false
    if prev then
      local delta = sim_ticks - prev.tick
      if delta > 0 and delta <= 64 then
        local dx,dy,dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
        local teleport_distance = length_sqr(dx,dy,dz)
        if teleport_distance > 4096 then breaking = true end
      end
    end
    _lp_state.prev = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
    return breaking
  end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1] ],pts[chain[2] ]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end

  
  if is_self_extrapolation_enabled() then
    local ox,oy,oz = entity.get_origin(lp)
    if ox and oy and oz then
      local vx,vy,vz = entity.get_prop(lp, "m_vecVelocity")
      if vx and vy and vz then
        local ticks = get_extrap_ticks() or 6
        local tickint = (globals.tickinterval and globals.tickinterval()) or 0.015625
        local dt = tickint * ticks
        local px,py,pz = ox + vx * dt, oy + vy * dt, oz + vz * dt
        local sx1,sy1 = renderer.world_to_screen(ox,oy,oz)
        local sx2,sy2 = renderer.world_to_screen(px,py,pz)
        if sx1 and sx2 then
          local r,g,b,a = get_extrap_color()
          renderer.line(sx1,sy1,sx2,sy2, r, g, b, a)
          renderer.circle(sx2,sy2, r, g, b, a, 6, 0, 1.0)
          renderer.text(sx2, sy2 - 10, r, g, b, a, 'c+', 0, tostring(ticks) .. 't')
          
          local bx1,by1,bx2,by2,alpha_mult = entity.get_bounding_box(lp)
          if bx1 and alpha_mult and alpha_mult ~= 0 then
            local sx_orig, sy_orig = sx1, sy1
            if sx_orig and sy_orig then
              local dx, dy = sx2 - sx_orig, sy2 - sy_orig
              local bw, bh = (bx2 - bx1), (by2 - by1)
              local pbx, pby = bx1 + dx, by1 + dy
              
              renderer.rectangle(pbx, pby, bw, bh, 255,255,255,40)
              renderer.rectangle(pbx-1, pby-1, bw+2, bh+2, 255,255,255,200)
            end
          end

          
          if is_predicted_3d_enabled() and is_local_breaking_lagcomp() then
            
            local o = {x = ox, y = oy, z = oz}
            local offs = {}
            local keys = {'head','pelvis','l_shoulder','r_shoulder','l_hip','r_hip'}
            for i=1,#keys do
              local def = boxes[keys[i] ]
              if def then
                local ok, hx, hy, hz = pcall(function() return find(lp, def) end)
                if ok and hx then
                  table.insert(offs, {x = hx - o.x, y = hy - o.y, z = hz - o.z})
                end
              end
            end
            if #offs > 0 then
              local minx,miny,minz = offs[1].x,offs[1].y,offs[1].z
              local maxx,maxy,maxz = offs[1].x,offs[1].y,offs[1].z
              for i=2,#offs do
                local v = offs[i]
                if v.x < minx then minx = v.x end
                if v.y < miny then miny = v.y end
                if v.z < minz then minz = v.z end
                if v.x > maxx then maxx = v.x end
                if v.y > maxy then maxy = v.y end
                if v.z > maxz then maxz = v.z end
              end
              
              local scale_pct = 105
              local cx = (minx + maxx) * 0.5
              local cy = (miny + maxy) * 0.5
              local cz = (minz + maxz) * 0.5
              local ex = (maxx - minx) * 0.5 * (1 + scale_pct / 100)
              local ey = (maxy - miny) * 0.5 * (1 + scale_pct / 100)
              local ez = (maxz - minz) * 0.5 * (1 + scale_pct / 100)
              minx = cx - ex; maxx = cx + ex
              miny = cy - ey; maxy = cy + ey
              minz = cz - ez; maxz = cz + ez

              
              local corners = {
                {x = px + minx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + maxy, z = pz + maxz},
                {x = px + minx, y = py + maxy, z = pz + maxz},
              }
              
              local sc = {}
              local all_on_screen = true
              for i=1,8 do
                local sx, sy = renderer.world_to_screen(corners[i].x, corners[i].y, corners[i].z)
                if not sx then all_on_screen = false break end
                sc[i] = {x = sx, y = sy}
              end
              if all_on_screen then
                
                local rr,gg,bb,aa = 255,255,255,200
                
                renderer.line(sc[1].x,sc[1].y,sc[2].x,sc[2].y, rr,gg,bb,aa)
                renderer.line(sc[2].x,sc[2].y,sc[3].x,sc[3].y, rr,gg,bb,aa)
                renderer.line(sc[3].x,sc[3].y,sc[4].x,sc[4].y, rr,gg,bb,aa)
                renderer.line(sc[4].x,sc[4].y,sc[1].x,sc[1].y, rr,gg,bb,aa)
                
                renderer.line(sc[5].x,sc[5].y,sc[6].x,sc[6].y, rr,gg,bb,aa)
                renderer.line(sc[6].x,sc[6].y,sc[7].x,sc[7].y, rr,gg,bb,aa)
                renderer.line(sc[7].x,sc[7].y,sc[8].x,sc[8].y, rr,gg,bb,aa)
                renderer.line(sc[8].x,sc[8].y,sc[5].x,sc[5].y, rr,gg,bb,aa)
                
                for i=1,4 do renderer.line(sc[i].x,sc[i].y,sc[i+4].x,sc[i+4].y, rr,gg,bb,aa) end
              end
            end
          end
        end
      end
    end
  end
end)]]
__bundle["require/features/paint/self_skeleton"] = [[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1] ],pts[chain[2] ]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end
end

if cb_ok and callbacks and callbacks.callback then
  callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end]]
__bundle["require/features/paint/skeletons"] = [[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}


local time = require("require/help/time")
local enemies = require("require/help/enemies")
local color = require("require/help/color")
local math_help = require("require/help/math")




local function find(ent, def)
    if not ent or not def then return end
    local names = def.names
    if names then
        for i = 1, #names do
            local x, y, z = entity.hitbox_position(ent, names[i])
            if x then return x, y, z end
        end
    end
    local idx = def.idx
    if idx then
        for i = 1, #idx do
            local x, y, z = entity.hitbox_position(ent, idx[i])
            if x then return x, y, z end
        end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    return pts
end


client.set_event_callback("paint", function()
    local enemy_list = entity.get_players(true)
    for i = 1, #enemy_list do
        local ent = enemy_list[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local pts = snap(ent)
            for _, chain in ipairs(chains) do
                local from = pts[chain[1] ]
                local to = pts[chain[2] ]
                if from and to then
                    local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                    local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                    if fx and fy and tx and ty then
                        renderer.line(fx, fy, tx, ty, 255, 0, 0, 255)
                    end
                end
            end
        end
    end
end)

]]
__bundle["require/features/paint/target_info"] = [[local menu_setup = require("require/abc/menu_setup")
local renderer = renderer
local client = client


local dot_texture_id = nil
local function get_dot_texture()
	if dot_texture_id then return dot_texture_id end
	if renderer.load_rgba then
		local ok, texture = pcall(renderer.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if ok and texture then dot_texture_id = texture end
	end
	return dot_texture_id
end




local state = state or {
	fl_val = math.random(0, 14),
	fl_target = math.random(0, 14),
	by_val = math.random(-58, 58),
	by_target = math.random(-58, 58),
	last_update = client.system_time()
}


local function update_random_values()
	state.fl_val = math.random(0, 14)
	state.by_val = math.random(-58, 58)
end



local function update_targets()
	local now = client.system_time()
	if now - state.last_update > 1 then
		state.fl_target = math.random(0, 14)
		state.by_target = math.random(-58, 58)
		state.last_update = now
	end
end

local function lerp_values()
	state.fl_val = state.fl_val + (state.fl_target - state.fl_val) * 0.08
	state.by_val = state.by_val + (state.by_target - state.by_val) * 0.08
end

local function on_paint_target_info()
	if not ui.get(menu_setup.ui.paint_target_info) then return end

	update_targets()
	lerp_values()
	update_random_values() 

	
	local screen_w, screen_h = client.screen_size()
	local panel_w = 170
	local panel_h = 80
	local panel_x = 30
	local panel_y = math.floor(screen_h / 2 - panel_h / 2)

	
	renderer.rectangle(panel_x - 7, panel_y - 5, panel_w + 14, panel_h + 10, 0, 0, 0, 200)
	renderer.rectangle(panel_x - 6, panel_y - 4, panel_w + 12, panel_h + 8, 60, 60, 60, 255)
	renderer.rectangle(panel_x - 5, panel_y - 3, panel_w + 10, panel_h + 6, 40, 40, 40, 255)
	renderer.rectangle(panel_x - 3, panel_y - 1, panel_w + 6, panel_h + 2, 60, 60, 60, 255)
	renderer.rectangle(panel_x - 2, panel_y, panel_w + 4, panel_h, 12, 12, 12, 255)
	renderer.rectangle(panel_x - 2, panel_y, panel_w + 4, panel_h, 32, 32, 32, 255)

	
	local tex_id = get_dot_texture()
	if tex_id and renderer.texture then
		renderer.texture(tex_id, panel_x - 2, panel_y, panel_w + 4, panel_h, 255,255,255,60, 'r')
	end

	
	local accent_y = panel_y
	local accent_h = 1
	local accent_w1 = math.floor((panel_w + 4) / 2)
	local accent_w2 = math.ceil((panel_w + 4) / 2)
	
	renderer.rectangle(panel_x - 2, accent_y - 1, panel_w + 4, accent_h + 2, 0, 0, 0, 255)
	if renderer.gradient then
		renderer.gradient(panel_x - 2, accent_y, accent_w1, accent_h, 59,175,222,255, 202,70,205,255, true)
		renderer.gradient(panel_x - 2 + accent_w1, accent_y, accent_w2, accent_h, 202,70,205,255, 204,227,53,255, true)
	end

	
	local row_x = panel_x + 12
	local row_y = panel_y + 13  
	local row_h = 18
	local slider_w = panel_w - 60 
	local slider_h = 7 

	
	local fake_lag_val = math.floor(state.fl_val + 0.5)
	
	local label_offset_y = slider_h / 2 - 7
	renderer.text(row_x - 8, row_y + label_offset_y, 255,255,255,255, '', 0, "Fake lag")
	local fl_slider_x = row_x + 42 
	local fl_slider_y = row_y + 6  
	local fl_slider_max = 14
	local fl_fill_w = math.floor(slider_w * (state.fl_val / fl_slider_max))
	
	local slider_outline_w = slider_w + 2
	local slider_outline_h = slider_h + 2
	local slider_fill_x = fl_slider_x + 1
	local slider_fill_y = fl_slider_y + 1
	local slider_fill_w = slider_w - 2
	local slider_fill_h = slider_h - 2
	renderer.rectangle(fl_slider_x - 1, fl_slider_y - 1, slider_outline_w, slider_outline_h, 0, 0, 0, 255)
	renderer.rectangle(fl_slider_x, fl_slider_y, slider_w, slider_h, 60, 60, 60, 255)
	renderer.rectangle(slider_fill_x, slider_fill_y, math.max(0, math.floor(slider_fill_w * (state.fl_val / fl_slider_max))), slider_fill_h, 180, 220, 80, 255)
	local fl_handle_x = fl_slider_x + fl_fill_w - 4
	local fl_handle_y = fl_slider_y + slider_h / 2
	renderer.circle(fl_handle_x, fl_handle_y, 5, 180,220,80,255, 16)
	
	local fl_value_text = tostring(fake_lag_val)
	local fl_value_x = fl_slider_x + fl_fill_w + 8 
	local fl_value_y = fl_slider_y + slider_h + 0 
	renderer.text(fl_value_x + 1, fl_value_y + 1, 0,0,0,255, '-', 0, fl_value_text)
	renderer.text(fl_value_x, fl_value_y, 255,255,255,255, '-', 0, fl_value_text)

	
	local body_yaw_val = math.floor(state.by_val + 0.5)
	renderer.text(row_x - 8, row_y + row_h + label_offset_y, 255,255,255,255, '', 0, "Body yaw")
	local by_slider_x = row_x + 42 
	local by_slider_y = row_y + row_h + 6  
	local by_slider_min = -58
	local by_slider_max = 58
	local by_slider_range = by_slider_max - by_slider_min
	
	local by_fill_w = math.floor(slider_w * ((state.by_val - by_slider_min) / by_slider_range))
	
	local by_slider_outline_w = slider_w + 2
	local by_slider_outline_h = slider_h + 2
	local by_slider_fill_x = by_slider_x + 1
	local by_slider_fill_y = by_slider_y + 1
	local by_slider_fill_w = slider_w - 2
	local by_slider_fill_h = slider_h - 2
	renderer.rectangle(by_slider_x - 1, by_slider_y - 1, by_slider_outline_w, by_slider_outline_h, 0, 0, 0, 255)
	renderer.rectangle(by_slider_x, by_slider_y, slider_w, slider_h, 60, 60, 60, 255)
	
	local center_x = by_slider_x + slider_w / 2
	local value_x = by_slider_x + by_fill_w
	if state.by_val < 0 then
		renderer.rectangle(value_x + 1, by_slider_fill_y, center_x - value_x, by_slider_fill_h, 180, 220, 80, 255)
	else
		renderer.rectangle(center_x + 1, by_slider_fill_y, value_x - center_x, by_slider_fill_h, 180, 220, 80, 255)
	end
	local by_handle_x = value_x - 4
	local by_handle_y = by_slider_y + slider_h / 2
	renderer.circle(by_handle_x, by_handle_y, 5, 180,220,80,255, 16)
	
	local by_value_text = tostring(body_yaw_val)
	local by_fill_x = by_slider_x + by_fill_w
	local by_value_x = by_fill_x + 8 
	local by_value_y = by_slider_y + slider_h + 0 
	renderer.text(by_value_x + 1, by_value_y + 1, 0,0,0,255, '-', 0, by_value_text)
	renderer.text(by_value_x, by_value_y, 255,255,255,255, '-', 0, by_value_text)

	
	local val_box_w = 22
	local val_box_h = 14

	
	local dt_status = math.random() > 0.5 and "[Offensive]" or "[Defensive]"
	local dt_color = dt_status == "[Offensive]" and {204,227,53,255} or {202,70,205,255}
	renderer.text(row_x - 8, row_y + row_h * 2 + label_offset_y, 255,255,255,255, '', 0, "Double tap")
	local dt_box_x = row_x + slider_w + 32
	local dt_box_y = row_y + row_h * 2 - 2
	renderer.text(dt_box_x + 4, dt_box_y + 2, table.unpack(dt_color), '', 0, dt_status)

	
	local fs_status = math.random() > 0.5 and "[On]" or "[Off]"
	local fs_color = fs_status == "[On]" and {80,255,80,255} or {255,255,80,255}
	renderer.text(row_x - 8, row_y + row_h * 3 + label_offset_y, 255,255,255,255, '', 0, "Freestanding")
	local fs_box_x = row_x + slider_w + 32
	local fs_box_y = row_y + row_h * 3 - 2
	renderer.text(fs_box_x + 4, fs_box_y + 2, table.unpack(fs_color), '', 0, fs_status)
end

local callbacks = require("require/abc/callbacks")
callbacks.callback('paint', on_paint_target_info, { alive_only = true, require_login = true })
]]
__bundle["require/features/paint/text_watermark"] = [[local S = require("require/help/string")
local T = require("require/help/time")
local C = require("require/help/color")
local rgba_hex = C.rgba_to_hex
local drag_lib = pcall(require, "require/help/drag") and require("require/help/drag") or nil
local wm_drag = nil

local function animated_text(style, speed, r,g,b,a, text)
    local t = T.realtime() or globals.curtime()
    if not text or #text == 0 then return "" end
    local out = {}

    if style == 0 then
        local hex = rgba_hex(r,g,b,a)
        for i=1,#text do out[#out+1] = hex .. text:sub(i,i) end
        return table.concat(out)
    end

    if style == 2 then
        local f = (math.sin(t * speed) + 1) * 0.5
        local la = C.clamp(math.floor(a * (0.45 + 0.55 * f)))
        local hex = rgba_hex(r,g,b,la)
        for i=1,#text do out[#out+1] = hex .. text:sub(i,i) end
        return table.concat(out)
    end

    if style == 3 then
        for i=1,#text do
            local phase = math.sin(t * speed - i * 0.6)
            local spike = math.max(0, phase)
            local f = spike * spike
            local la = C.clamp(math.floor(a * (0.35 + 0.65 * f)))
            out[#out+1] = rgba_hex(r,g,b,la) .. text:sub(i,i)
        end
        return table.concat(out)
    end

    for i=1,#text do
        local f = (math.sin(t*speed - i*0.35) + 1) * 0.5
        local la = C.clamp(math.floor(a * (0.4 + 0.6 * f)))
        out[#out+1] = rgba_hex(r,g,b,la) .. text:sub(i,i)
    end
    return table.concat(out)
end

local gs_item_refs = {}
local gs_ref_visible = {}
for i, item in ipairs({
    { 'misc', 'settings', 'menu color' },
}) do
    local refs = {ui.reference(item[1], item[2], item[3])}
    gs_item_refs[i] = refs
    for _, ref in ipairs(refs) do
        gs_ref_visible[ref] = true
    end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
    local sw, sh = client.screen_size()
    if not sw or not sh then return end
    local mr, mg, mb, ma = 255, 255, 255, 255
    
    local used_custom = false
    local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
    if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_advertisement_color then
        local ok_get, a, b, c, d = pcall(ui.get, menu_setup.ui.paint_advertisement_color)
        if ok_get then
            used_custom = true
            if type(a) == 'number' then
                mr = C.clamp(a or mr)
                mg = C.clamp(b or mg)
                mb = C.clamp(c or mb)
                ma = C.clamp(d or ma)
            elseif type(a) == 'string' and #a == 12 then
                local ok
                ok, mr = pcall(function() return tonumber(a:sub(1,3)) end)
                ok, mg = pcall(function() return tonumber(a:sub(4,6)) end)
                ok, mb = pcall(function() return tonumber(a:sub(7,9)) end)
                ok, ma = pcall(function() return tonumber(a:sub(10,12)) end)
                mr = C.clamp(mr or 255); mg = C.clamp(mg or 255); mb = C.clamp(mb or 255); ma = C.clamp(ma or 255)
            end
        end
    end

    if not used_custom then
        local ok_get, a, b, c, d = pcall(ui.get, gs_item_refs[1][1])
        if ok_get then
            if type(a) == 'number' then
                mr = C.clamp(a or mr)
                mg = C.clamp(b or mg)
                mb = C.clamp(c or mb)
                ma = C.clamp(d or ma)
            elseif type(a) == 'string' and #a == 12 then
                local ok
                ok, mr = pcall(function() return tonumber(a:sub(1,3)) end)
                ok, mg = pcall(function() return tonumber(a:sub(4,6)) end)
                ok, mb = pcall(function() return tonumber(a:sub(7,9)) end)
                ok, ma = pcall(function() return tonumber(a:sub(10,12)) end)
                mr = C.clamp(mr or 255); mg = C.clamp(mg or 255); mb = C.clamp(mb or 255); ma = C.clamp(ma or 255)
            end
        end
    end

    local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
    if not menu_ok or not menu_setup or not menu_setup.ui then return end
    if not ui.get(menu_setup.ui.paint_advertisement) then return end
    local t = T.realtime() or globals.curtime()
    local bob = 0
    local alpha = math.floor(200 + 55 * (math.sin(t*2)+1)/2)
    local main_text, suffix, spacing = "sodium", "[BETA]", 3

    local mw, mh = renderer.measure_text("", main_text)
    mw = mw or 0; mh = mh or 16
    local swid = (renderer.measure_text("", suffix) or 0)

    if drag_lib and not wm_drag then
        local default_left = math.floor(sw/2 - (mw + spacing + swid)/2)
        local default_top = math.floor(sh - 15)
        wm_drag = drag_lib.new('sodium_watermark', {
            x = default_left,
            y = default_top,
            w = mw + spacing + swid,
            h = mh,
                default_pos = { x = default_left, y = default_top },
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
        })
    end

    if wm_drag then
        wm_drag:handle()
    end

    local left, base_y
    if wm_drag then
        left = wm_drag.x
        base_y = wm_drag.y + bob
    else
        left = math.floor(sw/2 - (mw + spacing + swid)/2)
        base_y = sh - 15 + bob
    end

    local shadow_a = math.floor(math.max(0, alpha - 140) * 0.6)
    local offs = { {-1,0},{1,0},{0,-1},{0,1} }

    if wm_drag then wm_drag:draw() end

    for _,o in ipairs(offs) do renderer.text(left+o[1], base_y+o[2], 0,0,0, shadow_a, "", 0, main_text) end
    renderer.text(left, base_y, 255,255,255, alpha, "", 0, main_text)

    local anim_style = 1
    local menu_ok2, menu_setup2 = pcall(require, "require/abc/menu_setup")
    if menu_ok2 and menu_setup2 and menu_setup2.ui and menu_setup2.ui.paint_advertisement_animation then
        local ok_style, v = pcall(ui.get, menu_setup2.ui.paint_advertisement_animation)
        if ok_style and type(v) == 'number' then anim_style = v end
    end

    local sx = left + mw + spacing
    local anim_suf = animated_text(anim_style, 3.5, mr, mg, mb, ma, suffix)
    renderer.text(sx, base_y, mr, mg, mb, ma, "", 0, anim_suf)
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end]]
__bundle["require/features/paint/third_person_distance"] = [[local menu_setup = require("require/abc/menu_setup")
local T = require("require/help/time")
local M = require("require/help/math")
local Safe = require("require/help/safe")
local cam_state = { original = nil, last = nil, last_update = nil }

local function get_cam()
    if cvar.cam_idealdist and cvar.cam_idealdist.get_float then
        return cvar.cam_idealdist:get_float()
    end
    return nil
end

local function set_cam(val)
    if cvar.cam_idealdist and cvar.cam_idealdist.set_float then
        cvar.cam_idealdist:set_float(val)
        return true
    elseif client and client.exec then
        client.exec("cam_idealdist " .. tostring(val))
        return true
    end
    return false
end

local callbacks = require("require/abc/callbacks")
callbacks.callback('paint', function()
    local ref = menu_setup.ui and menu_setup.ui.paint_third_person_distance
    if not ref then
        client.log('third_person_distance: menu ref missing')
        return
    end
    local raw = Safe.safe_get(ref)
    if type(raw) ~= 'number' then
        client.log('third_person_distance: invalid slider value', tostring(raw))
        return
    end
    local target = M.clamp(raw, 29, 180)
    target = M.round(target, 2)
    if cam_state.original == nil then
        cam_state.original = get_cam()
        if cam_state.original == nil then
            client.log('third_person_distance: cam_idealdist cvar not available')
        end
    end
    if cam_state.last == nil then
        cam_state.last = get_cam() or target
    end
    local now = T.realtime()
    local last_update = cam_state.last_update or now
    local dt = now - last_update
    cam_state.last_update = now
    local speed = 300
    local step = speed * dt
    if math.abs(cam_state.last - target) > 0.01 then
        local t = M.clamp(step / math.max(math.abs(target - cam_state.last), 0.01), 0, 1)
        cam_state.last = M.lerp(cam_state.last, target, t)
        cam_state.last = M.round(cam_state.last, 2)
        set_cam(cam_state.last)
    end
end, { require_login = true })]]
__bundle["require/features/paint/warnings"] = [[local x, y = client.screen_size()
local _menu_ok, _menu_setup = pcall(require, "require/abc/menu_setup")


local function draw_lethality_warning()
    
    if not _menu_ok or not _menu_setup or not _menu_setup.ui or not _menu_setup.ui.paint_warnings then return end
    local sel = ui.get(_menu_setup.ui.paint_warnings)
    local show_lethal = false
    if type(sel) == "table" then
        for _, v in ipairs(sel) do
            if v == "lethal" then show_lethal = true break end
        end
    end
    if not show_lethal then return end

    if entity.get_prop(entity.get_local_player(), 'm_iHealth') and entity.get_prop(entity.get_local_player(), 'm_iHealth') > 0 and entity.get_prop(entity.get_local_player(), 'm_iHealth') < 93 then
        renderer.text(x / 2, y * 0.3, 255, 0, 0, 255, "c, -", 0, "YOU'RE LETHAL:   " .. entity.get_prop(entity.get_local_player(), 'm_iHealth') .. " HP REMAINING")
    end
    
end

local _cb_ok, _callbacks = pcall(require, "require/abc/callbacks")
if _cb_ok and _callbacks then
    _callbacks.callback('paint', draw_lethality_warning, { alive_only = true, require_login = true })
end]]
__bundle["require/features/paint/watermark_gamesense"] = [[local renderer = renderer
local client = client
local globals = globals
local C = require('require/help/color')

local drag_lib = pcall(require, "require/help/drag") and require("require/help/drag") or nil
local wm_drag = nil

local function get_fps()
	local frametime = globals and globals.frametime and globals.frametime() or 0.016
	if frametime > 0 then
		return math.floor(1 / frametime + 0.5)
	end
	return 0
end

local dot_texture_id = nil
local function get_dot_texture()
	if dot_texture_id then return dot_texture_id end
	if renderer.load_rgba then
		local ok, texture = pcall(renderer.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if ok and texture then dot_texture_id = texture end
	end
	return dot_texture_id
end

local hex_to_rgba = C.hex_to_rgba

local base_colors = {
	green  = "a5ca2aFF",
	red    = "d96464FF",
	yellow = "ccb854FF",
	blue   = "5462ccFF",
	purple = "7054ccFF",
	white  = "ffffffFF",
	grey   = "757575FF",
	black  = "000000FF",
	pink   = "c8a2deFF",
}


local login_system = require("require/abc/login_system")
local menu_setup = require("require/abc/menu_setup")
local self = require("require/help/self")

local time = require("require/help/time")
local last_fps = 0
local fps_timer = time.new(0.25)

local function draw_watermark()
	if not menu_setup or not menu_setup.ui then return end
	
	local ok_en, enabled = pcall(ui.get, menu_setup.ui.paint_watermark)
	if not ok_en or not enabled then return end
	
	local ok_type, wtype = pcall(ui.get, menu_setup.ui.paint_watermark_type)
	if not ok_type or wtype ~= 0 then return end
	local screen_w, screen_h = client and client.screen_size and client.screen_size() or 800, 600

	local username
	if login_system.logged_in then
		local cached = database.read and database.read('cached_credentials')
		if cached and cached.username then
			username = cached.username
		end
	else
		local creds = login_system.load_credentials and login_system.load_credentials()
		if creds and creds.username then
			username = creds.username
		end
	end
	if not username or username == "" then
		username = self.player_name and self.player_name() or "unknown"
	end
	if time.expired(fps_timer) then
		last_fps = get_fps()
		time.reset(fps_timer)
	end
	local fps = last_fps

	local ping_val = 0
	if self and self.ping then
		local p = self.ping()
		if type(p) == 'number' then ping_val = p end
	elseif client and client.latency then
		local p = client.latency()
		if type(p) == 'number' then ping_val = p end
	end
	local ping_ms = math.floor((ping_val or 0) * 1000 + 0.5)

	local font_style = ''
	local segments = {
		{text = "game", style = font_style, color = base_colors.white},
		{text = "sense", style = font_style, color = base_colors.green},
		{text = " ", style = font_style, color = base_colors.white},
		{text = "[beta]", style = font_style, color = base_colors.white},
		{text = " | ", style = font_style, color = base_colors.white},
		{text = username, style = font_style, color = base_colors.white},
		{text = " | ", style = font_style, color = base_colors.white},
		{text = tostring(ping_ms) .. " ms", style = font_style, color = base_colors.white},
		{text = " | ", style = font_style, color = base_colors.white},
		{text = tostring(fps) .. " fps", style = font_style, color = base_colors.white},
	}

	local total_w, max_h = 0, 0
	for _, seg in ipairs(segments) do
		local w, h = renderer.measure_text and renderer.measure_text(seg.style, seg.text) or 0, 13
		total_w = total_w + w
		if h > max_h then max_h = h end
	end
	local pad_x, pad_y = 5, 2
	local box_w = total_w + pad_x * 2
	local box_h = max_h + pad_y * 2
	local x = screen_w - box_w - 16
	local y = 16

	if drag_lib and not wm_drag then
		local default_left = x
		local default_top = y
		wm_drag = drag_lib.new('gamesense_watermark', {
			x = default_left,
			y = default_top,
			w = box_w,
			h = box_h,
			snap = true,
			snap_threshold = 24,
			require_menu_open = true,
			box_color = {255,255,255,100},
			default_pos = { x = default_left, y = default_top },
		})
	end

	if wm_drag then wm_drag:handle() end

	if wm_drag then
		x = wm_drag.x
		y = wm_drag.y
	end

	renderer.rectangle(x - 7, y - 5, box_w + 14, box_h + 10, 0, 0, 0, 200)
	renderer.rectangle(x - 6, y - 4, box_w + 12, box_h + 8, 60, 60, 60, 255)
	renderer.rectangle(x - 5, y - 3, box_w + 10, box_h + 6, 40, 40, 40, 255)
	renderer.rectangle(x - 3, y - 1, box_w + 6, box_h + 2, 60, 60, 60, 255)
	renderer.rectangle(x - 2, y, box_w + 4, box_h, 12, 12, 12, 255)
	renderer.rectangle(x - 2, y, box_w + 4, box_h, 32, 32, 32, 255)

	local tex_id = get_dot_texture()
	if tex_id and renderer.texture then
		renderer.texture(tex_id, x - 2, y, box_w + 4, box_h, 255,255,255,60, 'r')
	end

	if renderer.gradient then
		renderer.gradient(x - 2, y, box_w / 2 + 1, 1, 59,175,222,255, 202,70,205,255, true)
		renderer.gradient(x - 2 + box_w / 2, y, box_w / 2 + 4.5, 1, 202,70,205,255, 204,227,53,255, true)
	end

	local tx = x + pad_x
	local ty = y + pad_y
    if wm_drag then wm_drag:draw() end
	for _, seg in ipairs(segments) do
		local w, h = renderer.measure_text and renderer.measure_text(seg.style, seg.text) or 0, 13
			local r,g,b,a = hex_to_rgba(seg.color)
			r,g,b,a = C.normalize(r,g,b,a)
			renderer.text(tx, ty, r,g,b,a, seg.style, nil, seg.text)
		tx = tx + w
	end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
if cb_ok and callbacks and callbacks.callback then
	callbacks.callback('paint', draw_watermark, { alive_only = true, require_login = true })
end
]]
__bundle["require/features/paint/watermark_solus"] = [[local renderer = renderer
local client = client
local C = require('require/help/color')
local callbacks_ok, callbacks = pcall(require, "require/abc/callbacks")
local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local ok_menu_color_ref, menu_color_ref = pcall(ui.reference, 'misc', 'settings', 'menu color')
local drag_lib = pcall(require, "require/help/drag") and require("require/help/drag") or nil
local wm_drag = nil
local function draw_rounded_box(x,y,w,h,radius, r,g,b,a)
    renderer.rectangle(x+radius, y, w-(radius*2), h, r,g,b,a)
    renderer.rectangle(x, y+radius, w, h-(radius*2), r,g,b,a)
    renderer.circle(x+radius, y+radius, r,g,b,a, radius, 0, 1)
    renderer.circle(x+w-radius, y+radius, r,g,b,a, radius, 0, 1)
    renderer.circle(x+radius, y+h-radius, r,g,b,a, radius, 0, 1)
    renderer.circle(x+w-radius, y+h-radius, r,g,b,a, radius, 0, 1)
end

local globals = globals
local cached_fps = 0
local last_fps_sample = 0
local fps_update_interval = 0.1

local function safe_require(module)
    local ok, m = pcall(require, module)
    if ok then return m end
    return nil
end

local function draw_solus_watermark()
    if not menu_ok or not menu_setup or not menu_setup.ui then return end
    local ok_en, enabled = pcall(ui.get, menu_setup.ui.paint_watermark)
    if not ok_en or not enabled then return end
    local ok_type, wtype = pcall(ui.get, menu_setup.ui.paint_watermark_type)
    if not ok_type or wtype ~= 1 then return end

    local sw, sh = client.screen_size()
    if not sw or not sh then return end

    local username = "unknown"
    local login_system = safe_require('require/abc/login_system')
    local help_self = (pcall(require, 'require/help/self') and require('require/help/self')) or nil
    if login_system then
        if login_system.logged_in then
            local cached = database and database.read and database.read('cached_credentials')
            if cached and cached.username then username = cached.username end
        else
            if login_system.load_credentials then
                local creds = login_system.load_credentials()
                if creds and creds.username then username = creds.username end
            end
        end
    end
    if (not username or username == "") and help_self and help_self.player_name then
        username = help_self.player_name()
    end

    local fps = cached_fps or 0
    pcall(function()
        local now = globals and globals.realtime and globals.realtime() or os.clock()
        if (now - (last_fps_sample or 0)) >= fps_update_interval then
            local ft = globals and globals.frametime and globals.frametime() or 0.016
            if ft and ft > 0 then
                cached_fps = math.floor(1 / ft + 0.5)
            end
            last_fps_sample = now
        end
        fps = cached_fps or fps
    end)

    local ping_ms = 0
    if help_self and help_self.ping then
        local p = help_self.ping()
        if type(p) == 'number' then ping_ms = math.floor(p * 1000 + 0.5) end
    elseif client and client.latency then
        local p = client.latency()
        if type(p) == 'number' then ping_ms = math.floor(p * 1000 + 0.5) end
    end

    local segments = {
        { text = "gamesense ", bold = true },
        { text = " | ", bold = false },
        { text = username or "unknown", bold = false },
        { text = " | ", bold = false },
        { text = tostring(ping_ms) .. " ms", bold = false },
        { text = " | ", bold = false },
        { text = tostring(fps) .. " fps", bold = false },
    }

    local total_w, max_h = 0, 0
    for _, seg in ipairs(segments) do
        local w, h = 0, 13
        if renderer.measure_text then
            local ok, mw, mh = pcall(renderer.measure_text, '', seg.text)
            if ok and mw then w, h = mw, mh or h end
        end
        total_w = total_w + (w or 0)
        if h and h > max_h then max_h = h end
    end

    local pad_x, pad_y = 12, 6
    local box_w = total_w + pad_x * 2
    local box_h = max_h + pad_y * 2
    local margin = 18
    local x = sw - box_w - margin
    local y = margin
    local radius = 8
    if drag_lib and not wm_drag then
        local default_left = x
        local default_top = y
        wm_drag = drag_lib.new('solus_watermark', {
            x = default_left,
            y = default_top,
            w = box_w,
            h = box_h,
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
            default_pos = { x = default_left, y = default_top },
        })
    end

    if wm_drag then wm_drag:handle() end

    if wm_drag then
        x = wm_drag.x
        y = wm_drag.y
    end
    local mr, mg, mb, ma = 255, 140, 0, 255
    do
        
        if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_watermark_color then
            local ok_col, ca, cb, cc, cd = pcall(ui.get, menu_setup.ui.paint_watermark_color)
            if ok_col then
                if type(ca) == 'number' then
                    mr = C.clamp(ca or mr)
                    mg = C.clamp(cb or mg)
                    mb = C.clamp(cc or mb)
                    ma = C.clamp(cd or ma)
                elseif type(ca) == 'string' and #ca == 12 then
                    local ok
                    ok, mr = pcall(function() return tonumber(ca:sub(1,3)) end)
                    ok, mg = pcall(function() return tonumber(ca:sub(4,6)) end)
                    ok, mb = pcall(function() return tonumber(ca:sub(7,9)) end)
                    ok, ma = pcall(function() return tonumber(ca:sub(10,12)) end)
                    mr = C.clamp(mr or 255); mg = C.clamp(mg or 140); mb = C.clamp(mb or 0); ma = C.clamp(ma or 255)
                end
                
            else
                
                if ok_menu_color_ref and menu_color_ref then
                    local ok_col2, ca2, cb2, cc2, cd2 = pcall(ui.get, menu_color_ref)
                    if ok_col2 then
                        if type(ca2) == 'number' then
                            mr = C.clamp(ca2 or mr)
                            mg = C.clamp(cb2 or mg)
                            mb = C.clamp(cc2 or mb)
                            ma = C.clamp(cd2 or ma)
                        elseif type(ca2) == 'string' and #ca2 == 12 then
                            local ok
                            ok, mr = pcall(function() return tonumber(ca2:sub(1,3)) end)
                            ok, mg = pcall(function() return tonumber(ca2:sub(4,6)) end)
                            ok, mb = pcall(function() return tonumber(ca2:sub(7,9)) end)
                            ok, ma = pcall(function() return tonumber(ca2:sub(10,12)) end)
                            mr = C.clamp(mr or 255); mg = C.clamp(mg or 140); mb = C.clamp(mb or 0); ma = C.clamp(ma or 255)
                        end
                    end
                end
            end
        else
            
            if ok_menu_color_ref and menu_color_ref then
                local ok_col, ca, cb, cc, cd = pcall(ui.get, menu_color_ref)
                if ok_col then
                    if type(ca) == 'number' then
                        mr = C.clamp(ca or mr)
                        mg = C.clamp(cb or mg)
                        mb = C.clamp(cc or mb)
                        ma = C.clamp(cd or ma)
                    elseif type(ca) == 'string' and #ca == 12 then
                        local ok
                        ok, mr = pcall(function() return tonumber(ca:sub(1,3)) end)
                        ok, mg = pcall(function() return tonumber(ca:sub(4,6)) end)
                        ok, mb = pcall(function() return tonumber(ca:sub(7,9)) end)
                        ok, ma = pcall(function() return tonumber(ca:sub(10,12)) end)
                        mr = C.clamp(mr or 255); mg = C.clamp(mg or 140); mb = C.clamp(mb or 0); ma = C.clamp(ma or 255)
                    end
                end
            end
        end
    end

    local function add_arc_points(points, cx, cy, r, start_deg, end_deg, steps)
        local s = math.rad(start_deg)
        local e = math.rad(end_deg)
        for i=0,steps do
            local t = i / steps
            local a = s + (e - s) * t
            points[#points+1] = { cx + math.cos(a) * r, cy + math.sin(a) * r }
        end
    end

    local function build_perimeter(x,y,w,h,rad,step)
        local pts = {}
        step = step or 6
        local left = x
        local right = x + w
        local top = y
        local bottom = y + h
        local sx = left + rad
        local ex = right - rad
        local function push_point(px, py)
            local n = #pts
            if n == 0 then pts[#pts+1] = { px, py }; return end
            local last = pts[n]
            if not (math.abs(last[1] - px) < 0.001 and math.abs(last[2] - py) < 0.001) then
                pts[#pts+1] = { px, py }
            end
        end

        if ex > sx then
            for xx = sx, ex, step do push_point(xx, top) end
            
            push_point(ex, top)
        end

        add_arc_points(pts, right - rad, top + rad, rad, -90, 0, 6)

        local sy = top + rad
        local ey = bottom - rad
        if ey > sy then
            for yy = sy, ey, step do push_point(right, yy) end
            push_point(right, ey)
        end

        add_arc_points(pts, right - rad, bottom - rad, rad, 0, 90, 6)

        if ex > sx then
            for xx = ex, sx, -step do push_point(xx, bottom) end
            push_point(sx, bottom)
        end

        add_arc_points(pts, left + rad, bottom - rad, rad, 90, 180, 6)

        if ey > sy then
            for yy = ey, sy, -step do push_point(left, yy) end
            push_point(left, sy)
        end

        add_arc_points(pts, left + rad, top + rad, rad, 180, 270, 6)

        return pts
    end

    local sample_step = 3
    local pts = build_perimeter(x-1, y-1, box_w+2, box_h+2, radius+1, sample_step)
    local n = #pts

    if wm_drag then wm_drag:draw() end

    draw_rounded_box(x-1, y-1, box_w+2, box_h+2, radius+1, 0, 0, 0, 255)
    draw_rounded_box(x, y, box_w, box_h, radius, 0, 0, 0, 200)

    
    if n > 2 then
        local t = (globals and globals.realtime and globals.realtime() or 0)
        local laps_per_minute = 7
        laps_per_minute = laps_per_minute * 4
        local laps_per_second = laps_per_minute / 60
        local speed = math.max(0.5, laps_per_second * n)
        local ofs = math.floor((t * speed) % n)

        local tail = math.max(6, math.floor(n * 0.25))

        local base_alpha = C.clamp(math.floor((ma or 255) * 1.15))
        for j = tail - 1, 0, -1 do
            local idx1 = ((ofs + j) % n) + 1
            local idx2 = ((ofs + j + 1) % n) + 1
            local p1 = pts[idx1]
            local p2 = pts[idx2]
            if p1 and p2 then
                local alpha_scale = 1 - (j / tail)
                local a = C.clamp(math.floor(base_alpha * alpha_scale))
                renderer.line(p1[1], p1[2], p2[1], p2[2], mr, mg, mb, a)
            end
        end
    end

    local tx = x + pad_x
    local ty = y + math.floor((box_h - max_h) / 2)
    for i, seg in ipairs(segments) do
        local w = 0
        if renderer.measure_text then
            local ok, mw = pcall(renderer.measure_text, '', seg.text)
            if ok and mw then w = mw end
        end
        local flags = seg.bold and 'b' or ''
        renderer.text(tx, ty, 255,255,255,255, flags, 0, seg.text)
        tx = tx + w
    end
end

if callbacks_ok and callbacks and callbacks.callback then
    callbacks.callback('paint', draw_solus_watermark, { alive_only = true, require_login = true })
end

return true]]
__bundle["require/features/paint/world_hitmarker_plus"] = [[
local menu_setup = require("require/abc/menu_setup")
local hit = {shots = {}, last = 0}
local vec_ok, vec = pcall(require, "require/brain/api/vector/vector")

local function is_world_hitmarker_enabled()
	local sel = ui.get(menu_setup.ui.paint_hitmarker)
	if type(sel) == "table" then
		for _, v in ipairs(sel) do
			if v == "world +" then return true end
		end
	end
	return false
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function aim_fire_handler(ev)
	if not is_world_hitmarker_enabled() then hit.shots = {} return end
	if not is_world_hitmarker_enabled() then return end
	local now = globals.realtime()
	
	if hit.last and now - hit.last < 0.05 then return end
	hit.last = now
	hit.shots[#hit.shots + 1] = {impacts = {}, finished = false, t = now}
	if #hit.shots > 12 then table.remove(hit.shots, 1) end
end

local function bullet_impact_handler(ev)
	if not is_world_hitmarker_enabled() then hit = {shots = {}, last = 0} return end
	local me = entity.get_local_player()
	if not me then return end
	local shooter = client.userid_to_entindex(ev.userid or 0)
	if shooter ~= me then return end
	local now = globals.realtime()
	local shot
	for i = #hit.shots, 1, -1 do
		if not hit.shots[i].finished and now - (hit.shots[i].t or 0) < 1.2 then
			shot = hit.shots[i]
			break
		end
	end
	if not shot then return end
	local ix, iy, iz = ev.x, ev.y, ev.z
	local ok_eye, ex, ey, ez = pcall(client.eye_position)
	local dirx, diry, dirz = 0, 0, 0
	if ok_eye and ex and ey and ez then
		if vec_ok and vec and vec.make and vec.normalized and vec.sub then
			local impact_v = vec.make(ix, iy, iz)
			local eye_v = vec.make(ex, ey, ez)
			local nd = vec.normalized(vec.sub(impact_v, eye_v))
			dirx, diry, dirz = nd.x, nd.y, nd.z
		else
			dirx = ix - ex; diry = iy - ey; dirz = iz - ez
			local len = math.sqrt(dirx*dirx + diry*diry + dirz*dirz)
			if len > 0 then dirx, diry, dirz = dirx/len, diry/len, dirz/len end
		end
	end
	local hit_entity = false
	local ok_trace, frac, ent = pcall(client.trace_line, me, ix - (dirx or 0) * 1, iy - (diry or 0) * 1, iz - (dirz or 0) * 1, ix + (dirx or 0) * 1, iy + (diry or 0) * 1, iz + (dirz or 0) * 1)
	if ok_trace and ent and ent > 0 and ent ~= me then
		if entity.is_enemy(ent) then hit_entity = true end
	end
	local cr, cg, cb, ca
	local ok_col, ar, ag, ab, aa = pcall(ui.get, menu_setup.ui.paint_hitmarker_color)
	if ok_col and ar then
		cr, cg, cb, ca = ar or 0, ag or 235, ab or 235, aa or 255
	else
		cr, cg, cb, ca = 0, 235, 235, 255
	end
	shot.impacts[#shot.impacts + 1] = {x = ix, y = iy, z = iz, t = now, r = cr, g = cg, b = cb, a = ca, dir = {dirx, diry, dirz}, hit = hit_entity}
	
	if #shot.impacts > 5 then table.remove(shot.impacts, 1) end
	if hit_entity then
		shot.finished = true
	end
end

local function paint_handler(ev)
	if is_world_hitmarker_enabled() then
		local now = globals.realtime()
		local hold = 5.5 * 3 * 0.8
		local fade = 0.25 * 0.8
		local total = hold + fade
		local i = 1
		while i <= #hit.shots do
			if now - (hit.shots[i].t or 0) > total then
				table.remove(hit.shots, i)
			else
				i = i + 1
			end
		end
		
		local all_impacts = {}
		local max_collect = 12
		for si = #hit.shots, 1, -1 do
			local shot = hit.shots[si]
			for ii = #shot.impacts, 1, -1 do
				table.insert(all_impacts, shot.impacts[ii]) 
				if #all_impacts >= max_collect then break end
			end
			if #all_impacts >= max_collect then break end
		end
		local draw_count = math.min(4, #all_impacts)
		for j = 1, draw_count do
			local it = all_impacts[j]
			local draw_x, draw_y, draw_z = it.x, it.y, it.z
			if not it.hit and it.dir then
				local ex = it.x + (it.dir[1] or 0) * 24
				local ey = it.y + (it.dir[2] or 0) * 24
				local ez = it.z + (it.dir[3] or 0) * 24
				draw_x, draw_y, draw_z = ex, ey, ez
			end
			local sx, sy = renderer.world_to_screen(draw_x, draw_y, draw_z)
			if sx and sy then
				local age = now - (it.t or 0)
				local alpha = age <= hold and 255 or math.floor(math.max(0, (1 - math.max(0, age - hold) / fade) * 255))
				if alpha > 0 then
					local len = 4
					local r = it.r or 200
					local g = it.g or 200
					local b = it.b or 200
					renderer.line(sx - len, sy, sx + len, sy, r, g, b, alpha)
					renderer.line(sx, sy - len, sx, sy + len, r, g, b, alpha)
				end
			end
		end
	else
		hit = {shots = {}, last = 0}
	end
end

if cb_ok and callbacks and callbacks.callback then
	callbacks.callback('aim_fire', aim_fire_handler, { alive_only = true, require_login = true })
	callbacks.callback('bullet_impact', bullet_impact_handler, { alive_only = true, require_login = true })
	callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end
]]
__bundle["require/help/bit"] = [[local bit = {}

local BAND = 0xFFFFFFFF
local TWO32 = 4294967296

local function to_uint32(x)
	x = tonumber(x) or 0
	x = math.floor(x) % TWO32
	if x < 0 then x = x + TWO32 end
	return x
end

function bit.tobit(x)
	local ux = to_uint32(x)
	if ux >= 2147483648 then
		return ux - TWO32
	end
	return ux
end

function bit.tohex(x, n)
	local ux = to_uint32(x)
	local digits = 8
	local upper = false
	if n then
		if n < 0 then
			upper = true
			digits = -n
		else
			digits = n
		end
	end
	if digits < 1 then digits = 1 end
	if digits > 8 then digits = 8 end
	ux = ux % (2^(4 * digits))
	if upper then
		return string.format(string.format("%%0%uX", digits), ux)
	else
		return string.format(string.format("%%0%ux", digits), ux)
	end
end

local function mask_bit(ux, i)
	return math.floor(ux / 2^i) % 2
end

function bit.band(x1, ...)
	local args = {x1, ...}
	if #args == 0 then return 0 end
	local res = 0
	for i = 0, 31 do
		local ok = 1
		for j = 1, #args do
			if mask_bit(to_uint32(args[j]), i) == 0 then
				ok = 0
				break
			end
		end
		if ok == 1 then res = res + 2^i end
	end
	return bit.tobit(res)
end

function bit.bor(x1, ...)
	local args = {x1, ...}
	if #args == 0 then return 0 end
	local res = 0
	for i = 0, 31 do
		for j = 1, #args do
			if mask_bit(to_uint32(args[j]), i) == 1 then
				res = res + 2^i
				break
			end
		end
	end
	return bit.tobit(res)
end

function bit.bxor(x1, ...)
	local args = {x1, ...}
	if #args == 0 then return 0 end
	local res = 0
	for i = 0, 31 do
		local cnt = 0
		for j = 1, #args do
			if mask_bit(to_uint32(args[j]), i) == 1 then cnt = cnt + 1 end
		end
		if (cnt % 2) == 1 then res = res + 2^i end
	end
	return bit.tobit(res)
end

function bit.bnot(x)
	local ux = to_uint32(x)
	local res = BAND - ux
	return bit.tobit(res)
end

function bit.lshift(x, n)
	n = tonumber(n) or 0
	n = n % 32
	local ux = to_uint32(x)
	local res = (ux * 2^n) % TWO32
	return bit.tobit(res)
end

function bit.rshift(x, n)
	n = tonumber(n) or 0
	n = n % 32
	local ux = to_uint32(x)
	local res = math.floor(ux / 2^n) % TWO32
	return bit.tobit(res)
end

function bit.arshift(x, n)
	n = tonumber(n) or 0
	n = n % 32
	local vx = bit.tobit(x)
	local res = math.floor(vx / 2^n)
	return bit.tobit(res)
end

function bit.rol(x, n)
	n = tonumber(n) or 0
	n = n % 32
	if n == 0 then return bit.tobit(x) end
	local ux = to_uint32(x)
	local left = (ux * 2^n) % TWO32
	local right = math.floor(ux / 2^(32 - n))
	local res = (left + right) % TWO32
	return bit.tobit(res)
end

function bit.ror(x, n)
	n = tonumber(n) or 0
	n = n % 32
	if n == 0 then return bit.tobit(x) end
	local ux = to_uint32(x)
	local right = math.floor(ux / 2^n)
	local left = (ux * 2^(32 - n)) % TWO32
	local res = (left + right) % TWO32
	return bit.tobit(res)
end

function bit.bswap(x)
	local ux = to_uint32(x)
	local b0 = ux % 256
	local b1 = math.floor(ux / 256) % 256
	local b2 = math.floor(ux / 65536) % 256
	local b3 = math.floor(ux / 16777216) % 256
	local res = b0 * 16777216 + b1 * 65536 + b2 * 256 + b3
	return bit.tobit(res)
end

return bit]]
__bundle["require/help/client"] = [[local M = {}

function M.camera_angles(pitch, yaw)
  if pitch == nil and yaw == nil then
    return client.camera_angles()
  end
  return client.camera_angles(pitch, yaw)
end

function M.camera_position()
  return client.camera_position()
end

function M.color_log(r, g, b, ...)
  return client.color_log(r, g, b, ...)
end

function M.create_interface(module_name, interface_name)
  return client.create_interface(module_name, interface_name)
end

function M.current_threat()
  return client.current_threat()
end

function M.delay_call(delay, callback, ...)
  return client.delay_call(delay, callback, ...)
end

function M.draw_debug_text(x, y, z, line_offset, duration, r, g, b, a, ...)
  return client.draw_debug_text(x, y, z, line_offset, duration, r, g, b, a, ...)
end

function M.draw_hitboxes(entindex, duration, hitboxes, r, g, b, a, tick)
  return client.draw_hitboxes(entindex, duration, hitboxes, r, g, b, a, tick)
end

function M.error_log(msg)
  return client.error_log(msg)
end

function M.exec(...)
  return client.exec(...)
end

function M.eye_position()
  return client.eye_position()
end

function M.find_signature(module_name, pattern)
  return client.find_signature(module_name, pattern)
end

function M.fire_event(event_name, ...)
  return client.fire_event(event_name, ...)
end

function M.get_cvar(cvar_name)
  return client.get_cvar(cvar_name)
end

function M.get_model_name(model_index)
  return client.get_model_name(model_index)
end

function M.key_state(key)
  return client.key_state(key)
end

function M.latency()
  return client.latency()
end

function M.log(...)
  return client.log(...)
end

function M.random_float(minimum, maximum)
  return client.random_float(minimum, maximum)
end

function M.random_int(minimum, maximum)
  return client.random_int(minimum, maximum)
end

function M.real_latency()
  return client.real_latency()
end

function M.register_esp_flag(flag, r, g, b, callback)
  return client.register_esp_flag(flag, r, g, b, callback)
end

function M.reload_active_scripts()
  return client.reload_active_scripts()
end

function M.request_full_update()
  return client.request_full_update()
end

function M.scale_damage(entindex, hitgroup, damage)
  return client.scale_damage(entindex, hitgroup, damage)
end

function M.screen_size()
  return client.screen_size()
end

function M.set_clan_tag(...)
  return client.set_clan_tag(...)
end

function M.set_event_callback(event_name, callback)
  return client.set_event_callback(event_name, callback)
end

function M.system_time()
  return client.system_time()
end

function M.timestamp()
  return client.timestamp()
end

function M.trace_bullet(from_player, from_x, from_y, from_z, to_x, to_y, to_z, skip_players)
  return client.trace_bullet(from_player, from_x, from_y, from_z, to_x, to_y, to_z, skip_players)
end

function M.trace_line(skip_entindex, from_x, from_y, from_z, to_x, to_y, to_z)
  return client.trace_line(skip_entindex, from_x, from_y, from_z, to_x, to_y, to_z)
end

function M.unix_time()
  return client.unix_time()
end

function M.unset_event_callback(event_name, callback)
  return client.unset_event_callback(event_name, callback)
end

function M.update_player_list()
  return client.update_player_list()
end

function M.userid_to_entindex(userid)
  return client.userid_to_entindex(userid)
end

function M.visible(x, y, z)
  return client.visible(x, y, z)
end

return M]]
__bundle["require/help/color"] = [[local function hex_to_rgba(hex)
    hex = tostring(hex or "")
    local hex_only = hex:match("([0-9A-Fa-f]+)$")
    if not hex_only or #hex_only ~= 8 then
        return 255,255,255,255
    end
    local r = tonumber(hex_only:sub(1,2), 16)
    local g = tonumber(hex_only:sub(3,4), 16)
    local b = tonumber(hex_only:sub(5,6), 16)
    local a = tonumber(hex_only:sub(7,8), 16)
    return r,g,b,a
end

local function rgba_to_hex(r,g,b,a)
    return string.format("\a%02x%02x%02x%02x", tonumber(r) or 0, tonumber(g) or 0, tonumber(b) or 0, tonumber(a) or 255)
end

local function clamp(x)
    local n = tonumber(x) or 0
    if n < 0 then return 0 end
    if n > 255 then return 255 end
    return math.floor(n + 0.5)
end

local function lighten(r,g,b,a,amount)
    amount = tonumber(amount) or 32
    return clamp((r or 0) + amount), clamp((g or 0) + amount), clamp((b or 0) + amount), clamp(a or 255)
end

local function darken(r,g,b,a,amount)
    amount = tonumber(amount) or 32
    return clamp((r or 0) - amount), clamp((g or 0) - amount), clamp((b or 0) - amount), clamp(a or 255)
end

local base_colors = {
    default = "d6d6d6FF", 
    green  = "a5ca2aFF", 
    red    = "d96464FF", 
    reddark = "b22222FF", 
    orange = "dca53aFF", 
    yellow = "ccb854FF", 
    blue   = "5462ccFF", 
    cyan   = "54ccccFF", 
    purple = "7054ccFF", 
    white  = "ffffffFF", 
    grey   = "757575FF", 
    black  = "000000FF", 
    pink   = "c8a2deFF", 
    discord = "7289daFF", 
    youtube = "FF0000FF", 
    sellhub = "FFC107FF", 

}


local COLORS = {}
for name, hex in pairs(base_colors) do
    local r,g,b,a = hex_to_rgba(hex)
    COLORS[name] = {
        base = hex,
        lighter = rgba_to_hex(lighten(r,g,b,a,32)),
        darker  = rgba_to_hex(darken(r,g,b,a,32)),
        light2  = rgba_to_hex(lighten(r,g,b,a,64)),
        dark2   = rgba_to_hex(darken(r,g,b,a,64)),
        rgb = {r,g,b,a},
        log = {r,g,b},
        ui = hex,
    }
end

function COLORS.get(name, variant)
    variant = variant or "base"
    local entry = COLORS[name]
    if not entry then return nil end
    if variant == "log" and entry.log then
        return unpack(entry.log)
    elseif variant == "ui" and entry.ui then
        return "\a"..entry.ui
    elseif entry[variant] then
        return entry[variant]
    end
    return nil
end

function COLORS.blend(c1, c2, t)
    local r1,g1,b1,a1 = unpack(COLORS[c1].rgb)
    local r2,g2,b2,a2 = unpack(COLORS[c2].rgb)
    t = t or 0.5
    local r = clamp(r1 + (r2-r1)*t)
    local g = clamp(g1 + (g2-g1)*t)
    local b = clamp(b1 + (b2-b1)*t)
    local a = clamp(a1 + (a2-a1)*t)
    return rgba_to_hex(r,g,b,a)
end

function COLORS.hex_to_rgba(hex)
    return hex_to_rgba(hex)
end

function COLORS.rgba_to_hex(r,g,b,a)
    return rgba_to_hex(r,g,b,a)
end

function COLORS.clamp(r,g,b,a)
    return clamp(r), clamp(g), clamp(b), clamp(a)
end

function COLORS.normalize(r,g,b,a)
    return clamp(r), clamp(g), clamp(b), clamp(a or 255)
end

function COLORS.modulate(r,g,b,a, rm, gm, bm, am)
    rm = tonumber(rm) or 1
    gm = tonumber(gm) or rm
    bm = tonumber(bm) or rm
    am = tonumber(am) or 1
    local rr = clamp((tonumber(r) or 0) * rm)
    local gg = clamp((tonumber(g) or 0) * gm)
    local bb = clamp((tonumber(b) or 0) * bm)
    local aa = clamp((tonumber(a) or 255) * am)
    return rr, gg, bb, aa
end

function COLORS.alpha_modulate(a, factor)
    factor = tonumber(factor) or 1
    return clamp((tonumber(a) or 255) * factor)
end

return COLORS]]
__bundle["require/help/drag"] = [[local M = {}
local state = {}
local create_move_registered = false

local default_snap_anchors = {
	['top-left'] = function(sw,sh,w,h) return 0, 0 end,
	['top-center'] = function(sw,sh,w,h) return math.floor(sw/2 - w/2), 0 end,
	['top-right'] = function(sw,sh,w,h) return math.floor(sw - w), 0 end,
	['center-left'] = function(sw,sh,w,h) return 0, math.floor(sh/2 - h/2) end,
	['center'] = function(sw,sh,w,h) return math.floor(sw/2 - w/2), math.floor(sh/2 - h/2) end,
	['center-right'] = function(sw,sh,w,h) return math.floor(sw - w), math.floor(sh/2 - h/2) end,
	['bottom-left'] = function(sw,sh,w,h) return 0, math.floor(sh - h) end,
	['bottom-center'] = function(sw,sh,w,h) return math.floor(sw/2 - w/2), math.floor(sh - h) end,
	['bottom-right'] = function(sw,sh,w,h) return math.floor(sw - w), math.floor(sh - h) end,
}

local function inside_box(x,y,w,h, mx,my)
	if not mx or not my then return false end
	return mx >= x and mx <= x + w and my >= y and my <= y + h
end

local function clamp(n, lo, hi)
	if not n then return lo end
	if n < lo then return lo end
	if n > hi then return hi end
	return n
end

function M.new(id, opts)
	if not id then error('drag.new requires id') end
	opts = opts or {}
	local obj = {}
	obj.id = id
	obj.x = opts.x or 0
	obj.y = opts.y or 0
	obj.w = opts.w or 100
	obj.h = opts.h or 20
	obj.snap = opts.snap == nil and true or opts.snap
	obj.snap_threshold = opts.snap_threshold or 24
	obj.snap_positions = opts.snap_positions or nil
	obj.require_menu_open = opts.require_menu_open == nil and true or opts.require_menu_open
	obj.locked = opts.lock or false
	obj.box_color = opts.box_color or {255,255,255,100}
	obj.show_alignment = opts.show_alignment == nil and true or opts.show_alignment
	obj.align_color = opts.align_color or {255,255,255,100}
	obj.align_cross_size = opts.align_cross_size or 6
	obj.show_screen_guides = opts.show_screen_guides == nil and true or opts.show_screen_guides
	obj.line_snap_threshold = opts.line_snap_threshold or 6
	obj.bounds = opts.bounds or nil
	obj.constraint_center = opts.constraint_center or nil
	obj.constraint_box = opts.constraint_box or nil
	obj.default_pos = opts.default_pos or nil
	obj.default_center = opts.default_center or nil

	local s = {
		obj = obj,
		dragging = false,
		drag_offset_x = 0,
		drag_offset_y = 0,
		last_left = false,
		last_right = false,
		locked_to = nil,
		snap_progress = 0,
		snap_target = 0,
		line_snap_progress_x = 0,
		line_snap_progress_y = 0,
		line_snap_target_x = 0,
		line_snap_target_y = 0,
		drag_button = nil,
		disable_snap = false,
	}
	state[id] = s

	local ok_db, saved_positions = pcall(database.read, 'drag_positions')
	if ok_db and type(saved_positions) == 'table' and saved_positions[id] then
		local sp = saved_positions[id]
		if type(sp.x) == 'number' and type(sp.y) == 'number' then
			obj.x = sp.x
			obj.y = sp.y
		end
	end

	if not create_move_registered then
		client.set_event_callback('setup_command', function(cmd)
			for _, st in pairs(state) do
				if st.dragging then
					pcall(function()
						cmd.in_attack = false
						cmd.in_attack2 = false
					end)
					break
				end
			end
		end)
		create_move_registered = true
	end

	function obj:set_pos(x,y)
		self.x = x
		self.y = y
	end
	function obj:set_size(w,h)
		self.w = w; self.h = h
	end
	function obj:set_bounds(x,y,w,h)
		self.bounds = { x = x, y = y, w = w, h = h }
	end
	function obj:clear_bounds()
		self.bounds = nil
	end
	function obj:get_pos()
		return self.x, self.y
	end
	function obj:is_dragging()
		return not not s.dragging
	end
	function obj:get_bounds()
		return self.bounds
	end
	function obj:set_locked(v)
		self.locked = not not v
	end
	function obj:set_snap(v)
		self.snap = not not v
	end
	function obj:toggle_snap()
		self.snap = not self.snap
	end
	function obj:reset_to_anchor(anchor)
		local sw, sh = client.screen_size()
		if not sw or not sh then return end
		local fn = default_snap_anchors[anchor]
		if type(fn) == 'function' then
			local nx, ny = fn(sw,sh,self.w,self.h)
			self.x = nx; self.y = ny
			s.locked_to = anchor
		end
	end

	function obj:handle()
		if self.locked then return end
		local sw, sh = client.screen_size()
		if not sw or not sh then return end
		if self.require_menu_open and not ui.is_menu_open() then s.last_left = false; return end

		local mx, my = ui.mouse_position()
		local left = client.key_state(1)
		local right = client.key_state(2)

		if left and right and (inside_box(self.x, self.y, self.w, self.h, mx, my) or s.dragging) then
			if self.default_pos then
				self.x = self.default_pos.x
				self.y = self.default_pos.y
				return
			elseif self.default_center then
				self.x = (self.default_center.x or 0) - math.floor(self.w/2)
				self.y = (self.default_center.y or 0) - math.floor(self.h/2)
				return
			end
		end
		if left and not s.last_left and inside_box(self.x, self.y, self.w, self.h, mx, my) then
			s.dragging = true
			s.drag_button = 1
			s.disable_snap = false
			s.drag_offset_x = mx - self.x
			s.drag_offset_y = my - self.y
			s.locked_to = nil
		elseif right and not s.last_right and inside_box(self.x, self.y, self.w, self.h, mx, my) then
			s.dragging = true
			s.drag_button = 2
			s.disable_snap = true
			s.drag_offset_x = mx - self.x
			s.drag_offset_y = my - self.y
			s.locked_to = nil
			s.snap_target = 0
			s.line_snap_target_x = 0
			s.line_snap_target_y = 0
		end

		if (left and s.dragging and s.drag_button == 1) or (right and s.dragging and s.drag_button == 2) then
			local nx = mx - s.drag_offset_x
			local ny = my - s.drag_offset_y
			local minx, maxx = 0, math.max(0, sw - self.w)
			local miny, maxy = 0, math.max(0, sh - self.h)
			if self.constraint_center then
				local c = self.constraint_center
				local cx = c.cx or math.floor(sw/2)
				local cy = c.cy or math.floor(sh/2)
				local r = c.radius or 0
				minx = (cx - r) - math.floor(self.w/2)
				maxx = (cx + r) - math.floor(self.w/2)
				miny = (cy - r) - math.floor(self.h/2)
				maxy = (cy + r) - math.floor(self.h/2)
			elseif self.bounds or self.constraint_box then
				local b = self.bounds or self.constraint_box
				local bx = b.x or b[1] or 0
				local by = b.y or b[2] or 0
				local bw = b.w or b[3] or (sw - bx)
				local bh = b.h or b[4] or (sh - by)
				minx = bx
				maxx = math.max(bx, bx + bw - self.w)
				miny = by
				maxy = math.max(by, by + bh - self.h)
			end
			nx = clamp(nx, minx, maxx)
			ny = clamp(ny, miny, maxy)
			self.x = nx; self.y = ny
			if self.snap and not s.disable_snap then
				local candidates = {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and default_snap_anchors[p] then
							local fn = default_snap_anchors[p]
							local tx, ty = fn(sw,sh,self.w,self.h)
							table.insert(candidates, {x=tx,y=ty})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(candidates, {x=p[1], y=p[2]})
						end
					end
				else
					for k,fn in pairs(default_snap_anchors) do
						local tx, ty = fn(sw,sh,self.w,self.h)
						table.insert(candidates, {x=tx,y=ty})
					end
				end
				local bestd = math.huge
				for _,c in ipairs(candidates) do
					local dx = (c.x - self.x)
					local dy = (c.y - self.y)
					local d = math.sqrt(dx*dx + dy*dy)
					if d < bestd then bestd = d end
				end
				if bestd <= self.snap_threshold then s.snap_target = 1 else s.snap_target = 0 end
				local scx = math.floor(sw/2)
				local scy = math.floor(sh/2)
				local cx = math.floor(self.x + self.w/2)
				local cy = math.floor(self.y + self.h/2)
				if math.abs(cx - scx) <= (self.line_snap_threshold or 6) then s.line_snap_target_x = 1 else s.line_snap_target_x = 0 end
				if math.abs(cy - scy) <= (self.line_snap_threshold or 6) then s.line_snap_target_y = 1 else s.line_snap_target_y = 0 end
			end
		end

		local released = false
		if s.dragging then
			if s.drag_button == 1 and not left and s.last_left then released = true end
			if s.drag_button == 2 and not right and s.last_right then released = true end
		end
		if released then
			if not s.disable_snap then
				local scx, scy = math.floor(sw/2), math.floor(sh/2)
				local cx = math.floor(self.x + self.w/2)
				local cy = math.floor(self.y + self.h/2)
				if self.show_screen_guides then
					if math.abs(cx - scx) <= (self.line_snap_threshold or 6) then
						self.x = scx - math.floor(self.w/2)
					end
					if math.abs(cy - scy) <= (self.line_snap_threshold or 6) then
						self.y = scy - math.floor(self.h/2)
					end
				end
			end
			s.dragging = false
			local ok_read, positions = pcall(database.read, 'drag_positions')
			local pos_tbl = (ok_read and type(positions) == 'table') and positions or {}
			pos_tbl[self.id] = { x = self.x, y = self.y }
			pcall(function() database.write('drag_positions', pos_tbl) end)
			if self.snap and not s.disable_snap then
				local candidates = {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and default_snap_anchors[p] then
							local fn = default_snap_anchors[p]
							local tx, ty = fn(sw,sh,self.w,self.h)
							table.insert(candidates, {x=tx,y=ty, key=p})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(candidates, {x=p[1], y=p[2], key=nil})
						end
					end
				else
					for k,fn in pairs(default_snap_anchors) do
						local tx, ty = fn(sw,sh,self.w,self.h)
						table.insert(candidates, {x=tx,y=ty, key=k})
					end
				end
				local best, bestd = nil, math.huge
				for _,c in ipairs(candidates) do
					local dx = (c.x - self.x)
					local dy = (c.y - self.y)
					local d = math.sqrt(dx*dx + dy*dy)
					if d < bestd then bestd = d; best = c end
				end
				if best and bestd <= self.snap_threshold then
					self.x = best.x; self.y = best.y
					s.locked_to = best.key
				end
			end
		end

		s.last_left = left
		s.last_right = right
	end

	function obj:draw()
		local s = state[self.id]
		if not s then return end
		if s.dragging then
			local r,g,b,a = unpack(self.box_color)
			local ar,ag,ab,aa = unpack(self.align_color)
			local dt = globals.frametime() or 0.016
			local smooth = math.min(1, 12 * dt)
			s.snap_progress = s.snap_progress + (s.snap_target - s.snap_progress) * smooth
			s.line_snap_progress_x = s.line_snap_progress_x + (s.line_snap_target_x - s.line_snap_progress_x) * smooth
			s.line_snap_progress_y = s.line_snap_progress_y + (s.line_snap_target_y - s.line_snap_progress_y) * smooth
			local tr = math.floor(r + (0 - r) * s.snap_progress)
			local tg = math.floor(g + (0 - g) * s.snap_progress)
			local tb = math.floor(b + (0 - b) * s.snap_progress)
			local ta = math.floor(a + (200 - a) * s.snap_progress)
			renderer.rectangle(self.x, self.y, self.w, self.h, tr, tg, tb, ta)
			renderer.line(self.x, self.y, self.x + self.w, self.y, 200,200,200,150)
			renderer.line(self.x + self.w, self.y, self.x + self.w, self.y + self.h, 200,200,200,150)
			renderer.line(self.x + self.w, self.y + self.h, self.x, self.y + self.h, 200,200,200,150)
			renderer.line(self.x, self.y + self.h, self.x, self.y, 200,200,200,150)
			if self.show_alignment then
				local sw, sh = client.screen_size()
				if sw and sh then
					if self.show_screen_guides then
						local scx = math.floor(sw/2)
						local scy = math.floor(sh/2)
						local cx = math.floor(self.x + self.w/2)
						local cy = math.floor(self.y + self.h/2)
						local closeX = math.abs(cx - scx) <= (self.line_snap_threshold or 6)
						local closeY = math.abs(cy - scy) <= (self.line_snap_threshold or 6)
						local guide_a = math.floor(aa * 0.35)
						renderer.line(scx, scy, 0, scy, ar,ag,ab, guide_a)
						renderer.line(scx, scy, scx, 0, ar,ag,ab, guide_a)
						renderer.line(scx, scy, sw, scy, ar,ag,ab, guide_a)
						renderer.line(scx, scy, scx, sh, ar,ag,ab, guide_a)
						local highlight_ax = math.floor(aa * s.line_snap_progress_x)
						local highlight_ay = math.floor(aa * s.line_snap_progress_y)
						if highlight_ax > 0 then renderer.line(scx, 0, scx, sh, ar,ag,ab, highlight_ax) end
						if highlight_ay > 0 then renderer.line(0, scy, sw, scy, ar,ag,ab, highlight_ay) end
					end
				end
			end
			if self.constraint_center then
				local c = self.constraint_center
				local cx = c.cx or math.floor((client.screen_size()) / 2)
				local cy = c.cy or math.floor((client.screen_size()) / 2)
				local r = c.radius or 0
				local bx = cx - r
				local by = cy - r
				local bw = r * 2
				local bh = r * 2
				renderer.rectangle(bx, by, bw, bh, 255, 255, 255, 60)
				renderer.line(bx, by, bx + bw, by, 255, 255, 255, 160)
				renderer.line(bx + bw, by, bx + bw, by + bh, 255, 255, 255, 160)
				renderer.line(bx + bw, by + bh, bx, by + bh, 255, 255, 255, 160)
				renderer.line(bx, by + bh, bx, by, 255, 255, 255, 160)
			end
		end
	end

	return obj
end

function M.get(id)
	local s = state[id]
	if not s then return nil end
	return s.obj
end

function M.ids()
	local out = {}
	for k,_ in pairs(state) do table.insert(out, k) end
	return out
end

return M]]
__bundle["require/help/emojis"] = [[local icons = {

    chat = { "" },
    rewind = { "" },
    thumbsup = { "" },
    mail = { "U+E135" },
    square = { "" },
    square2 = { "" },
    square_hollow = { "" },
    play = { "" },
    pause = { "" },
    sun = { "" },
    pc = { "" },
    pc2 = { "" },
    phone = { "U+E1C9" },
    trash = { "" },
    reject = { "" },
    accept = { "" },
    config = { "" },
    config_write = { "U+E28F" },
    gear = { "" },
    arrow_right = { "" },
    arrow_left = { "" },
    arrow_up = { "" },
    arrow_down = { "" },
    star = { "U+E0B4" },
    minus = { "" },
    plus = { "" },
    plus_in_brackets = { "U+E0C5" },
    pen = { "" },
    recycle = { "" },
    camera = { "" },
    download = { "" },
    upload = { "" },
    question = { "" },
    search = { "" },
    globe = { "" },
    globe2 = { "" },
    id = { "" },
    phone = { "" },
    user = { "" },
    user2 = { "U+E2AF" },
    user3 = { "U+E13D" },
    users = { "" },
    users2 = { "U+E125" },
    user_no = { "U+E1E0" },
    pin = { "" },
    unpin = { "U+E196" },
    windows = { "" },
    turning = { "" },
    turning2 = { "" },
    arrow_double = { "" },
    clip = { "" },
    clipboard = { "U+E16D" },
    exclamation = { "" },
    time = { "" },
    clock = { "U+E2AD" },
    paper = { "" },
    paper2 = { "" },
    link = { "" },
    link2 = { "U+E167" },
    wrench = { "" },
    url = { "" },
    speaker = { "" },
    house = { "" },
    pallete = { "" },
    lock = { "" },
    lock_open = { "" },
    tsarrow_left = { "" },
    tsarrow_right = { "" },
    tsarrow_up = { "" },
    tsarrow_up = { "" },
    warning = { "⚠︎" },
    video = { "" },
    connection = { "" },
    heart = { "" },
    triangle_upside = { "⛛" },
    music_note = { "U+E142" },
    test = { "U+E2B1" },
    keyboard = { "U+E0D2" },
    latency0 = { "U+E1E5" },
    latency1 = { "U+E1E6" },
    latency2 = { "U+E1E7" },
    latency3 = { "U+E1E8" },
    latency4 = { "U+E1E9" },
    expand = { "U+E1D9" },
    monitor = { "U+E2F0" },
    rain = { "U+E28A" },
    likedislike = { "U+E19D" },
    text = { "U+E1C8" },
    back = { "U+E10E" },
    folder = { "U+E1C1" },
    menu = { "U+E179" },
    menu2 = { "U+E1A0" },
    at = { "U+E168" },
    circle = { "U+E235" },
    updown = { "U+E174" },

}

local M = {}

local function format_emoji(s)
    if s == nil then return "ERROR" end
    if type(s) ~= "string" then s = tostring(s) end
    if s == "ERROR" then return "ERROR" end
    local hex = s:match('^U%+([0-9A-Fa-f]+)$') or s:match('^u%+([0-9A-Fa-f]+)$') or s:match('^0x([0-9A-Fa-f]+)$')
    if hex then
        local cp = tonumber(hex, 16)
        if cp then
            local glyph = nil
            if type(utf8) == 'table' and type(utf8.char) == 'function' then
                pcall(function() glyph = utf8.char(cp) end)
            end
            if not glyph then
                local function cp_to_utf8(n)
                    if n < 0x80 then return string.char(n) end
                    if n < 0x800 then return string.char(0xC0 + math.floor(n / 0x40), 0x80 + (n % 0x40)) end
                    if n < 0x10000 then return string.char(0xE0 + math.floor(n / 0x1000), 0x80 + (math.floor(n / 0x40) % 0x40), 0x80 + (n % 0x40)) end
                    if n < 0x110000 then return string.char(0xF0 + math.floor(n / 0x40000), 0x80 + (math.floor(n / 0x1000) % 0x40), 0x80 + (math.floor(n / 0x40) % 0x40), 0x80 + (n % 0x40)) end
                    return '?'
                end
                glyph = cp_to_utf8(cp)
            end
            s = glyph or s
        end
    end
    if s:sub(-1) == " " then return s end
    return s .. " "
end

function M.get(key, default, index)
    if not key then return "ERROR" end
    local v = icons[key]
    if v == nil then return "ERROR" end
    if type(v) == "string" then return format_emoji(v) end
    if type(v) == "table" then
        if index == nil then
            return format_emoji(v[1])
        end
        local i = tonumber(index) or 1
        return format_emoji(v[i])
    end
    return "ERROR"
end

function M.set(key, value)
	if not key then return false end
	if type(value) == "string" then
		icons[key] = { value }
	else
		icons[key] = value
	end
	return true
end

function M.list()
	local t = {}
	for k, v in pairs(icons) do
		if type(v) == "table" then
			local copy = {}
			for i = 1, #v do copy[i] = v[i] end
			t[k] = copy
		else
			t[k] = v
		end
	end
	return t
end

setmetatable(M, {
    __index = function(_, k)
        local v = icons[k]
        if v == nil then return "ERROR" end
        if type(v) == "table" then return format_emoji(v[1]) end
        return format_emoji(v)
    end,
})

return M]]
__bundle["require/help/enemies"] = [[local M = {}

local entity = entity
local client = client
local globals = globals

function M.list()
    return entity and entity.get_players and entity.get_players(true) or {}
end

function M.is_alive(idx)
    return idx and entity.is_alive and entity.is_alive(idx) or false
end

function M.is_dormant(idx)
    return idx and entity.is_dormant and entity.is_dormant(idx) or false
end

function M.player_name(idx)
    return idx and entity.get_player_name and entity.get_player_name(idx) or nil
end

function M.steam64(idx)
    return idx and entity.get_steam64 and entity.get_steam64(idx) or nil
end

function M.health(idx)
    return idx and entity.get_prop and entity.get_prop(idx, 'm_iHealth') or 0
end

function M.current_threat()
    return client and client.current_threat and client.current_threat() or nil
end

local afk_tracker = {}

function M.is_afk(idx, threshold, duration)
    threshold = threshold or 5
    duration = duration or 20
    local vx, vy, vz = entity.get_prop(idx, 'm_vecVelocity')
    local speed = 0
    if vx and vy and vz then
        speed = math.sqrt(vx * vx + vy * vy + vz * vz)
    end
    local now = globals and globals.realtime and globals.realtime() or os.clock()
    if not afk_tracker[idx] then
        afk_tracker[idx] = { last_active = now, last_check = now }
    end
    if speed >= threshold then
        afk_tracker[idx].last_active = now
    end
    afk_tracker[idx].last_check = now
    return (now - afk_tracker[idx].last_active) > duration
end

function M.distance(idx, other_idx)
    if not idx or not entity.get_origin then return nil end
    local ax, ay, az = entity.get_origin(idx)
    if not ax then return nil end
    if not other_idx then
        other_idx = entity.get_local_player and entity.get_local_player()
    end
    local bx, by, bz = entity.get_origin(other_idx)
    if not bx then return nil end
    local dx, dy, dz = ax - bx, ay - by, az - bz
    return math.sqrt(dx * dx + dy * dy + dz * dz)
end


local function _lower(v)
    if not v then return "" end
    return tostring(v):lower()
end

local function _wep_class_or_model(wep)
    local cn = ""
    if wep and entity.get_classname then cn = entity.get_classname(wep) or "" end
    if cn == "" and wep and client.get_model_name then
        cn = client.get_model_name(wep) or ""
    end
    return _lower(cn)
end

function M.has_knife(idx)
    if not idx or not entity.get_player_weapon then return false end
    local wep = entity.get_player_weapon(idx)
    if not wep then return false end
    local s = _wep_class_or_model(wep)
    return s:find('knife') ~= nil
end

function M.has_nade(idx)
    if not idx or not entity.get_player_weapon then return false end
    local wep = entity.get_player_weapon(idx)
    if not wep then return false end
    local s = _wep_class_or_model(wep)
    local subs = {'grenade', 'hegrenade', 'flashbang', 'smoke', 'molotov', 'incendiary', 'decoy', 'frag', 'nade'}
    for i = 1, #subs do
        if s:find(subs[i]) then return true end
    end
    return false
end

function M.has_taser(idx)
    if not idx or not entity.get_player_weapon then return false end
    local wep = entity.get_player_weapon(idx)
    if not wep then return false end
    local s = _wep_class_or_model(wep)
    return s:find('taser') ~= nil or s:find('zeus') ~= nil
end

return M]]
__bundle["require/help/ffi"] = [[local _ffi = rawget(_G, 'ffi')
local M = {}

function M.available()
  return _ffi ~= nil
end

function M.cdef(s)
  if not _ffi then error('ffi not available') end
  return _ffi.cdef(s)
end

function M.typeof(t)
  if not _ffi then error('ffi not available') end
  return _ffi.typeof(t)
end

function M.new(t, ...)
  if not _ffi then error('ffi not available') end
  return _ffi.new(t, ...)
end

function M.cast(t, v)
  if not _ffi then error('ffi not available') end
  return _ffi.cast(t, v)
end

function M.string(cdata, size)
  if not _ffi then error('ffi not available') end
  return _ffi.string(cdata, size)
end

function M.copy(dest, src, size)
  if not _ffi then error('ffi not available') end
  return _ffi.copy(dest, src, size)
end

function M.fill(dest, value, size)
  if not _ffi then error('ffi not available') end
  return _ffi.fill(dest, value, size)
end

function M.sizeof(t)
  if not _ffi then error('ffi not available') end
  return _ffi.sizeof(t)
end

function M.alignof(t)
  if not _ffi then error('ffi not available') end
  return _ffi.alignof(t)
end

function M.errno()
  if not _ffi then error('ffi not available') end
  return _ffi.errno()
end

function M.gc(cdata, fn)
  if not _ffi then error('ffi not available') end
  return _ffi.gc(cdata, fn)
end

function M.load(libname, global)
  if not _ffi then error('ffi not available') end
  return _ffi.load(libname, global)
end

function M.metatype(t, mt)
  if not _ffi then error('ffi not available') end
  return _ffi.metatype(t, mt)
end

function M.offsetof(t, field)
  if not _ffi then error('ffi not available') end
  return _ffi.offsetof(t, field)
end

function M.istype(t, v)
  if not _ffi then error('ffi not available') end
  return _ffi.istype(t, v)
end

M.raw = _ffi

return M]]
__bundle["require/help/globals"] = [[local M = {}

M.raw = globals

function M.absoluteframetime()
  return globals.absoluteframetime()
end

function M.chokedcommands()
  return globals.chokedcommands()
end

function M.commandack()
  return globals.commandack()
end

function M.curtime()
  return globals.curtime()
end

function M.framecount()
  return globals.framecount()
end

function M.frametime()
  return globals.frametime()
end

function M.lastoutgoingcommand()
  return globals.lastoutgoingcommand()
end

function M.mapname()
  return globals.mapname()
end

function M.maxplayers()
  return globals.maxplayers()
end

function M.oldcommandack()
  return globals.oldcommandack()
end

function M.realtime()
  return globals.realtime()
end

function M.servertickcount()
  return globals.servertickcount()
end

function M.tickcount()
  return globals.tickcount()
end

function M.tickinterval()
  return globals.tickinterval()
end

return M]]
__bundle["require/help/json"] = [[local _json = rawget(_G, 'json')
local M = {}

function M.available()
  return _json ~= nil
end

function M.decode_invalid_numbers(setting)
  if not _json then error('json not available') end
  if setting == nil then
    return _json.decode_invalid_numbers()
  end
  return _json.decode_invalid_numbers(setting)
end

function M.decode_max_depth(depth)
  if not _json then error('json not available') end
  if depth == nil then
    return _json.decode_max_depth()
  end
  return _json.decode_max_depth(depth)
end

function M.encode_invalid_numbers(setting)
  if not _json then error('json not available') end
  if setting == nil then
    return _json.encode_invalid_numbers()
  end
  return _json.encode_invalid_numbers(setting)
end

function M.encode_max_depth(depth)
  if not _json then error('json not available') end
  if depth == nil then
    return _json.encode_max_depth()
  end
  return _json.encode_max_depth(depth)
end

function M.encode_number_precision(precision)
  if not _json then error('json not available') end
  if precision == nil then
    return _json.encode_number_precision()
  end
  return _json.encode_number_precision(precision)
end

function M.encode_sparse_array(...)
  if not _json then error('json not available') end
  return _json.encode_sparse_array(...)
end

function M.parse(text)
  if not _json then error('json not available') end
  if _json.parse then
    return _json.parse(text)
  end
  if _json.decode then
    return _json.decode(text)
  end
  error('json.parse / json.decode not available')
end

function M.stringify(obj)
  if not _json then error('json not available') end
  if _json.stringify then
    return _json.stringify(obj)
  end
  if _json.encode then
    return _json.encode(obj)
  end
  error('json.stringify / json.encode not available')
end

M.raw = _json

return M]]
__bundle["require/help/libs"] = [[local function safe_require(name)
	local ok, lib = pcall(require, name)
	return ok and lib or nil
end

local lib_defs = {
	antiaim_funcs   = 'gamesense/antiaim_funcs',
	base64          = 'gamesense/base64',
	clipboard       = 'gamesense/clipboard',
	http            = 'gamesense/http',
	csgo_weapons    = 'gamesense/csgo_weapons',
	icons           = 'gamesense/icons',
	entity          = 'gamesense/entity',
	vector          = 'vector',
	bit             = 'bit',
	ffi             = 'ffi',
	pui             = 'gamesense/pui',
	trace           = 'gamesense/trace',
	md5             = 'gamesense/md5',
	websocket       = 'gamesense/websocket',
	surface         = 'gamesense/surface',
	color           = 'gamesense/color',
}

local libs = {}
for k, v in pairs(lib_defs) do
	libs[k] = safe_require(v)
end

local features = {
	antiaim_funcs = {
		get_tickbase_shifting = "Returns true if tickbase shifting is active.",
		get_fake_lag = "Returns current fake lag value.",
		get_desync = "Returns current desync value.",
		get_manual_direction = "Returns manual anti-aim direction.",
		get_antiaim_condition = "Returns current anti-aim condition.",
		get_body_yaw = "Returns current body yaw value.",
		get_yaw_base = "Returns current yaw base value.",
		get_pitch = "Returns current pitch value.",
		get_yaw_jitter = "Returns current yaw jitter value.",
		get_enabled = "Returns if anti-aim is enabled.",
		get_fakelag_mode = "Returns fakelag mode.",
		get_fakelag_limit = "Returns fakelag limit.",
		get_fakelag_variance = "Returns fakelag variance.",
		get_fakelag_enabled = "Returns if fakelag is enabled.",
		get_double_tap = "Returns true if double tap exploit is active.",
		get_overlap = "Returns overlap value (exploit related).",
	},
	base64 = {
		encode = "Encodes a string to base64.",
		decode = "Decodes a base64 string.",
	},
	clipboard = {
		get = "Gets clipboard contents as string.",
		set = "Sets clipboard contents to string.",
	},
	http = {
		get = "Performs HTTP GET request.",
		post = "Performs HTTP POST request.",
		download = "Downloads a file from URL.",
	},
	csgo_weapons = {
		get_weapon_name = "Returns weapon name by id.",
		get_weapon_id = "Returns weapon id by name.",
		get_weapon_type = "Returns weapon type by id.",
		get_weapon_group = "Returns weapon group by id.",
		get_weapon_slot = "Returns weapon slot by id.",
		get_weapon_price = "Returns weapon price by id.",
	},
	icons = {
		hero = "Table of hero icons.",
		get_texture = "Returns texture id for icon name.",
		get_icon = "Returns icon object by name.",
		get_all_icons = "Returns all available icons.",
	},
	entity = {
		get_local_player = "Returns entindex of local player.",
		get_all = "Returns array of entindices for all entities.",
		get_players = "Returns array of player entindices.",
		get_game_rules = "Returns entindex of game rules proxy.",
		get_player_resource = "Returns entindex of player resource.",
		get_classname = "Returns classname of entity.",
		set_prop = "Sets netvar property.",
		get_prop = "Gets netvar property.",
		is_enemy = "Returns true if entity is enemy.",
		is_alive = "Returns true if entity is alive.",
		is_dormant = "Returns true if entity is dormant.",
		get_player_name = "Returns player name.",
		get_player_weapon = "Returns active weapon entindex.",
		hitbox_position = "Returns world position of hitbox.",
		get_steam64 = "Returns SteamID3.",
		get_bounding_box = "Returns bounding box coordinates.",
		get_origin = "Returns world origin of entity.",
		get_esp_data = "Returns ESP data for player.",
	},
	vector = {
		new = "Creates a new vector object.",
		dot = "Returns dot product of two vectors.",
		cross = "Returns cross product of two vectors.",
		length = "Returns length of vector.",
		normalize = "Normalizes vector.",
		add = "Adds two vectors.",
		sub = "Subtracts two vectors.",
		mul = "Multiplies vector by scalar.",
		div = "Divides vector by scalar.",
		dist = "Returns distance between two vectors.",
	},
	bit = {
		arshift = "Arithmetic right shift.",
		band = "Bitwise AND.",
		bnot = "Bitwise NOT.",
		bor = "Bitwise OR.",
		bswap = "Byte swap (endian conversion).",
		bxor = "Bitwise XOR.",
		lshift = "Logical left shift.",
		rol = "Bitwise left rotation.",
		ror = "Bitwise right rotation.",
		rshift = "Logical right shift.",
		tobit = "Normalize to 32-bit signed.",
		tohex = "Convert to hexadecimal string.",
	},
	ffi = {
		cdef = "Define C types/functions.",
		cast = "Cast value to C type.",
		new = "Allocate new C object.",
		typeof = "Get C type object.",
		string = "Convert C data to Lua string.",
	},
	pui = {
		create_panel = "Creates a custom UI panel.",
		add_icon = "Adds an icon to a panel.",
		set_icon = "Sets the icon for a panel.",
		set_panel_visible = "Shows/hides a panel.",
		set_panel_position = "Sets panel position.",
		set_panel_size = "Sets panel size.",
	},
	trace = {
		trace_line = "Performs a line trace.",
		trace_bullet = "Performs a bullet trace.",
		trace_hull = "Performs a hull trace.",
	},
	md5 = {
		sumhexa = "Returns MD5 hash as hex string.",
		sum = "Returns MD5 hash as raw bytes.",
	},
	websocket = {
		connect = "Connects to a WebSocket server.",
		send = "Sends data over WebSocket.",
		close = "Closes the WebSocket connection.",
		on_message = "Callback for incoming messages.",
	},
	surface = {
		text = "Draws text on screen.",
		rectangle = "Draws a rectangle.",
		line = "Draws a line.",
		circle = "Draws a circle.",
		gradient = "Draws a gradient rectangle.",
		load_texture = "Loads a texture from file.",
	},
	color = {
		blend = "Blends two colors.",
		lighten = "Lightens a color.",
		darken = "Darkens a color.",
		hex_to_rgba = "Converts hex to RGBA.",
		rgba_to_hex = "Converts RGBA to hex.",
	},
}

local function get(name)
	return libs[name]
end

function list()
	local out = {}
	for k, v in pairs(_G) do
		if type(v) == "table" or type(v) == "userdata" then
			out[#out+1] = k
		end
	end
	return out
end

function list_features(libname)
	local feats = features[libname]
	if not feats then return {} end
	local out = {}
	for k, v in pairs(feats) do
		out[#out+1] = k .. " - " .. v
	end
	return out
end

return {
	get = get,
	list = list,
	list_features = list_features,
	features = features,
	libs = libs,
	lib_defs = lib_defs
}
]]
__bundle["require/help/math"] = [[local M = {}

function M.clamp(val, min, max)
    if not min and not max then return val end
    min = tonumber(min) or 0
    max = tonumber(max) or min
    if min > max then min, max = max, min end
    val = tonumber(val) or min
    if val < min then return min end
    if val > max then return max end
    return val
end

function M.clamp01(val)
    return M.clamp(val, 0, 1)
end

function M.abs(val)
    val = tonumber(val) or 0
    return math.abs(val)
end

function M.max(...)
    local args = {...}
    if #args == 0 then return 0 end
    local m = nil
    for i = 1, #args do
        local v = tonumber(args[i]) or 0
        if m == nil or v > m then m = v end
    end
    return m
end

function M.min(...)
    local args = {...}
    if #args == 0 then return 0 end
    local m = nil
    for i = 1, #args do
        local v = tonumber(args[i]) or 0
        if m == nil or v < m then m = v end
    end
    return m
end

function M.atan2(y, x)
    y = tonumber(y) or 0
    x = tonumber(x) or 0
    return math.atan(y, x)
end

function M.floor(val)
    val = tonumber(val) or 0
    return math.floor(val)
end

function M.round(val, decimals)
    val = tonumber(val) or 0
    decimals = tonumber(decimals) or 0
    local mult = 10 ^ decimals
    return math.floor(val * mult + 0.5) / mult
end

function M.lerp(a, b, t)
    a = tonumber(a) or 0
    b = tonumber(b) or 0
    t = tonumber(t) or 0
    return a + (b - a) * t
end

function M.distance2d(x1, y1, x2, y2)
    x1 = tonumber(x1) or 0
    y1 = tonumber(y1) or 0
    x2 = tonumber(x2) or 0
    y2 = tonumber(y2) or 0
    return math.sqrt((x2 - x1)^2 + (y2 - y1)^2)
end

function M.distance3d(x1, y1, z1, x2, y2, z2)
    x1 = tonumber(x1) or 0
    y1 = tonumber(y1) or 0
    z1 = tonumber(z1) or 0
    x2 = tonumber(x2) or 0
    y2 = tonumber(y2) or 0
    z2 = tonumber(z2) or 0
    return math.sqrt((x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2)
end

function M.sign(val)
    val = tonumber(val) or 0
    return (val > 0 and 1) or (val < 0 and -1) or 0
end

function M.frac(val)
    val = tonumber(val) or 0
    return val - math.floor(val)
end

function M.is_even(val)
    val = tonumber(val) or 0
    return val % 2 == 0
end

function M.is_odd(val)
    val = tonumber(val) or 0
    return val % 2 ~= 0
end

function M.sqr(val)
    val = tonumber(val) or 0
    return val * val
end

function M.cube(val)
    val = tonumber(val) or 0
    return val * val * val
end

function M.approximately(a, b, epsilon)
    a = tonumber(a) or 0
    b = tonumber(b) or 0
    epsilon = tonumber(epsilon) or 1e-6
    return math.abs(a - b) < epsilon
end

function M.rad_to_deg(rad)
    rad = tonumber(rad) or 0
    return rad * (180 / math.pi)
end

function M.deg_to_rad(deg)
    deg = tonumber(deg) or 0
    return deg * (math.pi / 180)
end

function M.wrap_degrees(angle)
    local a = tonumber(angle) or 0
    a = a % 360
    if a < 0 then a = a + 360 end
    return a
end

function M.normalize_angle(angle)
    local a = tonumber(angle) or 0
    a = a % 360
    if a > 180 then a = a - 360 end
    return a
end

function M.angle_diff(a, b)
    a = tonumber(a) or 0
    b = tonumber(b) or 0
    local diff = (a - b) % 360
    if diff > 180 then diff = diff - 360 end
    return diff
end

function M.lerp_angle(a, b, t)
    a = tonumber(a) or 0
    b = tonumber(b) or 0
    t = tonumber(t) or 0
    local diff = M.angle_diff(b, a)
    return (a + diff * t) % 360
end

function M.map(val, in_min, in_max, out_min, out_max)
    val = tonumber(val) or 0
    in_min = tonumber(in_min) or 0
    in_max = tonumber(in_max) or in_min
    out_min = tonumber(out_min) or 0
    out_max = tonumber(out_max) or out_min
    if in_max == in_min then return out_min end
    return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min
end

function M.smoothstep(edge0, edge1, x)
    edge0 = tonumber(edge0) or 0
    edge1 = tonumber(edge1) or edge0
    x = tonumber(x) or 0
    if edge1 == edge0 then return 0 end
    local t = M.clamp((x - edge0) / (edge1 - edge0), 0, 1)
    return t * t * (3 - 2 * t)
end

function M.random_float(min, max)
    min = tonumber(min) or 0
    max = tonumber(max) or min
    if min > max then min, max = max, min end
    return min + math.random() * (max - min)
end

function M.random_int(min, max)
    min = tonumber(min) or 0
    max = tonumber(max) or min
    if min > max then min, max = max, min end
    return math.random(min, max)
end

function M.mean(tbl)
    if type(tbl) ~= 'table' or #tbl == 0 then return 0 end
    local sum = 0
    for i = 1, #tbl do sum = sum + (tonumber(tbl[i]) or 0) end
    return sum / #tbl
end

function M.swap(a, b)
    return b, a
end

return M]]
__bundle["require/help/panorama"] = [[local M = {}

M.raw = panorama

function M.loadstring(js_code, panel)
  return panorama.loadstring(js_code, panel)
end

function M.open(panel)
  return panorama.open(panel)
end

return M]]
__bundle["require/help/plist"] = [[local M = {}

M.raw = plist

function M.get(entindex, field)
  return plist.get(entindex, field)
end

function M.set(entindex, field, value)
  return plist.set(entindex, field, value)
end

return M]]
__bundle["require/help/reference"] = [[local M = {}

M.known_items = {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

function M.add_known(items)
    for _, it in ipairs(items or {}) do
        table.insert(M.known_items, it)
    end
end

function M.get(tab, container, name)
    return ui.reference(tab, container, name)
end

function M.build(list)
    local item_refs = {}
    local ref_visible = {}
    for i, item in ipairs(list) do
        local refs = {ui.reference(item[1], item[2], item[3])}
        item_refs[i] = refs
        for _, ref in ipairs(refs) do
            if ref ~= nil then
                ref_visible[ref] = true
            end
        end
    end
    return item_refs, ref_visible
end

function M.build_known()
    return M.build(M.known_items)
end

function M.get_all_known()
    return M.known_items
end

return M]]
__bundle["require/help/references_old"] = [[

local M = {}

local function wrap(refs)
    
    if type(refs) ~= 'table' then
        local handle = refs
        return {
            raw = handle,
            get = function()
                local ok, v = pcall(ui.get, handle)
                if ok then return v end
                return nil
            end
        }
    end

    
    
    
    local handles = refs
    return {
        raw = handles,
        get = function()
            if handles[2] ~= nil then
                local ok, v = pcall(ui.get, handles[2])
                if ok then return v end
            end
            if handles[1] ~= nil then
                local ok, v = pcall(ui.get, handles[1])
                if ok then return v end
            end
            return nil
        end
    }
end


M.minimum_damage = wrap(ui.reference("RAGE", "Aimbot", "Minimum damage"))
M.minimum_damage_override = wrap({ ui.reference("RAGE", "Aimbot", "Minimum damage override") })
M.doubletap = wrap({ ui.reference("RAGE", "Aimbot", "Double tap") })
M.force_body_aim = wrap({ ui.reference("RAGE", "Aimbot", "Force body aim") })
M.force_safe_point = wrap({ ui.reference("RAGE", "Aimbot", "Force safe point") })
M.duck_peek_assist = wrap({ ui.reference("RAGE", "Other", "Duck peek assist") })
M.quick_peek_assist = wrap({ ui.reference("RAGE", "Aimbot", "Quick peek assist") })


M.pitch = wrap(ui.reference("AA", "Anti-aimbot angles", "Pitch"))
M.yaw_base = wrap(ui.reference("AA", "Anti-aimbot angles", "Yaw base"))
M.yaw = wrap(ui.reference("AA", "Anti-aimbot angles", "Yaw"))
M.yaw_jitter = wrap(ui.reference("AA", "Anti-aimbot angles", "Yaw jitter"))
M.body_yaw = wrap(ui.reference("AA", "Anti-aimbot angles", "Body yaw"))
M.roll = wrap(ui.reference("AA", "Anti-aimbot angles", "Roll"))

return M]]
__bundle["require/help/renderer"] = [[local M = {}

M.raw = renderer

function M.blur(x, y, w, h, alpha, amount)
  return renderer.blur(x, y, w, h, alpha, amount)
end

function M.circle(x, y, r, g, b, a, radius, start_degrees, percentage)
  return renderer.circle(x, y, r, g, b, a, radius, start_degrees, percentage)
end

function M.circle_outline(x, y, r, g, b, a, radius, start_degrees, percentage, thickness)
  return renderer.circle_outline(x, y, r, g, b, a, radius, start_degrees, percentage, thickness)
end

function M.gradient(x, y, w, h, r1, g1, b1, a1, r2, g2, b2, a2, direction)
  return renderer.gradient(x, y, w, h, r1, g1, b1, a1, r2, g2, b2, a2, direction)
end

function M.indicator(r, g, b, a, ...)
  return renderer.indicator(r, g, b, a, ...)
end

function M.line(x1, y1, x2, y2, r, g, b, a)
  return renderer.line(x1, y1, x2, y2, r, g, b, a)
end

function M.load_jpg(contents, width, height)
  return renderer.load_jpg(contents, width, height)
end

function M.load_png(contents, width, height)
  return renderer.load_png(contents, width, height)
end

function M.load_rgba(contents, width, height)
  return renderer.load_rgba(contents, width, height)
end

function M.load_svg(contents, width, height)
  return renderer.load_svg(contents, width, height)
end

function M.measure_text(flags, ...)
  return renderer.measure_text(flags, ...)
end

function M.rectangle(x, y, w, h, r, g, b, a)
  return renderer.rectangle(x, y, w, h, r, g, b, a)
end

function M.text(x, y, r, g, b, a, flags, max_width, ...)
  return renderer.text(x, y, r, g, b, a, flags, max_width, ...)
end

function M.texture(tex, x, y, w, h, r, g, b, a, mode)
  return renderer.texture(tex, x, y, w, h, r, g, b, a, mode)
end

function M.triangle(x1, y1, x2, y2, x3, y3, r, g, b, a)
  return renderer.triangle(x1, y1, x2, y2, x3, y3, r, g, b, a)
end

function M.world_to_screen(x, y, z)
  return renderer.world_to_screen(x, y, z)
end

function M.rectangle_outline(x, y, w, h, r, g, b, a, thickness)
  thickness = thickness or 1
  for i = 0, thickness - 1 do
    renderer.line(x + i, y + i, x + w - i, y + i, r, g, b, a)
    renderer.line(x + i, y + h - i, x + w - i, y + h - i, r, g, b, a)
    renderer.line(x + i, y + i, x + i, y + h - i, r, g, b, a)
    renderer.line(x + w - i, y + i, x + w - i, y + h - i, r, g, b, a)
  end
end

function M.text_centered(x, y, r, g, b, a, flags, max_width, ...)
  local w, h = renderer.measure_text(flags, ...)
  if not w or not h then return end
  return renderer.text(x - w / 2, y - h / 2, r, g, b, a, flags, max_width, ...)
end

function M.texture_from_file(path)
  local contents = readfile(path)
  if not contents then return nil end
  local tex = renderer.load_png(contents)
  if not tex then
    tex = renderer.load_jpg(contents)
  end
  return tex
end

return M]]
__bundle["require/help/safe"] = [[local M = {}

function M.safe_call(func, ...)
	local ok, result = pcall(func, ...)
	return ok and result or nil
end

function M.safe_set(item, value)
	local ok = pcall(function() ui.set(item, value) end)
	return ok
end

function M.safe_get(item)
	local ok, result = pcall(function() return ui.get(item) end)
	return ok and result or nil
end

return M]]
__bundle["require/help/self"] = [[local M = {}

local entity = entity
local globals = globals
local client = client

function M.index()
	return entity and entity.get_local_player and entity.get_local_player() or nil
end

function M.exists()
	return M.index() ~= nil
end

function M.is_alive()
	local idx = M.index()
	return idx and entity.is_alive and entity.is_alive(idx) or false
end

function M.health()
	local idx = M.index()
	return idx and entity.get_prop and entity.get_prop(idx, 'm_iHealth') or 0
end

function M.ping()
	return client and client.latency and client.latency() or 0
end

function M.velocity()
	local idx = M.index()
	if not idx or not entity.get_prop then return 0 end
	local vx, vy, vz = entity.get_prop(idx, 'm_vecVelocity')
	if vx and vy and vz then
		return math.sqrt(vx * vx + vy * vy + vz * vz)
	end
	return 0
end

function M.velocity2d()
	local idx = M.index()
	if not idx or not entity.get_prop then return 0 end
	local vx, vy = entity.get_prop(idx, 'm_vecVelocity')
	if vx and vy then
		return math.sqrt(vx * vx + vy * vy)
	end
	return 0
end

function M.weapon()
	local idx = M.index()
	return idx and entity.get_player_weapon and entity.get_player_weapon(idx) or nil
end

function M.tickbase_shifted()
	
	return false
end

function M.simtime()
	local idx = M.index()
	return idx and entity.get_prop and entity.get_prop(idx, 'm_flSimulationTime') or 0
end

function M.eye_angles()
	return client and client.camera_angles and client.camera_angles() or nil
end

function M.fps()
	local frametime = globals and globals.absoluteframetime and globals.absoluteframetime() or globals.frametime and globals.frametime() or 0.01
	if frametime > 0 then
		return math.floor(1 / frametime + 0.5)
	end
	return 0
end

function M.map()
	return globals and globals.mapname and globals.mapname() or nil
end

function M.is_dormant()
	local idx = M.index()
	return idx and entity.is_dormant and entity.is_dormant(idx) or false
end

function M.team_number()
	local idx = M.index()
	return idx and entity.get_prop and entity.get_prop(idx, 'm_iTeamNum') or 0
end

function M.player_name()
	local idx = M.index()
	return idx and entity.get_player_name and entity.get_player_name(idx) or nil
end

function M.steam64()
	local idx = M.index()
	return idx and entity.get_steam64 and entity.get_steam64(idx) or nil
end

function M.ammo_count()
	local weapon = M.weapon()
	return weapon and entity.get_prop and entity.get_prop(weapon, 'm_iClip1') or 0
end

function M.has_armor()
	local idx = M.index()
	return idx and entity.get_prop and entity.get_prop(idx, 'm_ArmorValue') > 0 or false
end

function M.has_helmet()
	local idx = M.index()
	return idx and entity.get_prop and entity.get_prop(idx, 'm_bHasHelmet') == 1 or false
end

function M.current_tick()
	return globals and globals.tickcount and globals.tickcount() or 0
end

function M.tick_interval()
	return globals and globals.tickinterval and globals.tickinterval() or 0
end

function M.current_frame()
	return globals and globals.framecount and globals.framecount() or 0
end

function M.current_time()
	return globals and globals.curtime and globals.curtime() or 0
end

function M.real_latency()
	return client and client.real_latency and client.real_latency() or 0
end

function M.system_time()
	return client and client.system_time and client.system_time() or {0,0,0,0}
end

function M.unix_time()
	return client and client.unix_time and client.unix_time() or 0
end

function M.kills()
	local idx = M.index()
	if not idx or not entity.get_prop then return 0 end
	local player_resource = entity.get_player_resource and entity.get_player_resource()
	if player_resource then
		return entity.get_prop(player_resource, 'm_iKills', idx) or 0
	end
	return 0
end

function M.deaths()
	local idx = M.index()
	if not idx or not entity.get_prop then return 0 end
	local player_resource = entity.get_player_resource and entity.get_player_resource()
	if player_resource then
		return entity.get_prop(player_resource, 'm_iDeaths', idx) or 0
	end
	return 0
end

function M.assists()
	local idx = M.index()
	if not idx or not entity.get_prop then return 0 end
	local player_resource = entity.get_player_resource and entity.get_player_resource()
	if player_resource then
		return entity.get_prop(player_resource, 'm_iAssists', idx) or 0
	end
	return 0
end

return M
]]
__bundle["require/help/string"] = [[local S = {}

function S.lower(str)
	return string.lower(str)
end

function S.upper(str)
	return string.upper(str)
end

function S.capitalize(str)
	return (str:gsub("^%l", string.upper):gsub("^(%u)(.*)", function(f, r) return f .. string.lower(r) end))
end

function S.title(str)
	return (str:gsub("%S+", function(word)
		return word:sub(1,1):upper() .. word:sub(2):lower()
	end))
end

function S.random_case(str)
	local out = {}
	for i = 1, #str do
		local c = str:sub(i,i)
		if math.random() < 0.5 then
			out[i] = string.lower(c)
		else
			out[i] = string.upper(c)
		end
	end
	return table.concat(out)
end

function S.startswith(str, prefix)
	return str:sub(1, #prefix) == prefix
end

function S.endswith(str, suffix)
	return suffix == '' or str:sub(-#suffix) == suffix
end

function S.byte(str, i, j)
	return string.byte(tostring(str or ""), i, j)
end

function S.char(...)
	return string.char(...)
end

function S.find(str, pattern, init, plain)
	return string.find(tostring(str or ""), pattern, init, plain)
end

function S.format(fmt, ...)
	return string.format(fmt, ...)
end

function S.gmatch(str, pattern)
	return string.gmatch(tostring(str or ""), pattern)
end

function S.gsub(str, pattern, repl, n)
	return string.gsub(tostring(str or ""), pattern, repl, n)
end

function S.split(str, sep)
	local result = {}
	if sep == '' then
		for i = 1, #str do result[i] = str:sub(i,i) end
		return result
	end
	local pattern = string.format("([^%s]+)", sep)
	for part in str:gmatch(pattern) do
		result[#result+1] = part
	end
	return result
end

function S.join(tbl, sep)
	return table.concat(tbl, sep)
end

function S.replace(str, pattern, repl)
	return str:gsub(pattern, repl)
end

function S.reverse(str)
	return string.reverse(str)
end

function S.repeat_str(str, n)
	return string.rep(str, n)
end

function S.rep(str, n)
	return string.rep(tostring(str or ""), n)
end

function S.contains(str, substr)
	return str:find(substr, 1, true) ~= nil
end

function S.count(str, substr)
	if substr == '' then return 0 end
	local count = 0
	local pos = 1
	while true do
		local start = str:find(substr, pos, true)
		if not start then break end
		count = count + 1
		pos = start + #substr
	end
	return count
end

function S.is_empty(str)
	return str == nil or str == ''
end

function S.is_digit(str)
	return str:match("^%d+$") ~= nil
end

function S.is_alpha(str)
	return str:match("^%a+$") ~= nil
end

function S.random_string(len)
	local charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local out = {}
	for i = 1, len do
		local idx = math.random(1, #charset)
		out[i] = charset:sub(idx, idx)
	end
	return table.concat(out)
end

function S.safe_substr(str, i, j)
	local s = tostring(str or "")
	local n = #s
	local start = tonumber(i) or 1
	if start < 0 then start = n + 1 + start end
	if start < 1 then start = 1 end
	if j == nil then
		return s:sub(start)
	end
	local jn = tonumber(j)
	if not jn then
		return s:sub(start)
	end
	if jn >= 0 then
		return s:sub(start, math.min(n, start + jn - 1))
	else
		local finish = n + jn
		if finish < start then return "" end
		return s:sub(start, finish)
	end
end

function S.sub(str, s, e)
	return string.sub(tostring(str or ""), s, e)
end

function S.len(str)
	return string.len(tostring(str or ""))
end

function S.match(str, pattern, init)
	return string.match(tostring(str or ""), pattern, init)
end

function S.trim(str)
	return (tostring(str or ""):gsub("^%s*(.-)%s*$", "%1"))
end

function S.ltrim(str)
	return (tostring(str or ""):gsub("^%s*(.-)$", "%1"))
end

function S.rtrim(str)
	return (tostring(str or ""):gsub("^(.-)%s*$", "%1"))
end

function S.escape_pattern(str)
	return tostring(str or ""):gsub("([%%%$%(%)%.%[%]%*%+%-%?%^])", "%%%1")
end

function S.ensure_prefix(str, prefix)
	local s = tostring(str or "")
	local p = tostring(prefix or "")
	if p == "" then return s end
	if s:sub(1, #p) == p then return s end
	return p .. s
end

function S.ensure_suffix(str, suffix)
	local s = tostring(str or "")
	local su = tostring(suffix or "")
	if su == "" then return s end
	if s:sub(-#su) == su then return s end
	return s .. su
end

function S.truncate(str, maxlen, ellip)
	local s = tostring(str or "")
	local m = tonumber(maxlen) or 0
	if m <= 0 or #s <= m then return s end
	local e = tostring(ellip or "...")
	local take = m - #e
	if take <= 0 then return e:sub(1, m) end
	return s:sub(1, take) .. e
end

local _leet_map = {
	a = '4', A = '4', e = '3', E = '3', i = '1', I = '1', o = '0', O = '0',
	s = '5', S = '5', t = '7', T = '7', b = '8', B = '8', g = '6', G = '6',
	z = '2', Z = '2', l = '1', L = '1'
}

function S.leet(str, chance)
	local s = tostring(str or "")
	local p = tonumber(chance) or 1
	if p <= 0 then return s end
	local out = {}
	for i = 1, #s do
		local c = s:sub(i,i)
		local r = _leet_map[c]
		if r and math.random() <= p then out[#out+1] = r else out[#out+1] = c end
	end
	return table.concat(out)
end

function S.pipeline(str, ...)
	local s = tostring(str or "")
	for i = 1, select('#', ...) do
		local fn = select(i, ...)
		if type(fn) == 'function' then
			s = fn(s)
		elseif type(fn) == 'string' and S[fn] then
			s = S[fn](s)
		end
	end
	return s
end

return S]]
__bundle["require/help/time"] = [[local T = {}

local client = client
local globals = globals

local function now()
	if globals and globals.realtime then
		return globals.realtime()
	end
	if client and client.timestamp then
		local ms = client.timestamp()
		if ms then return ms / 1000 end
	end
	return 0
end

function T.simtime()
	if globals and globals.curtime then return globals.curtime() end
	return now()
end

function T.realtime()
	return now()
end

function T.tickcount()
	if globals and globals.tickcount then return globals.tickcount() end
	local ti = T.tickinterval()
	if ti and ti > 0 then return math.floor(now() / ti) end
	return 0
end

function T.tickinterval()
	if globals and globals.tickinterval then return globals.tickinterval() end
	return 0.015625
end

function T.seconds_to_ticks(seconds)
	local interval = T.tickinterval()
	if interval and interval > 0 then return math.floor(seconds / interval + 0.5) end
	return math.floor(seconds * 64 + 0.5)
end

function T.ticks_to_seconds(ticks)
	local interval = T.tickinterval()
	if interval then return ticks * interval end
	return ticks * 0.015625
end

function T.frametime()
	if globals and globals.frametime then return globals.frametime() end
	return 0
end

function T.absoluteframetime()
	if globals and globals.absoluteframetime then return globals.absoluteframetime() end
	return 0
end

function T.framecount()
	if globals and globals.framecount then return globals.framecount() end
	return 0
end

function T.framecount_to_seconds(framecount)
	local ft = T.frametime()
	return framecount * (ft or 0)
end

function T.seconds_to_framecount(seconds)
	local ft = T.frametime()
	if ft and ft > 0 then return math.floor(seconds / ft + 0.5) end
	return math.floor(seconds * 60 + 0.5)
end

function T.new(duration)
	return { start = now(), duration = duration or 0 }
end

function T.expired(timer)
	return now() - (timer.start or 0) >= (timer.duration or 0)
end

function T.reset(timer, duration)
	timer.start = now()
	if duration then timer.duration = duration end
end

function T.elapsed(timer)
	return now() - (timer.start or 0)
end

function T.interval(interval, callback)
	local last = now()
	return function(...)
		local t = now()
		if t - last >= interval then
			last = t
			callback(...)
		end
	end
end

function T.timeout(delay, callback)
	local triggered = false
	local start = now()
	return function(...)
		if not triggered and now() - start >= delay then
			triggered = true
			callback(...)
		end
	end
end

function T.debounce(interval, callback)
	local last = 0
	return function(...)
		local t = now()
		if t - last >= interval then
			last = t
			callback(...)
		end
	end
end

function T.throttle(interval, callback)
	local last = 0
	return function(...)
		local t = now()
		if t - last >= interval then
			last = t
			callback(...)
		end
	end
end

function T.wait(delay)
	local start = now()
	return function()
		return now() - start >= delay
	end
end

function T.stopwatch()
	local sw = { running = false, start = 0, elapsed = 0 }
	function sw:start()
		if not self.running then
			self.running = true
			self.start = now()
		end
	end
	function sw:stop()
		if self.running then
			self.running = false
			self.elapsed = self.elapsed + (now() - (self.start or 0))
		end
	end
	function sw:reset()
		self.running = false
		self.start = 0
		self.elapsed = 0
	end
	function sw:get()
		if self.running then
			return self.elapsed + (now() - (self.start or 0))
		else
			return self.elapsed
		end
	end
	return sw
end

T.Scheduler = {}
T.Scheduler.__index = T.Scheduler

function T.Scheduler.new()
    return setmetatable({ tasks = {} }, T.Scheduler)
end

function T.Scheduler:add(interval, callback)
	self.tasks[#self.tasks+1] = { interval = interval, callback = callback, last = now() }
end

function T.Scheduler:remove(callback)
    for i = #self.tasks, 1, -1 do
        if self.tasks[i].callback == callback then
            table.remove(self.tasks, i)
        end
    end
end

function T.Scheduler:run(...)
	local t = now()
	for _, task in ipairs(self.tasks) do
		if t - task.last >= task.interval then
			task.last = t
			task.callback(...)
		end
	end
end

function T.safe_timeout(delay, callback)
	local start = now()
	local triggered = false
	return function(...)
		if not triggered and now() - start >= delay then
			triggered = true
			callback(...)
		end
	end
end

function T.lerp(a,b,t)
	return a + (b - a) * t
end

function T.ease_in_out(t)
	if t < 0 then t = 0 end
	if t > 1 then t = 1 end
	return t < 0.5 and 2 * t * t or -1 + (4 - 2 * t) * t
end

function T.ping_pong(t, period)
	if period <= 0 then return 0 end
	local m = t % (period * 2)
	if m < period then return m / period end
	return 1 - ((m - period) / period)
end

function T.apply_animation(duration, update_fn, finish_fn)
	local start = now()
	return function()
		local t = (now() - start) / (duration or 1)
		if t >= 1 then
			update_fn(1)
			if finish_fn then finish_fn() end
			return true
		else
			update_fn(t)
			return false
		end
	end
end

function T.within_ticks_window(last_tick, window_ticks)
	local tc = T.tickcount()
	if not tc or not last_tick then return false end
	return tc - last_tick <= (window_ticks or 0)
end

return T]]
__bundle["require/help/trace"] = [[]]
__bundle["require/help/ui"] = [[local M = {}

M.raw = ui

local function ensure_ui()
    if type(ui) ~= 'table' then
        error('ui library is not available in this environment')
    end
end

function M.available()
    return type(ui) == 'table'
end

function M.get(item)
    ensure_ui()
    return ui.get(item)
end

function M.is_menu_open()
    ensure_ui()
    return ui.is_menu_open()
end

function M.menu_position()
    ensure_ui()
    return ui.menu_position()
end

function M.menu_size()
    ensure_ui()
    return ui.menu_size()
end

function M.mouse_position()
    ensure_ui()
    return ui.mouse_position()
end

function M.name(item)
    ensure_ui()
    return ui.name(item)
end


function M.new_button(tab, container, name, callback)
    ensure_ui()
    return ui.new_button(tab, container, name, callback)
end

function M.new_checkbox(tab, container, name)
    ensure_ui()
    return ui.new_checkbox(tab, container, name)
end

function M.new_color_picker(tab, container, name, r, g, b, a)
    ensure_ui()
    return ui.new_color_picker(tab, container, name, r or 0, g or 0, b or 0, a or 255)
end

function M.new_combobox(tab, container, name, ...)
    ensure_ui()
    return ui.new_combobox(tab, container, name, ...)
end

function M.new_hotkey(tab, container, name, inline, default_hotkey)
    ensure_ui()
    return ui.new_hotkey(tab, container, name, inline and true or false, default_hotkey)
end

function M.new_label(tab, container, name)
    ensure_ui()
    return ui.new_label(tab, container, name)
end

function M.new_listbox(tab, container, name, items)
    ensure_ui()
    return ui.new_listbox(tab, container, name, items)
end

function M.new_multiselect(tab, container, name, ...)
    ensure_ui()
    return ui.new_multiselect(tab, container, name, ...)
end

function M.new_slider(tab, container, name, min, max, init_value, show_tooltip, unit, scale, tooltips)
    ensure_ui()
    return ui.new_slider(tab, container, name, min, max, init_value, show_tooltip, unit, scale, tooltips)
end

function M.new_string(name, default_value)
    ensure_ui()
    return ui.new_string(name, default_value)
end

function M.new_textbox(tab, container, name)
    ensure_ui()
    return ui.new_textbox(tab, container, name)
end

function M.reference(tab, container, name)
    ensure_ui()
    return ui.reference(tab, container, name)
end


function M.set(item, ...)
    ensure_ui()
    return ui.set(item, ...)
end

function M.set_callback(item, callback)
    ensure_ui()
    return ui.set_callback(item, callback)
end

function M.set_enabled(item, enabled)
    ensure_ui()
    return ui.set_enabled(item, enabled)
end

function M.set_visible(item, visible)
    ensure_ui()
    return ui.set_visible(item, visible)
end

function M.type(item)
    ensure_ui()
    return ui.type(item)
end

function M.update(item, ...)
    ensure_ui()
    if ui.update then
        return ui.update(item, ...)
    end
    error('ui.update is not supported in this environment')
end

function M.get_color(item)
    ensure_ui()
    local r,g,b,a = ui.get(item)
    if r == nil then return nil end
    return { r = r, g = g, b = b, a = a }
end

function M.set_color(item, color)
    ensure_ui()
    if type(color) == 'table' then
        return ui.set(item, color.r or 0, color.g or 0, color.b or 0, color.a or 255)
    else
        error('color must be a table {r,g,b,a}')
    end
end

function M.get_multiselect(item)
    ensure_ui()
    local vals = ui.get(item)
    return vals
end

function M.list_refs(tab, container)
    ensure_ui()
    local refs = {}
    for _, name in ipairs(ui.get_children and ui.get_children(tab, container) or {}) do
        refs[#refs+1] = ui.reference(tab, container, name)
    end
    return refs
end

return M]]
__bundle["require/help/vector"] = [[local vector
do
    local function make_vec(a,b,c)
        local v = { x = 0, y = 0, z = 0 }
        if type(a) == "table" then
            v.x = a.x or a[1] or 0
            v.y = a.y or a[2] or 0
            v.z = a.z or a[3] or 0
        elseif type(a) == "number" then
            v.x = a
            v.y = b or 0
            v.z = c or 0
        elseif a ~= nil then
            v.x = (a.x or a[1]) or 0
            v.y = (a.y or a[2]) or 0
            v.z = (a.z or a[3]) or 0
        end
        return setmetatable(v, vector_mt)
    end

    local vector_methods = {}

    vector_mt = {
        __index = function(t,k)
            if k == 1 then return rawget(t,"x") end
            if k == 2 then return rawget(t,"y") end
            if k == 3 then return rawget(t,"z") end
            local v = rawget(t,k)
            if v ~= nil then return v end
            return vector_methods[k]
        end,
        __sub = function(a,b)
            return make_vec((a.x or 0) - (b.x or 0), (a.y or 0) - (b.y or 0), (a.z or 0) - (b.z or 0))
        end,
        __add = function(a,b)
            return make_vec((a.x or 0) + (b.x or 0), (a.y or 0) + (b.y or 0), (a.z or 0) + (b.z or 0))
        end,
        __mul = function(a,b)
            if type(a) == 'number' then return make_vec(a * (b.x or 0), a * (b.y or 0), a * (b.z or 0)) end
            if type(b) == 'number' then return make_vec((a.x or 0) * b, (a.y or 0) * b, (a.z or 0) * b) end
            return nil
        end,
        __div = function(a,b)
            if type(b) == 'number' and b ~= 0 then return make_vec((a.x or 0) / b, (a.y or 0) / b, (a.z or 0) / b) end
            return nil
        end,
        __unm = function(a) return make_vec(-(a.x or 0), -(a.y or 0), -(a.z or 0)) end,
        __tostring = function(a) return string.format("vec(%.3f, %.3f, %.3f)", a.x or 0, a.y or 0, a.z or 0) end
    }

    vector_methods.length = function(self) return math.sqrt((self.x or 0)^2 + (self.y or 0)^2 + (self.z or 0)^2) end
    vector_methods.dot = function(a,b) return (a.x or 0)*(b.x or 0) + (a.y or 0)*(b.y or 0) + (a.z or 0)*(b.z or 0) end
    vector_methods.cross = function(a,b)
        return make_vec((a.y or 0)*(b.z or 0) - (a.z or 0)*(b.y or 0),
                        (a.z or 0)*(b.x or 0) - (a.x or 0)*(b.z or 0),
                        (a.x or 0)*(b.y or 0) - (a.y or 0)*(b.x or 0))
    end
    vector_methods.normalized = function(self)
        local l = vector_methods.length(self)
        if l == 0 or l == nil then return make_vec(0,0,0) end
        return make_vec((self.x or 0)/l, (self.y or 0)/l, (self.z or 0)/l)
    end
    vector_methods.normalize = function(self)
        local l = vector_methods.length(self)
        if l == 0 or l == nil then return self end
        self.x = (self.x or 0)/l
        self.y = (self.y or 0)/l
        self.z = (self.z or 0)/l
        return self
    end
    vector_methods.copy = function(self) return make_vec(self.x or 0, self.y or 0, self.z or 0) end
    vector_methods.distance_to = function(self, other)
        local o = other
        if type(other) == 'number' then o = vector(other) end
        local dx = (self.x or 0) - (o.x or 0)
        local dy = (self.y or 0) - (o.y or 0)
        local dz = (self.z or 0) - (o.z or 0)
        return math.sqrt(dx*dx + dy*dy + dz*dz)
    end
    vector_methods.to_screen = function(self)
        if not renderer or not renderer.world_to_screen then return nil end
        return renderer.world_to_screen(self.x or 0, self.y or 0, self.z or 0)
    end
    vector_methods.to_angles = function(self, other)
        local o = other
        if not o then return nil end
        local dx = (o.x or 0) - (self.x or 0)
        local dy = (o.y or 0) - (self.y or 0)
        local dz = (o.z or 0) - (self.z or 0)
        local yaw = math.deg(math.atan2(dy, dx))
        local hyp = math.sqrt(dx*dx + dy*dy)
        local pitch = -math.deg(math.atan2(dz, hyp))
        return pitch, yaw
    end

    vector = setmetatable({}, {
        __call = function(_, a, b, c)
            return make_vec(a, b, c)
        end
    })
end
return vector]]
__bundle["main"] = [[



local function safe_require(path)
    local ok, mod = pcall(require, path)
    if ok then
        return mod
    else
        return nil
    end
end




local modules = {
    menu = safe_require("require/abc/menu_header"),
    login = safe_require("require/abc/login_system"),
    config = safe_require("require/abc/config_system"),
    player_condition = safe_require("require/aa/player_condition"),
    menu_setup = safe_require("require/abc/menu_setup"),
    gc = safe_require("require/abc/garbage_collector"),
    pushlog = safe_require("require/abc/push_logger"),
    screenlog = safe_require("require/abc/screen_logger"),
    self = safe_require("require/help/self"),
    enemies = safe_require("require/help/enemies"),
    COLORS = safe_require("require/help/color"),
    str = safe_require("require/help/string"),
    safe = safe_require("require/help/safe"),
    build_menu = safe_require("require/abc/build_menu"),
    menu_visibility = safe_require("require/abc/menu_visibility"),
    config_system = safe_require("require/abc/config_system"),
}




safe_require("require/abc/register")




safe_require("require/features/aa/antiaim")






safe_require("require/features/misc/resolver")
safe_require("require/features/misc/analyze")
safe_require("require/features/misc/dormant_aimbot")
safe_require("require/features/misc/fakelag")
safe_require("require/features/misc/hotkeys")
safe_require("require/features/misc/freestand_helper")
safe_require("require/features/misc/enhance_osaa")
safe_require("require/features/misc/roll")
safe_require("require/features/misc/exploit_fakelag")
safe_require("require/features/misc/walkbot")
safe_require("require/features/misc/backstab_assist")
safe_require("require/features/misc/spin_on_dead_enemies")
safe_require("require/features/misc/localdebug")




safe_require("require/features/paint/world_hitmarker_plus")
safe_require("require/features/paint/onshot_skeleton")
safe_require("require/features/paint/damage")
safe_require("require/features/paint/damage_penetration")
safe_require("require/features/paint/aimbot_logs")
safe_require("require/features/paint/aspect_ratio")
safe_require("require/features/paint/third_person_distance")
safe_require("require/features/paint/watermark_solus")
safe_require("require/features/paint/watermark_gamesense")
safe_require("require/features/paint/entidx")
safe_require("require/features/paint/target_info")
safe_require("require/features/paint/clantag")
safe_require("require/features/paint/indicators_bold")
safe_require("require/features/paint/indicators_small")
safe_require("require/features/paint/hit_miss_indicator")
safe_require("require/features/paint/bomb_esp")
safe_require("require/features/paint/presmoke_warning")
safe_require("require/features/paint/self_skeleton")
safe_require("require/features/paint/performance_mode")

safe_require("require/features/paint/minimum_damage")
safe_require("require/features/paint/filter_console")
safe_require("require/features/paint/warnings")
safe_require("require/features/paint/text_watermark")
safe_require("require/features/paint/bullet_tracer")
safe_require("require/features/paint/animations")
safe_require("require/features/paint/lagcomp_box")
safe_require("require/features/paint/insults")
safe_require("require/features/paint/molotov_particles")






modules.pushlog("The lua has initialized", 4, 255, 255, 0, 255)
modules.screenlog("The lua has initialized", 4, 255, 255, 255, 255)




local function load_cached_credentials()
    local creds = database.read('cached_credentials')
    if creds and creds.username and creds.password then
        modules.safe.safe_set(modules.menu_setup.ui.login_username, creds.username)
        modules.safe.safe_set(modules.menu_setup.ui.login_password, creds.password)
        modules.safe.safe_set(modules.menu_setup.ui.cache_credentials, true)
        
        local success = modules.login.login(creds.username, creds.password)
        if success then
            local r,g,b = modules.COLORS.get("green", "log")
            modules.screenlog("Auto-login successful!", 3, r, g, b, 255)
            modules.pushlog("Auto-login successful!", 3, 255, 255, 0, 255)
        else
            local r,g,b = modules.COLORS.get("red", "log")
            modules.screenlog("Auto-login failed!", 3, r, g, b, 255)
            modules.pushlog("Auto-login failed!", 3, 255, 255, 0, 255)
        end
    end
end




modules.build_menu(modules)
modules.menu_visibility.setup_callbacks(modules)





local function menu_setup()
    local logged_in = modules.login.logged_in
    if not logged_in then return end
    modules.menu.draw_menu()
    if modules.menu.is_menu_open() then
        local tab_rects = modules.menu.tab_sections()
        local mouse_x, mouse_y = modules.menu.mouse_position()
        local tab_index = modules.menu.current_tab_index()
        local tab_name = modules.menu.current_tab()
        local menu_x, menu_y = modules.menu.menu_position()
        local menu_w, menu_h = modules.menu.menu_size()
    end
end





local function disable_mouse_inside_menu(cmd)
    if not modules.menu.is_menu_open() then return end
    if not modules.menu.is_mouse_outside_menu() then
        cmd.in_attack = false
    end
end




local function garbage_collection()
    if modules.gc and modules.gc.step then
        modules.gc.step(10) 
    end
end





local function static()
    load_cached_credentials()
    modules.menu_visibility.update(modules)
end

static()



client.set_event_callback('setup_command', function(cmd)
    disable_mouse_inside_menu(cmd)
end)

client.set_event_callback('paint', function()
    menu_setup()
    garbage_collection()
end)

client.set_event_callback('paint_ui', function()

    if not modules.menu.is_menu_open() then return end
    local tab_name = modules.menu.current_tab()

    modules.menu_setup.toggle_gamesense_menu(false)

    if tab_name ~= last_tab then
        last_tab = tab_name
        modules.menu_visibility.update(modules)
    end

end)




client.set_event_callback('shutdown', function(cmd)
    modules.menu_setup.toggle_gamesense_menu(true)
end)]]

return __bundle_require("main")
