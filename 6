
local r662= {}
local r663= {}
local r664= require

local function r665(r666)
    if r663[r666] then
        return r663[r666]
    end

    local r667= r662[r666]
    if not r667 then
        return r664(r666)
    end
    local r668= {}
    setmetatable(r668, { __index = _G })
    r668.require = r665

    local r669, r670
    if type(setfenv) == "function" then
        r669, err = load(r667, r666)
        if not r669 then
            error("Failed to load module: " .. r666 .. " (" .. tostring(r670) .. ")")
        end
        setfenv(r669, r668)
    else
        r669, err = load(r667, r666, nil, r668)
        if not r669 then
            error("Failed to load module: " .. r666 .. " (" .. tostring(r670) .. ")")
        end
    end

    local r671= r669()
    r663[r666] = r671 or true
    return r663[r666]
end

r662["require/aa/player_condition"] = [[
local r46= require("require/help/libs")
local r47= r46.get("antiaim_funcs")
local r48= r46.get("entity") or r48
local r49= r46.get("bit") or r49
local r50= require('require/abc/menu_setup')
local r51= { last_air = false, last_tick = 0, last_cond = nil }

local function r52(r53)
    if r53 == 'global' then return true end
    if not r50 or not r50.ui then return true end
    local r54= 'enable_' .. r53
    local r55= r50.ui[r54]
    if not r55 then
        return true
    end
    local r56, r57= pcall(ui.get, r55)
    return r56 and r57 == true
end


local function r58()
    local r59= r48.get_local_player()
    if not r59 or not r48.is_alive(r59) then
        return nil
    end
    
    if client.key_state(0x45) then
        if r52('legit') then return "legit" end
    end

    local r60= false
    if r47 and r47.get_double_tap then
        r60 = r47.get_double_tap()
    else
        r60 = true
    end

    if r60 == false then
        if r52('fakelag') then return "fakelag" end
    end

    if misc_gs_hotkey_slowmotion and ui.get(misc_gs_hotkey_slowmotion) == true then
        if r52('walk') then return "walk" end
    end
    
    if client.key_state(0x10) then
        local r61, r62= r48.get_prop(r59, 'm_vecVelocity')
        local r63= math.sqrt((r61 or 0)^2 + (r62 or 0)^2)
        if r63 >= 20 and r63 <= 140 then
            if r52('walk') then return "walk" end
        end
    end

    local r61, r62= r48.get_prop(r59, 'm_vecVelocity')
    local r63= math.sqrt((r61 or 0)^2 + (r62 or 0)^2)
    local r64= r48.get_prop(r59, 'm_flDuckAmount') > 0.5
    local r65= r49.band(r48.get_prop(r59, 'm_fFlags') or 0, 1) == 1
    local r66= globals.tickcount()

    if not r65 then
        if r64 then
            r51.last_air = true
            r51.last_tick = r66
            r51.last_cond = "jump+"
            if r52('jump+') then return "jump+" end
        else
            r51.last_air = true
            r51.last_tick = r66
            r51.last_cond = "jump"
            if r52('jump') then return "jump" end
        end
    else
        if r51.last_air and (r66 - r51.last_tick <= 2) then
            if r51.last_cond and r52(r51.last_cond) then
                return r51.last_cond
            end
        end
        r51.last_air = false
        r51.last_cond = nil
    end

    if r64 then
        if r63 >= 2 then
            if r52('duck+') then return "duck+" end
        else
            if r52('duck') then return "duck" end
        end
    else
        if r63 >= 2 then
            if r52('move') then return "move" end
        else
            if r52('stand') then return "stand" end
        end
    end

    return "global"
end

return {
    get = r58
}]]
r662["require/abc/build_menu"] = [[tab = {
    "RAGE",
    "AA",
    "LEGIT",
    "VISUALS",
    "MISC",
    "PLIST",
    "CONFIG",
    "LUA"
}

cont = {
    {
        "Aimbot",
        "Other"
    },
    {
        "Anti-aimbot angles",
        "Fake lag",
        "Other"
    },
    {},
    {
        "Player ESP",
        "Other ESP",
        "Colored models",
        "Effects"
    },
    {},
    {},
    {},
    {
        "A",
        "B",
    }
}

local r49= {
    "global",
    "stand",
    "move",
    "duck",
    "duck+",
    "jump",
    "jump+",
    "walk",
    "fakelag",
    "legit",
}

local r50= require("require/abc/menu_setup")
local r51= require("require/help/color")
local r52= require("require/abc/screen_logger")
local r53= require("require/help/emojis")

local function r54(r55)
    local r56= 'inDGnidgdisgndsin'

    local function r57()
        local r58= database.read(r56)
        return type(r58) == 'table' and r58 or {}
    end

    local function r59(r58)
        database.write(r56, r58)
    end

    local function r60(r58,r61)
        for i = 1, #r58 do if r58[i] == r61 then return i end end
        return nil
    end

    local function r62()
        if not (r55 and r55.menu_setup and r55.menu_setup.ui and r55.menu_setup.ui.paint_logger) then
            return false
        end
        local r63, r64= pcall(ui.get, r55.menu_setup.ui.paint_logger)
        if not r63 or not r64 then return false end
        if type(r64) == 'table' then
            for _, v in ipairs(r64) do
                if tostring(v) == 'config' then return true end
            end
            return false
        else
            return tostring(r64) == 'config'
        end
    end

    local function r65(r66)
        local r67= r57()
        if #r67 == 0 then r67 = {'(empty)'} end
            if r50.ui.cfg_listbox then
                pcall(ui.set_visible, r50.ui.cfg_listbox, false)
            end
            r50.ui.cfg_listbox = r50.register_ui(
                ui.new_listbox(tab[2], cont[2][1], 'Configs', r67),
                { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
            )
        if r66 then
            local r68= r60(r67, r66)
            if r68 then ui.set(r50.ui.cfg_listbox, r68-1) end
        end
    end
 
    
    
    
    r50.ui.cache_credentials = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("pin") .. r51.get("default", "ui") .. 'Cache credentials'),
        { requires_login = false, key = 'cache_credentials', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    r50.ui.login_username = r50.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Username', 'username'),
        { requires_login = false, key = 'login_username', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    r50.ui.login_password = r50.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Password', 'password'),
        { requires_login = false, key = 'login_password', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    r50.ui.login_howto_header = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], r51.get("grey", "ui") .. '───────[ ' .. r51.get("white", "ui") .. 'How to ' .. r51.get("green", "ui") .. 'log in' .. r51.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'login_howto_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.login_console_register = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], r51.get("grey", "ui") .. '1. In console -> "register ' .. r51.get("green", "ui") .. 'user' .. r51.get("grey", "ui") .. ' ' .. r51.get("red", "ui") .. 'pass' .. r51.get("grey", "ui") .. ' ' .. r51.get("blue", "ui") .. 'code' .. r51.get("grey", "ui") .. '"'),
        { requires_login = false, key = 'login_console_register', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.login_menu_credentials = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], r51.get("grey", "ui") .. '2. Write password & username in the menu.'),
        { requires_login = false, key = 'login_menu_credentials', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.login_press_login = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], r51.get("grey", "ui") .. '3. Press log in and enjoy ' .. r51.get("green", "ui") .. 'premium features' .. r51.get("grey", "ui") .. '.'),
        { requires_login = false, key = 'login_press_login', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.login_spacer1 = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer1', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.reset_header = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], r51.get("grey", "ui") .. '───────[ ' .. r51.get("white", "ui") .. 'How to ' .. r51.get("yellow", "ui") .. 'reset pass' .. r51.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'reset_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.reset_step1 = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], r51.get("grey", "ui") .. '1. Write username -> press reset.'),
        { requires_login = false, key = 'reset_step1', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.reset_step2 = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], r51.get("grey", "ui") .. '2. Login with your oldest password.'),
        { requires_login = false, key = 'reset_step2', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.login_spacer2 = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer2', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.support_header = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], r51.get("grey", "ui") .. '───────[ ' .. r51.get("red", "ui") .. 'Support & Other' .. r51.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'support_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.support_discord = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], r51.get("grey", "ui") .. '1. Join the ' .. r51.get("discord", "ui") .. 'discord ' .. r51.get("grey", "ui") .. 'for support.'),
        { requires_login = false, key = 'support_discord', tab = 'AA', visible = true, config_type = 'label' }
    )

    r50.ui.login_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("lock_open") .. r51.get("default", "ui") .. 'Login', function()
            local r69= r55.safe.safe_get(r50.ui.login_username)
            local r70= r55.safe.safe_get(r50.ui.login_password)
            local r71= r55.safe.safe_get(r50.ui.cache_credentials)
            if r69 ~= '' and r70 ~= '' then
                local r72= r55.login.login(r69, r70)
                if r72 then
                    r55.pushlog("Welcome back, " .. r55.str.capitalize(r69) .. ". You logged in successfully.", 3, 75, 145, 55, 255)
                    if r71 then
                        database.write('cached_credentials', { username = r69, password = r70 })
                    else
                        database.write('cached_credentials', nil)
                    end
                    local r73,r74,r75= r51.get("green", "log")
                    r55.screenlog("Login successful!", 4, r73, r74, r75, 255)
                else
                    local r73,r74,r75= r51.get("red", "log")
                    r55.screenlog("Login failed!", 4, r73, r74, r75, 255)
                end
            end
                if r55.menu_visibility and r55.menu_visibility.update then
                    r55.menu_visibility.update(r55)
                end
        end),
        { requires_login = false, key = 'login_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    r50.ui.logout_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][3], r51.get("red", "ui") .. r53.get("lock") .. r51.get("default", "ui") .. 'Logout', function()
            r55.login.logout()
            local r73,r74,r75= r51.get("red", "log")
            r55.screenlog("Logged out!", 4, r73, r74, r75, 255)
                if r55.menu_visibility and r55.menu_visibility.update then
                    r55.menu_visibility.update(r55)
                end
        end),
        { requires_login = true, key = 'logout_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    r50.ui.reset_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][1], r51.get("yellow", "ui") .. r53.get("warning") .. r51.get("default", "ui") .. 'Reset', function()
            local r69= r55.safe.safe_get(r50.ui.login_username)
            r55.login.reset_password(r69)
            local r73,r74,r75= r51.get("yellow", "log")
            r55.screenlog("Password reset.", 4, r73, r74, r75, 255)
            r55.pushlog("Password reset for user: " .. r69, 5, 255, 255, 0, 255)
                if r55.menu_visibility and r55.menu_visibility.update then
                    r55.menu_visibility.update(r55)
                end
        end),
        { requires_login = true, key = 'reset_button', tab = 'AA', visible = true, config_type = 'button' }
    )

    r50.ui.discord_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][3], r51.get("discord", "ui") .. r53.get("chat") .. r51.get("default", "ui") .. 'Discord', function()
            local r76= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            r55.safe.safe_set(r76, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://discord.gg/a2bFbVWWg9')
        end),
        { requires_login = true, key = 'discord_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    r50.ui.youtube_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][3], r51.get("youtube", "ui") .. r53.get("play") .. r51.get("default", "ui") .. 'YouTube', function()
            local r76= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            r55.safe.safe_set(r76, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://www.youtube.com/@vile-gs/videos')
        end),
        { requires_login = true, key = 'youtube_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    r50.ui.sellhub_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][3], r51.get("sellhub", "ui") .. r53.get("folder") .. r51.get("default", "ui") .. 'Sellhub', function()
            local r76= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            r55.safe.safe_set(r76, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://sodium.sellhub.cx/#products-list')
        end),
        { requires_login = true, key = 'sellhub_button', tab = 'AA', visible = true, config_type = 'button' }
    )


    
    
    
    r50.ui.condition_label = r50.register_ui(
        ui.new_label(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("menu") .. r51.get("default", "ui") .. 'Condition', unpack(r49)),
        { requires_login = true, key = 'condition_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.condition = r50.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nCondition', unpack(r49)),
        { requires_login = true, key = 'condition', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    r50.ui.condition_label2 = r50.register_ui(
        ui.new_label(tab[2], cont[2][1], '\ncondition label'),
        { requires_login = true, key = 'condition_label2', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.misc_resolver = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("wrench") .. r51.get("default", "ui") .. 'Resolver'),
        { requires_login = true, key = 'misc_resolver', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    r50.ui.misc_ragebot = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("arrow_double") .. r51.get("default", "ui") .. 'Ragebot'),
        { requires_login = true, key = 'misc_ragebot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    r50.ui.misc_dormantaimbot = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("time") .. r51.get("default", "ui") .. 'Dormant aimbot'),
        { requires_login = true, key = 'misc_dormantaimbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    r50.ui.misc_dormantaimbot_key = r50.register_ui(
        ui.new_hotkey(tab[2], cont[2][1], '\ndormant aimbot key', true),
        { requires_login = true, key = 'misc_dormantaimbot_key', tab = 'MISC', visible = true, config_type = 'hotkey' }
    )
    r50.ui.misc_dormantaimbot_value = r50.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\ndormant aimbot value', 60, 100, 0, true, '%'),
        { requires_login = true, key = 'misc_dormantaimbot_value', tab = 'MISC', visible = true, config_type = 'slider' }
    )
    r50.ui.misc_exploit_fakelag = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("latency3") .. r51.get("default", "ui") .. 'Limit exploit fakelag'),
        { requires_login = true, key = 'misc_exploit_fakelag', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    r50.ui.misc_walkbot = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("arrow_up") .. r51.get("default", "ui") .. 'Walkbot'),
        { requires_login = true, key = 'misc_walkbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    r50.ui.misc_backstab = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("triangle_upside") .. r51.get("default", "ui") .. 'Backstab Assist'),
        { requires_login = true, key = 'misc_backstab', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    r50.ui.misc_spindead = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("turning2") .. r51.get("default", "ui") .. 'Spin on dead enemies'),
        { requires_login = true, key = 'misc_spindead', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    r50.ui.aa_gskey_freestandh = r50.register_ui(
        ui.new_label(tab[2], cont[2][3], r51.get("green", "ui") .. r53.get("turning2") .. r51.get("default", "ui") .. 'Freestand'),
        { requires_login = false, key = 'aa_gskey_freestandh', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.aa_gskey_freestand = r50.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'freestand', true),
        { requires_login = true, key = 'aa_gskey_freestand', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    r50.ui.aa_gskey_slowmotionh = r50.register_ui(
        ui.new_label(tab[2], cont[2][3], r51.get("green", "ui") .. r53.get("gear") .. r51.get("default", "ui") .. 'Slowmotion'),
        { requires_login = false, key = 'aa_gskey_slowmotionh', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.aa_gskey_slowmotion = r50.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'slowmotion', true),
        { requires_login = true, key = 'aa_gskey_slowmotion', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    r50.ui.aa_gskey_edgeyawh = r50.register_ui(
        ui.new_label(tab[2], cont[2][3], r51.get("green", "ui") .. r53.get("recycle") .. r51.get("default", "ui") .. 'Edge Yaw'),
        { requires_login = false, key = 'aa_gskey_edgeyawh', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.aa_gskey_edgeyaw = r50.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'edge yaw', true),
        { requires_login = true, key = 'aa_gskey_edgeyaw', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    r50.ui.aa_gskey_onshoth = r50.register_ui(
        ui.new_label(tab[2], cont[2][3], r51.get("green", "ui") .. r53.get("arrow_double") .. r51.get("default", "ui") .. 'On-shot aa'),
        { requires_login = false, key = 'aa_gskey_onshoth', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.aa_gskey_onshot = r50.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'on-shot aa', true),
        { requires_login = true, key = 'aa_gskey_onshot', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    
    for _, cond in ipairs(r49) do
        local r77= 'enable_' .. cond
        r50.ui[r77] = r50.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("accept") .. r51.get("default", "ui") .. 'Enable ' .. cond),
            { requires_login = true, key = r77, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        r50.ui['pitch_' .. cond] = r50.register_ui(
            ui.new_combobox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("triangle_upside") .. r51.get("default", "ui") .. 'Pitch', 'off', 'up', 'down', 'minimal', 'ideal'),
            { requires_login = true, key = 'pitch_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        r50.ui['yaw_base_' .. cond] = r50.register_ui(
            ui.new_combobox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("recycle") .. r51.get("default", "ui") .. 'Yaw Base', 'target', 'view', 'threat', 'distance', 'smart'),
            { requires_login = true, key = 'yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        r50.ui['yaw_' .. cond] = r50.register_ui(
            ui.new_combobox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("turning2") .. r51.get("default", "ui") .. 'Yaw', 'off', 'spin', '180', '3way', 'ideal'),
            { requires_login = true, key = 'yaw_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        r50.ui['label1_' .. cond] = r50.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label1_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        r50.ui['body_yaw_base_' .. cond] = r50.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Base', -90, 90, 0, true, '°'),
            { requires_login = true, key = 'body_yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        r50.ui['body_yaw_left_' .. cond] = r50.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Left', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_left_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        r50.ui['body_yaw_right_' .. cond] = r50.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Right', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_right_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        r50.ui['randomize_yaw_' .. cond] = r50.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Randomize Yaw', 0, 30, 0, true, '%', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'randomize_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        r50.ui['label2_' .. cond] = r50.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label2_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        r50.ui['yaw_jitter_' .. cond] = r50.register_ui(
            ui.new_combobox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("turning") .. r51.get("default", "ui") .. 'Yaw Jitter', 'off', 'center', 'skitter'),
            { requires_login = true, key = 'yaw_jitter_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        r50.ui['yaw_jitter_base_' .. cond] = r50.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Yaw Jitter - Base', 0, 120, 0, true, '°', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'yaw_jitter_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        r50.ui['body_yaw_mode_' .. cond] = r50.register_ui(
            ui.new_combobox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("gear") .. r51.get("default", "ui") .. 'Body Yaw Mode', 'off', 'static', 'opposite', 'jitter'),
            { requires_login = true, key = 'body_yaw_mode_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        r50.ui['static_body_yaw_' .. cond] = r50.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Static Body Yaw', -58, 58, 0, true, '°'),
            { requires_login = true, key = 'static_body_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        r50.ui['body_yaw_value_' .. cond] = r50.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw Value', 1, 3, 2, true, '', 2, {
                [1] = 'left', [2] = 'back', [3] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_value_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        r50.ui['delay_' .. cond] = r50.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Delay', 0, 17, 1, true, 't', 1, {
                [0] = 'jitter'
            }),
            { requires_login = true, key = 'delay_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        r50.ui['label3_' .. cond] = r50.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label3_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        r50.ui['fifty_fifty_' .. cond] = r50.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("question") .. r51.get("default", "ui") .. '50/50'),
            { requires_login = true, key = 'fifty_fifty_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        r50.ui['only_flip_on_0_choke_' .. cond] = r50.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("time") .. r51.get("default", "ui") .. 'Only Flip on 0 Choke'),
            { requires_login = true, key = 'only_flip_on_0_choke_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        r50.ui['aa_label_space' .. cond] = r50.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n abc'),
            { requires_login = true, key = 'aa_label_space', tab = 'AA', visible = true, config_type = 'label' }
        )
        r50.ui['aa_label_combo' .. cond] = r50.register_ui(
            ui.new_label(tab[2], cont[2][1], 'Send state -> state'),
            { requires_login = true, key = 'aa_label_combo', tab = 'AA', visible = true, config_type = 'label' }
        )
        r50.ui['send_combo' .. cond] = r50.register_ui(
            ui.new_combobox(tab[2], cont[2][1], '\n', unpack(r49)),
            { requires_login = true, key = 'send_combo' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        r50.ui['send_button' .. cond] = r50.register_ui(
            ui.new_button(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("upload") .. r51.get("default", "ui") .. 'Send', function() end),
            { requires_login = true, key = 'send_button', tab = 'AA', visible = true, config_type = 'button' }
        )

    end


    
    
    
    r50.ui.fakelag_mode = r50.register_ui(
        ui.new_combobox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("gear") .. r51.get("default", "ui") .. 'Mode', 'defensive', 'stealer', 'fakelag', 'settings'),
        { requires_login = true, key = 'fakelag_mode', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    r50.ui.fakelag_defensive = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("turning2") .. r51.get("default", "ui") .. 'Defensive'),
        { requires_login = true, key = 'fakelag_defensive', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    r50.ui.fakelag_force = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("exclamation") .. r51.get("default", "ui") .. 'Force'),
        { requires_login = true, key = 'fakelag_force', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    r50.ui.fakelag_fakedef = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("globe") .. r51.get("default", "ui") .. 'Unmatched.gg'),
        { requires_login = true, key = 'fakelag_fakedef', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    r50.ui.fakelag_force_on = r50.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("clip") .. r51.get("default", "ui") .. 'Force whilst', 'peek', 'reload', 'shot', 'damaged'),
        { requires_login = true, key = 'fakelag_force_on', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    
    
    
    r50.ui.cfg_load_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("arrow_double") .. r51.get("default", "ui") .. 'Load', function()
            local r67= r57()
            local r68= ui.get(r50.ui.cfg_listbox)
            local r78= r67[(r68 or 0) + 1]
            local r79= ui.get(r50.ui.cfg_input_box)
            local r61= (r78 and r78 ~= '(empty)' and r78 ~= '') and r78 or r79

            if r61 and r61 ~= '' and r61 ~= '(empty)' then
                local r80= require("require/abc/config_system")
                local function r81()
                    if not r50.ui.cfg_selection then return nil end
                    local r63, r82= pcall(ui.get, r50.ui.cfg_selection)
                    if not r63 or not r82 or type(r82) ~= 'table' or #r82 == 0 then return nil end
                    local r83= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local r84= {}
                    for _, v in ipairs(r82) do
                        local r58= r83[tostring(v)]
                        if r58 then r84[#r84+1] = r58 end
                    end
                    if #r84 == 0 then return nil end
                    return r84
                end
                local r85= r81()
                r80.load(r61, r85)
                r55.screenlog('[Config] Loaded config: ' .. r61, 4, 120, 180, 255, 255)
                if r55 and r55.pushlog and r62() then
                    r55.pushlog('Loaded config: ' .. r61, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for load.')
                if r55 and r55.pushlog and r62() then
                    r55.pushlog('No config name selected for load.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_load_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    r50.ui.cfg_save_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("config") .. r51.get("default", "ui") .. 'Save', function()
            local r67= r57()
            local r68= ui.get(r50.ui.cfg_listbox)
            local r78= r67[(r68 or 0) + 1]
            local r79= ui.get(r50.ui.cfg_input_box)
            local r61= (r78 and r78 ~= '(empty)' and r78 ~= '') and r78 or r79

            if r61 and r61 ~= '' then
                local r80= require("require/abc/config_system")
                local function r81()
                    if not r50.ui.cfg_selection then return nil end
                    local r63, r82= pcall(ui.get, r50.ui.cfg_selection)
                    if not r63 or not r82 or type(r82) ~= 'table' or #r82 == 0 then return nil end
                    local r83= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local r84= {}
                    for _, v in ipairs(r82) do
                        local r58= r83[tostring(v)]
                        if r58 then r84[#r84+1] = r58 end
                    end
                    if #r84 == 0 then return nil end
                    return r84
                end
                local r85= r81()
                r80.save(r61, r85)
                local r67= r57()
                if not r60(r67, r61) then
                    r67[#r67+1] = r61
                    r59(r67)
                end
                r65(r61)
                r55.screenlog('[Config] Saved config: ' .. r61, 4, 120, 180, 255, 255)
                if r55 and r55.pushlog and r62() then
                    r55.pushlog('Saved config: ' .. r61, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name provided for save.')
                if r55 and r55.pushlog and r62() then
                    r55.pushlog('No config name provided for save.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_save_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    r50.ui.cfg_create_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("plus") .. r51.get("default", "ui") .. 'Create', function()
            local r79= ui.get(r50.ui.cfg_input_box)
            if not r79 or r79 == '' then
                client.error_log('[Config] No config name provided for create.')
                if r55 and r55.pushlog and r62() then
                    r55.pushlog('No config name provided for create.', 4, 255, 255, 255, 255)
                end
                return
            end

            local r67= r57()
            if r60(r67, r79) then
                client.error_log('[Config] Config with that name already exists: ' .. r79)
                if r55 and r55.pushlog and r62() then
                    r55.pushlog('Config already exists: ' .. r79, 4, 255, 255, 255, 255)
                end
                return
            end

            local r80= require("require/abc/config_system")
            local function r81()
                if not r50.ui.cfg_selection then return nil end
                local r63, r82= pcall(ui.get, r50.ui.cfg_selection)
                if not r63 or not r82 or type(r82) ~= 'table' or #r82 == 0 then return nil end
                local r83= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local r84= {}
                for _, v in ipairs(r82) do
                    local r58= r83[tostring(v)]
                    if r58 then r84[#r84+1] = r58 end
                end
                if #r84 == 0 then return nil end
                return r84
            end
            local r85= r81()
            r80.save(r79, r85)
            r67[#r67+1] = r79
            r59(r67)
            r65(r79)
            r55.screenlog('[Config] Created config: ' .. r79, 4, 120, 180, 255, 255)
            if r55 and r55.pushlog and r62() then
                r55.pushlog('Created config: ' .. r79, 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_create_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    r50.ui.cfg_delete_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][1], r51.get("red", "ui") .. r53.get("trash") .. r51.get("default", "ui") .. 'Delete', function()
            local r67= r57()
            local r68= ui.get(r50.ui.cfg_listbox)
            local r78= r67[(r68 or 0) + 1]
            local r79= ui.get(r50.ui.cfg_input_box)
            local r61= (r78 and r78 ~= '(empty)' and r78 ~= '') and r78 or r79

            if r61 and r61 ~= '' and r61 ~= '(empty)' then
                local r80= require("require/abc/config_system")
                r80.delete(r61)
                local r67= r57()
                local r68= r60(r67, r61)
                if r68 then
                    table.remove(r67, r68)
                    r59(r67)
                end
                r65()
                r55.screenlog('[Config] Deleted config: ' .. r61, 4, 255, 80, 80, 255)
                if r55 and r55.pushlog and r62() then
                    r55.pushlog('Deleted config: ' .. r61, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for delete.')
                if r55 and r55.pushlog and r62() then
                    r55.pushlog('No config name selected for delete.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_delete_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    r50.ui.cfg_refresh_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("turning") .. r51.get("default", "ui") ..'Refresh', function()
            r65()
            r55.screenlog('[Config] Refreshed config list.', 4, 120, 180, 255, 255)
            if r55 and r55.pushlog and r62() then
                r55.pushlog('Refreshed config list.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_refresh_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    
    local r80= require("require/abc/config_system")
    local r86, r87= pcall(require, 'gamesense/clipboard')
    local r88= r87
    if not r86 or not r88 then
        r88 = {
            set = function(r89) end,
            get = function() return '' end,
        }
    end


    r50.ui.cfg_export_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("upload") .. r51.get("default", "ui") .. 'Export', function()
            local function r81()
                if not r50.ui.cfg_selection then return nil end
                local r63, r82= pcall(ui.get, r50.ui.cfg_selection)
                if not r63 or not r82 or type(r82) ~= 'table' or #r82 == 0 then return nil end
                local r83= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local r84= {}
                for r89, v in ipairs(r82) do
                    local r58= r83[tostring(v)]
                    if r58 then r84[#r84+1] = r58 end
                end
                if #r84 == 0 then return nil end
                return r84
            end
            local r85= r81()
            local r90= r80.build(r85)
            r88.set(r90)
            client.log('[Config] Exported config string:')
            client.log(r90)
            r55.screenlog('[Config] Exported config string to clipboard and console.', 4, 120, 180, 255, 255)
            if r55 and r55.pushlog and r62() then
                r55.pushlog('Exported config string to clipboard.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_export_button', tab = 'CFG', visible = true, config_type = 'button' }
    )

    r50.ui.cfg_import_button = r50.register_ui(
        ui.new_button(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("download") .. r51.get("default", "ui") .. 'Import', function()
            local r91= r88.get()
            if r91 and r91 ~= '' then
                local function r81()
                    if not r50.ui.cfg_selection then return nil end
                    local r63, r82= pcall(ui.get, r50.ui.cfg_selection)
                    if not r63 or not r82 or type(r82) ~= 'table' or #r82 == 0 then return nil end
                    local r83= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local r84= {}
                    for r89, v in ipairs(r82) do
                        local r58= r83[tostring(v)]
                        if r58 then r84[#r84+1] = r58 end
                    end
                    if #r84 == 0 then return nil end
                    return r84
                end
                local r85= r81()
                r80.apply(r91, r85)
                r55.screenlog('[Config] Imported config string from clipboard.', 4, 120, 180, 255, 255)
                if r55 and r55.pushlog and r62() then
                    r55.pushlog('Imported config string from clipboard.', 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config string found in clipboard.')
                if r55 and r55.pushlog and r62() then
                    r55.pushlog('No config string found in clipboard for import.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_import_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    r50.ui.cfg_selection = r50.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\n selection', 'antiaim', 'paint', 'misc'),
        { requires_login = true, key = 'cfg_selection', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    r50.ui.cfg_input_box = r50.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Config name'),
        { requires_login = true, key = 'cfg_input_box', tab = 'CFG', visible = true, config_type = 'textbox' }
    )
    r50.ui.cfg_listbox = r50.register_ui(
        ui.new_listbox(tab[2], cont[2][1], 'Configs', {}),
        { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    r65()

    r50.ui.cfg_cloud_apply = r50.register_ui(
        ui.new_button(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("globe") .. r51.get("default", "ui") .. ' Apply cloud', function()
            local r63, r82= pcall(ui.get, r50.ui.cfg_cloud)
            if not r63 then
                client.log('cfg_cloud_apply: failed to read selection')
                return
            end

            local r92= { 'Reset', 'Defensive', 'Unmatched', 'Community' }
            local r61= nil

            if type(r82) == 'number' then
                local r68= r82 + 1
                r61 = r92[r68]
            elseif type(r82) == 'table' then
                if #r82 > 0 and type(r82[1]) == 'number' then
                    r61 = r92[r82[1] + 1]
                else
                    r61 = tostring(r82[1])
                end
            else
                r61 = tostring(r82)
            end

            if not r61 or r61 == '' then
                client.log('cfg_cloud_apply: no selection')
                return
            end

            local r93, r94= pcall(require, 'require/abc/config_cloud')
            if not r93 or not r94 then
                client.log('cfg_cloud_apply: failed to load config_cloud module')
                return
            end

            local r95= r94[r61]
            if not r95 then
                client.log('cfg_cloud_apply: no cloud config string for', tostring(r61))
                return
            end

            local r96, r80= pcall(require, 'require/abc/config_system')
            if not r96 or not r80 or not r80.apply then
                client.log('cfg_cloud_apply: config_system.apply not available')
                return
            end

            r80.apply(r95)
            client.log('cfg_cloud_apply: applied cloud config', tostring(r61))
        end),
        { requires_login = true, key = 'cfg_cloud_apply', tab = 'AA', visible = true, config_type = 'button' }
    )

    r50.ui.cfg_cloud = r50.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'Cloud', { r51.get("red", "ui") .. 'Reset', r51.get("reddark", "ui") .. 'Defensive', r51.get("yellow", "ui") .. 'Unmatched', r51.get("grey", "ui") .. 'Community'}),
        { requires_login = true, key = 'cfg_cloud', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    r50.ui.fakelag_stealer = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("download") .. r51.get("default", "ui") .. 'Stealer' .. r51.get("blue", "ui") .. ' [BETA]' ),
        { requires_login = true, key = 'fakelag_stealer', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    r50.ui.fakelag_stealer_type = r50.register_ui(
        ui.new_combobox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("gear") .. r51.get("default", "ui") .. 'Type', 'mimic', 'import'),
        { requires_login = true, key = 'fakelag_stealer_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    r50.ui.fakelag_stealer_target = r50.register_ui(
        ui.new_combobox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("id") .. r51.get("default", "ui") .. 'Target', 'threat', 'closest', 'random', 'best kdas'),
        { requires_login = true, key = 'fakelag_stealer_target', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    r50.ui.fakelag_stealer_list = r50.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'target list', {'-'}),
        { requires_login = true, key = 'fakelag_stealer_list', tab = 'AA', visible = true, config_type = 'listbox' }
    )
    r50.ui.fakelag_stealer_refresh = r50.register_ui(
        ui.new_button(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("refresh") .. r51.get("default", "ui") .. 'Refresh', function() end),
        { requires_login = true, key = 'fakelag_stealer_refresh', tab = 'AA', visible = true, config_type = 'button' }
    )
    r50.ui.fakelag_stealer_steal = r50.register_ui(
        ui.new_button(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("clip") .. r51.get("default", "ui") .. 'Steal', function() end),
        { requires_login = true, key = 'fakelag_stealer_steal', tab = 'AA', visible = true, config_type = 'button' }
    )
    r50.ui.fakelag_fakelag = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("latency3") .. r51.get("default", "ui") .. 'Fakelag'),
        { requires_login = true, key = 'fakelag_fakelag', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    r50.ui.fakelag_fakelag_type = r50.register_ui(
        ui.new_combobox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("gear") .. r51.get("default", "ui") .. 'Type', 'gamesense', 'sodium'),
        { requires_login = true, key = 'fakelag_fakelag_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    r50.ui.fakelag_fakelag_amount = r50.register_ui(
        ui.new_combobox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("plus") .. r51.get("default", "ui") .. 'Amount', 'dynamic', 'maximum', 'fluctuate'),
        { requires_login = true, key = 'fakelag_fakelag_amount', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    r50.ui.fakelag_fakelag_variance = r50.register_ui(
        ui.new_slider(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("recycle") .. r51.get("default", "ui") .. 'Variance', 0, 100, 0, true, '%'),
        { requires_login = true, key = 'fakelag_fakelag_variance', tab = 'AA', visible = true, config_type = 'slider' }
    )
    r50.ui.fakelag_fakelag_limit = r50.register_ui(
        ui.new_slider(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("lock") .. r51.get("default", "ui") .. 'Limit', 1, 15, 1, true, 't'),
        { requires_login = true, key = 'fakelag_fakelag_limit', tab = 'AA', visible = true, config_type = 'slider' }
    )
    r50.ui.fakelag_fakelag_type2 = r50.register_ui(
        ui.new_combobox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("config") .. r51.get("default", "ui") .. 'Preset', 'jitter', 'max'),
        { requires_login = true, key = 'fakelag_fakelag_type2', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    r50.ui.fakelag_settings_freestanding = r50.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("turning2") .. r51.get("default", "ui") .. 'Freestanding options', 'static', 'zero pitch', 'defensive', 'side flip', 'pitch flip'),
        { requires_login = true, key = 'fakelag_settings_freestanding', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    r50.ui.fakelag_settings_enhance_onshot = r50.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("arrow_double") .. r51.get("default", "ui") .. 'Enhance on-shot aa', 'defensive', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_enhance_onshot', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    r50.ui.fakelag_settings_antibrute = r50.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("exclamation") .. r51.get("default", "ui") .. 'Antibrute', 'defensive', 'flip', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_antibrute', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    r50.ui.fakelag_settings_roll_checkbox = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], '\nuse roll'),
        { requires_login = true, key = 'fakelag_settings_roll_checkbox', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    r50.ui.fakelag_settings_roll_label = r50.register_ui(
        ui.new_label(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("recycle") .. r51.get("default", "ui") .. 'Roll'),
        { requires_login = false, key = 'label_roll', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.fakelag_settings_roll = r50.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nroll', 0, 45, 0, true, '°'),
        { requires_login = true, key = 'fakelag_settings_roll', tab = 'AA', visible = true, config_type = 'slider' }
    )
    r50.ui.fakelag_settings_side = r50.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nside', 1, 3, 1, true, '', 1, {
            [1] = 'left', [2] = 'swap', [3] = 'right'
        }),
        { requires_login = true, key = 'fakelag_settings_side', tab = 'AA', visible = true, config_type = 'slider' }
    )

    
    
    
    r50.ui.paint_advertisement = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nadvertisement', true),
        { requires_login = true, key = 'paint_advertisement', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_advertisement_animation = r50.register_ui(
        ui.new_slider(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("speaker") .. r51.get("default", "ui") .. 'Advertisement', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_advertisement_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    r50.ui.paint_advertisement_color = r50.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'rizz546456', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_advertisement_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    r50.ui.paint_watermark = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nwatermark'),
        { requires_login = true, key = 'paint_watermark', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_watermark_type = r50.register_ui(
        ui.new_slider(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("text") .. r51.get("default", "ui") .. 'Watermark', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_watermark_type', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    r50.ui.paint_watermark_color = r50.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'sigma9745', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_watermark_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    r50.ui.label_space2 = r50.register_ui(
        ui.new_label(tab[2], cont[2][1], '\n abc'),
        { requires_login = false, key = 'label_space2', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.label_space3 = r50.register_ui(
        ui.new_label(tab[2], cont[2][1], r51.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space3', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.paint_entidx = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'entidx'),
        { requires_login = true, key = 'paint_entidx', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_target_info = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'target info'),
        { requires_login = true, key = 'paint_target_info', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_filter_console = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'filter console'),
        { requires_login = true, key = 'paint_filter_console', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_minimum_damage = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'minimum damage'),
        { requires_login = true, key = 'paint_minimum_damage', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_show_damage_penetration = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'show damage penetration'),
        { requires_login = true, key = 'paint_show_damage_penetration', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_hitmiss_indicator = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'hit/miss indicator'),
        { requires_login = true, key = 'paint_hitmiss_indicator', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_self_skeleton = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'self skeleton'),
        { requires_login = true, key = 'paint_self_skeleton', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_bullet_tracer = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'bullet tracer'),
        { requires_login = true, key = 'paint_bullet_tracer', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_lagcomp_box = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lagcomp box'),
        { requires_login = true, key = 'paint_lagcomp_box', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_lagcomp_box_color = r50.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'lagcomp box color', 47, 117, 221, 255),
        { requires_login = true, key = 'paint_lagcomp_box_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    r50.ui.paint_presmoke = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'presmoke warning'),
        { requires_login = true, key = 'paint_presmoke', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_bombwarning = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'c4 warning'),
        { requires_login = true, key = 'paint_bombwarning', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_insults = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'insults'),
        { requires_login = true, key = 'paint_insults', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_rainbow_esp = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'rainbow esp'),
        { requires_login = true, key = 'paint_rainbow_esp', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_molotov = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'molotov particles'),
        { requires_login = true, key = 'paint_molotov', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_lag_record = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lag record'),
        { requires_login = true, key = 'paint_lag_record', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.label_space4 = r50.register_ui(
        ui.new_label(tab[2], cont[2][1], r51.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space4', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.paint_clantag = r50.register_ui(
        ui.new_combobox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("id") .. r51.get("default", "ui") .. 'Clantag', 'off', 'gamesense', 'sodium'),
        { requires_login = true, key = 'paint_clantag', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    r50.ui.paint_aimbot_logs = r50.register_ui(
        ui.new_combobox(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("clipboard") .. r51.get("default", "ui") .. 'Aimbot logs', 'off', 'gamesense', 'gamesense beta', 'sodium'),
        { requires_login = true, key = 'paint_aimbot_logs', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    r50.ui.label_space1 = r50.register_ui(
        ui.new_label(tab[2], cont[2][1], '\nextra space'),
        { requires_login = false, key = 'label_space1', tab = 'AA', visible = true, config_type = 'label' }
    )
    
    r50.ui.paint_indicators_enable = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n enable'),
        { requires_login = true, key = 'paint_indicators_enable', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_indicators_label = r50.register_ui(
        ui.new_label(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("pallete") .. r51.get("default", "ui") .. 'Indicators'),
        { requires_login = false, key = 'paint_indicators_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.paint_indicators = r50.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nIndicators', 'off', 'small', 'bold'),
        { requires_login = true, key = 'paint_indicators', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    r50.ui.paint_indicator_color = r50.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_indicator_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    r50.ui.paint_indicators_bar = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n bar'),
        { requires_login = true, key = 'paint_indicators_bar', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_indicators_animation = r50.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_indicators_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    r50.ui.paint_logger_checkbox = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n abc'),
        { requires_login = true, key = 'paint_logger_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_logger_label = r50.register_ui(
        ui.new_label(tab[2], cont[2][1], r51.get("green", "ui") .. r53.get("pen") .. r51.get("default", "ui") .. 'Logger'),
        { requires_login = false, key = 'paint_logger_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    r50.ui.paint_logger = r50.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\nLogger', 'aimbot', 'config', 'anti-aim', 'other'),
        { requires_login = true, key = 'paint_logger', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    r50.ui.paint_logger_color = r50.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_logger_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    r50.ui.paint_logger_animation = r50.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_logger_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    r50.ui.paint_hitmarker = r50.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("reject") .. r51.get("default", "ui") .. 'Hitmarkers', 'world +', 'skeleton', 'damage'),
        { requires_login = true, key = 'paint_hitmarker', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    r50.ui.paint_hitmarker_color = r50.register_ui(
        ui.new_color_picker(tab[2], cont[2][2], '\n + color', 0, 225, 225, 255),
        { requires_login = true, key = 'paint_hitmarker_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    r50.ui.paint_warnings = r50.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("warning") .. r51.get("default", "ui") .. 'Warnings', 'lethal', 'cant fire', 'low bullets'),
        { requires_login = true, key = 'paint_warnings', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    r50.ui.paint_performance_mode = r50.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("latency4") .. r51.get("default", "ui") .. 'Performance mode', 'blood', 'ragdolls', 'particles', 'lens flare', 'animations', 'feature updates'),
        { requires_login = true, key = 'paint_performance_mode', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    r50.ui.paint_animations = r50.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], r51.get("green", "ui") .. r53.get("turning2") .. r51.get("default", "ui") .. 'Animations', 'kingaru', 'body lean', 'gamesense legs', 'moonwalk', 'allah', 'static legs', 'no pitch on land', 'reversed legs', 'earthquake', 't-pose', 'blind', 'pitch up'),
        { requires_login = true, key = 'paint_animations', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    r50.ui.paint_aspect_ratio_checkbox = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], r51.get("green", "ui") .. r53.get("expand") .. r51.get("default", "ui") .. 'Aspect ratio'),
        { requires_login = true, key = 'paint_aspect_ratio_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_aspect_ratio = r50.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\naspect ratio', 0, 300, 0, true, '', 0.01, {
            [0] = 'default', [125] = '5:4', [133] = '4:3', [150] = '3:2', [160] = '16:10', [177] = '16:9'
        }),
        { requires_login = true, key = 'paint_aspect_ratio', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    r50.ui.paint_third_person_distance_checkbox = r50.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], r51.get("green", "ui") .. r53.get("camera") .. r51.get("default", "ui") .. 'Third person distance'),
        { requires_login = true, key = 'paint_third_person_distance_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    r50.ui.paint_third_person_distance = r50.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\nthird person distance', 30, 166, 150, true, '', 1, {
            [150] = 'default'
        }),
        { requires_login = true, key = 'paint_third_person_distance', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    
    
    
    
    local r97= {
        checkbox = 'c',
        slider = 's',
        combobox = 'o',
        multiselect = 'm',
    }
    for key, item in pairs(r50.ui) do
        for r89, entry in ipairs(r50.registered_items or {}) do
            if entry.key == key and entry.config_type and r97[entry.config_type] then
                r80.register(key, item, r97[entry.config_type], entry.tab)
            end
        end
    end
end

return r54]]
r662["require/abc/callbacks"] = [[




local r52= {}

local r53= 1
local r54= {}          
local r55= {}      
local r56= {}   

local function r57()
	local r58, r59= pcall(require, "require/abc/login_system")
	if not r58 or not r59 then return false end
	return r59.logged_in == true
end

local function r60(r61)
	if not r61 then return true end
	if r61.menu_only and not (ui and ui.is_menu_open and ui.is_menu_open()) then return false end
	if r61.alive_only then
		local r62= (entity and entity.get_local_player) and entity.get_local_player()
		if not r62 or not entity.is_alive(r62) then return false end
	end
	if r61.require_login then
		if not r57() then return false end
	end
	return true
end

local function r63(r64)
	return function(r65)
		local r66= r55[r64]
		if not r66 then return end
		local r67= {}
		for i=1,#r66 do r67[i] = r66[i] end
		for i=1,#r67 do
			local r68= r67[i]
			local r69= r54[r68]
			if r69 and r69.wrapper then
				local r58, r70= pcall(r69.wrapper, r65)
				if not r58 then
					local r71= nil
					pcall(function()
						r71 = debug.getinfo(r69.user_fn, "Sln")
					end)
					local r72= r71 and r71.short_src or "<unknown>"
					local r73= r71 and (r71.linedefined or -1) or -1
					pcall(client.error_log, string.format("callback[%d] error: %s (source=%s:%d)", r68, tostring(r70), r72, r73))
				end
			end
		end
	end
end



function r52.register(r64,r74,r75,r76,r77)
	if type(r64) ~= 'string' then error('event must be a string') end
	if type(r74) ~= 'function' then error('callback must be a function') end

	local r61= nil
	if type(r75) == 'table' then r61 = r75
	else
		r61 = { menu_only = (r75 == true), alive_only = (r76 == true), require_login = (r77 == true) }
	end

	local r68= r53; r53 = r53 + 1
	local r78= function(r65)
		if r60(r61) then
			return r74(r65)
		end
	end

	r54[r68] = { event = r64, wrapper = r78, user_fn = r74, opts = r61 }
	r55[r64] = r55[r64] or {}
	r55[r64][#r55[r64] + 1] = r68

	
	if not r56[r64] then
		local r79= r63(r64)
		r56[r64] = r79
		pcall(client.set_event_callback, r64, r79)
	end

	return r68
end

function r52.callback(r64,r75,r76,r77,r80)
	if type(r75) == 'function' then
		return r52.register(r64, r75, r76)
	end
	if type(r80) == 'function' then
		local r74= r80
		local r61= { menu_only = (r75 == true), alive_only = (r76 == true), require_login = (r77 == true) }
		return r52.register(r64, r74, r61)
	end
	error('invalid callback signature')
end

function r52.unregister(r68)
	local r69= r54[r68]
	if not r69 then return false end
	local r64= r69.event
	r54[r68] = nil
	local r81= r55[r64]
	if r81 then
		for i=#r81,1,-1 do if r81[i] == r68 then table.remove(r81, i) end end
		if #r81 == 0 then
			r55[r64] = nil
			local r79= r56[r64]
			if r79 then pcall(client.unset_event_callback, r64, r79) end
			r56[r64] = nil
		end
	end
	return true
end

function r52.clear_all()
	for r64, r79 in pairs(r56) do
		pcall(client.unset_event_callback, r64, r79)
	end
	r54 = {}
	r55 = {}
	r56 = {}
end

function r52._list()
	return { regs = r54, by_event = r55 }
end

pcall(function()
	if lua and lua.defer then
		lua.defer(r52.clear_all)
	else
		pcall(client.set_event_callback, 'shutdown', r52.clear_all)
	end
end)

return r52
]]
r662["require/abc/config_cloud"] = [[local r55= {
    Reset = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfbW92ZXx0PW98dj1vZmYKeWF3X2Zha2VsYWd8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wK3x0PXN8dj0wCmZha2VsYWdfc2V0dGluZ3Nfc2lkZXx0PXN8dj0xCnBpdGNoX21vdmV8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbW92ZXx0PXN8dj0wCmZha2VsYWdfZm9yY2Vfb258dD1tfHY9CmZha2VsYWdfZGVmZW5zaXZlfHQ9Y3x2PWZhbHNlCnlhd193YWxrfHQ9b3x2PW9mZgpzdGF0aWNfYm9keV95YXdfZmFrZWxhZ3x0PXN8dj0wCnBpdGNoX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfanVtcHx0PXN8dj0yCmJvZHlfeWF3X21vZGVfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXArfHQ9c3x2PTIKeWF3X2ppdHRlcl9iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfYmFzZV9kdWNrK3x0PW98dj10YXJnZXQKb25seV9mbGlwX29uXzBfY2hva2VfZHVjayt8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PWZhbHNlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9MApib2R5X3lhd19sZWZ0X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19zdGFuZHx0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19nbG9iYWx8dD1zfHY9MApwaXRjaF9kdWNrfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PW9mZgp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRhcmdldApmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wfHQ9c3x2PTAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PQpzZW5kX2NvbWJvanVtcHx0PW98dj1nbG9iYWwKc2VuZF9jb21ib2p1bXArfHQ9b3x2PWdsb2JhbApvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj1mYWxzZQpzdGF0aWNfYm9keV95YXdfbW92ZXx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVjayt8dD1zfHY9MAp5YXdfYmFzZV9nbG9iYWx8dD1vfHY9dGFyZ2V0CmVuYWJsZV9sZWdpdHx0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PQpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9kdWNrK3x0PXN8dj0yCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfdmFsdWVfbGVnaXR8dD1zfHY9Mgpib2R5X3lhd19iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfanVtcCt8dD1vfHY9b2ZmCmRlbGF5X3dhbGt8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdHlwZTJ8dD1vfHY9aml0dGVyCnlhd19sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9zdGFuZHx0PXN8dj0wCmVuYWJsZV9qdW1wK3x0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZmFrZWxhZ3x0PW98dj1nbG9iYWwKeWF3X2ppdHRlcl9iYXNlX2R1Y2t8dD1zfHY9MApmaWZ0eV9maWZ0eV9qdW1wfHQ9Y3x2PWZhbHNlCnBpdGNoX2xlZ2l0fHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfc3RhbmR8dD1zfHY9MAp5YXdfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfanVtcHx0PW98dj1vZmYKYm9keV95YXdfcmlnaHRfZHVja3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVjayt8dD1zfHY9MApib2R5X3lhd19tb2RlX3dhbGt8dD1vfHY9b2ZmCmJvZHlfeWF3X3JpZ2h0X2p1bXArfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10YXJnZXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj1mYWxzZQp5YXdfanVtcHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV93YWxrfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19nbG9iYWx8dD1zfHY9MApmaWZ0eV9maWZ0eV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfbW92ZXx0PW98dj1vZmYKeWF3X2Jhc2VfanVtcCt8dD1vfHY9dGFyZ2V0CnBpdGNoX2R1Y2srfHQ9b3x2PW1pbmltYWwKYm9keV95YXdfbW9kZV9qdW1wK3x0PW98dj1vZmYKc2VuZF9jb21ib2R1Y2t8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfZmFrZWxhZ3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVja3x0PW98dj1vZmYKZmFrZWxhZ19zdGVhbGVyX3RhcmdldHx0PW98dj10aHJlYXQKZmlmdHlfZmlmdHlfZHVjayt8dD1jfHY9ZmFsc2UKb25seV9mbGlwX29uXzBfY2hva2VfanVtcHx0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTAKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0wCmRlbGF5X2R1Y2srfHQ9c3x2PTEKYm9keV95YXdfbW9kZV9sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfZHVja3x0PXN8dj0yCmVuYWJsZV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PW9mZgp5YXdfYmFzZV9zdGFuZHx0PW98dj10YXJnZXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PW9mZgp5YXdfaml0dGVyX3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2xlZ2l0fHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19iYXNlX2xlZ2l0fHQ9b3x2PXRhcmdldApzdGF0aWNfYm9keV95YXdfd2Fsa3x0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X2Zha2VsYWd8dD1zfHY9MApkZWxheV9kdWNrfHQ9c3x2PTEKZmFrZWxhZ19zZXR0aW5nc19yb2xsfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2xpbWl0fHQ9c3x2PTEKZmFrZWxhZ19mYWtlbGFnX3ZhcmlhbmNlfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2Ftb3VudHx0PW98dj1keW5hbWljCmZha2VsYWdfZmFrZWxhZ190eXBlfHQ9b3x2PWdhbWVzZW5zZQpyYW5kb21pemVfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9nbG9iYWx8dD1zfHY9MApyYW5kb21pemVfeWF3X3dhbGt8dD1zfHY9MApjZmdfc2VsZWN0aW9ufHQ9bXx2PWFudGlhaW0KYm9keV95YXdfdmFsdWVfbW92ZXx0PXN8dj0yCmZpZnR5X2ZpZnR5X21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfbW92ZXx0PWN8dj1mYWxzZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ3x0PWN8dj1mYWxzZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfd2Fsa3x0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9zdGFuZHx0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZHVjayt8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnlhd19qaXR0ZXJfanVtcCt8dD1vfHY9b2ZmCnlhd19iYXNlX2p1bXB8dD1vfHY9dGFyZ2V0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKcGl0Y2hfanVtcCt8dD1vfHY9b2ZmCnlhd19kdWNrfHQ9b3x2PW9mZgpkZWxheV9qdW1wK3x0PXN8dj0xCmRlbGF5X3N0YW5kfHQ9c3x2PTEKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj0wCmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVja3x0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10YXJnZXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9MApib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgpib2R5X3lhd19sZWZ0X2dsb2JhbHx0PXN8dj0wCmRlbGF5X21vdmV8dD1zfHY9MQpkZWxheV9qdW1wfHQ9c3x2PTEKZW5hYmxlX2p1bXB8dD1jfHY9ZmFsc2UKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PTAKYm9keV95YXdfbGVmdF9qdW1wK3x0PXN8dj0wCnlhd19tb3ZlfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PWZhbHNlCmZha2VsYWdfZmFrZWRlZnx0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX2dsb2JhbHx0PW98dj1vZmYKZmlmdHlfZmlmdHlfanVtcCt8dD1jfHY9ZmFsc2UKY29uZGl0aW9ufHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X21vdmV8dD1zfHY9MApkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PWZhbHNl0000',
    Defensive = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9dHJ1ZQp5YXdfd2Fsa3x0PW98dj0xODAKc3RhdGljX2JvZHlfeWF3X2Zha2VsYWd8dD1zfHY9MApwaXRjaF9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXB8dD1zfHY9Mgpib2R5X3lhd19tb2RlX3N0YW5kfHQ9b3x2PWppdHRlcgpib2R5X3lhd192YWx1ZV9qdW1wK3x0PXN8dj0yCnlhd19qaXR0ZXJfYmFzZV9mYWtlbGFnfHQ9c3x2PTAKeWF3X2Jhc2VfZHVjayt8dD1vfHY9dGhyZWF0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2srfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PXRydWUKZGVsYXlfbGVnaXR8dD1zfHY9MQp5YXdfc3RhbmR8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVja3x0PXN8dj0wCmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKcGl0Y2hfZHVja3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfZHVjayt8dD1vfHY9aml0dGVyCnlhd19iYXNlX21vdmV8dD1vfHY9dGhyZWF0CmZha2VsYWdfbW9kZXx0PW98dj1zZXR0aW5ncwpwaXRjaF93YWxrfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9iYXNlX2p1bXB8dD1zfHY9MTIwCnNlbmRfY29tYm93YWxrfHQ9b3x2PWdsb2JhbApmYWtlbGFnX3NldHRpbmdzX2ZyZWVzdGFuZGluZ3x0PW18dj1zdGF0aWMJemVybyBwaXRjaAlkZWZlbnNpdmUJc2lkZSBmbGlwCnNlbmRfY29tYm9qdW1wfHQ9b3x2PWdsb2JhbApzZW5kX2NvbWJvanVtcCt8dD1vfHY9Z2xvYmFsCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXArfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9dHJ1ZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PWRlZmVuc2l2ZQlyb2xsCWppdHRlcgpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9MgpzZW5kX2NvbWJvbGVnaXR8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfbGVnaXR8dD1zfHY9LTU4Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTQKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9MApyYW5kb21pemVfeWF3X2R1Y2srfHQ9c3x2PTAKYm9keV95YXdfbW9kZV93YWxrfHQ9b3x2PXN0YXRpYwpib2R5X3lhd19yaWdodF9qdW1wK3x0PXN8dj0zNwpvbmx5X2ZsaXBfb25fMF9jaG9rZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmZha2VsYWdfc2V0dGluZ3NfYW50aWJydXRlfHQ9bXx2PQp5YXdfYmFzZV93YWxrfHQ9b3x2PXRocmVhdApmYWtlbGFnX3N0ZWFsZXJ8dD1jfHY9ZmFsc2UKZW5hYmxlX3N0YW5kfHQ9Y3x2PXRydWUKeWF3X2p1bXB8dD1vfHY9MTgwCmJvZHlfeWF3X2Jhc2Vfd2Fsa3x0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19zdGFuZHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZ2xvYmFsfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZHVja3x0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX21vdmV8dD1vfHY9aml0dGVyCnlhd19iYXNlX2p1bXArfHQ9b3x2PXRocmVhdApwaXRjaF9kdWNrK3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2p1bXB8dD1zfHY9MTgKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0tMwpkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjcKc2VuZF9jb21ib21vdmV8dD1vfHY9Z2xvYmFsCnJhbmRvbWl6ZV95YXdfbW92ZXx0PXN8dj0wCnBpdGNoX2p1bXB8dD1vfHY9ZG93bgp5YXdfYmFzZV9zdGFuZHx0PW98dj10aHJlYXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9zdGFuZHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2dsb2JhbHx0PWN8dj1mYWxzZQp5YXdfYmFzZV9sZWdpdHx0PW98dj10aHJlYXQKc3RhdGljX2JvZHlfeWF3X3dhbGt8dD1zfHY9MApib2R5X3lhd19yaWdodF9mYWtlbGFnfHQ9c3x2PTAKZGVsYXlfZHVja3x0PXN8dj01CmZha2VsYWdfc2V0dGluZ3Nfcm9sbHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19saW1pdHx0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ192YXJpYW5jZXx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19hbW91bnR8dD1vfHY9ZHluYW1pYwpmYWtlbGFnX2Zha2VsYWdfdHlwZXx0PW98dj1zb2RpdW0KcmFuZG9taXplX3lhd19qdW1wfHQ9c3x2PTAKeWF3X2ppdHRlcl9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKcmFuZG9taXplX3lhd193YWxrfHQ9c3x2PTAKY2ZnX3NlbGVjdGlvbnx0PW18dj1hbnRpYWltCmJvZHlfeWF3X3ZhbHVlX21vdmV8dD1zfHY9MgpmaWZ0eV9maWZ0eV9tb3ZlfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfYmFzZV9kdWNrK3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX21vdmV8dD1jfHY9dHJ1ZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0yNApmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV93YWxrfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCnNlbmRfY29tYm9kdWNrK3x0PW98dj1nbG9iYWwKYm9keV95YXdfcmlnaHRfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9qdW1wK3x0PW98dj1vZmYKeWF3X2Jhc2VfanVtcHx0PW98dj10aHJlYXQKb25seV9mbGlwX29uXzBfY2hva2VfbGVnaXR8dD1jfHY9dHJ1ZQpib2R5X3lhd19tb2RlX2R1Y2t8dD1vfHY9c3RhdGljCnN0YXRpY19ib2R5X3lhd19sZWdpdHx0PXN8dj0wCnBpdGNoX2p1bXArfHQ9b3x2PWRvd24KeWF3X2R1Y2t8dD1vfHY9MTgwCmRlbGF5X2p1bXArfHQ9c3x2PTMKZGVsYXlfc3RhbmR8dD1zfHY9NApmYWtlbGFnX2ZvcmNlfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X3JpZ2h0X2R1Y2srfHQ9c3x2PTQ0CmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0tMTUKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTE0Cnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9NTgKYm9keV95YXdfdmFsdWVfZ2xvYmFsfHQ9c3x2PTIKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApkZWxheV9tb3ZlfHQ9c3x2PTEKZGVsYXlfanVtcHx0PXN8dj0xCmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTQKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PS0xNgpib2R5X3lhd19sZWZ0X2p1bXArfHQ9c3x2PS05Cnlhd19tb3ZlfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PS0xNQpzdGF0aWNfYm9keV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3dhbGt8dD1jfHY9dHJ1ZQpmYWtlbGFnX2Zha2VkZWZ8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9nbG9iYWx8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmNvbmRpdGlvbnx0PW98dj1zdGFuZApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfbW92ZXx0PXN8dj00MgpkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PXRydWU00=',
    Unmatched = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9MgplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9ZmFsc2UKeWF3X3dhbGt8dD1vfHY9MTgwCnN0YXRpY19ib2R5X3lhd19mYWtlbGFnfHQ9c3x2PTAKcGl0Y2hfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9qdW1wfHQ9c3x2PTIKYm9keV95YXdfbW9kZV9zdGFuZHx0PW98dj1qaXR0ZXIKYm9keV95YXdfdmFsdWVfanVtcCt8dD1zfHY9Mgp5YXdfaml0dGVyX2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19iYXNlX2R1Y2srfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV9kdWNrK3x0PWN8dj10cnVlCnlhd19iYXNlX2Zha2VsYWd8dD1vfHY9dGFyZ2V0CnNlbmRfY29tYm9nbG9iYWx8dD1vfHY9Z2xvYmFsCnN0YXRpY19ib2R5X3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3dhbGt8dD1zfHY9MgplbmFibGVfd2Fsa3x0PWN8dj10cnVlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9LTM0CmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIxCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX3dhbGt8dD1zfHY9MApib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PWppdHRlcgpmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9ZG93bgp5YXdfaml0dGVyX2Jhc2VfanVtcHx0PXN8dj0xMjAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PXN0YXRpYwlkZWZlbnNpdmUKc2VuZF9jb21ib2p1bXB8dD1vfHY9Z2xvYmFsCnNlbmRfY29tYm9qdW1wK3x0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9ZmFsc2UKZmFrZWxhZ19zZXR0aW5nc19lbmhhbmNlX29uc2hvdHx0PW18dj1kZWZlbnNpdmUJcm9sbAlqaXR0ZXIKc3RhdGljX2JvZHlfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2Jhc2VfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF93YWxrfHQ9c3x2PTIzCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTIKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9NDQKcmFuZG9taXplX3lhd19kdWNrK3x0PXN8dj0wCmJvZHlfeWF3X21vZGVfd2Fsa3x0PW98dj1zdGF0aWMKYm9keV95YXdfcmlnaHRfanVtcCt8dD1zfHY9NTQKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10aHJlYXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj10cnVlCnlhd19qdW1wfHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3dhbGt8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfc3RhbmR8dD1zfHY9MApyYW5kb21pemVfeWF3X2dsb2JhbHx0PXN8dj0wCmZpZnR5X2ZpZnR5X2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9tb3ZlfHQ9b3x2PWppdHRlcgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9zdGFuZHx0PWN8dj10cnVlCmJvZHlfeWF3X2Jhc2VfanVtcHx0PXN8dj03CmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTI0CnJhbmRvbWl6ZV95YXdfZmFrZWxhZ3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfanVtcCt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9zdGFuZHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfanVtcCt8dD1zfHY9MApkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PWRvd24KeWF3X2Jhc2Vfc3RhbmR8dD1vfHY9dGhyZWF0Cnlhd19qaXR0ZXJfZmFrZWxhZ3x0PW98dj1vZmYKc2VuZF9jb21ib3N0YW5kfHQ9b3x2PWdsb2JhbApwaXRjaF9zdGFuZHx0PW98dj1kb3duCnlhd19qaXR0ZXJfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbGVnaXR8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV9nbG9iYWx8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfbGVnaXR8dD1vfHY9dGFyZ2V0CnN0YXRpY19ib2R5X3lhd193YWxrfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfZmFrZWxhZ3x0PXN8dj0wCmRlbGF5X2R1Y2t8dD1zfHY9NQpmYWtlbGFnX3NldHRpbmdzX3JvbGx8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfbGltaXR8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdmFyaWFuY2V8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfYW1vdW50fHQ9b3x2PWR5bmFtaWMKZmFrZWxhZ19mYWtlbGFnX3R5cGV8dD1vfHY9c29kaXVtCnlhd19qaXR0ZXJfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2dsb2JhbHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfd2Fsa3x0PXN8dj0wCmNmZ19zZWxlY3Rpb258dD1tfHY9YW50aWFpbQpib2R5X3lhd192YWx1ZV9tb3ZlfHQ9c3x2PTIKZmlmdHlfZmlmdHlfbW92ZXx0PWN8dj1mYWxzZQpkZWxheV9tb3ZlfHQ9c3x2PTMKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmZha2VsYWdfc3RlYWxlcl90eXBlfHQ9b3x2PW1pbWljCmJvZHlfeWF3X3JpZ2h0X3N0YW5kfHQ9c3x2PTQwCnBpdGNoX2R1Y2t8dD1vfHY9ZG93bgpmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQplbmFibGVfbW92ZXx0PWN8dj10cnVlCmVuYWJsZV9nbG9iYWx8dD1jfHY9ZmFsc2UKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApib2R5X3lhd19yaWdodF9tb3ZlfHQ9c3x2PTQyCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXArfHQ9b3x2PW9mZgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj10cnVlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1qaXR0ZXIKZGVsYXlfc3RhbmR8dD1zfHY9MQp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApwaXRjaF9qdW1wK3x0PW98dj1kb3duCmRlbGF5X2p1bXArfHQ9c3x2PTUKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQplbmFibGVfZmFrZWxhZ3x0PWN8dj1mYWxzZQpvbmx5X2ZsaXBfb25fMF9jaG9rZV9tb3ZlfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX21vdmV8dD1zfHY9MAp5YXdfZ2xvYmFsfHQ9b3x2PW9mZgpjYWNoZV9jcmVkZW50aWFsc3x0PWN8dj10cnVlCnJhbmRvbWl6ZV95YXdfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF9sZWdpdHx0PXN8dj0wCmRlbGF5X2dsb2JhbHx0PXN8dj0xCmRlbGF5X2p1bXB8dD1zfHY9MQpib2R5X3lhd19sZWZ0X2p1bXB8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2xlZnRfd2Fsa3x0PXN8dj0tMTYKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcCt8dD1zfHY9LTE4Cnlhd19kdWNrfHQ9b3x2PTE4MAp5YXdfYmFzZV9qdW1wK3x0PW98dj10aHJlYXQKeWF3X21vdmV8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVjayt8dD1zfHY9LTE1CmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKZmFrZWxhZ19mYWtlZGVmfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZ2xvYmFsfHQ9b3x2PW9mZgp5YXdfYmFzZV9qdW1wfHQ9b3x2PXRocmVhdApjb25kaXRpb258dD1vfHY9ZHVjaysKc2VuZF9jb21ib2R1Y2srfHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj00NAp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX2R1Y2srfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2Zha2VsYWd8dD1vfHY9b2ZmCmRlbGF5X2Zha2VsYWd8dD1zfHY9MQpzdGF0aWNfYm9keV95YXdfZHVjayt8dD1zfHY9MAp5YXdfaml0dGVyX2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXB8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X3dhbGt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfZmFrZWxhZ3x0PWN8dj1mYWxzZQpwaXRjaF9kdWNrK3x0PW98dj1kb3du0000',
    Community = '',
}
return r55]]
r662["require/abc/config_system"] = [[


local r58='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

local function r59(r60)
    return ((r60:gsub('.', function(r61)
        local r62,r58='',r61:byte()
        for i=8,1,-1 do r62=r62..(r58%2^i-r58%2^(i-1)>0 and '1' or '0') end
        return r62
    end)..'0000'):gsub('%d%d%d%d%d%d', function(r61)
        if (#r61 < 6) then return '' end
        return r58:sub(tonumber(r61,2)+1,tonumber(r61,2)+1)
    end)..({ '', '==', '=' })[#r60%3+1])
end

local function r63(r60)
    r60 = string.gsub(r60, '[^'..b..'=]', '')
    return (r60:gsub('.', function(r61)
        if r61 == '=' then return '' end
        local r62,r64='',(r58:find(r61)-1)
        for i=6,1,-1 do r62=r62..(r64%2^i-r64%2^(i-1)>0 and '1' or '0') end
        return r62
    end):gsub('%d%d%d%d%d%d%d%d', function(r61)
        if (#r61 ~= 8) then return '' end
        local r65=0
        for i=1,8 do r65=r65+(r61:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(r65)
    end))
end





local r66= database

local r67= {}
local r68= {}

local function r69(r70,r71,r72,r73)
    if not r70 or r70 == '' or not r71 or r68[r70] then return end
    r67[#r67+1] = { key = r70, ref = r71, type = r72, tab = r73 }
    r68[r70] = r67[#r67]
end

local function r74(r75)
    local function r76(r77,r75)
        if not r75 or #r75 == 0 then return true end
        if r77 == 'CFG' then return true end
        if not r77 then return true end
        for _, t in ipairs(r75) do if t == r77 then return true end end
        return false
    end

    local r78= { 'v=1' }
    for i = 1, #r67 do
        local r79= r67[i]
        if r76(r79.tab, r75) then
            local r80= r79.type
            local r81= ui.get(r79.ref)
            if r80 == 'c' then
                r78[#r78+1] = r79.key .. '|t=c|v=' .. (r81 and 'true' or 'false')
            elseif r80 == 's' then
                r78[#r78+1] = r79.key .. '|t=s|v=' .. tostring(r81 or 0)
            elseif r80 == 'o' then
                r78[#r78+1] = r79.key .. '|t=o|v=' .. tostring(r81 or '')
            elseif r80 == 'm' then
                if type(r81) == 'table' then
                    r78[#r78+1] = r79.key .. '|t=m|v=' .. table.concat(r81, '\t')
                end
            end
        end
    end
    return r59(table.concat(r78, '\n'))
end

local function r82(r83,r75)
    if not r83 or r83 == '' then return end
    local r84, r85= pcall(r63, r83)
    if not r84 or not r85 or r85 == '' then return end
    local function r76(r77,r75)
        if not r75 or #r75 == 0 then return true end
        if r77 == 'CFG' then return true end
        if not r77 then return true end
        for _, r80 in ipairs(r75) do if r80 == r77 then return true end end
        return false
    end
    for line in r85:gmatch('([^\n]+)') do
        if line ~= 'v=1' then
            local r70, r86, r87= line:match('^(.-)|t=(.)|v=(.*)$')
            if r70 and r86 and r87 then
                local r79= r68[r70]
                if r79 and r79.type == r86 and r76(r79.tab, r75) then
                    if r86 == 'c' then
                        ui.set(r79.ref, vseg == 'true')
                    elseif r86 == 's' then
                        local r88= tonumber(r87)
                        if r88 ~= nil then
                            ui.set(r79.ref, r88)
                        end
                    elseif r86 == 'o' then
                        pcall(ui.set, r79.ref, r87)
                    elseif r86 == 'm' then
                        local r89= {}
                        for token in r87:gmatch('[^\t]+') do r89[#r89+1] = token end
                        ui.set(r79.ref, r89)
                    end
                end
            end
        end
    end
end


local function r90(r91,r75)
    if not r91 or r91 == '' then return end
    local r83= r74(r75)
    r66.write('cfg:' .. r91, r83)
end


local function r92(r91,r75)
    if not r91 or r91 == '' then return end
    local r83= r66.read('cfg:' .. r91)
    if r83 then r82(r83, r75) end
end


local function r93(r91)
    if not r91 or r91 == '' then return end
    r66.write('cfg:' .. r91, nil)
end


local r94= {
    register = r69,
    build = r74,
    apply = r82,
    save = r90,
    load = r92,
    delete = r93,
}

return r94]]
r662["require/abc/garbage_collector"] = [[local r61= {}

local r62= {
    pause = 200,
    stepmul = 600,
    mode = "collect"
}

function r61.tune(r63)
	if type(r63) == "table" then
		if r63.pause then
			collectgarbage("setpause", r63.pause)
			r62.pause = r63.pause
		end
		if r63.stepmul then
			collectgarbage("setstepmul", r63.stepmul)
			r62.stepmul = r63.stepmul
		end
		if r63.mode then
			r62.mode = r63.mode
		end
	end
end

function r61.collect(r64)
	collectgarbage(r64 or r62.mode)
end

function r61.step(r65)
	return collectgarbage("step", r65 or 0)
end

function r61.stop()
	collectgarbage("stop")
end

function r61.restart()
	collectgarbage("restart")
end

function r61.memory()
	return collectgarbage("count")
end

function r61.status()
	return {
		memory = r61.memory(),
		pause = r62.pause,
		stepmul = r62.stepmul,
		mode = r62.mode
	}
end

local r66= 0
function r61.dynamic(r63)
	r63 = type(r63) == "table" and r63 or {}
	local r67= r63.min_interval or 0.6
	local r68= (globals and globals.realtime) and globals.realtime() or (r66 + r67)
	if r68 - r66 < r67 then
		return
	end
	r66 = r68

	local r65= r63.step_size or 20
	local r69= r63.full_threshold_kb or 65536
	local r70= r63.aggressive_threshold_kb or 12288

	local r71, r72= pcall(collectgarbage, "count")
	if not r71 or type(r72) ~= "number" then
		pcall(collectgarbage, "step", r65)
		return
	end

	if r72 >= r69 then
		pcall(collectgarbage, "collect")
		return
	end

	if r72 >= r70 then
		pcall(collectgarbage, "step", r65)
		pcall(collectgarbage, "step", r65)
		return
	end

	pcall(collectgarbage, "step", r65)
end

if lua and lua.defer then
	lua.defer(function()
		r61.collect()
	end)
end

return r61]]
r662["require/abc/hwid_check"] = [[local r64= require("ffi")
local r65= require("require/brain/dll")
local r66= 1
local r67= 1

local function r68()
    return globals.curtime and globals.curtime() or 0
end

local function r69()
    local shared= rawget(_G, "loader_shared")
    if not shared or type(shared) ~= "table" then
    return nil, "missing"
    end
    local r70= tonumber(shared.expires) or 0
    if r68() > r70 then
    return nil, "expired"
    end
    if type(shared.hwids) ~= "table" then
    return nil, "bad_hwids"
    end
    return shared, nil
end

local r71= false

local function r72()
    if not r65 or type(r65) ~= "table" or type(r65.get_hwid) ~= "function" then
        print("invalid hwid")
    return
    end

    local r73
    
    local r74, r75= pcall(r65.get_hwid)
    if r74 and r75 and r75 ~= r64.NULL then
    if type(r75) == "cdata" then
        local r76, r77= pcall(r64.string, r75)
        if r76 then r73 = r77 end
    else
        r73 = tostring(r75)
    end
    end

    if not r73 or r73 == "" then
        print("invalid hwid")
    end

    local shared, r78= r69()
    if not shared then
        print("invalid hwid")
    end

    local r79= shared.hwids
    local r80= false
    for i = 1, #r79 do
    local r81= tostring(r79[i] or "")
    if r81:find(tostring(r73), 1, true) then
        r80 = true
        break
    end
    end


    if r80 then
        local r82= rawget(_G, "loader_init_after_hwid")
        if not r71 and type(r82) == "function" then
        r71 = true
        local r83, r84= pcall(r82)
        if not r83 then
            print("invalid hwid")
        end
        end
    else
        print("invalid hwid")
    end
end

local r85= 0
local function r86()
    r85 = r85 + 1
    local shared= rawget(_G, "loader_shared")
    if shared then
    r72()
    return
    end
    if r85 > r66 then
        print("invalid hwid")
        return
    end

    if type(client.delay_call) == "function" then
        client.delay_call(r67, r86)
    else
        r72()
    end

end


r86()]]
r662["require/abc/login_system"] = [[local r67= {}


local function r68(r69)
	if client.hash_sha256 then
		return client.hash_sha256(r69)
	end
	
	return tostring(r69):reverse()
end


local r70= "acc_" .. "897ntv45ynvttyjt980745nyv0t485vn87t6"

local function r71()
	local r72= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local r73= ""
	for i = 1, 16 do
		local r74= math.random(1, #r72)
		r73 = r73 .. r72:sub(r74, r74)
	end
	return r73
end

function r67.hash_password(r75,r73)
	return r68(r73 .. r75)
end

function r67.verify_password(r75,r76,r73)
	return r67.hash_password(r75, r73) == r76
end

function r67.get_hwid()
	
	return tostring(client.userid_to_entindex(client.userid_to_entindex(1)))
end

function r67.store_credentials(r77,r75)
	local r73= r71()
	local r76= r67.hash_password(r75, r73)
	database.write("login_credentials", { username = r77, hash = r76, salt = r73 })
end

function r67.load_credentials()
	return database.read("login_credentials")
end


function r67.login(r77,r75)
	
	local r78= database.read(r70) or {}
	local r79= r78[r77]
	if r79 and r79.enabled ~= false then
		if r67.verify_password(r75, r79.hash, r79.salt) then
			r67.logged_in = true
			return true
		end
	end
	
	local r80= r67.load_credentials()
	if r80 and r80.username == r77 then
		if r67.verify_password(r75, r80.hash, r80.salt) then
			r67.logged_in = true
			return true
		end
	end
	r67.logged_in = false
	return false
end

function r67.logout()
	r67.logged_in = false
end

function r67.reset_password(r81)
	
	database.write("login_credentials", nil)
end



function r67.is_valid_invite(r82)
	if not r82 or r82 == "" then
		return false, nil
	end
	local r83= database.read(r70 .. ":invites") or {}
	local r84= r83[r82]
	if not r84 then
		return false, nil
	end
	if r84.used then
		return false, r84
	end
	return true, r84
end

function r67.add_account(r77,r75)
	local r73= r71()
	local r76= r67.hash_password(r75, r73)
	local r78= database.read(r70) or {}
	r78[r77] = { hash = r76, salt = r73, role = "user", enabled = true, orig_password = r75 }
	database.write(r70, r78)
end

function r67.register_with_invite(r82,r77,r75)
	if not r82 or r82 == '' then return false, 'no invite provided' end
	local r83= database.read(r70 .. ":invites") or {}
	local r84= r83[r82]
	if not r84 then return false, 'invalid invite' end
	if r84.used then return false, 'invite already used' end

	r67.add_account(r77, r75)

	r84.used = true
	r84.used_by = r77
	r84.redeemed_at = client.unix_time()
	r83[r82] = r84
	database.write(r70 .. ":invites", r83)

	return true
end

function r67.invalidate_invite(r82)
	local r83= database.read(r70 .. ":invites") or {}
	if r83[r82] then
		r83[r82] = nil
		database.write(r70 .. ":invites", r83)
		return true
	end
	return false
end

return r67
]]
r662["require/abc/menu_header"] = [[local r70, r71, r72= 1, 398, 49
local r73= 0.85 
local r74= { "AA", "PAINT", "MISC", "CFG" }
local r75= r74[r70]
local r76= {}
local r77= {
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS1.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS2.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS3.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS4.png"
}
local r78

local r79= {
    size = {
        x = 6,
        y = 6,
        w = 120,
        h = 72, 
    },
    skeet_cur_tab = 8,
}

local function r80()
    local r81= { ui.menu_position() }
    local r82= { ui.mouse_position() }
    if not r81[1] or not r81[2] or not r82[1] or not r82[2] then
        return r79.skeet_cur_tab
    end

    for i = 1, 9 do
        local r83= { r79.size.x, r79.size.y + r79.size.h * (i - 1) }
        if r82[1] >= r81[1] + r83[1]
           and r82[1] <= r81[1] + r79.size.w + r83[1]
           and r82[2] >= r81[2] + r83[2]
           and r82[2] <= r81[2] + r79.size.h + r83[2] then
            return i
        end
    end

    return r79.skeet_cur_tab
end

local function r84()
    if not renderer.load_png or not readfile then return end
    for i, path in ipairs(r77) do
        if not r76[i] then
            local r85= readfile(path)
            if r85 then
                r76[i] = renderer.load_png(r85, r71, r72)
            end
        end
    end
end


local function r86()
    local r87= ui.is_menu_open()
    local r88, r89= ui.menu_position()
    local r90, r91= ui.menu_size()
    r90 = r90-2
    r88 = r88+1
    if r87 and r88 and r89 and r90 and r91 then
        local r92= (r79.skeet_cur_tab == 2)
        local r93= math.floor(90 * r73)
        local r94= math.max(1, math.floor(4 * r73))
        local r95= math.max(1, math.floor(3 * r73))
        local r96= math.max(1, math.floor(2 * r73))
        local r97= math.max(0, math.floor(1 * r73))
        local r98= 0
        local r99= r88 + r94
        local r100= r89 - math.floor(7 * r73) - r93
        local r101= r90 - 2 * r94

        if r92 then
            renderer.rectangle(r99-r94*1.3, r100-8, r101+2*r94*1.5-1, r93+16, 12, 12, 12, 255)
            renderer.rectangle(r99-r95*1.5, r100-7, r101+2*r95*1.5, r93+14, 60, 60, 60, 255)
            renderer.rectangle(r99-r96*1.51, r100-6, r101+2*r96*2, r93+12, 40, 40, 40, 255)
            renderer.rectangle(r99-r97, r100-3, r101+2*r97, r93+6, 60, 60, 60, 255)
            renderer.rectangle(r99-r98, r100-2, r101+2*r98, r93+4, 12, 12, 12, 255)

            local r102= nil
            if renderer.load_rgba then
                local r103, r104= pcall(renderer.load_rgba,
                    string.char(
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
                    ), 4, 4)
                if r103 and r104 then r102 = r104 end
            end
            if r102 and renderer.texture then
                renderer.texture(r102, r99-r98, r100-2, r101+2*r98, r93+4, 255,255,255,255, 'r')
            end

            if renderer.gradient then
                renderer.gradient(r99-r98, r100-2, (r101+2*r98)/2+1, 1, 59,175,222,255, 202,70,205,255, true)
                renderer.gradient(r99-r98+(r101+2*r98)/2+1, r100-2, (r101+2*r98)/2-1, 1, 202,70,205,255, 204,227,53,255, true)
            end

            local r105= math.max(1, math.floor(2 * r73))
            local r106= r100 - math.floor(8 * r73)

            local r107= math.max(1, math.floor(5 * r73))
            local r108= 60
            renderer.circle(r99-r94+r107, r106+r105/2, r107, 59,175,222, r108, 16)
            renderer.circle(r99+r101-r94-r98-r107, r106+r105/2, r107, 204,227,53, r108, 16)
        end

        local r109= 4
        local r110= r100 + r93 / 2
        local r111, r112= ui.mouse_position()
        local r113= {}
        local r114= r93
            local r115= math.max(1, math.floor(59 * r73))
            local r116= math.max(1, math.floor(r71 * r73))
            local r117= math.max(1, math.floor(r72 * r73))
            local r118= r109 * r116 + (r109 - 1) * r115
            local r119= math.max(0, r101 * 0.5)
            local r120= r99 + r119 + (r101 - 2 * r119 - r118) / 2
            if r118 > r101 then
                r115 = math.max(0, math.floor((r101 - r109 * r116) / (r109 - 1)))
                r118 = r109 * r116 + (r109 - 1) * r115
                r120 = r99 + (r101 - r118) / 2
            end
        r84()
        local r121= r101 / r109
        for i=1,r109 do
            local r122= r99 + (i-1) * r121
            local r123= r100
            r113[i] = {x=r122, y=r123, w=r121, h=r114}
            if r92 then
                if r70 == i then
                    renderer.rectangle(r122, r123, r121, r114+1, 32,32,32, 85)
                end
                local r124= r122 + r121/2 - r116/2
                local r125= r123 + r114/2 - r117/2
                if r76[i] then
                    renderer.texture(r76[i], r124, r125, r116, r117, 255,255,255,255, "f")
                else
                    renderer.text(r124 + r116/2, r125 + r117/2, 255,255,255,255, '+c', 0, tostring(i))
                end
            end
        end

        local r126= client.key_state(1)
        if r87 and r111 and r112 and ui.is_menu_open() then
            if r126 and not prev_mouse_down then
                for i=1,r109 do
                    local r127= r113[i]
                    if r111 >= r127.x and r111 <= r127.x+r127.w and r112 >= r127.y and r112 <= r127.y+r127.h then
                        r70 = i
                        r75 = r74[r70]
                    end
                end
                local r128= { ui.menu_position() }
                if r128[1] and r128[2] then
                    for si = 1, 9 do
                        local r83= { r79.size.x, r79.size.y + r79.size.h * (si - 1) }
                        if r111 >= r128[1] + r83[1]
                           and r111 <= r128[1] + r79.size.w + r83[1]
                           and r112 >= r128[2] + r83[2]
                           and r112 <= r128[2] + r79.size.h + r83[2] then
                            r79.skeet_cur_tab = si
                            break
                        end
                    end
                end
            end
            prev_mouse_down = r126
        else
            prev_mouse_down = false
        end
        local r129= r80()
        local r130= r79.skeet_cur_tab or 0
        local r131= "Skeet sel: " .. tostring(r130)
        if r129 and r129 ~= r130 then
            r131 = r131 .. "  (hover: " .. tostring(r129) .. ")"
        end
        if r92 then
            if renderer.measure_text then
                pcall(function() renderer.measure_text(nil, r131) end)
            end
            renderer.text(r99 + 6, r100 + r93 + 6, 200,200,200,255, nil, 0, r131)
        end
    end
end

local function r132()
    if not ui.is_menu_open() then return false end
    local r111, r112= ui.mouse_position()
    local r133, r134= ui.menu_position()
    local r135, r136= ui.menu_size()
    local r93= math.floor(90 * r73)
    local r94= math.max(1, math.floor(4 * r73))
    local r99, r100, r101= r133 + r94, r134 - math.floor(7 * r73) - r93, r135 - 2 * r94
    return not (
        r111 >= r133 and r111 <= r133 + r135 and r112 >= r134 and r112 <= r134 + r136
        or r111 >= r99 and r111 <= r99 + r101 and r112 >= r100 and r112 <= r100 + r93
    )
end

return {
    current_tab = function() return r75 end,
    current_tab_index = function() return r70 end,
    tab_names = r74,
    tab_sections = function() return r78 end,
    menu_position = function() return ui.menu_position() end,
    menu_size = function() return ui.menu_size() end,
    is_menu_open = function() return ui.is_menu_open() end,
    mouse_position = function() return ui.mouse_position() end,
    is_mouse_outside_menu = r132,
    draw_menu = r86
}]]
r662["require/abc/menu_setup"] = [[local r73= {
    ui = {},
    registered_items = {},
}

function r73.register_ui(r74,r75)
    
    
    
    if r75 and r75.key then
        for i = #r73.registered_items, 1, -1 do
            local r76= r73.registered_items[i]
            if r76 and r76.key == r75.key then
                
                pcall(function()
                    if r76.item then ui.set_visible(r76.item, false) end
                end)
                table.remove(r73.registered_items, i)
            end
        end
    end

    table.insert(r73.registered_items, {
        item = r74,
        key = r75.key,
        requires_login = r75.requires_login,
        tab = r75.tab,
        visible = r75.visible ~= false,
        config_type = r75.config_type,
        show_condition = r75.show_condition,
    })
    return r74
end

function r73.update_visibility(r77)
    for _, r76 in ipairs(r73.registered_items) do
        local r78= r76.visible
        if r76.requires_login and not r77 then
            r78 = false
        end
        if r76.show_condition then
            r78 = r76.show_condition()
        end
        if r76.item then
            ui.set_visible(r76.item, r78)
        end
    end
end

function r73.save_config()
    local r79= {}
    for _, r76 in ipairs(r73.registered_items) do
        if r76.key and r76.item then
            r79[r76.key] = ui.get(r76.item)
        end
    end
    return r79
end

function r73.load_config(r80)
    for _, r76 in ipairs(r73.registered_items) do
        if r76.key and r76.item and r80[r76.key] ~= nil then
            ui.set(r76.item, r80[r76.key])
        end
    end
end

local r81= {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

local r82= {

    { 'Rage', 'other', 'accuracy boost' },
    { 'Rage', 'other', 'anti-aim correction' },
    { 'rage', 'other', 'automatic fire' },
    { 'Rage', 'other', 'automatic penetration' },
    { 'Rage', 'other', 'silent aim' },
    { 'Rage', 'other', 'remove recoil' },
    { 'Rage', 'other', 'reduce aimstep' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'log misses due to spread' },
    { 'Rage', 'other', 'low fps mitigations ' },
    { 'rage', 'other', 'delay shot' },
    { 'Rage', 'other', 'quick peek assist' },
    { 'Rage', 'other', 'quick peek assist mode' },
    { 'Rage', 'other', 'quick peek assist distance' },
    { 'Rage', 'other', 'reduce aim step' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'low fps mitigations' },
    { 'Rage', 'other', 'duck peek assist' },


}

function r73.toggle_gamesense_menu(r78)
    r73.state = r73.state or {}
    r73.hidden_refs = r73.hidden_refs or {}
    for _, r76 in ipairs(r81) do
        local r83, r84, r85, r86, r87= pcall(ui.reference, r76[1], r76[2], r76[3], r76[4])
        if r83 then
            if r76[1] == 'AA' and r76[2] == 'Anti-aimbot angles' and r76[3] == 'Enabled' then
                r73.state.gs_enabled_ref = r84
                if r84 ~= nil and r78 then
                    if r73.state.gs_enabled_previous ~= nil then
                        ui.set(r84, r73.state.gs_enabled_previous)
                    end
                elseif r84 ~= nil and not r78 then
                    r73.state.gs_enabled_previous = ui.get(r84)
                    ui.set(r84, true)
                end
            end
            local r88= { r84, r85, r86, r87 }
            local r89= {}
            for _, ref in ipairs(r88) do
                if ref ~= nil then
                    ui.set_visible(ref, r78)
                    r89[#r89 + 1] = ref
                end
            end
            if not r78 and #r89 > 0 then
                table.insert(r73.hidden_refs, r89)
            end
        end
    end
    r73.state.gs_hidden = not r78
end

function r73.toggle_rage_menu(r78)
    r73.state = r73.state or {}
    r73.hidden_rage_refs = r73.hidden_rage_refs or {}
    r73.hidden_rage_refs = {} 

    for _, r76 in ipairs(r82) do
        local r83, r84, r85, r86, r87= pcall(ui.reference, r76[1], r76[2], r76[3])
        if r83 then
            local r88= { r84, r85, r86, r87 }
            local r89= {}
            for _, ref in ipairs(r88) do
                if ref ~= nil then
                    pcall(function() ui.set_visible(ref, r78) end)
                    r89[#r89 + 1] = ref
                end
            end
            if not r78 and #r89 > 0 then
                table.insert(r73.hidden_rage_refs, r89)
            end
        end
    end
    r73.state.rage_hidden = not r78
end

return r73]]
r662["require/abc/menu_visibility"] = [[local r76= {
	"global",
	"stand",
	"move",
	"duck",
	"duck+",
	"jump",
	"jump+",
	"walk",
	"fakelag",
	"legit",
}

local r77= require("require/abc/login_system")

local function r78(r79)
	if r79.menu_setup and r79.menu_setup.refresh_cfg_listbox then
		r79.menu_setup.refresh_cfg_listbox()
	end

	if r79 and not r79.login then
		r79.login = r77
	end
	r79.menu_setup.toggle_gamesense_menu(false)
	r79.menu_setup.toggle_rage_menu(true)
	r79.menu_setup.update_visibility(r79.login and r79.login.logged_in)
	local r80= (r79.login and r79.login.logged_in) or false

	local r81= not r80
	local r82= (r79.menu_header and r79.menu_header.current_tab and r79.menu_header.current_tab()) or r79.menu.current_tab()
	 	
	ui.set_visible(r79.menu_setup.ui.login_howto_header, r81)
	ui.set_visible(r79.menu_setup.ui.login_console_register, r81)
	ui.set_visible(r79.menu_setup.ui.login_menu_credentials, r81)
	ui.set_visible(r79.menu_setup.ui.login_press_login, r81)
	ui.set_visible(r79.menu_setup.ui.login_spacer1, r81)
	ui.set_visible(r79.menu_setup.ui.reset_header, r81)
	ui.set_visible(r79.menu_setup.ui.reset_step1, r81)
	ui.set_visible(r79.menu_setup.ui.reset_step2, r81)
	ui.set_visible(r79.menu_setup.ui.login_spacer2, r81)
	ui.set_visible(r79.menu_setup.ui.support_header, r81)
	ui.set_visible(r79.menu_setup.ui.support_discord, r81)
	ui.set_visible(r79.menu_setup.ui.login_username, r81)
	ui.set_visible(r79.menu_setup.ui.login_password, r81)
	ui.set_visible(r79.menu_setup.ui.cache_credentials, r81)
	ui.set_visible(r79.menu_setup.ui.login_button, r81)
	ui.set_visible(r79.menu_setup.ui.reset_button, r81)
	ui.set_visible(r79.menu_setup.ui.discord_button, r81)
	ui.set_visible(r79.menu_setup.ui.youtube_button, r81)
	ui.set_visible(r79.menu_setup.ui.sellhub_button, r81)
	ui.set_visible(r79.menu_setup.ui.logout_button, r80 and r82 == "CFG")

	if r79.menu_setup.ui.condition then
		local r83= ui.get(r79.menu_setup.ui.condition)
		for _, cond in ipairs(r76) do
			local r84= r80 and r82 == "AA" and r83 == cond
			local r85= 'enable_' .. cond
			if r79.menu_setup.ui[r85] then
				ui.set_visible(r79.menu_setup.ui[r85], r84)
				local r86= r79.safe.safe_get(r79.menu_setup.ui[r85])

				local r87= r79.menu_setup.ui['yaw_' .. cond] and ui.get(r79.menu_setup.ui['yaw_' .. cond]) or nil
				local r88= r79.menu_setup.ui['yaw_jitter_' .. cond] and ui.get(r79.menu_setup.ui['yaw_jitter_' .. cond]) or nil
				local r89= r79.menu_setup.ui['body_yaw_mode_' .. cond] and ui.get(r79.menu_setup.ui['body_yaw_mode_' .. cond]) or nil
				local r90= r79.menu_setup.ui['delay_' .. cond] and ui.get(r79.menu_setup.ui['delay_' .. cond]) or nil
				ui.set_visible(r79.menu_setup.ui['pitch_' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['yaw_base_' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['yaw_' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['label1_' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['label2_' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['label3_' .. cond], r84 and r86)
				local r91= r84 and r86 and (r87 ~= 'off' and r87 ~= 'ideal' and r87 ~= '3way')
				ui.set_visible(r79.menu_setup.ui['body_yaw_base_' .. cond], r91)
				local r92= r84 and r86 and (r87 == '180' or r87 == '3way')
				ui.set_visible(r79.menu_setup.ui['body_yaw_left_' .. cond], r92)
				ui.set_visible(r79.menu_setup.ui['body_yaw_right_' .. cond], r92)
				local r93= r84 and r86 and (r87 ~= 'off' and r87 ~= 'ideal')
				ui.set_visible(r79.menu_setup.ui['randomize_yaw_' .. cond], r93)
				local r94= r84 and r86 and (r88 ~= 'off')
				ui.set_visible(r79.menu_setup.ui['yaw_jitter_base_' .. cond], r94)
				local r95= r84 and r86 and (r89 == 'static')
				ui.set_visible(r79.menu_setup.ui['static_body_yaw_' .. cond], r95)
				local r96= r84 and r86 and (r89 == 'jitter' and r90 and r90 <= 0)
				ui.set_visible(r79.menu_setup.ui['body_yaw_value_' .. cond], r96)
				local r97= r84 and r86 and (r89 == 'jitter')
				ui.set_visible(r79.menu_setup.ui['delay_' .. cond], r97)
				ui.set_visible(r79.menu_setup.ui['yaw_jitter_' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['body_yaw_mode_' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['fifty_fifty_' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['only_flip_on_0_choke_' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['aa_label_space' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['aa_label_combo' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['send_button' .. cond], r84 and r86)
				ui.set_visible(r79.menu_setup.ui['send_combo' .. cond], r84 and r86)
			end
		end
		ui.set_visible(r79.menu_setup.ui.condition, r80 and r82 == "AA")
		ui.set_visible(r79.menu_setup.ui.condition_label, r80 and r82 == "AA")
		ui.set_visible(r79.menu_setup.ui.condition_label2, r80 and r82 == "AA")


		ui.set_visible(r79.menu_setup.ui.fakelag_mode, r80 and r82 == "AA")
		if r79.menu_setup.ui.fakelag_mode then
			local r98= ui.get(r79.menu_setup.ui.fakelag_mode)
			local r99= r80 and r82 == "AA"
			local r100= r99 and r98 == "defensive"
			local r101= r79.safe.safe_get(r79.menu_setup.ui.fakelag_defensive) == true
			ui.set_visible(r79.menu_setup.ui.fakelag_defensive, r100)
			ui.set_visible(r79.menu_setup.ui.fakelag_force, r100 and r101)
			ui.set_visible(r79.menu_setup.ui.fakelag_force_on, r100 and r101)
			ui.set_visible(r79.menu_setup.ui.fakelag_fakedef, r100 and r101)

			local r102= r99 and r98 == "stealer"
			local r103= r79.safe.safe_get(r79.menu_setup.ui.fakelag_stealer) == true
			ui.set_visible(r79.menu_setup.ui.fakelag_stealer, r102)
			ui.set_visible(r79.menu_setup.ui.fakelag_stealer_type, r102 and r103)
			ui.set_visible(r79.menu_setup.ui.fakelag_stealer_target, r102 and r103)
			ui.set_visible(r79.menu_setup.ui.fakelag_stealer_list, r102 and r103)
			ui.set_visible(r79.menu_setup.ui.fakelag_stealer_refresh, r102 and r103)
			ui.set_visible(r79.menu_setup.ui.fakelag_stealer_steal, r102 and r103)

			local r104= r99 and r98 == "fakelag"
			local r105= r79.safe.safe_get(r79.menu_setup.ui.fakelag_fakelag) == true
			local r106= r79.safe.safe_get(r79.menu_setup.ui.fakelag_fakelag_type) == "sodium"
			ui.set_visible(r79.menu_setup.ui.fakelag_fakelag, r104)
			ui.set_visible(r79.menu_setup.ui.fakelag_fakelag_type, r104 and r105)
			ui.set_visible(r79.menu_setup.ui.fakelag_fakelag_amount, r104 and r105 and not r106)
			ui.set_visible(r79.menu_setup.ui.fakelag_fakelag_variance, r104 and r105 and not r106)
			ui.set_visible(r79.menu_setup.ui.fakelag_fakelag_limit, r104 and r105 and not r106)
			ui.set_visible(r79.menu_setup.ui.fakelag_fakelag_type2, r104 and r105 and r106)

			local r107= r99 and r98 == "settings"
			ui.set_visible(r79.menu_setup.ui.fakelag_settings_freestanding, r107)
			ui.set_visible(r79.menu_setup.ui.fakelag_settings_enhance_onshot, r107)
			ui.set_visible(r79.menu_setup.ui.fakelag_settings_antibrute, r107)
			ui.set_visible(r79.menu_setup.ui.fakelag_settings_roll_label, r107)
			ui.set_visible(r79.menu_setup.ui.fakelag_settings_roll_checkbox, r107)
			local r108= r107 and r79.safe.safe_get(r79.menu_setup.ui.fakelag_settings_roll_checkbox) == true
			ui.set_visible(r79.menu_setup.ui.fakelag_settings_roll, r108)
			ui.set_visible(r79.menu_setup.ui.fakelag_settings_side, r108)
		end

		local r109= r80 and r82 == "PAINT" and ui.get(r79.menu_setup.ui.paint_indicators_enable) == true
		local r110= r80 and r82 == "PAINT" and r109 and ui.get(r79.menu_setup.ui.paint_indicators) ~= "off"
		local r111= r80 and r82 == "PAINT" and r109 and ui.get(r79.menu_setup.ui.paint_indicators) == "small"
		ui.set_visible(r79.menu_setup.ui.paint_indicators, r109)
		ui.set_visible(r79.menu_setup.ui.paint_indicators_enable, r110)
		ui.set_visible(r79.menu_setup.ui.paint_indicators_animation, r110)
		ui.set_visible(r79.menu_setup.ui.paint_indicators_bar, r111)
		ui.set_visible(r79.menu_setup.ui.paint_indicator_color, r110)

		local r112= r80 and r82 == "PAINT" and ui.get(r79.menu_setup.ui.paint_advertisement) == true
		ui.set_visible(r79.menu_setup.ui.paint_advertisement_color, r112)

		local r113= r80 and r82 == "PAINT" and ui.get(r79.menu_setup.ui.paint_watermark) == true
		ui.set_visible(r79.menu_setup.ui.paint_watermark_color, r113)

		local r114= r80 and r82 == "MISC" and r79.safe.safe_get(r79.menu_setup.ui.misc_dormantaimbot) == true
		ui.set_visible(r79.menu_setup.ui.misc_dormantaimbot_key, r114)
		ui.set_visible(r79.menu_setup.ui.misc_dormantaimbot_value, r114)

		local r115= r80 and r82 == "PAINT" and r79.safe.safe_get(r79.menu_setup.ui.paint_logger_checkbox) == true
		ui.set_visible(r79.menu_setup.ui.paint_logger, r115)
		ui.set_visible(r79.menu_setup.ui.paint_logger_animation, r115)
		ui.set_visible(r79.menu_setup.ui.paint_logger_color, r115)

		local r116= r80 and r82 == "PAINT" and r79.safe.safe_get(r79.menu_setup.ui.paint_aspect_ratio_checkbox) == true
		ui.set_visible(r79.menu_setup.ui.paint_aspect_ratio, r116)

		local r117= r80 and r82 == "PAINT" and r79.safe.safe_get(r79.menu_setup.ui.paint_third_person_distance_checkbox) == true
		ui.set_visible(r79.menu_setup.ui.paint_third_person_distance, r117)

	end

	local r118= {
		'aa_gskey_freestand',
		'aa_gskey_freestandh',
		'aa_gskey_slowmotion',
		'aa_gskey_slowmotionh',
		'aa_gskey_edgeyaw',
		'aa_gskey_edgeyawh',
		'aa_gskey_onshot',
		'aa_gskey_onshoth',
	}
	for _, key in ipairs(r118) do
		if r79.menu_setup.ui[key] then
			ui.set_visible(r79.menu_setup.ui[key], tab_name == "AA")
		end
	end

	local r119= {
		'misc_resolver',
		'misc_ragebot',
		'misc_dormantaimbot',
		'misc_exploit_fakelag',
		'misc_walkbot',
		'misc_backstab',
		'misc_spindead',
	}
	for _, key in ipairs(r119) do
		if r79.menu_setup.ui[key] then
			ui.set_visible(r79.menu_setup.ui[key], tab_name == "MISC")
		end
	end

	local r120= {
		'paint_target_info',
		'label_space2',
		'label_space3',
		'label_space4',
		'paint_entidx',
		'paint_filter_console',
		'paint_minimum_damage',
		'paint_show_damage_penetration',
		'paint_hitmiss_indicator',
		'paint_self_skeleton',
		'paint_bullet_tracer',
		'paint_lagcomp_box',
		'paint_lagcomp_box_color',
		'paint_presmoke',
		'paint_bombwarning',
		'paint_insults',
		'paint_rainbow_esp',
		'paint_molotov',
		'paint_lag_record',
		'paint_advertisement',
		'paint_advertisement_animation',
		'paint_clantag',
		'paint_aimbot_logs',
		'paint_indicators_label',
		'paint_indicators_enable',
		'label_space1',
		'paint_watermark',
		'paint_watermark_type',
		'paint_logger_label',
		'paint_logger_checkbox',
		'paint_hitmarker',
		'paint_hitmarker_color',
		'paint_warnings',
		'paint_animations',
		'paint_performance_mode',
		'paint_aspect_ratio_checkbox',
		'paint_third_person_distance_checkbox',
	}
	for _, key in ipairs(r120) do
		if r79.menu_setup.ui[key] then
			ui.set_visible(r79.menu_setup.ui[key], tab_name == "PAINT")
		end
	end

		local r121= {
			'cfg_load_button',
			'cfg_save_button',
			'cfg_delete_button',
			'cfg_refresh_button',
			'cfg_create_button',
			'cfg_export_button',
			'cfg_import_button',
			'cfg_input_box',
			'cfg_listbox',
			'cfg_selection',
			'cfg_cloud',
			'cfg_cloud_apply',
		}
		for _, key in ipairs(r121) do
			if r79.menu_setup.ui[key] then
				ui.set_visible(r79.menu_setup.ui[key], r80 and r82 == "CFG")
			end
		end

end

local function r122(r79)
	local r123= {
		r79.menu_setup.ui.condition,
		r79.menu_setup.ui.fakelag_mode,
	}
	for _, item in ipairs(r123) do
		if item then
			ui.set_callback(item, function()
				r78(r79)
			end)
		end
	end

	for _, cond in ipairs(r76) do
		local r124= {
			'enable_' .. cond,
			'yaw_' .. cond,
			'yaw_jitter_' .. cond,
			'body_yaw_mode_' .. cond,
			'fifty_fifty_' .. cond,
			'only_flip_on_0_choke_' .. cond,
			'aa_label_space' .. cond,
			'aa_label_combo' .. cond,
			'send_button' .. cond,
			'send_combo' .. cond,
		}
		for _, key in ipairs(r124) do
			local r125= r79.menu_setup.ui[key]
			if r125 then
				ui.set_callback(r125, function()
					r78(r79)
				end)
			end
		end
	end

	local r126= {
		'fakelag_defensive',
		'fakelag_stealer',
		'fakelag_fakelag',
		'fakelag_fakelag_type',
		'fakelag_settings_roll_label',
		'fakelag_settings_roll_checkbox',
	}
	for _, key in ipairs(r126) do
		local r125= r79.menu_setup.ui[key]
		if r125 then
			ui.set_callback(r125, function()
				r78(r79)
			end)
		end
	end

	if r79.menu_setup.ui.paint_indicators then
		ui.set_callback(r79.menu_setup.ui.paint_indicators, function()
			r78(r79)
		end)
	end

	if r79.menu_setup.ui.paint_advertisement then
		ui.set_callback(r79.menu_setup.ui.paint_advertisement, function()
			r78(r79)
		end)
	end
	
	if r79.menu_setup.ui.paint_watermark then
		ui.set_callback(r79.menu_setup.ui.paint_watermark, function()
			r78(r79)
		end)
	end

	if r79.menu_setup.ui.misc_dormantaimbot then
		ui.set_callback(r79.menu_setup.ui.misc_dormantaimbot, function()
			r78(r79)
		end)
	end

	if r79.menu_setup.ui.paint_logger_checkbox then
		ui.set_callback(r79.menu_setup.ui.paint_logger_checkbox, function()
			r78(r79)
		end)
	end

	if r79.menu_setup.ui.paint_aspect_ratio_checkbox then
		ui.set_callback(r79.menu_setup.ui.paint_aspect_ratio_checkbox, function()
			r78(r79)
		end)
	end

	if r79.menu_setup.ui.paint_third_person_distance_checkbox then
		ui.set_callback(r79.menu_setup.ui.paint_third_person_distance_checkbox, function()
			r78(r79)
		end)
	end

	if r79.menu_setup.ui.paint_indicators_enable then
		ui.set_callback(r79.menu_setup.ui.paint_indicators_enable, function()
			r78(r79)
		end)
	end

	if r79.login and type(r79.login.add_state_callback) == 'function' then
		r79.login.add_state_callback(function()
			r78(r79)
		end)
	end
end

return {
	update = r78,
	setup_callbacks = r122
}]]
r662["require/abc/push_gamesense"] = [[local r79= renderer
local r80= globals
local r81= string.char

local r82= nil
local function r83()
    if r82 then return r82 end
    if r79.load_rgba then
        local r84, r85= pcall(r79.load_rgba,
            string.char(
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
            ), 4, 4)
        if r84 and r85 then r82 = r85 end
    end
    return r82
end


local function r86(r87,r88,r89,r90,r91,r92)
    local r93= r87 - 3
    local r94= r88 - 40
    local r95= r89 + 5
    local r96= r90 + 1
    r79.rectangle(r87 - 10, r88 - 48, r89 + 20, r90 + 16, 0, 0, 0, 200)
    r79.rectangle(r87 - 9, r88 - 47, r89 + 18, r90 + 14, 60, 60, 60, 255)
    r79.rectangle(r87 - 8, r88 - 46, r89 + 16, r90 + 12, 40, 40, 40, 255)
    r79.rectangle(r87 - 5, r88 - 43, r89 + 10, r90 + 6, 60, 60, 60, 255)
    r79.rectangle(r87 - 4, r88 - 42, r89 + 8, r90 + 4, 12, 12, 12, 255)
    r79.rectangle(r87 - 4, r88 - 42, r89 + 8, r90 + 4, 32, 32, 32, 255)
    local r97= r83()
    if r97 and r79.texture then
        r79.texture(r97, r93, r94, r95, r96, 255,255,255,r91, 'r')
    else
        r79.rectangle(r93, r94, r95, r96, 0, 0, 0, 0)
    end

    
    if r79.gradient then
        r79.gradient(r87 - 4, r88 - 42, r89 / 2 + 1, 1, 59, 175, 222, 255, 202, 70, 205, 255, true)
        r79.gradient(r87 - 4 + r89 / 2, r88 - 42, r89 / 2 + 8.5, 1, 202, 70, 205, 255, 204, 227, 53, 255, true)
    end
    r79.text(r87, r88 - 40, 255, 255, 255, 255, '', nil, r92)
end

return r86
]]
r662["require/abc/push_logger"] = [[local r82= renderer
local r83= globals
local r84= client
local r85= entity
local r86= table.insert
local r87= table.remove
local r88= math.floor
local r89= math.sqrt
local r90= string.char


local r91, r92= pcall(require, "require/abc/menu_setup")


local r93, r94= pcall(ui.reference, 'misc', 'settings', 'menu color')

local r95= {}
local r96= 5

local function r97(r98,r99,r100,r101,r102,r103)
    if #r95 >= r96 then
        r87(r95, 1)
    end
    r86(r95, {
        text = tostring(r98),
        duration = r99 or 5,
        color = { r100 or 255, r101 or 255, r102 or 255, r103 or 255 },
        timestamp = r83 and r83.curtime and r83.curtime() or os.clock(),
    })
end

local function r104(r105)
    local r106, r107, r108= pcall(r82.measure_text, '', r105)
    if r106 and type(r107) == 'number' then return r107, r108 or 0 end
    r106, r107, h = pcall(r82.measure_text, r105)
    if r106 and type(r107) == 'number' then return r107, r108 or 0 end
    return 0, 0
end

local function r109(r110,r111,r112)
    if r110 < r111 then return r111 end
    if r110 > r112 then return r112 end
    return r110
end


local function r113()
    if r91 and r92 and r92.ui and r92.ui.paint_logger then
        local r106, r114= pcall(ui.get, r92.ui.paint_logger)
        if r106 and r114 then return true end
        return false
    end
    
    return true
end


local function r115()
    if r91 and r92 and r92.ui and r92.ui.paint_logger_animation then
        local r106, r110= pcall(ui.get, r92.ui.paint_logger_animation)
        if r106 and type(r110) == 'number' then return r110 end
    end
    return 0
end


local r116, r117= pcall(require, "require/abc/push_modern")
local r118, r119= pcall(require, "require/abc/push_gamesense")


local function r120(r121)
    local r122= 80
    local r123= r121 - 80
    local r124= 40
    local r125= r121 / 2 - 300
    local r126= r121 - r125 - 10
    r126 = r109(r126, r122 + r124, r123 - r124)
    local r127= r126 - r124
    local r128= r126 + r124
    return r127, r128, r126
end

local function r129()
    if not r82 or not r82.text then return end
    if not r113() then return end

    local r130= r115() or 0
    local r131= r83 and r83.curtime and r83.curtime()
    local r132, r121= r84 and r84.screen_size and r84.screen_size() or 800, 600
    local r133= r121 * 0.5 + (r121 * 0.5 * 1.8)
    local r134= 0
    for i = #r95, 1, -1 do
        local r135= r95[i]
        local r136= (r135.timestamp + r135.duration) - r131
        if r136 <= 0 then
            r87(r95, i)
        else
            local r137, r138= r104(r135.text)
            local r139= (r130 == 1) and 4 or 2
            local r140= 2
            local r141= r132 / 2 - r137 / 2
            local r142= r133 + r134
            local r143= 5
            local r144= r88((r135.color[4] or 255) * math.min(1, (r136 / r135.duration) * r143))
            local r145= (r135.duration - r136)
            local r146= (r135.duration > 0 and r135.duration or 1)
            local r147= r145 / r146
            local r148= 6
            local r149= r109(r147 * r148, 0, 1)
            local r150= r149
            
            
            local r151= math.min(0.5, r146 * 0.25)
            if r136 <= r151 then
                local r152= r136 / r151 
                r150 = r109(r152, 0, 1)
            end
            if r130 == 1 then
                r117(r141, r142, r137, 13, r144, r135.text, r150)
                r134 = r134 + (r138 + r139 * 2 + r89(r140 / 10) * 4)
            else
                r119(r141, r142, r137, 13, r144, r135.text)
                r134 = r134 + (r138 + r139 * 2 + r89(r140 / 10) * 35)
            end
        end
    end
end

if r84 and r84.set_event_callback then
    r84.set_event_callback('paint', r129)
else
    
    r84.set_event_callback('paint', r129)
end

return r97
]]
r662["require/abc/push_modern"] = [[local r85= renderer
local r86= ui
local r87= math.floor

local r88, r89= pcall(require, "require/abc/menu_setup")
local r90, r91= pcall(r86.reference, 'misc', 'settings', 'menu color')

local function r92(r93,r94,r95,r96,r97,r98,r99,r100,r101)
    if not r97 or r97 <= 0 then
        r85.rectangle(r93, r94, r95, r96, r98,r99,r100,r101)
        return
    end
    r85.rectangle(r93 + r97, r94, r95 - (r97 * 2), r96, r98,r99,r100,r101)
    r85.rectangle(r93, r94 + r97, r95, r96 - (r97 * 2), r98,r99,r100,r101)
    r85.circle(r93 + r97, r94 + r97, r98,r99,r100,r101, r97, 0, 1)
    r85.circle(r93 + r95 - r97, r94 + r97, r98,r99,r100,r101, r97, 0, 1)
    r85.circle(r93 + r97, r94 + r96 - r97, r98,r99,r100,r101, r97, 0, 1)
    r85.circle(r93 + r95 - r97, r94 + r96 - r97, r98,r99,r100,r101, r97, 0, 1)
end

local function r102(r103,r104,r105,r106)
    local r107, r108, r109, r110= r103 or 255, r104 or 140, r105 or 0, r106 or 255
    
    if r88 and r89 and r89.ui and r89.ui.paint_logger_color then
        local r111, r112, r113, r114, r115= pcall(r86.get, r89.ui.paint_logger_color)
        if r111 then
            if type(r112) == 'number' then
                r107 = r87(r112 or r107)
                r108 = r87(r113 or r108)
                r109 = r87(r114 or r109)
                r110 = r87(r115 or r110)
            elseif type(r112) == 'string' and #r112 == 12 then
                local r116
                r116, mr = pcall(function() return tonumber(r112:sub(1,3)) end)
                r116, mg = pcall(function() return tonumber(r112:sub(4,6)) end)
                r116, mb = pcall(function() return tonumber(r112:sub(7,9)) end)
                r116, ma = pcall(function() return tonumber(r112:sub(10,12)) end)
                r107 = r107 or r103; r108 = r108 or r104; r109 = r109 or r105; r110 = r110 or r106
            end
            return r107, r108, r109, r110
        end
    end

    
    if r90 and r91 then
        local r111, r112, r113, r114, r115= pcall(r86.get, r91)
        if r111 then
            if type(r112) == 'number' then
                r107 = r87(r112 or r107)
                r108 = r87(r113 or r108)
                r109 = r87(r114 or r109)
                r110 = r87(r115 or r110)
            elseif type(r112) == 'string' and #r112 == 12 then
                local r116
                r116, mr = pcall(function() return tonumber(r112:sub(1,3)) end)
                r116, mg = pcall(function() return tonumber(r112:sub(4,6)) end)
                r116, mb = pcall(function() return tonumber(r112:sub(7,9)) end)
                r116, ma = pcall(function() return tonumber(r112:sub(10,12)) end)
                r107 = r107 or r103; r108 = r108 or r104; r109 = r109 or r105; r110 = r110 or r106
            end
        end
    end
    return r107, r108, r109, r110
end

local function r117(r93,r94,r95,r96,r118,r119,r120)
    local r121= r93 - 4
    local r122= r94 - 40
    local r123= r95 + 8
    local r124= r96 + 1

    local r125= 6
    if r124 < 12 then r125 = math.max(1, math.floor(r124 / 2)) end
    local r126= math.max(1, r125 - 1)

    local r107, r108, r109, r110= r102(255, 140, 0, 255)
    local r127= r87((r110 or 255) * 0.95)

    r120 = math.max(0, math.min(1, r120 or 1))
    local r128= r121 - 1
    local r129= r122 - 1
    local r130= r123 + 2
    local r131= r124 + 2
    local r132= r130 / 2 + (r130 * 0.1)
    local r133= r87(r132 * r120)

    if r133 > 0 then
        local r134= math.min(r125 + 1, r87(r131 / 2), r87(r133 / 2))
        r92(r128, r129, r133, r131, r134, r107, r108, r109, r127)
        r92(r128 + r130 - r133, r129, r133, r131, r134, r107, r108, r109, r127)
    end
    r92(r121, r122, r123, r124, r125, 10, 10, 10, 230)
    r92(r121 + 1, r122 + 1, r123 - 2, r124 - 2, r126, 6, 6, 6, 220)
    if r85.gradient then
        r85.gradient(r121 + 2, r122 + 1, math.max(0, r123 - 4), 2, r107, r108, r109, r87(r127 * 0.14), r107, r108, r109, 0, true)
    end
    r85.text(r93, r94 - 40, 255, 255, 255, 255, '', nil, r119)
end

return r117]]
r662["require/abc/register"] = [[local r88= require("require.abc.login_system")
local r89= "acc_" .. "OIDFGNSOIGNSFGIOSNGOISNGIOS"

local function r90(r91)
    local r92= {}
    for part in r91:gmatch("%S+") do
        table.insert(r92, part)
    end
    return r92
end

client.set_event_callback("console_input", function(r93)
    local r92= r90(r93 or "")
    if #r92 == 0 then return end

    local r94= r92[1]:lower()
    if r94 ~= "register" then
        
        return
    end

    if #r92 < 4 then
        client.log("Usage: register <username> <password> <invite>")
        return
    end

    local r95= r92[2]
    local r96= r92[3]
    local r97= r92[4]

    local r98, r99= r88.is_valid_invite(r97)
    if not r98 then
        client.log("Register failed: invalid or used invite")
        return
    end

    local r100= database.read(r89) or {}
    if r100[r95] then
        client.log("Register failed: username already exists - ", r95)
        return
    end

    local r101, r102= r88.register_with_invite(r97, r95, r96)
    if r101 then
        client.log("Registered user:", r95)
    else
        client.log("Register failed:", r102 or "unknown error")
    end
end)]]
r662["require/abc/screen_logger"] = [[local r91= renderer
local r92= globals
local r93= client
local r94= table.insert
local r95= table.remove
local r96= math.floor




local r97= {}
local r98= 12

local function r99(r100)
    local r101, r102, r103= pcall(r91.measure_text, '', r100)
    if r101 and type(r102) == 'number' then return r102, r103 or 0 end
    r101, r102, h = pcall(r91.measure_text, r100)
    if r101 and type(r102) == 'number' then return r102, r103 or 0 end
    return 0, 0
end

local function r104(r105,r106,r107,r108,r109,r110)
    if not r105 then return end
    r106 = r106 or 4
    if #r97 >= r98 then
        r95(r97, 1)
    end
    r94(r97, {
        text = tostring(r105),
        duration = r106,
        color = { r107 or 255, r108 or 255, r109 or 255, r110 or 255 },
        ts = r92 and r92.curtime and r92.curtime() or os.clock(),
    })
    return true
end

local function r111()
    if not r91 or not r91.text then return end
    local r112= r92 and r92.curtime and r92.curtime() or os.clock()
    local r113, r114= r93 and r93.screen_size and r93.screen_size() or 800, 600

    local r115= 8
    local r116= 6
    local r117= 14
    local r118= 2

    local r119= r116

    for i = #r97, 1, -1 do
        local r120= r97[i]
        if not r120 then goto continue end
        local r121= r112 - (r120.ts or 0)
        local r122= (r120.duration or 4) - r121
        if r122 <= 0 then
            r95(r97, i)
        else
            local r123, r124= r99(r120.text)
            
            local r125= r96(r120.color[4] or 255)
            
            pcall(r91.text, r115, r119, r120.color[1] or 255, r120.color[2] or 255, r120.color[3] or 255, r125, 'b', 0, r120.text)
            r119 = r119 + (r124 > 0 and r124 or r117) + r118
        end
        ::continue::
    end
end

if r93 and r93.set_event_callback then
    r93.set_event_callback('paint', r111)
end

return r104]]
r662["require/brain/dll"] = [=[local ffi = require("ffi")

ffi.cdef([[
struct Vec3 { double x; double y; double z; };
struct AspectState { double original; double last; double last_update; int initialized; };
const char* clipboard_get();
int clipboard_set(const char* text);
int clipboard_empty();
int clantag_anim(double start_time, double now, char* out_buf, int out_buf_len);
void tracer_reset();
void tracer_push_shot(double sx, double sy, double sz, double t);
void tracer_set_impact(double ix, double iy, double iz, double t);
int tracer_collect(double now, double tracer_life, double fade_fraction, double pitch, double yaw, double fallback_dist, double base_alpha, double* out_buf, int max_lines);
 ]])


local function hex(val)
    local ok, num = pcall(ffi.cast, "uintptr_t", val)
    if not ok then return "<na>" end
    return string.format("0x%X", tonumber(num))
end

local function resolve_call_trampoline()
    local tramp = client.find_signature("engine.dll", "\xFF\xE1")
    if tramp == nil then
        return nil
    end
    return ffi.cast("void*", tramp)
end

local function make_import_thunk(sig_pattern, cast_type)
    local addr = client.find_signature("engine.dll", sig_pattern)
    if addr == nil then
        return nil
    end
    local ptr = ffi.cast("void***", ffi.cast("uintptr_t", addr) + 2)[0][0]
    return ptr
end

local call_trampoline = resolve_call_trampoline()
local gm_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B", "void *")
local gpa_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05", "void *")

if gm_thunk and gpa_thunk then
else
    return
end

local function via_trampoline(target, signature, label)
    local fn = ffi.cast(signature, call_trampoline)
    return function(...)
        return fn(target, ...)
    end
end

local function to_wide(str)
    local buf = ffi.new("wchar_t[?]", #str + 1)
    for i = 1, #str do buf[i - 1] = string.byte(str, i) end
    buf[#str] = 0
    return buf
end

local GetModuleHandleA_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const char *)", "GMH A")
local GetModuleHandleW_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const wchar_t *)", "GMH W")
local GetProcAddress_tr   = via_trampoline(gpa_thunk, "void *(__thiscall *)(void *, void *, const char *)", "GPA")

local function call_GetModuleHandle(name)
    local ok1, res1 = pcall(GetModuleHandleA_tr, name)
    if not ok1 then dbg("GetModuleHandleA tramp err", res1) end
    if ok1 and res1 ~= nil and res1 ~= ffi.NULL then
        return res1, "tramp ansi"
    end

    local ok2, res2 = pcall(GetModuleHandleW_tr, to_wide(name))
    if not ok2 then dbg("GetModuleHandleW tramp err", res2) end
    if ok2 and res2 ~= nil and res2 ~= ffi.NULL then
        return res2, "tramp wide"
    end

    return nil, "failed"
end

local function call_GetProcAddress(mod, name)
    local ok, res = pcall(GetProcAddress_tr, mod, name)
    if not ok then dbg("GetProcAddress tramp err", res) end
    if ok and res ~= nil and res ~= ffi.NULL then return res end
    return nil
end

local mod, gm_variant = call_GetModuleHandle("sodiumdll.dll")
if mod == nil then
    return
end

local function bind_export(name, cdecl_sig)
    local addr = call_GetProcAddress(mod, name)
    if addr == nil then
        return nil
    end
    return addr, ffi.cast(cdecl_sig, addr)
end

local add_addr, add_fn = bind_export("add", "int(__cdecl*)(int, int)")
local get_value_addr, get_value_fn = bind_export("get_value", "int(__cdecl*)(void)")
local pin_module_addr, pin_module_fn = bind_export("pin_module", "void(__cdecl*)(void)")
local release_module_addr, release_module_fn = bind_export("release_module", "void(__cdecl*)(void)")
local get_hwid_addr, get_hwid_fn = bind_export("get_hwid", "const char*(__cdecl*)(void)")
local clipboard_get_addr, clipboard_get_fn = bind_export("clipboard_get", "const char*(__cdecl*)(void)")
local clipboard_set_addr, clipboard_set_fn = bind_export("clipboard_set", "int(__cdecl*)(const char*)")
local clipboard_empty_addr, clipboard_empty_fn = bind_export("clipboard_empty", "int(__cdecl*)(void)")
local clantag_anim_addr, clantag_anim_fn = bind_export("clantag_anim", "int(__cdecl*)(double, double, char*, int)")
local tracer_reset_addr, tracer_reset_fn = bind_export("tracer_reset", "void(__cdecl*)(void)")
local tracer_push_shot_addr, tracer_push_shot_fn = bind_export("tracer_push_shot", "void(__cdecl*)(double, double, double, double)")
local tracer_set_impact_addr, tracer_set_impact_fn = bind_export("tracer_set_impact", "void(__cdecl*)(double, double, double, double)")
local tracer_collect_addr, tracer_collect_fn = bind_export("tracer_collect", "int(__cdecl*)(double, double, double, double, double, double, double, double*, int)")

local vec_make_addr, vec_make_fn = bind_export("vec_make", "struct Vec3(__cdecl*)(double, double, double)")
local vec_add_addr, vec_add_fn = bind_export("vec_add", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_sub_addr, vec_sub_fn = bind_export("vec_sub", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_mul_scalar_addr, vec_mul_scalar_fn = bind_export("vec_mul_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_div_scalar_addr, vec_div_scalar_fn = bind_export("vec_div_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_unm_addr, vec_unm_fn = bind_export("vec_unm", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_length_addr, vec_length_fn = bind_export("vec_length", "double(__cdecl*)(struct Vec3)")
local vec_dot_addr, vec_dot_fn = bind_export("vec_dot", "double(__cdecl*)(struct Vec3, struct Vec3)")
local vec_cross_addr, vec_cross_fn = bind_export("vec_cross", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_normalized_addr, vec_normalized_fn = bind_export("vec_normalized", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_distance_addr, vec_distance_fn = bind_export("vec_distance", "double(__cdecl*)(struct Vec3, struct Vec3)")

local m_clamp_addr, m_clamp_fn = bind_export("m_clamp", "double(__cdecl*)(double, double, double)")
local m_clamp01_addr, m_clamp01_fn = bind_export("m_clamp01", "double(__cdecl*)(double)")
local m_abs_addr, m_abs_fn = bind_export("m_abs", "double(__cdecl*)(double)")
local m_lerp_addr, m_lerp_fn = bind_export("m_lerp", "double(__cdecl*)(double, double, double)")
local m_distance2d_addr, m_distance2d_fn = bind_export("m_distance2d", "double(__cdecl*)(double, double, double, double)")
local m_distance3d_addr, m_distance3d_fn = bind_export("m_distance3d", "double(__cdecl*)(double, double, double, double, double, double)")
local m_rad_to_deg_addr, m_rad_to_deg_fn = bind_export("m_rad_to_deg", "double(__cdecl*)(double)")
local m_deg_to_rad_addr, m_deg_to_rad_fn = bind_export("m_deg_to_rad", "double(__cdecl*)(double)")
local m_wrap_degrees_addr, m_wrap_degrees_fn = bind_export("m_wrap_degrees", "double(__cdecl*)(double)")
local m_normalize_angle_addr, m_normalize_angle_fn = bind_export("m_normalize_angle", "double(__cdecl*)(double)")
local m_angle_diff_addr, m_angle_diff_fn = bind_export("m_angle_diff", "double(__cdecl*)(double, double)")
local m_lerp_angle_addr, m_lerp_angle_fn = bind_export("m_lerp_angle", "double(__cdecl*)(double, double, double)")
local m_map_addr, m_map_fn = bind_export("m_map", "double(__cdecl*)(double, double, double, double, double)")
local m_smoothstep_addr, m_smoothstep_fn = bind_export("m_smoothstep", "double(__cdecl*)(double, double, double)")
local aspect_update_addr, aspect_update_fn = bind_export("aspect_update", "void(__cdecl*)(void*, double, double, double, double*, int*)")

if not (add_fn and get_value_fn and pin_module_fn and release_module_fn and get_hwid_fn and
    vec_make_fn and vec_add_fn and vec_sub_fn and vec_mul_scalar_fn and vec_div_scalar_fn and
    vec_unm_fn and vec_length_fn and vec_dot_fn and vec_cross_fn and vec_normalized_fn and vec_distance_fn and
    m_clamp_fn and m_clamp01_fn and m_abs_fn and m_lerp_fn and m_distance2d_fn and m_distance3d_fn and
    m_rad_to_deg_fn and m_deg_to_rad_fn and m_wrap_degrees_fn and m_normalize_angle_fn and m_angle_diff_fn and
    m_lerp_angle_fn and m_map_fn and m_smoothstep_fn and aspect_update_fn and
    clipboard_get_fn and clipboard_set_fn and clipboard_empty_fn and clantag_anim_fn and
    tracer_reset_fn and tracer_push_shot_fn and tracer_set_impact_fn and tracer_collect_fn) then
    return
end

local Call_add = via_trampoline(add_addr, "int(__thiscall *)(void*, int, int)", "add")
local Call_get_value = via_trampoline(get_value_addr, "int(__thiscall *)(void*)", "get_value")
local Call_pin_module = via_trampoline(pin_module_addr, "void(__thiscall *)(void*)", "pin_module")
local Call_release_module = via_trampoline(release_module_addr, "void(__thiscall *)(void*)", "release_module")
local Call_get_hwid = via_trampoline(get_hwid_addr, "const char*(__thiscall *)(void*)", "get_hwid")
local Call_clipboard_get = via_trampoline(clipboard_get_addr, "const char*(__thiscall *)(void*)", "clipboard_get")
local Call_clipboard_set = via_trampoline(clipboard_set_addr, "int(__thiscall *)(void*, const char*)", "clipboard_set")
local Call_clipboard_empty = via_trampoline(clipboard_empty_addr, "int(__thiscall *)(void*)", "clipboard_empty")
local Call_clantag_anim = via_trampoline(clantag_anim_addr, "int(__thiscall *)(void*, double, double, char*, int)", "clantag_anim")
local Call_tracer_reset = via_trampoline(tracer_reset_addr, "void(__thiscall *)(void*)", "tracer_reset")
local Call_tracer_push_shot = via_trampoline(tracer_push_shot_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_push_shot")
local Call_tracer_set_impact = via_trampoline(tracer_set_impact_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_set_impact")
local Call_tracer_collect = via_trampoline(tracer_collect_addr, "int(__thiscall *)(void*, double, double, double, double, double, double, double, double*, int)", "tracer_collect")
local Call_vec_make = via_trampoline(vec_make_addr, "struct Vec3(__thiscall *)(void*, double, double, double)", "vec_make")
local Call_vec_add = via_trampoline(vec_add_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_add")
local Call_vec_sub = via_trampoline(vec_sub_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_sub")
local Call_vec_mul_scalar = via_trampoline(vec_mul_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_mul_scalar")
local Call_vec_div_scalar = via_trampoline(vec_div_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_div_scalar")
local Call_vec_unm = via_trampoline(vec_unm_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_unm")
local Call_vec_length = via_trampoline(vec_length_addr, "double(__thiscall *)(void*, struct Vec3)", "vec_length")
local Call_vec_dot = via_trampoline(vec_dot_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_dot")
local Call_vec_cross = via_trampoline(vec_cross_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_cross")
local Call_vec_normalized = via_trampoline(vec_normalized_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_normalized")
local Call_vec_distance = via_trampoline(vec_distance_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_distance")

local Call_m_clamp = via_trampoline(m_clamp_addr, "double(__thiscall *)(void*, double, double, double)", "m_clamp")
local Call_m_clamp01 = via_trampoline(m_clamp01_addr, "double(__thiscall *)(void*, double)", "m_clamp01")
local Call_m_abs = via_trampoline(m_abs_addr, "double(__thiscall *)(void*, double)", "m_abs")
local Call_m_lerp = via_trampoline(m_lerp_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp")
local Call_m_distance2d = via_trampoline(m_distance2d_addr, "double(__thiscall *)(void*, double, double, double, double)", "m_distance2d")
local Call_m_distance3d = via_trampoline(m_distance3d_addr, "double(__thiscall *)(void*, double, double, double, double, double, double)", "m_distance3d")
local Call_m_rad_to_deg = via_trampoline(m_rad_to_deg_addr, "double(__thiscall *)(void*, double)", "m_rad_to_deg")
local Call_m_deg_to_rad = via_trampoline(m_deg_to_rad_addr, "double(__thiscall *)(void*, double)", "m_deg_to_rad")
local Call_m_wrap_degrees = via_trampoline(m_wrap_degrees_addr, "double(__thiscall *)(void*, double)", "m_wrap_degrees")
local Call_m_normalize_angle = via_trampoline(m_normalize_angle_addr, "double(__thiscall *)(void*, double)", "m_normalize_angle")
local Call_m_angle_diff = via_trampoline(m_angle_diff_addr, "double(__thiscall *)(void*, double, double)", "m_angle_diff")
local Call_m_lerp_angle = via_trampoline(m_lerp_angle_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp_angle")
local Call_m_map = via_trampoline(m_map_addr, "double(__thiscall *)(void*, double, double, double, double, double)", "m_map")
local Call_m_smoothstep = via_trampoline(m_smoothstep_addr, "double(__thiscall *)(void*, double, double, double)", "m_smoothstep")
local Call_aspect_update = via_trampoline(aspect_update_addr, "void(__thiscall *)(void*, void*, double, double, double, double*, int*)", "aspect_update")


return {
    add = function(a, b)
        return Call_add(a, b)
    end,
    get_value = function()
        return Call_get_value()
    end,
    pin_module = function()
        return Call_pin_module()
    end,
    release_module = function()
        return Call_release_module()
    end,
    get_hwid = function()
        return Call_get_hwid()
    end,
    clipboard_get = function()
        return Call_clipboard_get()
    end,
    clipboard_set = function(text)
        return Call_clipboard_set(text)
    end,
    clipboard_empty = function()
        return Call_clipboard_empty()
    end,
    clantag_anim = function(start_time, now, out_buf, out_buf_len)
        return Call_clantag_anim(start_time, now, out_buf, out_buf_len)
    end,
    tracer_reset = function()
        return Call_tracer_reset()
    end,
    tracer_push_shot = function(sx, sy, sz, t)
        return Call_tracer_push_shot(sx, sy, sz, t)
    end,
    tracer_set_impact = function(ix, iy, iz, t)
        return Call_tracer_set_impact(ix, iy, iz, t)
    end,
    tracer_collect = function(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
        return Call_tracer_collect(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
    end,
    vec_make = function(x, y, z)
        return Call_vec_make(x, y, z)
    end,
    vec_add = function(a, b)
        return Call_vec_add(a, b)
    end,
    vec_sub = function(a, b)
        return Call_vec_sub(a, b)
    end,
    vec_mul_scalar = function(v, s)
        return Call_vec_mul_scalar(v, s)
    end,
    vec_div_scalar = function(v, s)
        return Call_vec_div_scalar(v, s)
    end,
    vec_unm = function(v)
        return Call_vec_unm(v)
    end,
    vec_length = function(v)
        return Call_vec_length(v)
    end,
    vec_dot = function(a, b)
        return Call_vec_dot(a, b)
    end,
    vec_cross = function(a, b)
        return Call_vec_cross(a, b)
    end,
    vec_normalized = function(v)
        return Call_vec_normalized(v)
    end,
    vec_distance = function(a, b)
        return Call_vec_distance(a, b)
    end,
    m_clamp = function(val, minVal, maxVal)
        return Call_m_clamp(val, minVal, maxVal)
    end,
    m_clamp01 = function(val)
        return Call_m_clamp01(val)
    end,
    m_abs = function(val)
        return Call_m_abs(val)
    end,
    m_lerp = function(a, b, t)
        return Call_m_lerp(a, b, t)
    end,
    m_distance2d = function(x1, y1, x2, y2)
        return Call_m_distance2d(x1, y1, x2, y2)
    end,
    m_distance3d = function(x1, y1, z1, x2, y2, z2)
        return Call_m_distance3d(x1, y1, z1, x2, y2, z2)
    end,
    m_rad_to_deg = function(rad)
        return Call_m_rad_to_deg(rad)
    end,
    m_deg_to_rad = function(deg)
        return Call_m_deg_to_rad(deg)
    end,
    m_wrap_degrees = function(angle)
        return Call_m_wrap_degrees(angle)
    end,
    m_normalize_angle = function(angle)
        return Call_m_normalize_angle(angle)
    end,
    m_angle_diff = function(a, b)
        return Call_m_angle_diff(a, b)
    end,
    m_lerp_angle = function(a, b, t)
        return Call_m_lerp_angle(a, b, t)
    end,
    m_map = function(val, in_min, in_max, out_min, out_max)
        return Call_m_map(val, in_min, in_max, out_min, out_max)
    end,
    m_smoothstep = function(edge0, edge1, x)
        return Call_m_smoothstep(edge0, edge1, x)
    end,
    aspect_update = function(state, raw_slider, current_aspect, now, out_target, out_dirty)
        return Call_aspect_update(state, raw_slider, current_aspect, now, out_target, out_dirty)
    end,
    module_base = mod,
}]=]
r662["require/brain/test"] = [[local r97= require("require/brain/api/math/math")
local r98= require("require/brain/api/health/health")
local r99= require("require/brain/api/hwid/hwid")
local r100= require("require/brain/dll")


client.set_event_callback("paint_ui", function()
    local r101, r102= pcall(r97.add, 2, math.random(1, 100))
    if r101 then
        
    end

end)

local r103, r104= pcall(r99.get_hwid)
if r103 and r104 and r104 ~= "" then
    
else
    
end]]
r662["require/brain/api/clipboard/clipboard"] = [[]]
r662["require/brain/api/health/health"] = [[local r103= require("require/brain/dll")

if not r103 then
	error("sodiumdll exports unavailable")
end

return {
	pin_module = function()
		return r103.pin_module()
	end,
	release_module = function()
		return r103.release_module()
	end,
	module_base = r103.module_base,
}]]
r662["require/brain/api/hwid/hwid"] = [[local r106= require("ffi")
local r107= require("require/brain/dll")

if not r107 or not r107.get_hwid then
    error("sodiumdll hwid export missing")
end

return {
	get_hwid = function()
		local r108= r107.get_hwid()
		if not r108 or r108 == r106.NULL then
			return ""
		end
		return r106.string(r108)
	end,
}]]
r662["require/brain/api/ip/ip"] = [[
local r109= require("require/brain/dll")

if not r109 or not r109.get_public_ip then
	return error("sodiumdll ip export missing")
end

return {
	get_public_ip = function(r110,r111)
		return r109.get_public_ip(r110, r111)
	end,
}]]
r662["require/brain/api/math/math"] = [[local r112= require("require/brain/dll")

if not r112 or not r112.m_clamp then
	error("sodiumdll math exports missing")
end

return {
	add = function(r113,r114)
		return r112.add(r113, r114)
	end,
	get_value = function()
		return r112.get_value()
	end,
	m_clamp = function(r115,r116,r117)
		return r112.m_clamp(r115, r116, r117)
	end,
	m_clamp01 = function(r115)
		return r112.m_clamp01(r115)
	end,
	m_abs = function(r115)
		return r112.m_abs(r115)
	end,
	m_lerp = function(r113,r114,r118)
		return r112.m_lerp(r113, r114, r118)
	end,
	m_distance2d = function(r119,r120,r121,r122)
		return r112.m_distance2d(r119, r120, r121, r122)
	end,
	m_distance3d = function(r119,r120,r123,r121,r122,r124)
		return r112.m_distance3d(r119, r120, r123, r121, r122, r124)
	end,
	m_rad_to_deg = function(r125)
		return r112.m_rad_to_deg(r125)
	end,
	m_deg_to_rad = function(r126)
		return r112.m_deg_to_rad(r126)
	end,
	m_wrap_degrees = function(r127)
		return r112.m_wrap_degrees(r127)
	end,
	m_normalize_angle = function(r127)
		return r112.m_normalize_angle(r127)
	end,
	m_angle_diff = function(r113,r114)
		return r112.m_angle_diff(r113, r114)
	end,
	m_lerp_angle = function(r113,r114,r118)
		return r112.m_lerp_angle(r113, r114, r118)
	end,
	m_map = function(r115,r128,r129,r130,r131)
		return r112.m_map(r115, r128, r129, r130, r131)
	end,
	m_smoothstep = function(r132,r133,r134)
		return r112.m_smoothstep(r132, r133, r134)
	end,
}]]
r662["require/brain/api/vector/vector"] = [[local r115= require("ffi")
local r116= require("require/brain/dll")

if not r116 or not r116.vec_make or not r116.vec_add or not r116.vec_sub or not r116.vec_mul_scalar or
   not r116.vec_div_scalar or not r116.vec_unm or not r116.vec_length or not r116.vec_dot or
   not r116.vec_cross or not r116.vec_normalized or not r116.vec_distance or not r116.aspect_update then
    error("sodiumdll vector exports missing")
end

local r117= r115.typeof("struct Vec3")

local function r118(r119)
    if r115.istype(r117, r119) then
        return r119
    end
    local r120= (r119 and r119.x) or 0
    local r121= (r119 and r119.y) or 0
    local r122= (r119 and r119.z) or 0
    return r116.vec_make(r120, r121, r122)
end

return {
    Vec3 = r117,
    make = function(r120,r121,r122)
        return r116.vec_make(r120 or 0, r121 or 0, r122 or 0)
    end,
    add = function(r123,r124)
        return r116.vec_add(r118(r123), r118(r124))
    end,
    sub = function(r123,r124)
        return r116.vec_sub(r118(r123), r118(r124))
    end,
    mul_scalar = function(r119,r125)
        return r116.vec_mul_scalar(r118(r119), r125)
    end,
    div_scalar = function(r119,r125)
        return r116.vec_div_scalar(r118(r119), r125)
    end,
    unm = function(r119)
        return r116.vec_unm(r118(r119))
    end,
    length = function(r119)
        return r116.vec_length(r118(r119))
    end,
    dot = function(r123,r124)
        return r116.vec_dot(r118(r123), r118(r124))
    end,
    cross = function(r123,r124)
        return r116.vec_cross(r118(r123), r118(r124))
    end,
    normalized = function(r119)
        return r116.vec_normalized(r118(r119))
    end,
    distance = function(r123,r124)
        return r116.vec_distance(r118(r123), r118(r124))
    end,
    aspect_update = r116.aspect_update,
}]]
r662["require/brain/examples/boxes"] = [[local r118= require("ffi")
local r119= {


}


r119.GetModuleHandlePtr = 
    r118.cast(
        "void***", 
        r118.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B")) + 2
    )[0][0]

r119.GetProcAddressPtr = 
    r118.cast(
        "void***", 
        r118.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05")) + 2
    )[0][0]


r119.reinterpret_cast = function(r120,r121) 
    return function(...) 
        return r118.cast(r121, client.find_signature("engine.dll", "\xFF\xE1"))(r120, ...) 
    end
end


r119.fnGetModuleHandle = r119.reinterpret_cast(
    r119.GetModuleHandlePtr, 
    "void*(__thiscall*)(void*, const char*)"
)

r119.GetModuleHandle = function(r122)
    return r119.fnGetModuleHandle(r122)
end 


r119.fnGetProcAddress = r119.reinterpret_cast(
    r119.GetProcAddressPtr, 
    "void*(__thiscall*)(void*, void*, const char*)"
)

r119.GetProcAddress = function(r122,r123)
    local r120= r119.fnGetProcAddress(r122, r123)
    return r120
end 


r119.lib = {}
r119.lib.user32 = r119.GetModuleHandle("user32.dll")


r119.export = {}
r119.export.user32 = {}

r119.export.user32.MessageBoxPtr = r119.GetProcAddress(r119.lib.user32, "MessageBoxA")
r119.export.user32.MessageBox = r119.reinterpret_cast(
    r119.export.user32.MessageBoxPtr,
    "int(__thiscall*)(void*, void*, const char*, const char*, unsigned int)"
)


local r124= 0x00000000
local r125= 0x00000001
local r126= 0x00000004
local r127= 0x00000010
local r128= 0x00000020
local r129= 0x00000030
local r130= 0x00000040


local r131= 1
local r132= 2
local r133= 6
local r134= 7


local function r135(r136,r137,r138)
    r137 = r137 or "Gamesense"
    r138 = r138 or r124
    
    local r139= r119.export.user32.MessageBox(nil, r136, r137, r138)
    return r139
end


local function r140(r136,r137)
    return r135(r136, r137, r124 + r130)
end

local function r141(r136,r137)
    return r135(r136, r137, r124 + r129)
end

local function r142(r136,r137)
    return r135(r136, r137, r124 + r127)
end

local function r143(r136,r137)
    local r139= r135(r136, r137, r126 + r128)
    return r139 == r133
end
r140("test", "test")]]
r662["require/brain/features/aspectratio"] = [[local r121= require("ffi")
local r122= require("require/brain/dll")

if not r122 or not r122.aspect_update then
    error("sodiumdll aspect_update export missing")
end

return {
    aspect_update = function(r123,r124,r125,r126)
        local r127= r121.new("double[1]")
        local r128= r121.new("int[1]")

        r122.aspect_update(r123 or r121.NULL, r124, r125, r126, r127, r128)

        return r127[0], r128[0]
    end,
}]]
r662["require/features/aa/aa_collect"] = [[
local r124= entity
local r125= require('require/abc/menu_setup')
local r126= require('require/aa/player_condition')

local r127= {}
r127.last_side = 'left'

local function r128()
    local r129, r130= pcall(r126.get)
    if not r129 or not r130 then return nil end
    local r131= 'delay_' .. r130
    if not (r125 and r125.ui) then return nil end
    local r132= r125.ui[r131]
    if not r132 then return nil end
    local r133, r134= pcall(ui.get, r132)
    if not r133 then return nil end
    local r135= tonumber(r134)
    if r135 then return r135 end
    return r134
end

local function r136()
    local r129, r130= pcall(r126.get)
    if not r129 or not r130 then return nil end
    local r131= 'fifty_fifty_' .. r130
    if not (r125 and r125.ui) then return nil end
    local r132= r125.ui[r131]
    if not r132 then return nil end
    local r133, r134= pcall(ui.get, r132)
    if not r133 then return nil end
    local r135= tonumber(r134)
    if r135 then return r135 end
    return r134
end

local function r137()
    local r129, r130= pcall(r126.get)
    if not r129 or not r130 then return nil end
    local r131= 'body_yaw_mode_' .. r130
    if not (r125 and r125.ui) then return nil end
    local r132= r125.ui[r131]
    if not r132 then return nil end
    local r133, r134= pcall(ui.get, r132)
    if not r133 then return nil end
    local r135= tonumber(r134)
    if r135 then return r135 end
    return r134
end

local function r138(r139)
    if not (r124 and r124.get_prop and r139) then return r127.last_side end
    local r140= r124.get_prop(r139, 'm_flPoseParameter', 11)
    if r140 == nil then
        return r127.last_side
    end
    local r141= (r140 > 0.5) and 'right' or 'left'
    r127.last_side = r141
    return r141
end

local function r142()
    local r143= r128() + 1
    local r135= tonumber(r143) or 1
    if r135 < 1 then r135 = 1 end
    if r135 > 17 then r135 = 17 end

    local r144= globals.tickcount()
    if not r144 then return r127.last_side end

    local r145= math.floor(r144 / r135) % 2
    local r141= (r145 == 0) and 'left' or 'right'
    r127.last_side = r141
    return r141
end




local function r146()

    local r147= r136()

    if r147 then
        local r148= math.random(0, 1)
        local r141= (r148 == 0) and 'left' or 'right'
        r127.last_side = r141
        return r141
    end

    local r143= r128()
    local r135= tonumber(r143)

    if r137() ~= 'jitter' then
        return r138(r124.get_local_player())
    end

    if not r135 or r135 == 0 then
        local r139= r124.get_local_player()
        if not r139 or r139 == 0 then return r127.last_side end
        return r138(r139)
    else
        return r142()
    end
end





r127.resolve_side = r138
r127.resolve_local_side = r146
r127.get_delay_for_current_condition = r128

return r127]]
r662["require/features/aa/antiaim"] = [[local r127= require('require/features/aa/builder')
local r128= require('require/features/aa/defensive')

local r129= require('require/abc/callbacks')

local function r130()
    local r131= (globals.maxplayers and globals.maxplayers() or 64)
    local r132, r133, r134= entity.get_classname, entity.is_enemy, entity.is_alive
    if not (r132 and r133 and r134) then return 0 end
    local r135= 0
    for i=1,r131 do
        if r132(i) == 'CCSPlayer' and r133(i) and r134(i) then r135 = r135 + 1 end
    end
    return r135
end

r129.register('setup_command', function(r136)
    if r127 and r127.activate then
        r127.activate(r136)
    end

end, { alive_only = true, require_login = true })]]
r662["require/features/aa/antibrute"] = [[]]
r662["require/features/aa/builder"] = [[local r133= require('require/abc/menu_setup')
local r134= require('require/aa/player_condition')
local r135= require('require/features/aa/aa_collect')
local r136= require('require/help/math')
local r137= require('require/help/vector')
local r138= require('require/help/time')
local r139= require('require/help/string')

local r140= {}
client.set_event_callback('weapon_fire', function(r141)
  if not r141 or not r141.userid then return end
  local r142, r143= pcall(client.userid_to_entindex, r141.userid)
  if not r142 or not r143 or r143 == 0 then return end
  r140[r143] = r138.tickcount()
end)

local function r144(r145)
	if not r145 then return nil end

	local r146= {
		pitch = 'pitch_',
		yaw_base = 'yaw_base_',
		yaw = 'yaw_',
		body_yaw_base = 'body_yaw_base_',
		body_yaw_left = 'body_yaw_left_',
		body_yaw_right = 'body_yaw_right_',
		randomize_yaw = 'randomize_yaw_',
		yaw_jitter = 'yaw_jitter_',
		yaw_jitter_base = 'yaw_jitter_base_',
		body_yaw_mode = 'body_yaw_mode_',
		static_body_yaw = 'static_body_yaw_',
		body_yaw_value = 'body_yaw_value_',
		delay = 'delay_',
		fifty_fifty = 'fifty_fifty_',
		only_flip_on_0_choke = 'only_flip_on_0_choke_',
	}

	local r147= { condition = r145 }
	for name, prefix in pairs(r146) do
		local r148= prefix .. r145
		local r149= r133.ui and r133.ui[r148]
		if r149 then
			local r150, r151= pcall(ui.get, r149)
			if r150 then r147[name] = r151 else r147[name] = nil end
		else
			r147[name] = nil
		end
	end

	return r147
end




local function r152()
  local r150, r145= pcall(r134.get)
  if not r150 or not r145 then
    return nil
  end
  local r153= r144(r145)
  return r153 and r153.pitch or nil
end




local function r154()
  local r150, r145= pcall(r134.get)
  if not r150 or not r145 then
    return nil
  end
  local r153= r144(r145)
  local r155= r153 and r153.yaw_base or nil
  if r155 == nil then return nil end
  local r156= r139.lower(tostring(r155))
  if r156 == 'threat' then
    return 'local view'
  elseif r156 == 'distance' then
    return 'local view'
  elseif r156 == 'target' then
    return 'at targets'
  elseif r156 == 'view' then
    return 'local view'
  elseif r156 == 'smart' then
    return 'local view'
  else
    return tostring(r155)
  end
end




local function r157()
	local r150, r145= pcall(r134.get)
	if not r150 or not r145 then
		return nil
	end
	local r153= r144(r145)
	return r153 and r153.yaw or nil
end




local function r158()
    local r150, r145= pcall(r134.get)
    if not r150 or not r145 then
        return nil
    end
    local r153= r144(r145)
    return r153 and r153.yaw_jitter or nil
end




local function r159()
  local r150, r145= pcall(r134.get)
  if not r150 or not r145 then
    return nil
  end
  local r153= r144(r145)
  return r153 and r153.yaw_jitter_base or nil
end




local function r160()
  local r150, r145= pcall(r134.get)
  if not r150 or not r145 then return nil end
  local r153= r144(r145)
  if not r153 then return nil end
  local r161= r153.randomize_yaw
  if r161 == nil then return nil end
  local r162= tonumber(r161)
  if not r162 then return nil end
  if r162 < 0 then r162 = 0 end
  if r162 > 30 then r162 = 30 end
  return math.floor(r162)
end




local function r163()
    local r150, r145= pcall(r134.get)
    if not r150 or not r145 then
        return nil
    end
  local r153= r144(r145)
  local r164= r153 and r153.body_yaw_mode or nil
  if not r164 then return nil end
  local r165= r139.lower(tostring(r164))
  if r165 == 'jitter' then
    local r166= r135.get_delay_for_current_condition and r135.get_delay_for_current_condition() or nil
    local r162= tonumber(r166) or 0
    if r162 > 0 then
      return 'static'
    else
      return 'jitter'
    end
  end
  return r164
end




local function r167()
  local r150, r145= pcall(r134.get)
  if not r150 or not r145 then
    return nil
  end
  local r153= r144(r145)
  if not r153 then return nil end


  local r164= r153.body_yaw_mode
  if r164 ~= nil then r164 = r139.lower(tostring(r164)) end

  if r164 == 'jitter' then
    local r166= r135.get_delay_for_current_condition and r135.get_delay_for_current_condition() or nil
    local r168= tonumber(r166) or 0
    if r168 > 0 then
      local r169= r135.resolve_local_side and r135.resolve_local_side() or nil
      if r169 == 'right' then
        return -58
      else
        return 58
      end
    end

    local r155= r153.body_yaw_value
    local r162= tonumber(r155) or nil
    if r162 == 1 then
      return -180
    elseif r162 == 2 then
      return 0
    elseif r162 == 3 then
      return 180
    end
    return nil
  elseif r164 == 'static' then
    if r153.static_body_yaw ~= nil then
      local r170= tonumber(r153.static_body_yaw)
      if r170 then return r170 end
    end
    local r155= r153.body_yaw_value
    local r162= tonumber(r155) or nil
    if r162 == 1 then
      return -180
    elseif r162 == 2 then
      return 0
    elseif r162 == 3 then
      return 180
    end
    return nil
  else
    return 0
  end
end




local function r171()
  local r150, r145= pcall(r134.get)
  if not r150 or not r145 then
    return nil
  end
  local r153= r144(r145)
  return r153 and r153.body_yaw_base or nil
end




local function r172()
    local r150, r145= pcall(r134.get)
    if not r150 or not r145 then
        return nil
    end
    local r153= r144(r145)
    return r153 and r153.body_yaw_left or nil
end




local function r173()
    local r150, r145= pcall(r134.get)
    if not r150 or not r145 then
        return nil
    end
    local r153= r144(r145)
    return r153 and r153.body_yaw_right or nil
end




local function r174()
    local r150, r145= pcall(r134.get)
    if not r150 or not r145 then
        return nil
    end
    local r153= r144(r145)
    if not r153 then return nil end
    local r161= r153.only_flip_on_0_choke
    if r161 == nil then return nil end
    return not not r161
end




local function r175()
  local r150, r145= pcall(r134.get)
  if not r150 or not r145 then
    return nil
  end
  local r148= 'delay_' .. r145
  if not (r133 and r133.ui) then return nil end
  local r149= r133.ui[r148]
  if not r149 then return nil end
  local r176, r151= pcall(ui.get, r149)
  if r176 then return r151 end
  return nil
end




local function r177()
  local r150, r145= pcall(r134.get)
  if not r150 or not r145 then return nil end
  local r153= r144(r145)
  if not r153 then return nil end
  local r161= r153.fifty_fifty
  if r161 == nil then return nil end
  return not not r161
end





local function r178(r164)
  local r165= r139.lower(tostring(r164 or 'threat'))

  local r179= nil
  if r165 == 'distance' then
    local r180, r181= pcall(entity.get_players, true)
    if not r180 or not r181 or #r181 == 0 then return nil end
    local r182= entity.get_local_player()
    if not r182 then return nil end
    local r183, r184, r185, r186= pcall(entity.get_origin, r182)
    if not r183 or not r184 then return nil end
    local r187= nil
    local r188= nil
    for _, r143 in ipairs(r181) do
      if r143 and entity.is_alive and entity.is_alive(r143) and entity.is_enemy and entity.is_enemy(r143) then
        local r189, r190, r191, r192= pcall(entity.get_origin, r143)
        if r189 and r190 then
          local r193= r136.distance2d(r184, r185, r190, r191)
          if not r188 or r193 < r188 then
            r188 = r193
            r187 = r143
          end
        end
      end
    end
    r179 = r187
    elseif r165 == 'smart' then
      local r180, r181= pcall(entity.get_players, true)
      if r180 and r181 and #r181 > 0 then
        local r182= entity.get_local_player()
        if r182 then
          local r183, r184, r185, r186= pcall(entity.get_origin, r182)
          if r183 and r184 then
            local r187= nil
            local r188= nil
            for _, r143 in ipairs(r181) do
              if r143 and entity.is_alive and entity.is_alive(r143) and entity.is_enemy and entity.is_enemy(r143) then
                local r189, r190, r191, r192= pcall(entity.get_origin, r143)
                if r189 and r190 then
                  local r194= r140[r143]
                  if r194 and r138.within_ticks_window(r194, 10) then goto continue_smart end
                  local r195, r196= pcall(entity.get_player_weapon, r143)
                  if r195 and r196 and r196 ~= 0 then
                    local r197, r198= pcall(entity.get_classname, r196)
                    local r199= r139.lower(r197 and r198 and tostring(r198) or '')
                    if r199:find('knife') or r199:find('grenade') or r199:find('taser') or r199:find('zeus') then goto continue_smart end
                  end
                  do
                    local r193= r136.distance2d(r184, r185, r190, r191)
                    if not r188 or r193 < r188 then
                      r188 = r193
                      r187 = r143
                    end
                  end
                  ::continue_smart::
                end
              end
            end
            r179 = r187
          end
        end
      end
      if not r179 then
        local r200, r201= pcall(client.current_threat)
        if r200 and r201 then r179 = r201 end
      end
    else
      local r200, r201= pcall(client.current_threat)
      if r200 and r201 then r179 = r201 end
    end

  if not r179 then return nil end
  if not (entity.is_alive and entity.is_enemy and entity.is_alive(r179) and entity.is_enemy(r179)) then
    return nil
  end

  local r182= entity.get_local_player()
  if not r182 then return nil end

  local r202, r184, r185, r186= pcall(entity.get_origin, r182)
  local r203, r190, r191, r192= pcall(entity.get_origin, r179)
  if not r202 or not r203 or not r184 or not r190 then return nil end

  local r204= r190 - r184
  local r205= r191 - r185
  local r206= math.atan2(r205, r204)
  local r207= r136.rad_to_deg(r206)

  local r208, r209, r210= pcall(client.camera_angles)
  local r211= r208 and r210 or 0

  local r212= r136.normalize_angle(r207 - r211)
  return r136 and r136.round and r136.round(r212) or math.floor(r212 + 0.5)

end




local r213= {}
local r214= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local r215= {ui.reference(item[1], item[2], item[3])}
    r213[i] = r215
    for _, ref in ipairs(r215) do
        r214[ref] = true
    end
end





local function r216(r217)
  if weaponn ~= nil and entity.get_classname(weaponn) == "CC4" then
    if r217.in_attack == 1 then
        r217.in_attack = 0 
        r217.in_use = 1
    end
  else
    if r217.chokedcommands == 0 then
        r217.in_use = 0
    end
  end

end





local function r218(r217)

    local r219= r217.chokedcommands
    
    if r174() then
        if r219 > 0 then
            return
        end
    end

    local r169= r135.resolve_local_side()

    
    
    
    ui.set(r213[2][1], tostring(r152()))

    
    
    
    ui.set(r213[3][1], tostring(r154()))

    
    
    
    local r220= r157()
    if r220 == "3way" then
      r220 = '180'
    elseif r220 == "ideal" then
      r220 = '180'
    end
    ui.set(r213[4][1], r220)

    
    
    
    ui.set(r213[5][1], tostring(r158()))

    
    
    
    ui.set(r213[5][2], tostring(r159()))

    
    
    
    ui.set(r213[6][1], tostring(r163()))

    
    
    
    ui.set(r213[6][2], tostring(r167()))

    
    
    
    local r221= tonumber(r171()) or 0
    local r222= 0
    if ui.get(r213[4][1]) == '180' then
      if r169 == 'right' then
        r222 = tonumber(r172()) or 0
      elseif r169 == 'left' then
        r222 = tonumber(r173()) or 0
      end
    end
    local r223= r221 + r222
    local r224= tonumber(r160()) or 0
    if r224 > 0 then
      local r225= math.abs(r223) * (r224 / 100)
      local r226= (r136.random_int(-1000, 1000) / 1000)
      local r227= r226 * r225
      r223 = r223 + r227
    end

    do
      local r228, r145= pcall(r134.get)
      if r228 and r145 then
        local r153= r144(r145)
        if r153 then
          local r229= r139.lower(tostring(r153.yaw_base or ''))
          if r229 == 'threat' or r229 == 'distance' then
            local r230= r178(r229)
            if r230 then
              r223 = r223 + tonumber(r230) or r223
            end
          end
        end
      end
    end

    local r231= r136.normalize_angle(r223)
    ui.set(r213[4][2], r136.round(r231))

    
    
    
    r216(r217)

end


return {
  gather = r144,
  activate = r218,
  print_current = r218,
}]]
r662["require/features/aa/defensive"] = [[local r136= {}
r136.active = nil
r136.activate = nil
local r137= require('require/help/time')
local r138= require('require/abc/menu_setup')
local r139= require('require/features/aa/defensive_presets')
local r140= require('require/aa/player_condition')
local r141= require('require/abc/screen_logger')
local r142, r143= pcall(require, 'require/abc/callbacks')




local r144= {}
local r145= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'RAGE', 'Aimbot', 'Double tap' },
    { 'RAGE', 'Other', 'Duck peek assist' },

}) do
    local r146= {ui.reference(item[1], item[2], item[3])}
    r144[i] = r146
    for _, ref in ipairs(r146) do
        r145[ref] = true
    end
end


local r147= {
    cond = nil,
    idx = nil,
    preset = nil,
    selected_tick = 0,
}
local r148= false
local r149= 0





local r150= {
    last = false,
    pending_until = nil,
}
local function r151()
    local r152, r153= pcall(ui.get, r144[10][2])
    local r154= r152 and not not r153 or false
    local r155= r137.tickcount() or (globals and globals.tickcount and globals.tickcount()) or 0
    if r154 and not r150.last then
        r150.pending_until = r155 + 32
    end
    if not r154 then
        r150.pending_until = nil
    end
    r150.last = r154
    if r150.pending_until then
        return r155 >= r150.pending_until
    end
    return r154
end

local function r156()
    local r146= r144[11]
    if not r146 or not r146[1] then
        return false
    end
    local r152, r153= pcall(ui.get, r146[1])
    return r152 and not not r153 or false
end

local function r157()
  local r158= entity.get_local_player()
  if not r158 or not entity.is_alive(r158) then
    return false
  end
  local r159= entity.get_player_weapon(r158)
  if not r159 then
    return false
  end
  local r160= entity.get_classname(r159)
  return r160 == "CKnife"
end




local function r161()
    if not r138 or type(r138) ~= 'table' or not r138.ui then
        return false
    end
    local r162= r138.ui.fakelag_defensive
    if not r162 then
        return false
    end
    local r152, r153= pcall(ui.get, r162)
    return r152 and not not r153 or false
end

local function r163()
    if not r138 or type(r138) ~= 'table' or not r138.ui then
        return false
    end
    local r162= r138.ui.fakelag_force
    if not r162 then
        return false
    end
    local r152, r153= pcall(ui.get, r162)
    return r152 and not not r153 or false
end

local function r164(r165)

    


    local r155= (globals and globals.tickcount and globals.tickcount()) or r137.tickcount() or 0
    r149 = r155
end




local function r166(r167)

    r167 = r167 or 20
    local r168= entity.get_local_player()
    if not r168 then return false end
    local r169= entity.get_prop(r168, "m_flSimulationTime")
    local r170= 1 / globals.tickinterval()
    if not r169 or r170 == 0 then return false end
    local r171= math.floor(r169 * r170 + 0.5)
    local r172= globals.tickcount()
    nigga = r172 >= r171 and r172 <= r171 + r167

    return r172 >= r171 and r172 <= r171 + r167

end







local function r173(r165)
    
    
    
    local r174= false
    local r175= r161()
    local r176= r151()
    local r177= r156()
    local r178= r157()
    local r179= r166()
    

    r174 = r175 and r176 and not r177 and not r178 
    r136.active = r174


    local r155= (globals and globals.tickcount and globals.tickcount()) or r137.tickcount() or 0
    local r180= false
    if r155 and (r149 == nil or r155 - r149 >= 64) then
        r180 = true
        r164(r165)
    end



    
    
    

    
    
    
    if r174 then
        local r181= r140.get() or 'global'
        if (not r148) or (r147.cond ~= r181) or (not r147.preset) then
            local r182, r183= r139.get_random_for_condition(r181)
            if r182 and r183 then
                r147.cond = r181
                r147.idx = r182
                r147.preset = r183
                r147.selected_tick = globals.tickcount()
            else
                r147.cond = r181
                r147.idx = nil
                r147.preset = nil
                r147.selected_tick = 0
            end
        end

        if not r180 then
            if r147.preset and type(r147.preset.apply) == 'function' then
                r147.preset.apply(r147, r165)
            end
        end
    else
        if r148 then
            r147.cond = nil
            r147.idx = nil
            r147.preset = nil
            r147.selected_tick = 0
        end
    end

    r148 = r174

end


r136.activate = r173
r136.reset = r164


r143.register('setup_command', function(r165)
    r173(r165)
end, { alive_only = true, require_login = true })


return r136]]
r662["require/features/aa/defensive_presets"] = [[local r139= require('require/aa/player_condition')
local r140= require('require/help/time')
local r141= require('require/abc/screen_logger')



local r142= {}
local r143= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },

}) do
    local r144= {ui.reference(item[1], item[2], item[3])}
    r142[i] = r144
    for _, ref in ipairs(r144) do
        r143[ref] = true
    end
end


local r145= {}

local function r146(r147,r148,r149) if r147 < r148 then return r148 end if r147 > r149 then return r149 end return r147 end

local function r150(r151,r152,r153)
    local r144= r142[r151]
    if not r144 or not r144[r152] then return false end
    pcall(ui.set, r144[r152], r153)
    return true
end



local r154, r155= pcall(require, "require/abc/menu_setup")



local function r156(r157)

    local r158, r155= pcall(require, "require/abc/menu_setup")
    if not r158 or not r155 or not r155.ui then return end
    local r159, r160= pcall(ui.get, r155.ui.fakelag_fakedef)

    
    if r160 then 
        r157.force_defensive = false
    else
        r157.force_defensive = true
    end

end

do
    local r161, r162= pcall(require, "require/abc/callbacks")

    ticks = ticks or {}
    ticks.tickbase_max = ticks.tickbase_max or nil
    ticks.tickbase_diff = ticks.tickbase_diff or nil
    ticks.current_cmd = ticks.current_cmd or nil

    ticks.runc = function(r157)
        if not r157 then return end
        ticks.current_cmd = r157.command_number
    end

    ticks.tickcalc = function(r157)
        if not r157 then return end
        if r157.command_number == ticks.current_cmd then
            ticks.current_cmd = nil
            local r163= entity.get_local_player()
            if not r163 then return end
            local r164= entity.get_prop(r163, "m_nTickBase")
            if r164 then
                if ticks.tickbase_max ~= nil then
                    ticks.tickbase_diff = r164 - ticks.tickbase_max
                end
                ticks.tickbase_max = math.max(r164, ticks.tickbase_max or 0)
            end
        end
    end

    if r161 and r162 and r162.callback then
        r162.callback('run_command', ticks.runc, { alive_only = true, require_login = true })
        r162.callback('predict_command', ticks.tickcalc, { alive_only = true, require_login = true })
    end
end

client.set_event_callback("level_init", function()
    ticks.tickbase_max = nil
    ticks.tickbase_diff = nil
end)


local function r165(r166)
    local r163= entity.get_local_player()
    if not r163 then return false end

    local r167= entity.get_prop(r163, 'm_nTickBase')
    if not r167 then return false end

    local r168= ticks and ticks.tickbase_max or 0

    if math.abs(r167 - r168) > 64 then
        r168 = 0
    end

    local r169= 0

    if r167 > r168 then
        r168 = r167
    elseif r168 > r167 then
        r169 = math.min(14, math.max(0, r168 - r167 - 1))
    end

    r166 = r166 or 7

    return r169 > r166
end




local r170= {



    stand = {

        [1] = {
            name = "jitter -90/90",
            apply = function(r171,r157)

                local r172= globals.tickcount()
                local r173= math.floor(r172 / 2) % 2

                local function r174()
                    local r172= globals.tickcount()

                    if not r171._next_change_at then
                        r171._next_change_at = r172 + math.random(24, 64)
                        r171._mode = math.random(1, 3)
                        r171._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        r171._spin_speed = math.random(45, 55)
                        r171._spin_angle = (r173 == 0) and -90 or 90
                    end

                    if r172 >= (r171._next_change_at or 0) then
                        r171._next_change_at = r172 + math.random(24, 64)
                        r171._mode = math.random(1, 3)
                        r171._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        r171._spin_speed = math.random(45, 55)
                        r171._spin_angle = (r173 == 0) and -90 or 90

                        if r171._mode == 2 then
                            r171._spin_until = r172 + math.random(12, 24)
                        elseif r171._mode == 3 then
                            local r175= math.ceil(360 / r171._spin_speed)
                            r171._spin_until = r172 + r175
                            r171._rest_until = r172 + r175 + math.random(24, 64)
                            r171._spin_done = false
                        else
                            r171._spin_until = nil
                            r171._rest_until = nil
                        end
                    end

                    if r171._mode == 1 then
                        local r176= (r173 == 0) and -120 or 120
                        local r177= 0
                        return r176, r177

                    elseif r171._mode == 2 then
                        if r171._spin_until and r172 <= r171._spin_until then
                            r171._spin_angle = (r171._spin_angle or ((r173 == 0) and -90 or 90)) + (r171._spin_dir * (r171._spin_speed or 50))
                            if r171._spin_angle > 180 then r171._spin_angle = r171._spin_angle - 360 end
                            if r171._spin_angle < -180 then r171._spin_angle = r171._spin_angle + 360 end
                            return r171._spin_angle, 0
                        end
                        local r176= (r173 == 0) and -90 or 90
                        return r176, 0
                    else
                        if r171._spin_until and r172 <= r171._spin_until then
                            r171._spin_angle = (r171._spin_angle or ((r173 == 0) and -90 or 90)) + (r171._spin_dir * (r171._spin_speed or 50))
                            if r171._spin_angle > 180 then r171._spin_angle = r171._spin_angle - 360 end
                            if r171._spin_angle < -180 then r171._spin_angle = r171._spin_angle + 360 end
                            return r171._spin_angle, -89
                        end

                        if r171._rest_until and r172 <= r171._rest_until then
                            return nil, nil
                        end

                        local r176= (r173 == 0) and -90 or 90
                        return r176, 0
                    end
                end

                local r176, r177= r174()

                if r176 ~= nil and r157.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (r165(6))) then
                    r156(r157)
                    r150(4, 2, r176)
                    r150(2, 1, 'Custom')
                    r150(2, 2, r177)
                    r150(5, 1, 'off')
                    r150(6, 1, 'off')
                end

            end
        }
    },

    move = {

        [1] = {
            name = "jitter -90/90",
            apply = function(r171,r157)


                local r172= globals.tickcount()
                local r173= math.floor(r172 / 2) % 2
                local r176= (r173 == 0) and -135 or 135
                r171._side = r176
                r171._pitch = -55


                if r157.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (r165(3))) then
                    r156(r157)
                    r150(4, 2, r171._side)
                    r150(2, 1, 'Custom')
                    r150(2, 2, r171._pitch)
                    r150(5, 1, 'off')
                    r150(6, 1, 'off')
                    r150(3, 1, 'at targets')
                end
            end
        }
    },

    walk = {

        [1] = {
            name = "jitter -90/90",
            apply = function(r171,r157)

                local r172= globals.tickcount()
                local r173= math.floor(r172 / 2) % 2
                local r178= (r173 == 0) and -130 or 130

                
                local r176, r177
                if (r172 % 8) == 0 then
                    r176 = 0
                    r177 = 89
                else
                    r176 = r178
                    r177 = -65
                end

                r171._side = r176
                r171._pitch = r177





                if r157.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (r165(3))) then
                    r156(r157)
                    r150(4, 2, r171._side)
                    r150(2, 1, 'Custom')
                    r150(2, 2, r171._pitch)
                    r150(5, 1, 'off')
                    r150(6, 1, 'off')
                    r150(3, 1, 'at targets')
                end
            end
        },
    },

    duck = {
        
        [1] = {
            name = "jitter -90/90",
            apply = function(r171,r157)

                local r172= globals.tickcount()
                local r173= math.floor(r172 / 2) % 2

                local function r174()
                    local r172= globals.tickcount()

                    
                    if not r171._next_change_at then
                        r171._next_change_at = r172 + math.random(24, 64)
                        r171._mode = 1 
                    end

                    if r172 >= (r171._next_change_at or 0) then
                        r171._next_change_at = r172 + math.random(24, 64)
                        r171._mode = math.random(1, 5)
                        
                        r171._spin_dir = nil
                        r171._spin_speed = nil
                        r171._spin_angle = nil
                        r171._jitter_yaw = nil
                        r171._jitter_pitch = nil
                        r171._rand_yaw = nil
                        r171._rand_pitch = nil
                        r171._rand_until = nil
                        r171._phase_tick = r172
                    end

                    
                    
                    
                    
                    
                    

                    if r171._mode == 1 then
                        if not r171._spin_dir then
                            r171._spin_dir = (math.random(0,1) == 0) and -1 or 1
                            r171._spin_speed = 35
                            r171._spin_angle = (r173 == 0) and -90 or 90
                        end

                        if r172 % 10 == 0 then
                            return nil, nil
                        end

                        r171._spin_angle = (r171._spin_angle or ((r173 == 0) and -90 or 90)) + (r171._spin_dir * (r171._spin_speed or 45))
                        if r171._spin_angle > 180 then r171._spin_angle = r171._spin_angle - 360 end
                        if r171._spin_angle < -180 then r171._spin_angle = r171._spin_angle + 360 end
                        return r171._spin_angle, 0

                    elseif r171._mode == 2 then
                        local r179= math.random(-100, 100)
                        return r179, -50

                    elseif r171._mode == 3 then
                        local r179= math.random(-180, 180)
                        local r177= math.random(-89, 89)
                        return r179, r177

                    elseif r171._mode == 4 then
                        if not r171._rand_until then
                            r171._rand_yaw = math.random(-180, 180)
                            r171._rand_pitch = math.random(-89, 89)
                            r171._rand_until = r172 + 2
                            r171._rand_rest = r172 + 3
                        end
                        if r172 <= r171._rand_until then
                            return r171._rand_yaw, r171._rand_pitch
                        elseif r172 <= r171._rand_rest then
                            return nil, nil
                        else
                            r171._rand_until = nil
                            r171._rand_rest = nil
                            return nil, nil
                        end

                    else
                        
                        if not r171._ramp then
                            r171._ramp = {}
                            r171._ramp.yaw = math.random(-180, 180)
                            r171._ramp.pitch = 89
                            r171._ramp.dir = -1 
                        end

                        
                        if not r171._ramp.step then r171._ramp.step = 30 end
                        if r171._ramp.pitch == 89 then
                            
                            r171._ramp.pitch = r171._ramp.pitch + (r171._ramp.dir * r171._ramp.step)
                            if r171._ramp.pitch < -89 then r171._ramp.pitch = -89 end
                            return r171._ramp.yaw, 89
                        else
                            
                            local r180= r171._ramp.pitch
                            r171._ramp.pitch = r171._ramp.pitch + (r171._ramp.dir * r171._ramp.step)
                            if r171._ramp.pitch <= -89 then
                                
                                r171._ramp = nil
                            end
                            return r171._ramp and r171._ramp.yaw or math.random(-180,180), r180
                        end
                    end
                end

                local r176, r177= r174()

                if r176 ~= nil and r157.chokedcommands == 1 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (r165(8))) then
                    r156(r157)
                    r150(4, 2, r176)
                    r150(2, 1, 'Custom')
                    r150(2, 2, r177)
                    r150(5, 1, 'off')
                    r150(6, 1, 'off')
                    r150(3, 1, 'at targets')
                end
            end
        }
    },

    ["duck+"] = {
        
        [1] = {

            name = "jitter -90/90",
            apply = function(r171,r157)


                local r172= globals.tickcount()
                local r173= math.floor(r172 / 2) % 2
                local r176= (r173 == 0) and -90 or 90
                r171._side = 180
                r171._pitch = -76


                if r157.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (r165(1))) then
                    r156(r157)
                    r150(4, 2, r171._side)
                    r150(2, 1, 'Custom')
                    r150(2, 2, r171._pitch)
                    r150(5, 1, 'off')
                    r150(6, 1, 'off')
                    r150(3, 1, 'at targets')
                end

            end
        }
    },

    ['jump'] = {
        [1] = {
            name = "jitter -90/90",
            apply = function(r171,r157)

                local r172= globals.tickcount()
                
                if not r171._spin_choice_at then
                    r171._spin_choice_at = r172 + 64
                    r171._spin_dir = (math.random(0,1) == 0) and -1 or 1
                    r171._spin_angle = 0
                end

                if r172 >= (r171._spin_choice_at or 0) then
                    r171._spin_choice_at = r172 + 64
                    r171._spin_dir = (math.random(0,1) == 0) and -1 or 1
                end

                
                if (r172 % 10) == 0 then
                    return
                end

                
                r171._spin_angle = (r171._spin_angle or 0) + (r171._spin_dir * 35)
                if r171._spin_angle > 180 then r171._spin_angle = r171._spin_angle - 360 end
                if r171._spin_angle < -180 then r171._spin_angle = r171._spin_angle + 360 end

                local r176= r171._spin_angle
                r171._side = r176
                r171._pitch = 0

                if r157.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (r165(8))) then
                    r156(r157)
                    r150(4, 2, r171._side)
                    r150(2, 1, 'Custom')
                    r150(2, 2, r171._pitch)
                    r150(5, 1, 'off')
                    r150(6, 1, 'off')
                    r150(3, 1, 'at targets')
                end
            end
        },

    },

    ['jump+'] = {
        [0] = {
            name = "jitter -90/90",
            apply = function(r171,r157)

                local r172= globals.tickcount()
                local r173= math.floor(r172 / 2) % 2
                local r176= (r173 == 0) and -90 or 90
                r171._side = r176
                r171._pitch = 0

                if r157.chokedcommands > 0 and (not (r165(6))) then
                    r156(r157)
                    r150(4, 2, r171._side)
                    r150(2, 1, 'Custom')
                    r150(2, 2, r171._pitch)
                    r150(5, 1, 'off')
                    r150(6, 1, 'off')
                    r150(3, 1, 'at targets')
                end
            end
        },
    },

    
    global = {
        [0] = {
            name = "back",
            apply = function(r171,r157)

            end
        }
    }


}





local function r181(r182)
    local r183= {}
    for k, _ in pairs(r182) do
        if type(k) == 'number' then table.insert(r183, k) end
    end
    table.sort(r183)
    return r183
end

function r145.get_presets_for_condition(r184)
    r184 = r184 or r139.get() or 'global'
    return r170[r184] or r170['global'] or {}
end

function r145.get_preset_by_index(r184,r185)
    local r186= r145.get_presets_for_condition(r184)
    return r186[r185]
end

function r145.get_random_for_condition(r184)
    local r186= r145.get_presets_for_condition(r184)
    local r183= r181(r186)
    if #r183 == 0 then return nil, nil end
    local r187= r183[math.random(1, #r183)]
    return r187, r186[r187]
end

function r145.get_random_for_current_condition()
    return r145.get_random_for_condition(r139.get())
end


function r145.get_next_for_condition(r184,r188)
    local r186= r145.get_presets_for_condition(r184)
    local r183= r181(r186)
    if #r183 == 0 then return nil, nil end
    
    local r189= 1
    for i, k in ipairs(r183) do
        if k == r188 then r189 = i; break end
    end
    local r190= (r189 % #r183) + 1
    local r191= r183[r190]
    return r191, r186[r191]
end


function r145.available_conditions()
    local r192= {}
    for k, _ in pairs(r170) do table.insert(r192, k) end
    table.sort(r192)
    return r192
end

r145._presets = r170

return r145]]
r662["require/features/misc/analyze"] = [[local function r142(r143)
	while r143 > 180 do r143 = r143 - 360 end
	while r143 < -180 do r143 = r143 + 360 end
	return r143
end

local r144= _G.player_labels or {}
_G.player_labels = r144

local r145= function(ent)
	return (_G.player_history and _G.player_history[ent]) or nil
end

local r146, r147= pcall(require, "require/features/misc/resolver_dispatcher")
local r148= require('require/abc/callbacks')

local function r149(r150)
	
	local r151= r145(r150)
	if not r151 or #r151 < 2 then
		r144[r150] = nil
		return
	end

	
	
	local r152, r153= pcall(function() return (globals and globals.curtime and globals.curtime()) or nil end)
	if r151[1] and r151[1].last_shot_time and r152 and r153 then
		local r154= r153 - r151[1].last_shot_time
		if r154 >= 0 and r154 <= 0.25 then
			r144[r150] = "ON SHOT"
			return
		end
	end

	
	local r155= {}
	for i = 1, #r151 - 1 do
		local r156= r151[i] and r151[i].yaw
		local r157= r151[i+1] and r151[i+1].yaw
		if r156 ~= nil and r157 ~= nil then
			r155[#r155 + 1] = r142(r156 - r157)
		end
	end

	if #r155 == 0 then
		r144[r150] = nil
		return
	end

	
	local r158, r159= 0, 0
	local r160, r161= -1e9, 1e9
	for _, v in ipairs(r155) do
		r158 = r158 + v
		r159 = r159 + math.abs(v)
		if v > r160 then r160 = v end
		if v < r161 then r161 = v end
	end
	local r162= r158 / #r155
	local r163= r159 / #r155

	local r164= 0
	for _, v in ipairs(r155) do
		r164 = r164 + (v - r162) ^ 2
	end
	local r165= math.sqrt(r164 / #r155)

	local r166= 0
	for i = 2, #r155 do
		if (r155[i] > 0 and r155[i-1] < 0) or (r155[i] < 0 and r155[i-1] > 0) then
			r166 = r166 + 1
		end
	end

	
	local r167= r155[1]
	local r168= r160 - r161

	
	local r169= {}
	for i, v in ipairs(r155) do r169[i] = v end
	table.sort(r169)
	local r170= r169[math.ceil(#r169 / 2)]

	
	local r171= {
		deltas = r155,
		mean = r162,
		meanabs = r163,
		std = r165,
		sign_changes = r166,
		max_delta = r160,
		min_delta = r161,
		total_range = r168,
		median = r170,
		last_delta = r167,
		samples = #r155,
		last_yaw = r151[1] and r151[1].yaw,
		oldest_yaw = r151[#r151] and r151[#r151].yaw,
		hist = r151
	}

	
	do
		local r172, r173= 0, 0
		local r174, r175, r176
		for i=1,math.min(#r151, 20) do
			local r177= r151[i]
			if r177 then
				if r177.moveSpeedAnim then r172 = r172 + (r177.moveSpeedAnim or 0); r173 = r173 + 1 end
				if r177.speed2d then r172 = r172 + (r177.speed2d or 0); r173 = r173 + 1 end
				if not r174 and r177.feetYaw then r174 = r177.feetYaw end
				if not r175 and r177.goalFeetYaw then r175 = r177.goalFeetYaw end
				if not r176 and r177.moveSpeedAnim then r176 = r177.moveSpeedAnim end
			end
		end
		local r178= (r173 > 0) and (r172 / r173) or 0
		r171.movement = r178 >= 1.2
		r171.avg_speed = r178
		r171.feet_yaw = r174
		r171.goal_feet_yaw = r175
		r171.move_anim = r176
	end

	local r179= nil
	if detect_static and detect_static(r171, r150) then r179 = "STATIC" end
	if detect_spin and detect_spin(r171, r150) then r179 = "SPIN" end
	if detect_jitter_minus and detect_jitter_minus(r171, r150) then r179 = "JITTER-" end
	if detect_jitter and detect_jitter(r171, r150) then r179 = "JITTER" end
	if detect_jitter_plus and detect_jitter_plus(r171, r150) then r179 = "JITTER+" end
	if detect_sway and detect_sway(r171, r150) then r179 = "SWAY" end
	if detect_skitter and detect_skitter(r171, r150) then r179 = "SKITTER" end
	if detect_defensive and detect_defensive(r171, r150) then r179 = "DEFENSIVE" end
	if detect_random and detect_random(r171, r150) then r179 = "RANDOM" end
	if detect_delayed and detect_delayed(r171, r150) then r179 = "DELAYED" end

	if not r179 then r179 = "?" end
	pcall(function()
		local r180= nil
		pcall(function() r180 = entity.get_player_name(r150) end)
		local r181= "nil"
		if r151 and r151[1] and r151[1].last_shot_time then
			r181 = string.format("%.3f", r151[1].last_shot_time)
		end
		local r182= r171.feet_yaw and string.format("%.2f", r171.feet_yaw) or "nil"
		local r183= r171.goal_feet_yaw and string.format("%.2f", r171.goal_feet_yaw) or "nil"

	end)

	r144[r150] = r179

	
	if r146 and r147 and type(r147.process_entity) == "function" then
		pcall(function() r147.process_entity(r150, r179, r171) end)
	end
end



function r184(r171,r150)
	local r163= r171.meanabs or 0
	local r165= r171.std or 0
	local r185= r171.samples or 0
	local r155= r171.deltas or {}
	local r186= 1.0
	local r187= 1.5
	local r188= 2.5

	if r163 <= r186 and r165 <= r187 then
		return true
	end

	local r189= 0
	local r190= nil
	for i, d in ipairs(r155) do
		if math.abs(d) >= r188 then
			r189 = r189 + 1
			if not r190 then
				r190 = i
			end
		end
	end

	if r189 == 0 then
		return true
	end

	if r189 == 1 and r190 and r190 > 20 then
		return true
	end

	return false
end

function r191(r171,r150)
	local r163= r171.meanabs or 0
	local r165= r171.std or 0
	local r185= r171.samples or 0
	local r166= r171.sign_changes or 0
	local r192= math.max(math.abs(r171.max_delta or 0), math.abs(r171.min_delta or 0))

	local r193= false

	if r185 >= 4 then
		local r194= 5.0
		local r195= 12.0
		local r196= 22.0
		local r197= 40.0

		if r163 >= r194 and r163 < r195 and r165 <= r196 and r192 <= r197 then
			r193 = true
		end
	end

	return r193
end

function r198(r171,r150)
	local r163= r171.meanabs or 0
	local r165= r171.std or 0
	local r185= r171.samples or 0
	local r166= r171.sign_changes or 0
	local r192= math.max(math.abs(r171.max_delta or 0), math.abs(r171.min_delta or 0))

	local r193= false

	if r185 >= 4 then
		local r194= (r171.movement and 8.0) or 6.0
		local r195= 24.0
		local r199= 34.0
		local r200= 28.0
		local r201= 100.0

		if r163 >= r194 and r163 < r195 and r165 <= r199 then
			if r166 >= 2 or r192 <= r201 or (r163 < 12.0 and r165 <= r200) then
				r193 = true
			end
		end
	end

	return r193
end

function r202(r171,r150)
	local r163= r171.meanabs or 0
	local r165= r171.std or 0
	local r185= r171.samples or 0
	local r166= r171.sign_changes or 0
	local r192= math.max(math.abs(r171.max_delta or 0), math.abs(r171.min_delta or 0))

	local r193= false

	if r185 >= 4 then
		local r194= 18.0
		local r203= 22.0
		local r204= 26.0
		local r205= 70.0

		if r163 >= r194 and (r165 >= r204 or r192 >= r205) then
			if r163 >= r203 or r192 >= r205 or r165 >= (r204 + 8) then
				r193 = true
			end
		end
	end
	
	return r193
end

function r206(r171,r150)
	local r163= r171.meanabs or 0
	local r165= r171.std or 0
	local r185= r171.samples or 0
	local r166= r171.sign_changes or 0
	local r168= r171.total_range or 0
	local r192= math.max(math.abs(r171.max_delta or 0), math.abs(r171.min_delta or 0))

	local r193= false

	if r185 >= 6 then
		local r194= 2.5
		local r195= 15.0
		local r207= 0.08
		local r208= 30.0
		local r209= 180.0

		if r163 >= r194 and r163 < r195 and r165 <= 40.0 and r168 >= r208 and r168 <= r209 then
			if (r166 / math.max(1, r185)) >= r207 then
				r193 = true
			end
		end
	end

	return r193
end

function r210(r171,r150)
	local r163= r171.meanabs or 0
	local r165= r171.std or 0
	local r185= r171.samples or 0
	local r166= r171.sign_changes or 0
	local r168= r171.total_range or 0
	local r167= r171.last_delta or 0
	local r192= math.max(math.abs(r171.max_delta or 0), math.abs(r171.min_delta or 0))

	local r155= r171.deltas or {}

	local r211, r212, r213= 0, 0, 0
	for _, v in ipairs(r155) do
		if v > 0.5 then r211 = r211 + 1
		elseif v < -0.5 then r212 = r212 + 1
		else r213 = r213 + 1 end
	end

	local r214= math.max(r211, r212) / math.max(1, r185)
	local r215= math.abs(r211 - r212) / math.max(1, (r211 + r212))

	local r216, r217, r218= 0, 0, 0
	for _, v in ipairs(r155) do
		local r177= 0
		if v > 0.5 then r177 = 1 elseif v < -0.5 then r177 = -1 end
		if r177 ~= 0 and r177 == r218 then
			r217 = r217 + 1
		else
			r217 = (r177 ~= 0) and 1 or 0
			r218 = r177
		end
		if r217 > r216 then r216 = r217 end
	end

	local r219= r216 / math.max(1, r185)

	local r193= false

	if r185 >= 6 then
		if r168 >= 300 and (r214 >= 0.60 or r215 >= 0.60) then
			r193 = true
		end

		if not r193 and r168 >= 140 and r163 >= 9 and (r214 >= 0.75 or r215 >= 0.70 or r166 <= 1) then
			r193 = true
		end

		if not r193 and r219 >= 0.50 and r163 >= 8 and r168 >= 120 then
			r193 = true
		end

		if not r193 and r192 >= 120 and (r214 >= 0.60 or r215 >= 0.60) then
			r193 = true
		end
	end
	local r220= nil
	if not r193 and r185 > 0 then
		local r221= math.min(r168, 360) / 360.0
		local r222= math.min(r163, 60) / 60.0
		local r223= (r166 or 0) / math.max(1, r185)
		r220 = r221 * 0.45 + r222 * 0.35 + r215 * 0.15 + r214 * 0.05 - r223 * 0.20
		if r220 >= 0.42 and r168 >= 200 and r163 >= 6 then
			r193 = true
		end
		r171.spin_score = r220
	end

	return r193
end

function r224(r171,r150)
	
	return false
end

function r225(r171,r150)
	
	return false
end

function r226(r171,r150)
	local r163= r171.meanabs or 0
	local r165= r171.std or 0
	local r185= r171.samples or 0
	local r166= r171.sign_changes or 0
	local r168= r171.total_range or 0
	local r192= math.max(math.abs(r171.max_delta or 0), math.abs(r171.min_delta or 0))
	local r155= r171.deltas or {}

	if r185 < 6 then return false end

	local r227= r166 / math.max(1, r185)
	local r228= r171.movement
	if r227 >= 0.45 and r165 >= (r228 and 12.0 or 18.0) and r163 >= (r228 and 4.0 or 6.0) then
		return true
	end

	if r192 >= 120 and r227 >= 0.30 and r165 >= 12.0 then
		return true
	end

	if r168 >= 60 and r168 <= 300 and r227 >= 0.40 and r165 >= 14.0 and r163 >= 4.0 then
		return true
	end

	if r165 >= 30.0 and r227 >= 0.25 and r163 >= 5.0 then
		return true
	end

	return false
end

function r229(r171,r150)
	local r163= r171.meanabs or 0
	local r165= r171.std or 0
	local r185= r171.samples or 0
	local r166= r171.sign_changes or 0
	local r168= r171.total_range or 0
	local r192= math.max(math.abs(r171.max_delta or 0), math.abs(r171.min_delta or 0))

	if r185 >= 6 then
		local r194= 2.5
		local r195= 24.0
		local r230= 9.0
		local r231= 40.0
		local r208= 10.0

		if r163 >= r194 and r163 < r195 and r165 >= r230 and r165 <= r231 and r168 >= r208 then
			local r232= (r166 or 0) / math.max(1, r185)
			if r166 <= 3 or r232 <= 0.12 or r192 >= 40 then
				return true
			end
		end
	end

	return false
end

local function r233()
	local r234, r235= pcall(entity.get_players, true)
	if not r234 or type(r235) ~= "table" then return end
	for _, r150 in ipairs(r235) do
		if entity.is_alive(r150) and not entity.is_dormant(r150) then
			pcall(r149, r150)
		else
			r144[r150] = nil
		end
	end
end

local function r236(r150)
	if not entity.is_alive(entity.get_local_player()) then return end
	if not r150 or r150 == 0 then return end

	local r237= r144[r150]


	if r237 then
		return true, r237
	end

	local r151= r145(r150)
	if r151 and r151[1] and r151[1].yaw ~= nil then
		return true, tostring(r151[1].yaw)
	end
end

client.register_esp_flag("Resolver", 255, 255, 255, r236)

r148.register('net_update_end', function()
	local r238, r239= pcall(require, "require/abc/menu_setup")
	if r238 and r239 and r239.ui and r239.ui.misc_resolver then
		local r240, r241= pcall(ui.get, r239.ui.misc_resolver)
		if r240 and r241 then
			pcall(r233)
		end
	end
end, { alive_only = true, require_login = true })
]]
r662["require/features/misc/backstab_assist"] = [[local r145= require("require/abc/menu_setup")
local r146= require('require/abc/callbacks')
local r147= require('require/help/enemies')

local r148= ui.reference("AA", "Anti-aimbot angles", "Pitch")
local r149= ui.reference("AA", "Anti-aimbot angles", "Yaw base")
local r150, r151= ui.reference("AA", "Anti-aimbot angles", "Yaw")
local r152= nil

local function r153()
	if r152 then return end
	r152 = {}
	if r148 then r152.pitch = ui.get(r148) end
	if r149 then r152.yaw_base = ui.get(r149) end
	if r150 then r152.yaw = ui.get(r150) end
	if r151 then r152.yaw_slider = ui.get(r151) end
end

local function r154()
	if not r152 then return end
	if r148 and r152.pitch ~= nil then pcall(ui.set, r148, r152.pitch) end
	if r149 and r152.yaw_base ~= nil then pcall(ui.set, r149, r152.yaw_base) end
	if r150 and r152.yaw ~= nil then pcall(ui.set, r150, r152.yaw) end
	if r151 and r152.yaw_slider ~= nil then pcall(ui.set, r151, r152.yaw_slider) end
	r152 = nil
end

local function r155()
	r153()
	if r148 then pcall(ui.set, r148, "Off") end
	if r149 then pcall(ui.set, r149, "At targets") end
	if r150 then pcall(ui.set, r150, "180") end
	if r151 then pcall(ui.set, r151, 180) end
end

local function r156(r157)
	local r158= entity.get_local_player()
	if not r158 or not entity.is_alive(r158) then return false end
	local r159= r147.list() or {}
	for _, enemy in ipairs(r159) do
		if r147.is_alive(enemy) and not r147.is_dormant(enemy) and r147.has_knife(enemy) then
			local r160= r147.distance(enemy)
			if r160 and r160 <= r157 then
				return true
			end
		end
	end
	return false
end

local function r161(r162)
	if not (r145 and r145.ui and r145.ui.misc_backstab) then r154() return end
	local r163, r164= pcall(ui.get, r145.ui.misc_backstab)
	if not r163 or not r164 then r154() return end
	local r157= 200
	if r156(r157) then
		r155()
	else
		r154()
	end
end

if r145 and r145.ui and r145.ui.misc_backstab then
	ui.set_callback(r145.ui.misc_backstab, function()
		local r163, r165= pcall(ui.get, r145.ui.misc_backstab)
		if not r163 or not r165 then r154() end
	end)
end

r146.register("setup_command", r161, { alive_only = true, require_login = true })
r146.register("shutdown", r154, { alive_only = true, require_login = true })]]
r662["require/features/misc/collect"] = [=[
local M = {}


do
    local ok, ffi = pcall(require, "ffi")
    if ok and ffi and client and client.create_interface then
        local status, entity_list_ptr = pcall(function()
            return client.create_interface("client.dll", "VClientEntityList003")
        end)

        if status and entity_list_ptr then
            local pointer_type = ffi.typeof("void***")
            local entity_list = ffi.cast(pointer_type, entity_list_ptr)
            local ok_cast, get_client_entity = pcall(function()
                return ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
            end)

            if ok_cast and get_client_entity then
                
                local animstate_offset = 0x9960

                
                
                
                ffi.cdef[[
                struct animation_layer_t {
                    char  pad_0000[20];
                    uint32_t m_nOrder;
                    uint32_t m_nSequence;
                    float m_flPrevCycle;
                    float m_flWeight;
                    float m_flWeightDeltaRate;
                    float m_flPlaybackRate;
                    float m_flCycle;
                    void *m_pOwner;
                    char  pad_0038[4];
                };
                ]]

                
                
                

                ffi.cdef[[
                struct c_animstate_min {
                    char pad0[3];
                    char m_bForceWeaponUpdate;
                    char pad1[91];
                    void* m_pBaseEntity;
                    void* m_pActiveWeapon;
                    void* m_pLastActiveWeapon;
                    float m_flLastClientSideAnimationUpdateTime;
                    int m_iLastClientSideAnimationUpdateFramecount;
                    float m_flAnimUpdateDelta;
                    float m_flEyeYaw;
                    float m_flPitch;
                    float m_flGoalFeetYaw;
                    float m_flCurrentFeetYaw;
                    float m_flCurrentTorsoYaw;
                    float m_flUnknownVelocityLean;
                    float m_flLeanAmount;
                    char pad2[4];
                    float m_flFeetCycle;
                    float m_flFeetYawRate;
                    char pad3[4];
                    float m_fDuckAmount;
                    float m_fLandingDuckAdditiveSomething;
                    char pad4[4];
                    float m_vOriginX;
                    float m_vOriginY;
                    float m_vOriginZ;
                    float m_vLastOriginX;
                    float m_vLastOriginY;
                    float m_vLastOriginZ;
                    float m_vVelocityX;
                    float m_vVelocityY;
                    char pad5[4];
                    float m_flUnknownFloat1;
                    char pad6[8];
                    float m_flUnknownFloat2;
                    float m_flUnknownFloat3;
                    float m_flUnknown;
                    float m_flSpeed2D;
                    float m_flUpVelocity;
                    float m_flSpeedNormalized;
                    float m_flFeetSpeedForwardsOrSideWays;
                    float m_flFeetSpeedUnknownForwardOrSideways;
                    float m_flTimeSinceStartedMoving;
                    float m_flTimeSinceStoppedMoving;
                    bool m_bOnGround;
                    bool m_bInHitGroundAnimation;
                    char pad7[2];
                    float m_flTimeSinceInAir;
                    float m_flLastOriginZ;
                    float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
                    float m_flStopToFullRunningFraction;
                    float m_flMagicFraction;
                    char pad8[60];
                    float m_flWorldForce;
                    char pad9[462];
                    float m_flMaxYaw;
                };
                ]]

                
                M._get_animstate = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    
                    
                    local base = ffi.cast("char*", ent_ptr)
                    local anim_ptr_ptr = ffi.cast("struct c_animstate_min**", base + animstate_offset)
                    if anim_ptr_ptr == nil or anim_ptr_ptr == ffi.NULL then return nil end
                    local anim_ptr = anim_ptr_ptr[0]
                    if anim_ptr == nil or anim_ptr == ffi.NULL then return nil end
                    return anim_ptr
                end
                
                M._get_entity_ptr = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    return ent_ptr
                end
            end
        end
    end
end



function M.get_sim_time(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flSimulationTime") end)
    if ok then return val end
    return nil
end


function M.get_enemies_simtimes()
    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        out[ent] = M.get_sim_time(ent)
    end
    return out
end


function M.get_velocity_3d(ent)
    local ok, vals = pcall(function() return { entity.get_prop(ent, "m_vecVelocity") } end)
    if not ok or type(vals) ~= "table" then return nil end
    if #vals >= 3 then
        return { vals[1], vals[2], vals[3] }
    end
    return nil
end


function M.get_speed_2d(ent)
    local v = M.get_velocity_3d(ent)
    if not v then return nil end
    local x, y = v[1] or 0, v[2] or 0
    return math.sqrt(x * x + y * y)
end




function M.get_origin(ent)
    local ok, x, y, z = pcall(function() return entity.get_prop(ent, "m_vecOrigin") end)
    if ok and x then
        
        if type(x) == "table" then
            return x[1], x[2], x[3]
        elseif y and z then
            return x, y, z
        end
    end
    return nil
end


function M.get_view_offset(ent)
    local tries = { "m_vecViewOffset[0]", "m_vecViewOffset" }
    for _, prop in ipairs(tries) do
        local ok, v1, v2, v3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and v1 then
            if type(v1) == "table" then
                return v1[1], v1[2], v1[3]
            elseif v2 and v3 then
                return v1, v2, v3
            end
        end
    end
    return nil
end


function M.get_eye_pos(ent)
    local ox, oy, oz = M.get_origin(ent)
    local vx, vy, vz = M.get_view_offset(ent)
    if ox and vx then
        return ox + vx, oy + vy, oz + vz
    end
    return nil
end


function M.get_eye_angles(ent)
    local tries = { "m_angEyeAngles[0]", "m_angEyeAngles", "m_angRotation", "m_angNetworkAngles" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return nil
end


function M.get_abs_angles(ent)
    local tries = { "m_angAbsRotation", "m_angAbsAngles", "m_angAbsOrigin" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return M.get_eye_angles(ent)
end


function M.get_lower_body_yaw(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flLowerBodyYawTarget") end)
    if ok and val then return val end
    return nil
end


function M.get_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flCurrentFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    
    return M.get_lower_body_yaw(ent)
end

function M.get_goal_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flGoalFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    return M.get_feet_yaw(ent)
end


function M.get_speed(ent)
    
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flVelocityModifier") end)
    if ok and val then return val end
    
    local v = M.get_velocity_3d(ent)
    if v then
        return math.sqrt((v[1] or 0) * (v[1] or 0) + (v[2] or 0) * (v[2] or 0) + (v[3] or 0) * (v[3] or 0))
    end
    return nil
end

function M.get_move_speed_anim(ent)
    
    
    
    
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local try_fields = { "m_flFeetSpeedForwardsOrSideWays", "m_flSpeed2D", "m_flSpeedNormalized", "m_flFeetSpeedUnknownForwardOrSideways" }
            for _, f in ipairs(try_fields) do
                local okf, val = pcall(function() return tonumber(anim[f]) end)
                if okf and val and val ~= 0 then
                    return val
                end
            end
        end
    end

    
    local ok_nv, nv = pcall(function() return entity.get_prop(ent, "m_flMaxspeed") end)
    if ok_nv and nv then return nv end

    
    return M.get_speed_2d(ent)
end


function M.get_flags(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_fFlags") end)
    if ok and val then return val end
    ok, val = pcall(function() return entity.get_prop(ent, "m_iFlags") end)
    if ok and val then return val end
    return nil
end



function M.read_animstate(ent)
    if not M._get_animstate then return nil end
    local ok, anim = pcall(function() return M._get_animstate(ent) end)
    if not ok or not anim then return nil end
    local out = {}
    pcall(function()
        out.m_flEyeYaw = tonumber(anim.m_flEyeYaw)
        out.m_flPitch = tonumber(anim.m_flPitch)
        out.m_flGoalFeetYaw = tonumber(anim.m_flGoalFeetYaw)
        out.m_flCurrentFeetYaw = tonumber(anim.m_flCurrentFeetYaw)
        out.m_flCurrentTorsoYaw = tonumber(anim.m_flCurrentTorsoYaw)
        out.m_flUnknownVelocityLean = tonumber(anim.m_flUnknownVelocityLean)
        out.m_flLeanAmount = tonumber(anim.m_flLeanAmount)
        out.m_flFeetCycle = tonumber(anim.m_flFeetCycle)
        out.m_flFeetYawRate = tonumber(anim.m_flFeetYawRate)
        out.m_fDuckAmount = tonumber(anim.m_fDuckAmount)
        out.m_fLandingDuckAdditiveSomething = tonumber(anim.m_fLandingDuckAdditiveSomething)
        out.m_vOrigin = { tonumber(anim.m_vOriginX), tonumber(anim.m_vOriginY), tonumber(anim.m_vOriginZ) }
        out.m_vLastOrigin = { tonumber(anim.m_vLastOriginX), tonumber(anim.m_vLastOriginY), tonumber(anim.m_vLastOriginZ) }
        out.m_vVelocity = { tonumber(anim.m_vVelocityX), tonumber(anim.m_vVelocityY) }
        out.m_flUnknownFloat1 = tonumber(anim.m_flUnknownFloat1)
        out.m_flUnknownFloat2 = tonumber(anim.m_flUnknownFloat2)
        out.m_flUnknownFloat3 = tonumber(anim.m_flUnknownFloat3)
        out.m_flUnknown = tonumber(anim.m_flUnknown)
        out.m_flSpeed2D = tonumber(anim.m_flSpeed2D)
        out.m_flUpVelocity = tonumber(anim.m_flUpVelocity)
        out.m_flSpeedNormalized = tonumber(anim.m_flSpeedNormalized)
        out.m_flFeetSpeedForwardsOrSideWays = tonumber(anim.m_flFeetSpeedForwardsOrSideWays)
        out.m_flFeetSpeedUnknownForwardOrSideways = tonumber(anim.m_flFeetSpeedUnknownForwardOrSideways)
        out.m_flTimeSinceStartedMoving = tonumber(anim.m_flTimeSinceStartedMoving)
        out.m_flTimeSinceStoppedMoving = tonumber(anim.m_flTimeSinceStoppedMoving)
        out.m_bOnGround = (anim.m_bOnGround ~= 0)
        out.m_bInHitGroundAnimation = (anim.m_bInHitGroundAnimation ~= 0)
        out.m_flTimeSinceInAir = tonumber(anim.m_flTimeSinceInAir)
        out.m_flLastOriginZ = tonumber(anim.m_flLastOriginZ)
        out.m_flHeadHeightOrOffsetFromHittingGroundAnimation = tonumber(anim.m_flHeadHeightOrOffsetFromHittingGroundAnimation)
        out.m_flStopToFullRunningFraction = tonumber(anim.m_flStopToFullRunningFraction)
        out.m_flMagicFraction = tonumber(anim.m_flMagicFraction)
        out.m_flWorldForce = tonumber(anim.m_flWorldForce)
        out.m_flMaxYaw = tonumber(anim.m_flMaxYaw)
    end)
    return out
end



function M.read_anim_layers(ent)
    if not M._get_entity_ptr then return nil end
    local ok_ent, ent_ptr = pcall(function() return M._get_entity_ptr(ent) end)
    if not ok_ent or not ent_ptr then return nil end
    local ok, res = pcall(function()
        local ffi = require("ffi")
        local base = ffi.cast("char*", ent_ptr)
        local layers_ptr = ffi.cast("struct animation_layer_t**", base + 0x2990)
        if layers_ptr == nil or layers_ptr == ffi.NULL then return nil end
        local owner = layers_ptr[0]
        if owner == nil or owner == ffi.NULL then return nil end
        local out = {}
        for i = 0, 15 do
            local layer = owner[i]
            if layer == nil or layer == ffi.NULL then break end
            local t = {}
            t.m_nOrder = tonumber(layer.m_nOrder)
            t.m_nSequence = tonumber(layer.m_nSequence)
            t.m_flPrevCycle = tonumber(layer.m_flPrevCycle)
            t.m_flWeight = tonumber(layer.m_flWeight)
            t.m_flWeightDeltaRate = tonumber(layer.m_flWeightDeltaRate)
            t.m_flPlaybackRate = tonumber(layer.m_flPlaybackRate)
            t.m_flCycle = tonumber(layer.m_flCycle)
            t.m_pOwner = tostring(layer.m_pOwner)
            table.insert(out, t)
        end
        return out
    end)
    if not ok then return nil end
    return res
end


function M.get_tick_from_simtime(simtime)
    if not simtime or not globals or not globals.tickinterval then return nil end
    local ti = globals.tickinterval()
    if not ti or ti == 0 then return nil end
    return math.floor(simtime / ti + 0.5)
end

function M.get_tick(ent)
    local sim = M.get_sim_time(ent)
    if sim then return M.get_tick_from_simtime(sim) end
    return nil
end








function M.get_enemies_snapshot(opts)
    opts = opts or {}
    local heavy = true 

    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        local snap = {}

        
        snap.is_alive = (pcall(function() return entity.is_alive(ent) end) and entity.is_alive(ent)) or false
        snap.is_dormant = (pcall(function() return entity.is_dormant(ent) end) and entity.is_dormant(ent)) or false

        
        local ok_name, name = pcall(function() return entity.get_player_name(ent) end)
        snap.name = ok_name and name or nil

        
        snap.simtime = M.get_sim_time(ent)
        do
            local base_tick = snap.simtime and M.get_tick_from_simtime(snap.simtime) or nil
            
            local ok_flags, esp_flags = pcall(function()
                local d = entity.get_esp_data and entity.get_esp_data(ent)
                return (d and d.flags) or 0
            end)

            local adjusted_tick = base_tick
            if ok_flags and esp_flags and base_tick then
                
                local ok_bit, is_backtrack = pcall(function()
                    return bit and bit.band(esp_flags, bit.lshift(1, 17)) ~= 0
                end)
                if ok_bit and is_backtrack then
                    adjusted_tick = base_tick - 14
                end
            end
            snap.simTicks = adjusted_tick
        end

        
        do
            local ok, ox, oy, oz = pcall(function() return M.get_origin(ent) end)
            if ok and ox then snap.origin = { ox, oy, oz } end
        end
        do
            local ok, vx, vy, vz = pcall(function() return M.get_view_offset(ent) end)
            if ok and vx then snap.viewOffset = { vx, vy, vz } end
        end
        do
            local ok, ex, ey, ez = pcall(function() return M.get_eye_pos(ent) end)
            if ok and ex then snap.eyePos = { ex, ey, ez } end
        end

        
        do
            local ok, a1, a2, a3 = pcall(function() return M.get_eye_angles(ent) end)
            if ok and a1 then snap.eyeAngles = { a1, a2, a3 } end
        end
        do
            local ok, aa1, aa2, aa3 = pcall(function() return M.get_abs_angles(ent) end)
            if ok and aa1 then snap.absAngles = { aa1, aa2, aa3 } end
        end

        
        snap.lowerBodyYaw = (pcall(function() return M.get_lower_body_yaw(ent) end) and M.get_lower_body_yaw(ent)) or nil
        snap.feetYaw = (pcall(function() return M.get_feet_yaw(ent) end) and M.get_feet_yaw(ent)) or snap.lowerBodyYaw
        snap.goalFeetYaw = (pcall(function() return M.get_goal_feet_yaw(ent) end) and M.get_goal_feet_yaw(ent)) or snap.feetYaw

        
        snap.velocity3d = (pcall(function() return M.get_velocity_3d(ent) end) and M.get_velocity_3d(ent)) or nil
        if snap.velocity3d then
            snap.speed2d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0))
            snap.speed3d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0) + (snap.velocity3d[3] or 0) * (snap.velocity3d[3] or 0))
        else
            snap.speed2d = M.get_speed_2d(ent)
            snap.speed3d = M.get_speed(ent)
        end

        
        do
            local ok_ms, ms = pcall(function() return M.get_move_speed_anim(ent) end)
            if ok_ms and ms then
                snap.moveSpeedAnim = ms
            else
                snap.moveSpeedAnim = nil
            end
        end

        
        snap.flags = (pcall(function() return M.get_flags(ent) end) and M.get_flags(ent)) or nil

        
        local ok_head, hx, hy, hz = pcall(function() return entity.hitbox_position(ent, "head") end)
        if ok_head and hx then snap.headPos = { hx, hy, hz } end

        
        local ok_w, w = pcall(function() return entity.get_player_weapon(ent) end)
        snap.weapon = ok_w and w or nil

        

        
        local ok_b, bones = pcall(function() return entity.get_bone_matrices and entity.get_bone_matrices(ent) end)
        if ok_b and bones then snap.bones = bones end

        local ok_as, as = pcall(function() return M.read_animstate(ent) end)
        if ok_as and as then snap.animstate_full = as end
        local ok_layers, layers = pcall(function() return M.read_anim_layers(ent) end)
        if ok_layers and layers then snap.animLayers = layers end

        out[ent] = snap
    end
    return out
end

return M
]=]
r662["require/features/misc/dormant_aimbot"] = [[local r151, r152, r153, r154= client.visible, client.eye_position, client.log, client.trace_bullet
local r155, r156, r157, r158, r159, r160, r161, r162, r163, r164= entity.get_bounding_box, entity.get_local_player, entity.get_origin, entity.get_player_name, entity.get_player_resource, entity.get_player_weapon, entity.get_prop, entity.is_dormant, entity.is_enemy, entity.is_alive
local r165, r166, r167= globals.curtime, globals.maxplayers, globals.tickcount
local r168, r169, r170= math.max, math.min, math.sqrt
local r171, r172, r173= renderer.indicator, string.format, table.unpack or unpack
local r174, r175, r176, r177, r178, r179, r180, r181, r182, r183= ui.get, ui.new_checkbox, ui.new_color_picker, ui.new_hotkey, ui.new_multiselect, ui.new_slider, ui.reference, ui.set, ui.set_callback, ui.set_visible
local r184, r185= plist.get, entity.hitbox_position
local r186= require("ffi")
local r187= require("vector")
local r188= require("gamesense/csgo_weapons")
local r189= vtable_bind("client_panorama.dll", "VClientEntityList003", 3, "void*(__thiscall*)(void*, int)")
local r190= vtable_thunk(166, "bool(__thiscall*)(void*)")
local r191= vtable_thunk(483, "float(__thiscall*)(void*)")
local r192= {
	mindamage = r180("RAGE", "Aimbot", "Minimum damage"),
	dormant_esp = r180("VISUALS", "Player ESP", "Dormant"),
	override_mindamage = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}
local r193= require("require/abc/menu_setup")
local r194= require('require/abc/callbacks')

local r195= {}
local function r196(r197)
	if type(r193) ~= 'table' then return false end
	if r195[r197] == nil then r195[r197] = r193.ui and r193.ui[r197] end
	local r198= r195[r197]
	if not r198 then return false end
	local r199, r200= pcall(r174, r198)
	if not r199 then
		r195[r197] = r193.ui and r193.ui[r197]
		r198 = r195[r197]
		if not r198 then return false end
		r199, val = pcall(r174, r198)
		if not r199 then return false end
	end
	return r200
end

local r201= { "Head", "Chest", "Stomach" }
local r202= {
	"generic",
	"head",
	"chest",
	"stomach",
	"left arm",
	"right arm",
	"left leg",
	"right leg",
	"neck",
	"?",
	"gear"
}

local r203= {
	"",
	"Head",
	"Chest",
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs",
	"Head",
	"",
	""
}

local r204= {
	{ scale = 5, hitbox = "Stomach", vec = r187(0, 0, 40) },
	{ scale = 6, hitbox = "Chest", vec = r187(0, 0, 50) },
	{ scale = 3, hitbox = "Head", vec = r187(0, 0, 58) },
	{ scale = 4, hitbox = "Legs", vec = r187(0, 0, 20) }
}

local r205= {
	[0] = "Head",
	nil,
	"Stomach",
	nil,
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs"
}

local r206= 0
local r207= {}
local r208= {}
local r209= 1
local r210= false
local r211
local r212
local r213
local r214
local r215= false
local r216= {}

local r217= {
	0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18
}

local function r218(r219,r220,r221)
	local r222, r223= r219:to(r220):angles()
	local r224= math.rad(r223 + 90)
	local r225= r187(math.cos(r224), math.sin(r224), 0) * r221

	return {
		{ text = "Middle", vec = r220 },
		{ text = "Left", vec = r220 + r225 },
		{ text = "Right", vec = r220 - r225 }
	}
end

local function r226(r227,r228)
	for i = 1, #r227 do if r227[i] == r228 then return true end end
	return false
end
local function r229(r227,r228)
	for i = 1, #r227 do local r230= r227[i] if type(r230) == 'table' and r230[1] == r228 then return i end end
end
local function r231(r227,r232) return r229(r227, r232) ~= nil end
local function r233(r227,r232) local r234= r229(r227, r232) if r234 then table.remove(r227, r234) end end

local function r235(r236,r237)
	local r238= r170(r236.forwardmove*r236.forwardmove + r236.sidemove*r236.sidemove)
	if r237<=0 or r238<=0 then return end
	if r236.in_duck==1 then r237 = r237*2.94117647 end
	if r238<=r237 then return end
	local r239= r237/r238; r236.forwardmove = r236.forwardmove*r239; r236.sidemove = r236.sidemove*r239
end

local function r240()
	local r241, r242= {}, r159()
	for i=1,r166() do if r161(r242, "m_bConnected", i)==1 and i~=r156() and r163(i) then r241[#r241+1]=i end end
	return r241
end
local function r243()
	local r241, r242= {}, r159()
	for i=1,r166() do if r161(r242, "m_bConnected", i)==1 and not r184(i, "Add to whitelist") and r162(i) and r163(i) then r241[#r241+1]=i end end
	return r241
end

local function r244()
	for r222,enemy in ipairs(r240()) do
		local r222,r222,r222,r222,r245= r155(enemy)
		if r245<1 then if not r231(r208,enemy) then r208[#r208+1]={enemy,r167()} end else r233(r208,enemy) end
	end
end

local function r246(r247)
	local r248= r174(r192.override_mindamage[1]) and r174(r192.override_mindamage[2])
	local r249= r248 and r174(r192.override_mindamage[3]) or r174(r192.mindamage)
	local r250= entity.get_esp_data(r247).health
	if r249>100 then r249 = r249 - 100 + r250 end
	return r249
end

local function r251(r252,r239) return (r252.type=="sniperrifle" and r239) and r252.max_player_speed_alt or r252.max_player_speed end

local function r253(r247,r254,r255)
	local r256= {}
	local r257= r161(r247, "m_flDuckAmount") or 0
	for r222,p in ipairs(r204) do
		if #r255==0 or r226(r255,p.hitbox) then
			local r258= p.vec
			if p.hitbox=="Head" then r258 = r258 - r187(0,0,r257*10) elseif p.hitbox=="Chest" then r258 = r258 - r187(0,0,r257*4) end
			r256[#r256+1]={vec=r254+r258,scale=p.scale,hitbox=p.hitbox}
		end
	end
	for i=1,7 do
		local r259= r205[i-1]
		if r259 and (#r255==0 or r226(r255,r259)) then
			local r260= r185(r247,i-1)
			if r260 then r256[#r256+1]={vec=r187(r260),scale=3,hitbox=r259} end
		end
	end
	return r256
end

local function r261(r262,r263,r264,r265,r266)
	for r222,p in ipairs(r265) do
		for r222,r258 in ipairs(r218(r264,p.vec,3)) do
			local r222,r267= r154(r262, r264.x,r264.y,r264.z, r258.vec.x,r258.vec.y,r258.vec.z, true)
			if p.hitbox=="Head" then r267=r267*4 end
			if r267>r266 then return r258.vec,r267,p.hitbox,r258.text end
		end
	end
end

local function r268(r236)
	r244()

	if not r196('misc_dormantaimbot') and r196('misc_dormantaimbot_key') then
		return
	end

	local r269= r156()
	if not r269 or not r164(r269) then
		return
	end

	local r270= r160(r269)
	if not r270 then
		return
	end

	local r271= r189(r270)
	if not r271 or not r190(r271) then
		return
	end

	local r272= r191(r271)
	if not r272 then
		return
	end

	local r273= r187(r152())
	local r274= r161(r269, "m_flSimulationTime")
	local r275= r167()
	local r276= r188(r270)
	local r277= r161(r269, "m_bIsScoped") == 1
	local r278= bit.band(r161(r269, "m_fFlags"), bit.lshift(1, 0))

	local r279= r243()
	if #r279 == 0 then
		r207 = {}
		return
	end

	if r275 % #r279 ~= 0 then
		r209 = r209 + 1
	else
		r209 = 1
	end

	local r247= r279[r209]
	if not r247 then
		r207 = {}
		return
	end

	if r275 < r206 then
		r207 = {}
		return
	end

	if r276.type == "grenade" or r276.type == "knife" then
		r207 = {}
		return
	end

	if r236.in_jump == 1 and r278 == 0 then
		r207 = {}
		return
	end

	local r280= r201
	local r281= r187(r157(r247))
	local r222, r222, r222, r222, r282= r155(r247)

	r207[r247] = nil

	if r282 < 1 then
		if not r231(r216, r247) then
			r216[#r216 + 1] = { r247, r275 }
		end
	else
		r233(r216, r247)
	end

	local r283= r253(r247, r281, r280)
	local r284= r246(r247)

	local r285
	if r276.is_revolver then
		r285 = r274 > r161(r270, "m_flNextPrimaryAttack")
	else
		r285 = r274 > r168(
			r161(r269, "m_flNextAttack"),
			r161(r270, "m_flNextPrimaryAttack"),
			r161(r270, "m_flNextSecondaryAttack")
		)
	end

	if not r285 then
		return
	end

	local r286, r287, r288, r289= r261(
		r269,
		r276,
		r273,
		r283,
		r284
	)

	if not r286 then
		return
	end

	if r151(r286.x, r286.y, r286.z) then
		return
	end

	r235(r236, r251(r276, r277) * 0.33)

	local r290, r223= r273:to(r286):angles()

	if not r277 and r276.type == "sniperrifle" and r236.in_jump == 0 and r278 == 1 then
		r236.in_attack2 = 1
	end

	r207[r247] = true

	if r272 < 0.01 then
		r236.pitch = r290
		r236.yaw = r223
		r236.in_attack = 1
		r210 = true
		r211 = r288
		r212 = r289
		r213 = r247
		r214 = (r174(r193.ui.misc_dormantaimbot_value) or 0)
	end
end

local function r291(r292)
	client.delay_call(0.03, function()
		local r269= r156()
		if client.userid_to_entindex(r292.userid) ~= r269 then
			return
		end

		if r210 and not r215 then
			client.fire_event("dormant_miss", {
				userid = r213,
				aim_hitbox = r211,
				aim_point = r212,
				accuracy = r214
			})
		end

		r215 = false
		r210 = false
		r211 = nil
		r212 = nil
		r213 = nil
		r214 = nil
	end)
end

local function r293(r292)
	local r294= client.userid_to_entindex(r292.userid)
	local r295= client.userid_to_entindex(r292.attacker)

	if r295 == r156() and r294 ~= nil and r210 then
		r215 = true

		client.fire_event("dormant_hit", {
			userid = r294,
			attacker = r295,
			health = r292.health,
			armor = r292.armor,
			weapon = r292.weapon,
			dmg_health = r292.dmg_health,
			dmg_armor = r292.dmg_armor,
			hitgroup = r292.hitgroup,
			accuracy = r214 or 0,
			aim_hitbox = r211
		})
	end
end

local function r296()
	local r297= (cvar.mp_freezetime:get_float() + 1) / globals.tickinterval()
	r206 = r167() + r297
end

r194.register("setup_command", r268, { alive_only = true, require_login = true })
r194.register("round_prestart", r296, { alive_only = true, require_login = true })
r194.register("player_hurt", r293, { alive_only = true, require_login = true })
r194.register("weapon_fire", r291, { alive_only = true, require_login = true })

client.register_esp_flag("DA", 255, 255, 255, function(r232)
	if r196('misc_dormantaimbot') and r196('misc_dormantaimbot_key') and r164(r156()) then
		return r207[r232]
	end
end)


r194.register("paint", function()
	if not r164(r156()) then return end
	if r196('misc_dormantaimbot') and r196('misc_dormantaimbot_key') then
		local r298= {255,255,255,200}
		for r222,r230 in pairs(r207) do if r230 then r298={143,194,21,255}; break end end
		if #r243()==0 then r298={255,0,50,255} end
		r171(r298[1],r298[2],r298[3],r298[4],"DA")
	end
end, { alive_only = true, require_login = true })]]
r662["require/features/misc/enhance_osaa"] = [[local r154, r155= pcall(require, "require/abc/menu_setup")

local r156= require('require/abc/callbacks')

local r157= {}
local r158= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local r159= {ui.reference(item[1], item[2], item[3])}
    r157[i] = r159
    for _, ref in ipairs(r159) do
        r158[ref] = true
    end
end

local r160= {}
local r161= {}

r156.register("weapon_fire", function(r162)
    local r163= entity.get_local_player()
    if r163 and client.userid_to_entindex(r162.userid) == r163 then
        r160[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

r156.register("player_hurt", function(r162)
    local r163= entity.get_local_player()
    if r163 and client.userid_to_entindex(r162.userid) == r163 then
        r161[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

local function r164()
    local r165= globals.tickcount()
    local r166= nil
    for t = r165-20, r165 do
        if r160[t] then
            r166 = t
            break
        end
    end
    if r166 then
        if r165 - r166 <= 4 then
            return true
        end
        return true
    end
    return false
end



local function r167(r168)

    local r164= has_fired()

    local function r169(r170,r171)
        if type(r170) ~= 'table' then return false end
        for _, v in ipairs(r170) do if tostring(v) == tostring(r171) then return true end end
        return false
    end

    local r172= ui.get(r155.ui.fakelag_settings_enhance_onshot) or {}

    if r155 and r155.ui and r164 then
            if r169(r172, 'defensive') then
                r168.force_defensive = true
            end

            if r169(r172, 'roll') then
                ui.set(r157[3][1], math.random(-45, 45))
            end

            local r173= globals.tickcount() % 4 < 2
            if r169(r172, 'jitter') then
                ui.set(r157[2][1], '180')
                ui.set(r157[2][2], r173 and 55 or -48)
            end
    end
end

r156.register('setup_command', function(r168)

    r167(r168)

end, { alive_only = true, require_login = true })]]
r662["require/features/misc/events"] = [[local r157= {}
local r158= globals

r157.last_hit = {}
r157.last_miss = {}

r157.shots_queue = {}
r157.shots_by_id = {}

function r157.record_weapon_fire(r159)
  if not r159 or not r159.t then return end
  r157.shots_queue[#r157.shots_queue+1] = r159
end

function r157.record_aim_fire(r160,r159)
  if not r160 or not r159 then return end
  r157.shots_by_id[r160] = r159
end

function r157.record_aim_miss(r160,r161,r162)
  if not r161 then return end
  local r163= r158.curtime()
  local r164= r162 or {}
  r164.time = r163
  r157.last_miss[r161] = r164
  if r160 then r157.shots_by_id[r160] = nil end
end

function r157.record_player_hurt(r160,r161,r162)
  if not r161 then return end
  local r163= r158.curtime()
  local r164= r162 or {}
  r164.time = r163
  r157.last_hit[r161] = r164
  if r160 then r157.shots_by_id[r160] = nil end
end

function r157.link_recent_shot_to_victim(r161,r165)
  r165 = r165 or 0.35
  local r163= r158.curtime()
  for i=#r157.shots_queue,1,-1 do
    local r166= r157.shots_queue[i]
    if r166 and r166.target == r161 and (r163 - (r166.t or r163)) <= r165 and not r166.linked then
      r157.shots_queue[i].linked = true
      return r157.shots_queue[i]
    end
  end
  return nil
end

return r157
]]
r662["require/features/misc/exploit_fakelag"] = [[local r160, r161= pcall(require, "require/abc/menu_setup")

local r162= require('require/abc/callbacks')

local r163= {}
local r164= {}
for i, item in ipairs({
    { 'rage', 'aimbot', 'double tap' },
    { 'aa', 'other', 'on shot anti-aim' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },

}) do
    local r165= {ui.reference(item[1], item[2], item[3])}
    r163[i] = r165
    for _, ref in ipairs(r165) do
        r164[ref] = true
    end
end


local function r166(r167)

    local r168= ui.get(r161.ui.misc_exploit_fakelag)

    local r169= (ui.get(r163[1][1]) and ui.get(r163[1][2]))
    local r170= (ui.get(r163[2][1]) and ui.get(r163[2][2]))

    local r171= r168 and (r169 or r170)

    if r171 then
        ui.set(r163[3][1], false)
    end

end

r162.register('setup_command', function(r167)

    r166(r167)

end, { alive_only = true, require_login = true })]]
r662["require/features/misc/fakelag"] = [[local r163= {}
local r164= {}
for i, item in ipairs({
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
}) do
    local r165= {ui.reference(item[1], item[2], item[3])}
    r163[i] = r165
    for _, ref in ipairs(r165) do
        r164[ref] = true
    end
end

local r166, r167= pcall(require, "require/abc/menu_setup")

local r168= require('require/abc/callbacks')

r168.register("setup_command", function()
    if not (r166 and r167 and r167.ui) then return end

    local r169, r170= pcall(ui.get, r167.ui.fakelag_fakelag)
    if not r169 or not r170 then return end

    local r171, r172= pcall(ui.get, r167.ui.fakelag_fakelag_type)
    if not r171 then return end

    if tostring(r172) == "gamesense" then
        ui.set(r163[1][1], true)
        local r173, r174= pcall(ui.get, r167.ui.fakelag_fakelag_amount)
        local r175, r176= pcall(ui.get, r167.ui.fakelag_fakelag_variance)
        local r177, r178= pcall(ui.get, r167.ui.fakelag_fakelag_limit)

        if r173 and r174 and r163[2] and r163[2][1] then
            pcall(ui.set, r163[2][1], r174)
        end
        if r175 and r176 and r163[3] and r163[3][1] then
            pcall(ui.set, r163[3][1], r176)
        end
        if r177 and r178 and r163[4] and r163[4][1] then
            pcall(ui.set, r163[4][1], r178)
        end

        return
    end

    if tostring(r172) == "sodium" then
        ui.set(r163[1][1], true)
        local r179, r180= pcall(ui.get, r167.ui.fakelag_fakelag_type2)
        if not r179 then return end

        if tostring(r180) == "jitter" then
            if r163[2] and r163[2][1] then
                pcall(ui.set, r163[2][1], "dynamic")
            end
            local r181= globals.tickcount() or 0
            local r182= math.max(r181 % 101, 100)
            local r183= math.min(math.random(7) + (r181 % 15), 11)
            if r163[3] and r163[3][1] then pcall(ui.set, r163[3][1], r182) end
            if r163[4] and r163[4][1] then pcall(ui.set, r163[4][1], 15) end

            return
        end

        if tostring(r180) == "max" then
            if r163[2] and r163[2][1] then
                pcall(ui.set, r163[2][1], "dynamic")
            end
            if r163[3] and r163[3][1] then
                pcall(ui.set, r163[3][1], 0)
            end
            local r178= 14 + ((globals.tickcount() or 0) % 2)
            if r163[4] and r163[4][1] then pcall(ui.set, r163[4][1], r178) end

            return
        end
    end
end, { alive_only = true, require_login = true })]]
r662["require/features/misc/freestand_helper"] = [[local r166= {}
local r167= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
}) do
    local r168= {ui.reference(item[1], item[2], item[3])}
    r166[i] = r168
    for _, ref in ipairs(r168) do
        r167[ref] = true
    end
end

local r169, r170= pcall(require, "require/abc/menu_setup")

local r171= require('require/abc/callbacks')

local function r172(r173)
    if not (r170 and r170.ui and r170.ui.aa_gskey_freestand) then return end
    if not ui.get(r170.ui.aa_gskey_freestand) then return end

    local function r174(r175,r176)
        if type(r175) ~= 'table' then return false end
        for _, v in ipairs(r175) do if tostring(v) == tostring(r176) then return true end end
        return false
    end

    local r177= ui.get(r170.ui.fakelag_settings_freestanding) or {}


    localplayer = entity.get_local_player()
    local r178, r179, r180= entity.get_prop(localplayer, 'm_vecVelocity')
    if r178 and r179 and r180 then
        velvel =  math.sqrt(r178 * r178 + r179 * r179 + r180 * r180)
    end
    


    if r174(r177, 'static') then
        ui.set(r166[1][1], true)
        ui.set(r166[5][1], '180')
        ui.set(r166[5][2], 6)
        ui.set(r166[6][1], 'off')
        ui.set(r166[7][1], 'off')
    end

    if r174(r177, 'zero pitch') and velvel > 5 then
        ui.set(r166[3][1], 'Off')
    end

    if r174(r177, 'defensive') then
        r173.force_defensive = true
    end

    local r181= globals.tickcount() % 4 < 2
    if r174(r177, 'side flip') and velvel > 5 then
        ui.set(r166[5][1], '180')
        ui.set(r166[5][2], r181 and -90 or 90)
    end

    local r181= globals.tickcount() % 6 < 2
    if r174(r177, 'pitch flip') and velvel > 5 then
        ui.set(r166[3][1], 'custom')
        ui.set(r166[3][2], r181 and -89 or 89)
    end

end

r171.register('setup_command', function(r173)
    r172(r173)
end, { alive_only = true, require_login = true })]]
r662["require/features/misc/history"] = [[
local r169= {}

local r170= 20
local r171= {}

local function r172(r173)
  if not r171[r173] then r171[r173] = { buf = {} } end
  return r171[r173]
end

function r169.push(r173,r174)
  if not r173 or not r174 then return end
  local r175= r172(r173)
  r175.buf[#r175.buf+1] = r174
  if #r175.buf > r170 then table.remove(r175.buf, 1) end
end

function r169.get_last_n(r173,r176)
  r176 = r176 or r170
  local r175= r171[r173]
  if not r175 or #r175.buf == 0 then return {} end
  local r177= {}
  local r178= #r175.buf
  local r179= math.max(1, r178 - r176 + 1)
  for i = r179, r178 do r177[#r177+1] = r175.buf[i] end
  return r177
end

function r169.clear(r173)
  if not r173 then r171 = {} return end
  r171[r173] = nil
end

return r169
]]
r662["require/features/misc/hotkeys"] = [[local r172= {}
local r173= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local r174= {ui.reference(item[1], item[2], item[3])}
    r172[i] = r174
    for _, ref in ipairs(r174) do
        r173[ref] = true
    end
end

local r175, r176= pcall(require, "require/abc/menu_setup")

local r177= require('require/abc/callbacks')

local function r178()

    if ui.get(r176.ui.aa_gskey_freestand) then
        ui.set(r172[3][1], true)
        ui.set(r172[3][2], 'Always on')
    else
        ui.set(r172[3][1], false)
        ui.set(r172[3][2], 'On hotkey')
    end

    if ui.get(r176.ui.aa_gskey_slowmotion) then
        ui.set(r172[4][1], true)
    else
        ui.set(r172[4][1], false)
    end

    if r176 and r176.ui and ui.get(r176.ui.aa_gskey_edgeyaw) then
        ui.set(r172[2][1], true)
    else
        ui.set(r172[2][1], false)
    end

    if r176 and r176.ui and ui.get(r176.ui.aa_gskey_onshot) then
        ui.set(r172[6][2], 'Always on')
    else
        ui.set(r172[6][2], 'On hotkey')
    end

end

r177.register('setup_command', function()

    r178()

end, { alive_only = true, require_login = true })]]
r662["require/features/misc/localdebug"] = [=[local callbacks_ok, callbacks = pcall(require, "require/abc/callbacks")
local M = {}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")

local state = {
    last_yaw = nil,
    last_pitch = nil,
    last_defensive = false,
    skel_list = {},
    last_choked = 0,
    shot_ticks = {},
    shot_ticks_aim = {},
    skel_history = {},
}

local function normalize_angle(a)
    if not a then return a end
    local ang = tonumber(a) or 0
    while ang > 180 do ang = ang - 360 end
    while ang <= -180 do ang = ang + 360 end
    return ang
end

local function on_weapon_fire(ev)
    if not ev then return end
    local attacker_ent = client.userid_to_entindex(ev.userid)
    local lp = entity.get_local_player()
    if attacker_ent ~= lp then return end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks, t)
    while #state.shot_ticks > 200 do table.remove(state.shot_ticks, 1) end
end

local function on_aim_fire(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    if ev.attacker then
        local attacker_ent = client.userid_to_entindex(ev.attacker)
        if attacker_ent ~= lp then return end
    end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks_aim, t)
    while #state.shot_ticks_aim > 200 do table.remove(state.shot_ticks_aim, 1) end
end

local function had_recent_shot(ticks_back)
    ticks_back = ticks_back or 30
    local now = globals.tickcount and globals.tickcount() or 0
    for i = #state.shot_ticks_aim, 1, -1 do
        local s = state.shot_ticks_aim[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    for i = #state.shot_ticks, 1, -1 do
        local s = state.shot_ticks[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    return false
end

local function safe_tonumber(v)
    local n = tonumber(v)
    if n then return n end
    return 0
end


local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {
    head={names={'head','Head','HEAD'},idx={0}},
    neck={names={'neck','Neck'},idx={1}},
    chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},
    stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},
    pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},
    l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},
    l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},
    l_hand={names={'left hand','Left Hand'},idx={14}},
    r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},
    r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},
    r_hand={names={'right hand','Right Hand'},idx={13}},
    l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},
    l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},
    l_foot={names={'left foot','Left Foot'},idx={12}},
    r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},
    r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},
    r_foot={names={'right foot','Right Foot'},idx={11}},
}

local function find_bone(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x,y,z = entity.hitbox_position(ent, def.names[i])
        if x then return x,y,z end
    end
    for i = 1, #(def.idx or {}) do
        local x,y,z = entity.hitbox_position(ent, def.idx[i])
        if x then return x,y,z end
    end
end

local function snap_ent(ent)
    if not ent then return end
    local pts = {}
    for key, def in pairs(boxes) do
        local x,y,z = find_bone(ent, def)
        if x then pts[key] = {x=x,y=y,z=z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local function paint_handler()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lag_record then
        local ok_enabled, enabled = pcall(ui.get, menu_setup.ui.paint_lag_record)
        if not ok_enabled or not enabled then return end
    end
    if not renderer or not renderer.world_to_screen or not renderer.line then return end
    local now = globals.realtime and globals.realtime() or os.time()
    local i = 1
    while i <= #state.skel_list do
        local it = state.skel_list[i]
        if not it or not it.t or (now - it.t) > 10 then
            table.remove(state.skel_list, i)
        else
            local SKEL_SCALE = 1.15
            
            local trail = it.trail or {}
            if trail and #trail > 0 then
                for ti = 1, #trail do
                    local entry = trail[ti]
                    local trail_pts = entry.pts or {}
                    
                    local ratio = ti / #trail
                    local r, g, b, alpha
                    if ti == #trail then
                        
                        r = 0
                        g = 140
                        b = 255
                        alpha = 200
                    else
                        
                        r = 255
                        g = math.floor(255 * (1 - ratio))
                        b = math.floor(255 * (1 - ratio))
                        alpha = math.floor(40 + ratio * (160 - 40))
                    end
                    
                    local center = trail_pts.pelvis or trail_pts.chest
                    if not center then
                        local sx, sy, sz, ccount = 0,0,0,0
                        for k, v in pairs(trail_pts) do
                            if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                        end
                        if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
                    end
                    for c = 1, #chains do
                        local chain = chains[c]
                        local from, to = trail_pts[chain[1]], trail_pts[chain[2]]
                        if from and to then
                            local fxw, fyw, fzw = from.x, from.y, from.z
                            local txw, tyw, tzw = to.x, to.y, to.z
                            if center and center.x then
                                fxw = center.x + (from.x - center.x) * SKEL_SCALE
                                fyw = center.y + (from.y - center.y) * SKEL_SCALE
                                fzw = center.z + (from.z - center.z) * SKEL_SCALE
                                txw = center.x + (to.x - center.x) * SKEL_SCALE
                                tyw = center.y + (to.y - center.y) * SKEL_SCALE
                                tzw = center.z + (to.z - center.z) * SKEL_SCALE
                            end
                            local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                            local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                            if fx and tx then renderer.line(fx,fy,tx,ty,r,g,b,alpha) end
                        end
                    end
                end
            end
            
            local pts = it.pts or {}
            local center = pts.pelvis or pts.chest
            if not center then
                local sx, sy, sz, ccount = 0,0,0,0
                for k, v in pairs(pts) do
                    if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                end
                if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
            end
            for c = 1, #chains do
                local chain = chains[c]
                local from, to = pts[chain[1]], pts[chain[2]]
                if from and to then
                    local fxw, fyw, fzw = from.x, from.y, from.z
                    local txw, tyw, tzw = to.x, to.y, to.z
                    if center and center.x then
                        fxw = center.x + (from.x - center.x) * SKEL_SCALE
                        fyw = center.y + (from.y - center.y) * SKEL_SCALE
                        fzw = center.z + (from.z - center.z) * SKEL_SCALE
                        txw = center.x + (to.x - center.x) * SKEL_SCALE
                        tyw = center.y + (to.y - center.y) * SKEL_SCALE
                        tzw = center.z + (to.z - center.z) * SKEL_SCALE
                    end
                    local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                    local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                    if fx and tx then renderer.line(fx,fy,tx,ty,255,0,0,220) end
                end
            end
            i = i + 1
        end
    end
end


local function on_setup_command(cmd)
    if not cmd then return end
    local aa_funcs = nil
    local ok_req, req_lib = pcall(require, 'gamesense/antiaim_funcs')
    if ok_req and req_lib then aa_funcs = req_lib end
    if not aa_funcs then
        local ok_libs, libs = pcall(require, 'require/help/libs')
        if ok_libs and libs and libs.get then
            aa_funcs = libs.get('antiaim_funcs')
        end
    end

    local pitch, yaw = nil, nil
    if aa_funcs then
        local okp, pval = pcall(function() return aa_funcs.get_pitch and aa_funcs.get_pitch() end)
        if okp and pval ~= nil then pitch = pval end
        local oky, yval = pcall(function() return aa_funcs.get_yaw_base and aa_funcs.get_yaw_base() end)
        if oky and yval ~= nil then yaw = yval end
        if yaw == nil then
            local okb, bval = pcall(function() return aa_funcs.get_body_yaw and aa_funcs.get_body_yaw() end)
            if okb and bval ~= nil then yaw = bval end
        end
    end

    if (pitch == nil or yaw == nil) then
        local lp = entity.get_local_player()
        if lp then
            local ax, ay = entity.get_prop(lp, "m_angEyeAngles")
            if ax and ay then
                if pitch == nil then pitch = ax end
                if yaw == nil then yaw = ay end
            end
        end
    end

    if pitch ~= nil then state.last_pitch = pitch end
    if yaw ~= nil then state.last_yaw = normalize_angle(yaw) end

    do
        local ok_def, def_mod = pcall(require, 'require/features/aa/defensive')
        if ok_def and def_mod and def_mod.active ~= nil then
            state.last_defensive = not not def_mod.active
        else
            if cmd and cmd.force_defensive ~= nil then
                state.last_defensive = not not cmd.force_defensive
            end
        end
    end
    if cmd and cmd.chokedcommands ~= nil then
        state.last_choked = tonumber(cmd.chokedcommands) or 0
    end
    local lp = entity.get_local_player()
    if lp then
        local tick = globals.tickcount and globals.tickcount() or 0
        local hist_pts = snap_ent(lp)
        if hist_pts then
            state.skel_history[#state.skel_history + 1] = { tick = tick, pts = hist_pts }
            if #state.skel_history > 128 then table.remove(state.skel_history, 1) end
        end
    end
end

local function on_player_death(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    local victim_ent = client.userid_to_entindex(ev.userid)
    local attacker_ent = nil
    if ev.attacker then attacker_ent = client.userid_to_entindex(ev.attacker) end

    if victim_ent == lp then
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then
                attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker)
            else
                attacker_name = tostring(ev.attacker)
            end
        end
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] DIED — last_yaw=%.2f last_pitch=%.2f attacker=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
        return
    end
    if attacker_ent == lp and victim_ent and victim_ent ~= 0 and victim_ent ~= lp then
        local victim_name = entity.get_player_name(victim_ent) or tostring(ev.userid)
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] KILLED — last_yaw=%.2f last_pitch=%.2f victim=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, victim_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end
end

if callbacks_ok and callbacks and callbacks.callback then
    callbacks.callback('setup_command', on_setup_command, { alive_only = false, require_login = false })
    callbacks.callback('player_death', on_player_death, { alive_only = false, require_login = false })
    callbacks.callback('paint', paint_handler, { alive_only = false, require_login = false })
    callbacks.callback('weapon_fire', on_weapon_fire, { alive_only = false, require_login = false })
    callbacks.callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end, { alive_only = false, require_login = false })
else
    client.set_event_callback('setup_command', on_setup_command)
    client.set_event_callback('player_death', on_player_death)
    client.set_event_callback('paint', paint_handler)
    client.set_event_callback('weapon_fire', on_weapon_fire)
    client.set_event_callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end)
end
]=]
r662["require/features/misc/resolver"] = [[














local r178, r179= pcall(require, "require/features/misc/collect")
local r180, r181= pcall(require, "require/features/misc/history")
local r182, r183= pcall(require, "require/features/misc/state")
local r184, r185= pcall(require, "require/features/misc/events")
local r186, r187= pcall(require, "require/help/vector")
local r188= r186 and r187 or nil
local r189= require('require/abc/callbacks')







if not M then M = {} end
M.players = M.players or {}


local function r190()
	pcall(function()
		if not r178 or type(r179) ~= "table" or not r179.get_enemies_snapshot then return end

		local r191, r192= pcall(function() return r179.get_enemies_snapshot() end)
		if not r191 or type(r192) ~= "table" then return end

		M.players = M.players or {}

		for ent, snap in pairs(r192) do
			M.players[ent] = M.players[ent] or {}
			M.players[ent].snapshot = snap

            
            
            
			M.players[ent].simtime = snap.simtime
			M.players[ent].simTicks = snap.simTicks
			M.players[ent].lowerBodyYaw = snap.lowerBodyYaw
			M.players[ent].speed2d = snap.speed2d
			M.players[ent].velocity3d = snap.velocity3d
			M.players[ent].is_alive = snap.is_alive
			M.players[ent].is_dormant = snap.is_dormant
			M.players[ent].feetYaw = snap.feetYaw
			M.players[ent].goalFeetYaw = snap.goalFeetYaw
			M.players[ent].moveSpeedAnim = snap.moveSpeedAnim
		end

		for ent, snap in pairs(r192) do
			local r193= snap.name or "?"
			local r194= snap.simtime or 0
			local r195= snap.speed2d or 0
			local r196= snap.lowerBodyYaw or "nil"
			local r197= snap.moveSpeedAnim or 0
			local r198= snap.feetYaw or "nil"
			local r199= snap.goalFeetYaw or "nil"
			local r200= snap.animstate_full.m_fDuckAmount

		end
	end)
end



local function r201(r202)
    while r202 > 180 do
        r202 = r202 - 360
    end
    while r202 < -180 do
        r202 = r202 + 360
    end
    return r202
end


local function r203(r204,r205)
    local r206= r205 - r204
    local r202= math.atan(r206.y / r206.x)
    r202 = r201(r202 * 180 / math.pi)

    if r206.x >= 0 then
        r202 = r201(r202 + 180)
    end

    return r202
end



local r207= 100
local r208= {}
_G.player_history = r208

local function r209(r210)
    return math.floor(0.5 + r210 / globals.tickinterval())
end

local function r211(r212)
    local r213= entity.get_players(true)

	if #r213 == 0 then
		
		r208 = {}
		_G.player_history = r208
		return nil
	end


	for i, player in ipairs(r213) do
		if entity.is_alive(player) and not entity.is_dormant(player) then

			local r214= 0
			local r215= entity.get_esp_data(player).flags or 0

			if bit.band(r215, bit.lshift(1, 17)) ~= 0 then
				r214 = r209(entity.get_prop(player, "m_flSimulationTime")) - 14
			else
				r214 = r209(entity.get_prop(player, "m_flSimulationTime"))
			end

			
			local r216= r208[player] or {}
			local r217= r216[1]

			if r217 == nil or (r214 - (r217.simtime or -999)) >= 1 then

				local r218= r188(entity.get_prop(r212, "m_vecOrigin"))
				local r219= r188(entity.get_prop(player, "m_angEyeAngles"))
				local r220= r188(entity.get_prop(player, "m_vecOrigin"))
				local r221= math.floor(r201(r219.y - r203(r218, r220)))
				

				local r222= {
					id = player or nil,
					origin = r188(entity.get_origin(player)) or r188(nil,nil,nil),
					pitch = r219.x or nil,
					yaw = r221 or nil,
					yaw_backwards = backwards_angle or nil,
					simtime = r214 or nil,
					stance = stance or nil,
					esp_flags = entity.get_esp_data(player).flags or 0,
					last_shot_time = last_shot_time or nil
				}

				table.insert(r216, 1, r222)
				while #r216 > r207 do
					table.remove(r216)
				end

				r208[player] = r216
			end
		end
	end
end















client.set_event_callback('net_update_end', function()
    pcall(function()

        
        

        local r212= entity.get_local_player()
        if not entity.is_alive(r212) then
            return
        end
        r211(r212)


        local r223= (globals and globals.tickcount and globals.tickcount()) or (globals and globals.realtime and globals.realtime()) or os.time()
        

    end)
end, { alive_only = true, require_login = true })

r189.register('weapon_fire', function(r224)
    pcall(function()







        local r225= (r224 and r224.userid) and (client.userid_to_entindex and client.userid_to_entindex(r224.userid)) or (r224 and (r224.attacker or r224.userid)) or "?"
        local r226= (r224 and (r224.weapon or r224.weapon_name or r224.weaponid)) or "?"
        
    end)
    if EVENTS and EVENTS.record_weapon_fire then pcall(EVENTS.record_weapon_fire, r224) end
end, { alive_only = true, require_login = true })

r189.register('aim_fire', function(r224)
    pcall(function()








        local r227= r224 and r224.id or "?"
        local r228= r224 and r224.target or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_fire then pcall(EVENTS.record_aim_fire, r224) end
end, { alive_only = true, require_login = true })

r189.register('aim_hit', function(r224)
    pcall(function()








        local r227= r224 and r224.id or "?"
        local r228= r224 and r224.target or "?"
        local r229= r224 and r224.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_hit then pcall(EVENTS.record_aim_hit, r224) end
end, { alive_only = true, require_login = true })

r189.register('aim_miss', function(r224)
    pcall(function()






        local r227= r224 and r224.id or "?"
        local r230= r224 and r224.reason or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_miss then pcall(EVENTS.record_aim_miss, r224) end
end, { alive_only = true, require_login = true })

r189.register('player_hurt', function(r224)
    pcall(function()






        local r231= (r224 and r224.attacker) or (r224 and r224.userid) or "?"
        local r232= (r224 and r224.userid) or (r224 and r224.userid) or "?"
        local r229= r224 and r224.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_player_hurt then pcall(EVENTS.record_player_hurt, r224) end
end, { alive_only = true, require_login = true })

r189.register('bullet_impact', function(r224)
    pcall(function()




        local r225= (r224 and r224.userid) and (client.userid_to_entindex and client.userid_to_entindex(r224.userid)) or "?"
        local r233,r234,r235= r224 and r224.x or "?", r224 and r224.y or "?", r224 and r224.z or "?"
        
    end)
    if EVENTS and EVENTS.on_bullet_impact then pcall(EVENTS.on_bullet_impact, r224) end
    if EVENTS and EVENTS.record_bullet_impact then pcall(EVENTS.record_bullet_impact, r224) end
end, { alive_only = true, require_login = true })

r189.register('paint', function()
    pcall(function()

        

    end)
    if EVENTS and EVENTS.on_paint then pcall(EVENTS.on_paint) end
end, { alive_only = true, require_login = true })

r189.register("round_start", function(r224)
    pcall(function() print("[resolver] round_start") end)



    M.players = {}
    if EVENTS and EVENTS.on_round_start then pcall(EVENTS.on_round_start, r224) end
end, { alive_only = true, require_login = true })

r189.register("shutdown", function()
    if client and client.unset_event_callback then



    end
end, { alive_only = true, require_login = true })
]]
r662["require/features/misc/resolver_dispatcher"] = [[local r181= {}


local r182= {}


_G.player_resolver_state = _G.player_resolver_state or {}

local function r183(r184)
    if not r184 or type(r184) ~= "string" then return nil end
    
    local r185= r184:lower()
    r185 = r185:gsub("%+", "plus")
    r185 = r185:gsub("%-% ", "minus_") 
    r185 = r185:gsub("%-%", "minus")
    r185 = r185:gsub("%s+", "_")
    r185 = r185:gsub("[^%w_]", "")
    return r185
end

local function r186(r184)
    local r187
    
    if r184 == "?" then
        r187 = "default"
    else
        r187 = r183(r184)
    end
    if not r187 or r187 == "" then return nil end
    if r182[r187] ~= nil then return r182[r187] end
    local r188= "require/features/misc/res_" .. r187
    local r189, r190= pcall(require, r188)
    if r189 and type(r190) == "table" then
        r182[r187] = r190
        return r190
    end
    r182[r187] = false
    return nil
end



function r181.process_entity(r191,r184,r192)
    local r189, r193= pcall(function()
        if not r191 or r191 == 0 then return end
        if not r184 or r184 == "?" then return end

        local r190= r186(r184)
        if not r190 then return end

        
        local r194= _G.player_resolver_state[r191]
        if not r194 then
            r194 = {}
            _G.player_resolver_state[r191] = r194
        end

        if type(r190.run) == "function" then
            
            pcall(function() r190.run(r191, r192 or {}, r194, r184) end)
        elseif type(r190.process) == "function" then
            pcall(function() r190.process(r191, r192 or {}, r194, r184) end)
        end
    end)
    return r189
end


r181._modules = r182
r181._sanitize_label = r183

return r181
]]
r662["require/features/misc/res_default"] = [[local r184= {}

local function r185(r186)
    pcall(function()
        if plist and type(plist.set) == "function" then
            
            plist.set(r186, "Force body yaw", false)
            plist.set(r186, "Force body yaw value", 0)
            plist.set(r186, "Force pitch", false)
            plist.set(r186, "Force pitch value", 0)
        end
    end)
end

function r184.run(r186,r187,r188,r189)
    
    if r189 ~= "?" and r189 ~= "DEFAULT" and r189 ~= "default" then return end

    r188.clears = (r188.clears or 0) + 1
    r188.last_seen = (globals and globals.curtime and globals.curtime()) or os.time()

    
    r185(r186)

    pcall(function()
        print(string.format("[res_default] ent=%d cleared_forces label=%s count=%d", r186, tostring(r189), r188.clears))
    end)
end

return r184
]]
r662["require/features/misc/res_static"] = [=[local M = {}
local ok_ffi, ffi = pcall(require, "ffi")
local ok_bit, bit = pcall(require, "bit")


local get_entity_ptr
local function init_ffi_helpers()
    if not ok_ffi or not client or not client.create_interface then return end
    local status, res = pcall(function()
        local pointer_type = ffi.typeof("void***")
        local entity_list_ptr = client.create_interface("client.dll", "VClientEntityList003")
        if not entity_list_ptr then return nil end
        local entity_list = ffi.cast(pointer_type, entity_list_ptr)
        local get_client_entity = ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
        return function(entindex)
            if not entindex or entindex == 0 then return nil end
            local ptr = get_client_entity(entity_list, entindex)
            if ptr == nil then return nil end
            return ptr
        end
    end)
    if status and type(res) == "function" then
        get_entity_ptr = res
    else
        get_entity_ptr = nil
    end
end
init_ffi_helpers()

local function get_speed2d(ent)
    
    local ok, vx, vy = pcall(function()
        local x,y,z = entity.get_prop(ent, "m_vecVelocity")
        return x or 0, y or 0
    end)
    if ok and vx and vy then
        return math.sqrt((vx or 0)*(vx or 0) + (vy or 0)*(vy or 0))
    end
    return 0
end

local function estimate_max_desync_ent(ent)
    
    if not ok_ffi or not get_entity_ptr then return nil end
    local ok_read, result = pcall(function()
        ffi.cdef[[
        struct c_animstate {
            char pad0[3];
            char m_bForceWeaponUpdate;
            char pad1[91];
            void* m_pBaseEntity;
            void* m_pActiveWeapon;
            void* m_pLastActiveWeapon;
            float m_flLastClientSideAnimationUpdateTime;
            int m_iLastClientSideAnimationUpdateFramecount;
            float m_flAnimUpdateDelta;
            float m_flEyeYaw;
            float m_flPitch;
            float m_flGoalFeetYaw;
            float m_flCurrentFeetYaw;
            float m_flCurrentTorsoYaw;
            float m_flUnknownVelocityLean;
            float m_flLeanAmount;
            char pad2[4];
            float m_flFeetCycle;
            float m_flFeetYawRate;
            char pad3[4];
            float m_fDuckAmount;
            float m_fLandingDuckAdditiveSomething;
            char pad4[4];
            float m_vOriginX;
            float m_vOriginY;
            float m_vOriginZ;
            float m_vLastOriginX;
            float m_vLastOriginY;
            float m_vLastOriginZ;
            float m_vVelocityX;
            float m_vVelocityY;
            char pad5[4];
            float m_flUnknownFloat1;
            char pad6[8];
            float m_flUnknownFloat2;
            float m_flUnknownFloat3;
            float m_flUnknown;
            float m_flSpeed2D;
            float m_flUpVelocity;
            float m_flSpeedNormalized;
            float m_flFeetSpeedForwardsOrSideWays;
            float m_flFeetSpeedUnknownForwardOrSideways;
            float m_flTimeSinceStartedMoving;
            float m_flTimeSinceStoppedMoving;
            bool m_bOnGround;
            bool m_bInHitGroundAnimation;
            char pad7[2];
            float m_flTimeSinceInAir;
            float m_flLastOriginZ;
            float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
            float m_flStopToFullRunningFraction;
            float m_flMagicFraction;
            char pad8[60];
            float m_flWorldForce;
            char pad9[462];
            float m_flMaxYaw;
        };
        ]]
        local ent_ptr = get_entity_ptr(ent)
        if not ent_ptr then return nil end
        local animstate_ptr = ffi.cast("struct c_animstate**", ffi.cast("uintptr_t", ent_ptr) + 0x9960)
        if animstate_ptr == nil or animstate_ptr == ffi.NULL then return nil end
        local anim = animstate_ptr[0]
        if anim == nil or anim == ffi.NULL then return nil end

        local duck_amount = tonumber(anim.m_fDuckAmount) or 0
        local speed2d_norm = tonumber(anim.m_flFeetSpeedForwardsOrSideWays) or 0
        local stop_to_full = tonumber(anim.m_flStopToFullRunningFraction) or 0
        local max_yaw = tonumber(anim.m_flMaxYaw) or 0

        local yaw_modifier = ((-0.3 * stop_to_full) - 0.2) * math.max(0, math.min(speed2d_norm, 1)) + 1.0
        if duck_amount > 0 then
            yaw_modifier = yaw_modifier + (duck_amount * 0.5) * (0.5 - yaw_modifier)
        end

        local raw_delta = max_yaw * yaw_modifier
        local velocity = get_speed2d(ent) or 0
        local velocity_clamped = math.min(math.max(velocity, 0), 260)
        local move_scale = 1.0 - (velocity_clamped / 260)
        move_scale = 0.35 + (move_scale * 0.65)
        local delta = raw_delta * move_scale
        if velocity >= 250 then
            delta = math.min(delta, 28)
        end
        local flags = nil
        if ok_bit and entity and entity.get_prop then
            flags = entity.get_prop(ent, "m_fFlags") or 0
        end
        local on_ground = true
        if flags then on_ground = bit.band(flags, 1) == 1 end
        if not on_ground then delta = delta * 0.55 end
        if duck_amount > 0.9 then delta = delta * 0.9 end
        delta = math.max(0, math.min(delta, 60))
        return delta
    end)
    if ok_read then return result end
    return nil
end

local function safe_unset(ent)
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", false)
            plist.set(ent, "Force body yaw value", 0)
        end
    end)
end

local function now_time()
    local ok, t = pcall(function() return (globals and globals.curtime and globals.curtime()) or os.time() end)
    return ok and t or os.time()
end

local function normalize_angle(angle)
    if not angle or type(angle) ~= "number" then return 0 end
    while angle > 180 do angle = angle - 360 end
    while angle < -180 do angle = angle + 360 end
    return angle
end

local function round(n)
    return math.floor((n or 0) + 0.5)
end

function M.run(ent, features, state, label)
    
    state.count = (state.count or 0) + 1
    state.last_seen = now_time()
    if state.last_label and state.last_label ~= label then state.count = 1 end
    state.last_label = label

    
    if not label or label ~= "STATIC" then return end

    
    local required_count = 3
    if state.count < required_count then return end

    
    if features and features.shot_age and tonumber(features.shot_age) and features.shot_age <= 0.25 then
        return
    end

    
    local avg_speed = tonumber((features and features.avg_speed) or 0) or 0
    if features and features.movement and features.movement == true then return end
    if avg_speed >= 1.2 then return end

    
    local max_mag_low = 58
    local max_mag_high = 28
    local speed_cap = 250
    local t = math.min(math.max(avg_speed / speed_cap, 0), 1)
    local max_mag = max_mag_low + (max_mag_high - max_mag_low) * t

    
    local ok_est, est = pcall(function() return estimate_max_desync_ent(ent) end)
    if ok_est and est and type(est) == "number" then
        max_mag = math.min(max_mag, est)
    end

    
    local on_ground = true
    pcall(function()
        if ok_bit and entity and entity.get_prop then
            local flags = entity.get_prop(ent, "m_fFlags") or 0
            on_ground = bit.band(flags, 1) == 1
        end
    end)
    if not on_ground then max_mag = max_mag * 0.55 end

    
    local forced_val = 0

    
    local last_yaw = (features and features.last_yaw)
    local ref_yaw = features and (features.goal_feet_yaw or features.feet_yaw)
    local desync = nil
    if last_yaw and ref_yaw then
        desync = normalize_angle(last_yaw - ref_yaw)
    end

    
    if not desync then
        forced_val = 0
    else
        local absd = math.abs(desync)
        
        if absd <= 10 then
            forced_val = 0
        else
            
            if ok_est and est and type(est) == "number" and est >= 8 then
                local mag = math.min(math.floor(max_mag + 0.5), math.floor(est + 0.5))
                local desired = math.min(absd, mag)
                
                if desired >= 8 then
                    forced_val = (desync >= 0) and desired or -desired
                else
                    forced_val = 0
                end
            else
                
                forced_val = 0
            end
        end
    end

    
    forced_val = round(forced_val)
    if forced_val > 60 then forced_val = 60 end
    if forced_val < -60 then forced_val = -60 end

    
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", true)
            plist.set(ent, "Force body yaw value", forced_val)
            state.forced = true
            state.forced_value = forced_val
            state.cooldown = now_time() + 0.5

            if client and type(client.delay_call) == "function" then
                client.delay_call(0.6, function()
                    pcall(function()
                        local t = now_time()
                        if not state.cooldown or t > state.cooldown then
                            safe_unset(ent)
                            state.forced = nil
                            state.forced_value = nil
                        end
                    end)
                end)
            end
        end
    end)
end

return M
]=]
r662["require/features/misc/roll"] = [[local r190, r191= pcall(require, "require/abc/menu_setup")

local r192= {}
local r193= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local r194= {ui.reference(item[1], item[2], item[3])}
    r192[i] = r194
    for _, ref in ipairs(r194) do
        r193[ref] = true
    end
end

local function r195(r196)

    local r197= 0
    if r191 and r191.ui and r191.ui.fakelag_settings_roll then
        r197 = ui.get(r191.ui.fakelag_settings_roll) or 0
    end
    local r198= ui.get(r191.ui.fakelag_settings_side) or 1
    local r199= entity.get_local_player()
    local r200= r199 and entity.get_prop(r199, 'm_vecVelocity') or 0

    if r200 > 3 then
        ui.set(r192[1][1], 0)
        return
    end

    if r198 == 3 then
        ui.set(r192[1][1], -r197)
    elseif r198 == 2 then
        local r201= (globals.tickcount() % 20) < 10
        ui.set(r192[1][1], r201 and r197 or -r197)
    elseif r198 == 1 then
        ui.set(r192[1][1], r197)
    end

end

client.set_event_callback('setup_command', function(r196)

    r195(r196)

end)]]
r662["require/features/misc/spin_on_dead_enemies"] = [[local r193= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local r194= {ui.reference(item[1], item[2], item[3])}
    r193[i] = r194
end

local r195, r196, r197, r198= entity, globals, ui, client
local r199= require("require/abc/menu_setup")
local r200= (r198.random_int(1, 2) == 1) and 1 or -1

local function r201()
    local r202= {
        {2, 'Off'}, {3, 'Local view'}, {4, {'Spin', 45}}, {5, {'Off', 0}}, {6, {'Off', 0}},
    }
    local r200= (r198.random_int(1, 2) == 1) and 1 or -1
    for _, v in ipairs(r202) do
        local r203, r204= v[1], v[2]
        local r194= r193[r203]
        if not r194 then goto continue end
        if type(r204) ~= 'table' then
            pcall(r197.set, r194[1], r204)
        else
            if r194[1] then pcall(r197.set, r194[1], r204[1]) end
            if r194[2] then
                if type(r204[2]) == 'number' and r204[1] == 'Spin' then
                    pcall(r197.set, r194[2], r204[2] * r200)
                else
                    pcall(r197.set, r194[2], r204[2])
                end
            end
        end
        ::continue::
    end
end

local function r205()
    local r206= (r196.maxplayers and r196.maxplayers() or 64)
    local r207, r208, r209= r195.get_classname, r195.is_enemy, r195.is_alive
    if not (r207 and r208 and r209) then return 0 end
    local r210= 0
    for i=1,r206 do
        if r207(i) == 'CCSPlayer' and r208(i) and r209(i) then r210 = r210 + 1 end
    end
    return r210
end

local function r211()
    if not r197.get(r199.ui.misc_spindead) then return end
    if r205() == 0 then r201() end
end

local r212, r213= pcall(require, "require/abc/callbacks")
if r212 and r213 then
    r213.callback('run_command', r211, { alive_only = true, require_login = true })
end
]]
r662["require/features/misc/walkbot"] = [[local r196= require("require/abc/callbacks")
local r197= require("require/abc/menu_setup")

local r198= nil
local r199= 1
local r200= 0
local r201= 40
local r202= 30
local r203= 450
local r204= 200
local r205= 8
local r206= {150, 300}
local r207= nil
local r208= nil
local r209= nil
local r210= 0
local r211= 700
local r212= 3

local r213= {}
local r214= 3
local r215= 4
local r216= 0
local r217= nil
local r218= 0
local r219= 500
local r220= 1500
local r221= 30
local r222= {}
local r223= false

local r224= 500 
local r225= 0

local r226= {
    { name = "A", x = -445.0, y = -1997.7, z = -180.0 },
    { name = "B", x = -2032.4, y = 259.8, z = -160.0 },
    { name = "Mid", x = -350.3, y = -617.1, z = -269.2 },
}

local function r227(r228)
    if not r228 then return false end
    local r229, r230= pcall(ui.get, r228)
    if not r229 then return false end
    return r230
end

local function r231(r232)
    while r232 > 180 do r232 = r232 - 360 end
    while r232 < -180 do r232 = r232 + 360 end
    return r232
end

local function r233(r234,r235,r236,r237,r238,r239)
    local r240, r241, r242= r234-r237, r235-r238, r236-r239
    return math.sqrt(r240*r240 + r241*r241 + r242*r242)
end

local function r243(r244,r245,r246,r247,r248,r249,r250)
    local r229, r251, r252= pcall(function()
        return client.trace_line(r244, r245, r246, r247, r248, r249, r250)
    end)
    if not r229 then return nil end
    return r251, r252
end

local function r253(r244,r254,r255,r256)
    local r257= r256 + 1000
    local r258= r256 - 1000
    local r251= r243(r244, r254, r255, r257, r254, r255, r258)
    if not r251 then return r256 end
    if type(r251) ~= 'number' then return r256 end
    local r259= r257 + (r258 - r257) * r251
    return r259
end

local function r260(r244,r245,r246,r247,r248,r249,r250)
    local r251= r243(r244, r245, r246, r247, r248, r249, r250)
    if not r251 then return false end
    if r251 >= 1 then return true end
    return false
end

local function r261(r254,r255)
    return tostring(math.floor(r254/50))..":"..tostring(math.floor(r255/50))
end

local function r262(r254,r255)
    local r263= r261(r254, r255)
    r213[r263] = (r213[r263] or 0) + 1
    if r213[r263] >= r214 then
        r222[r263] = true
    end
    return r213[r263]
end

local function r264(r254,r255)
    local r263= r261(r254, r255)
    r213[r263] = nil
end

local function r265(r244)
    local r266, r267, r268= entity.get_origin(r244)
    if not r266 then return nil end
    for i=1,r202 do
        local r269= math.random()*math.pi*2
        local r270= 200 + math.random()*800
        local r248= r266 + math.cos(r269)*r270
        local r249= r267 + math.sin(r269)*r270
        local r250= r268
            local r251= r243(r244, r266, r267, r268 + 16, r248, r249, r250 + 16)
        if r251 and r251 >= 1 then
            local r271= r253(r244, r248, r249, r250)
            return { x = r248, y = r249, z = r271 }
        end
        if r251 and r251 < 1 then
            local r272= r266 + (r248-r266)*r251
            local r273= r267 + (r249-r267)*r251
            local r274= r268 + (r250-r268)*r251
            for _, r in ipairs(r206) do
                for s=0,r205-1 do
                    local r232= (s/r205) * math.pi * 2
                    local r275= r272 + math.cos(r232)*r
                    local r276= r273 + math.sin(r232)*r
                    local r277= r253(r244, r275, r276, r274)
                    local r278= r243(r244, r266, r267, r268+16, r275, r276, r277+16)
                    local r279= r243(r244, r275, r276, r277+16, r248, r249, r250+16)
                    if r278 and r278>=1 and r279 and r279>=1 then
                        local r271= r253(r244, r248, r249, r250)
                        return { x = r248, y = r249, z = r271 }
                    end
                end
            end
        end
    end
    return nil
end

local function r280(r281)
    local r282= {}
    while r281 do
        r282[#r282+1] = { x = r281.x, y = r281.y, z = r281.z }
        r281 = r281.parent
    end
    local r283= {}
    for i=#r282,1,-1 do r283[#r283+1] = r282[i] end
    return r283
end

local function r284(r244,r285)
    local r266, r267, r268= entity.get_origin(r244)
    if not r266 then return nil end
    local r286= { x = r266, y = r267, z = r268 }
    r286.z = r253(r244, r286.x, r286.y, r286.z)
    local r287= { { x = r286.x, y = r286.y, z = r286.z, parent = nil } }
    local r288= {}
    local function r289(r290)
        local r291= tostring(math.floor(r290.x/50))..":"..tostring(math.floor(r290.y/50))
        r288[r291] = true
    end
    local function r292(r290)
        local r291= tostring(math.floor(r290.x/50))..":"..tostring(math.floor(r290.y/50))
        if r222[r291] then return true end
        return r288[r291]
    end
    r289(r286)
    local r293= 0
    while #r287 > 0 and r293 < r204 do
        local r294= table.remove(r287, 1)
        r293 = r293 + 1
        local r251= r243(r244, r294.x, r294.y, r294.z+16, r285.x, r285.y, r285.z+16)
        if r251 and r251 >= 1 then
            local r295= r280(r294)
            r295[#r295+1] = { x = r285.x, y = r285.y, z = r285.z }
            return r295
        end
        if r251 and r251 < 1 then
            local r272= r294.x + (r285.x-r294.x)*r251
            local r273= r294.y + (r285.y-r294.y)*r251
            local r274= r294.z + (r285.z-r294.z)*r251
            for _, r in ipairs(r206) do
                for s=0,r205-1 do
                    local r232= (s/r205) * math.pi * 2
                    local r275= r272 + math.cos(r232)*r
                    local r276= r273 + math.sin(r232)*r
                    local r277= r253(r244, r275, r276, r274)
                    if not r292({x=r275,y=r276}) then
                        local r278= r243(r244, r294.x, r294.y, r294.z+16, r275, r276, r277+16)
                        if r278 and r278 >= 1 then
                            r289({x=r275,y=r276})
                            table.insert(r287, { x = r275, y = r276, z = r277, parent = r294 })
                        end
                    end
                end
            end
        end
    end
    return nil
end

local function r296(r297,r244,r248,r249,r250)
    local r266, r267, r268= entity.get_origin(r244)
    if not r266 then return end
    
    local r240, r241= r248 - r266, r249 - r267
    local r298= math.sqrt(r240*r240 + r241*r241)
    if r298 <= 0 then return end
    local r299, r300= r240 / r298, r241 / r298
    local r301= 64
    local r245= r266 + r299 * r301
    local r246= r267 + r300 * r301
    local r247= r268

    
    local r302, r303= client.camera_angles()
    local r269= math.deg(math.atan2(r241, r240))
    local r304= r231(r269 - r303)
    local r305= math.rad(r304)
    local r306= math.cos(r305) * r203
    local r307= -math.sin(r305) * r203

    
    local r308, r309, r310= client.eye_position()
    if not r308 then r308, r309, ez = r266, r267, r268 end
    if type(r308) == 'table' then r308, r309, ez = r308[1], r308[2], r308[3] end
    local r311= r266 + r299 * 24
    local r312= r267 + r300 * 24
    local r313= r268 + 16
    local r314= r243(r244, r308, r309, r310, r311, r312, r313)
    if r314 and r314 < 1 then
        
        if r223 then pcall(client.log, "move_towards: short forward blocked, sidestep") end
        pcall(function() r297.forwardmove = 0; r297.sidemove = -r203 end)
        local r315= r266 - r300 * r301
        local r316= r267 + r299 * r301
        local r317= r243(r244, r266, r267, r268 + 16, r315, r316, r247 + 16)
        if r317 and r317 >= 1 then return end
        pcall(function() r297.forwardmove = 0; r297.sidemove = r203 end)
        local r318= r266 + r300 * r301
        local r319= r267 - r299 * r301
        local r320= r243(r244, r266, r267, r268 + 16, r318, r319, r247 + 16)
        if r320 and r320 >= 1 then return end
        
        pcall(function() r262(r248, r249); r200 = client.timestamp() + 250 end)
        r198 = nil
        return
    end

    
    pcall(function()
        r297.forwardmove = r306
        r297.sidemove = r307
    end)

    if r223 then pcall(client.log, string.format("move_towards: fwd=%.1f side=%.1f yaw_diff=%.1f", r306, r307, r304)) end

    local r251= r243(r244, r266, r267, r268 + 16, r245, r246, r247 + 16)
    if r251 and r251 < 1 then
        
        if r223 then pcall(client.log, "move_towards: forward blocked, attempting sidestep") end
        
        pcall(function() r297.forwardmove = 0; r297.sidemove = -r203 end)
        local r315= r266 - r300 * r301
        local r316= r267 + r299 * r301
        local r317= r243(r244, r266, r267, r268 + 16, r315, r316, r247 + 16)
        if r317 and r317 >= 1 then return end
        
        pcall(function() r297.forwardmove = 0; r297.sidemove = r203 end)
        local r318= r266 + r300 * r301
        local r319= r267 - r299 * r301
        local r320= r243(r244, r266, r267, r268 + 16, r318, r319, r247 + 16)
        if r320 and r320 >= 1 then return end
        
        pcall(function()
            r262(r248, r249)
            r200 = client.timestamp() + 250
        end)
        r198 = nil
        return
    end
end

r196.register("setup_command", function(r297)
    local r229, r321= pcall(function()
        if not r227(r197.ui.misc_walkbot) then return end
        local r244= entity.get_local_player()
        if not r244 or not entity.is_alive(r244) then return end
        local r322= client.timestamp()
        if r322 < r200 then return end

        
        do
            local r323= client.timestamp()
            if r323 - r225 >= r224 then
                local r324, r325, r326= entity.get_origin(r244)
                if r324 then
                    pcall(function()
                        client.log(string.format("walkbot_coord: %.1f %.1f %.1f", r324, r325, r326))
                    end)
                    r225 = r323
                end
            end
        end
        if client.key_state(87) or client.key_state(65) or client.key_state(83) or client.key_state(68) or client.key_state(32) or client.key_state(16) or client.key_state(17) then
            r200 = r322 + 500
            return
        end
        
        do
            local r327= entity.get_players(true) or {}
            for i=1,#r327 do
                local r328= r327[i]
                local r324, r325, r326= entity.get_origin(r328)
                if r324 then
                    local r329= pcall(function() return client.visible(r324, r325, r326) end)
                    if r329 and client.visible(r324, r325, r326) then
                        pcall(function()
                            local r330= r297.buttons or 0
                            r297.buttons = bit.bor(r330, 4) 
                        end)
                        break
                    end
                end
            end
        end
        
        local r266, r267, r268= entity.get_origin(r244)
        if r266 then
            local r327= entity.get_players(true) or {}
            if #r327 > 0 then
                if not r207 or not entity.is_alive(r207) or entity.is_dormant(r207) then
                    
                    local r331= {}
                    for i=1,#r327 do
                        local r328= r327[i]
                        local r324, r325, r326= entity.get_origin(r328)
                        if r324 then
                            local r332= r233(r266, r267, r268, r324, r325, r326)
                            r331[#r331+1] = { ent = r328, dist = r332 }
                        end
                    end
                    table.sort(r331, function(r232,r330) return r232.dist < r330.dist end)
                    if #r331 > 0 then
                                r207 = r331[1].ent  
                        r198 = nil
                        r199 = 1
                    end
                end
            else
                r207 = nil
            end
        end

        
        if r207 and entity.is_alive(r207) and not entity.is_dormant(r207) then
            local r248, r249, r250= entity.get_origin(r207)
            if r248 then
                local r271= r253(r244, r248, r249, r250)
                r208 = { x = r248, y = r249, z = r271 }
            else
                r207 = nil
                r208 = nil
            end
        else
            r207 = nil
            r208 = nil
        end

        
        do
            local r322= client.timestamp()
            if r266 then
                if not r217 then
                    r217 = { x = r266, y = r267, z = r268 }
                    r218 = r322
                else
                    if r322 - r218 >= r219 then
                        local r333= r233(r217.x, r217.y, r217.z, r266, r267, r268)
                        if r333 >= r221 then
                            
                            r216 = 0
                            r217 = { x = r266, y = r267, z = r268 }
                            r218 = r322
                        else
                            
                            if r322 - r218 >= r220 then
                                r216 = r216 + 1
                                r198 = nil
                                r200 = r322 + 300
                                r217 = { x = r266, y = r267, z = r268 }
                                r218 = r322
                                if r216 >= r215 then
                                    
                                    r207 = nil
                                    r208 = nil
                                    r216 = 0
                                end
                            end
                        end
                    end
                end
            end
        end

        if r208 then
            local r322= client.timestamp()
            local r334= (not r198) or (r322 > r210)
            if not r209 then r334 = true end
            if r209 and r208 and r233(r209.x, r209.y, r209.z, r208.x, r208.y, r208.z) > 100 then
                r334 = true
            end
            if r334 then
                local r328= r284(r244, r208)
                if r328 then
                    r198 = r328
                    r199 = 1
                    r210 = client.timestamp() + r211
                    r209 = { x = r208.x, y = r208.y, z = r208.z }
                else
                    
                    r207 = nil
                    r208 = nil
                    r198 = nil
                end
            end
        else
            if not r198 then
                local r335= r265(r244)
                
                if not r335 and #r226 > 0 then
                    local r336= r226[ math.random(1, #r226) ]
                    if r336 then r335 = { x = r336.x, y = r336.y, z = r336.z } end
                end
                if r335 then
                    local r328= r284(r244, r335)
                    if r328 then
                        r198 = r328
                        r199 = 1
                    else
                        
                        r198 = nil
                    end
                end
            end
        end
        if not r198 then return end
        local r266, r267, r268= entity.get_origin(r244)
        if not r266 then return end
        local r337= r198[r199+1] or r198[#r198]
        if not r337 then r198 = nil return end
        local r332= r233(r266, r267, r268, r337.x, r337.y, r337.z)
        if r332 <= r201 then
            r199 = r199 + 1
            
            r264(r337.x, r337.y)
            if r199 >= #r198 then r198 = nil return end
            return
        end
        do
            local r338= false
            if r207 and r208 then
                local r248, r249, r250= r208.x, r208.y, r208.z
                local r270= r233(r266, r267, r268, r248, r249, r250)
                if r270 > 1000 then
                    
                end
            end
            if not r338 then
                r296(r297, r244, r337.x, r337.y, r337.z)
            end
        end
    end)
    if not r229 then pcall(client.error_log, "walkbot error: "..tostring(r321)) end
end)

r196.register("paint", function()
    if not r227(r197.ui.misc_walkbot) then return end
    if not r198 or #r198 == 0 then return end
    local r244= entity.get_local_player()
    if not r244 then return end
    local r266, r267, r268= entity.get_origin(r244)
    if not r266 then return end
    local r339, r340, r341= r266, r267, r268
    r341 = r253(r244, r339, r340, r341)
    local r324, r325= renderer.world_to_screen(r339, r340, r341)
    for i=r199, #r198 do
        local r283= r198[i]
        if not r283 then break end
        local r342= r253(r244, r283.x, r283.y, r283.z)
        local r245, r246= renderer.world_to_screen(r283.x, r283.y, r342)
        if r245 and r246 and r324 and r325 then
            renderer.line(r324, r325, r245, r246, 255, 180, 0, 200)
            renderer.rectangle(r245-3, r246-3, 6, 6, 255, 80, 0, 200)
        end
        r324, py = r245, r246
    end
end)

return true
]]
r662["require/features/paint/aimbot_logs"] = [[local r199= require("require/abc/menu_setup")
local r200= require("require/abc/screen_logger")


local r201= nil
pcall(function() r201 = require('require/abc/callbacks') end)
if not r201 then error("callbacks manager required: require/abc/callbacks") end
local r202= {}
local r203= {}

local function r204()
	local r205= r199.ui.paint_aimbot_logs
	if not r205 then return false end
	local r206= ui.get(r205)
	if type(r206) == "string" then
		return r206 ~= "off"
	end
	return false
end

local function r207()
	local r205= r199.ui.paint_aimbot_logs
	if not r205 then return "gamesense" end
	local r206= ui.get(r205)
	if type(r206) == "table" then
		for _, v in ipairs(r206) do
			if v == "gamesense beta" then return "gamesense beta" end
			if v == "sodium" then return "sodium" end
			if v == "gamesense" then return "gamesense" end
		end
	elseif type(r206) == "string" then
		return r206
	end
	return "gamesense"
end

local r208= require("require/help/enemies")
local r209= require("require/abc/push_logger")
local r210= require("require/help/safe")

local r211, r212= pcall(require, "require/features/misc/collect")


local function r213(r214)
	if not r214 or r214 == 0 then return 0 end
	
	if r211 and r212 then
		local r215, r216= pcall(function()
			return r212.get_goal_feet_yaw(r214) or r212.get_feet_yaw(r214) or r212.get_lower_body_yaw(r214)
		end)
		if r215 and r216 and r216 ~= 0 then return r216 end
	end
	
	local r217, r218, r219, r220= pcall(function() return entity.get_prop(r214, "m_angAbsRotation") end)
	if r217 and r218 then
		if type(r218) == "table" then
			return r218[2] or 0
		else
			return r219 or 0
		end
	end
	
	local r221, r222= pcall(function() return entity.get_prop(r214, "m_flLowerBodyYawTarget") end)
	if r221 and r222 then return r222 end
	return 0
end


local function r223(r214)
	local r215, r224= pcall(function() return _G.player_labels end)
	if not r215 or type(r224) ~= "table" then return nil end
	local r225, r226= pcall(function() return r224[r214] end)
	if not r225 then return nil end
	return r226
end


local function r227()
	local r215, r228, r229, r230= pcall(function() return client.camera_angles() end)
	if not r215 then return nil, nil, nil end
	return r228 or 0, r229 or 0, r230 or 0
end


local function r231(r214)
	if not r214 or r214 == 0 then return nil, nil, nil end
	local r215, r232, r233, r234= pcall(function() return entity.get_prop(r214, "m_angAbsRotation") end)
	if not r215 then return nil, nil, nil end
	
	if type(r232) == "table" then
		return r232[1] or 0, r232[2] or 0, r232[3] or 0
	else
		return r232 or 0, r233 or 0, r234 or 0
	end
end

local function r235(r236)
	local r205= r199.ui.paint_logger
	if not r205 then return false end
	local r206= r210.safe_get(r205)
	if type(r206) == 'table' then
		for _, v in ipairs(r206) do
			if v == r236 then return true end
		end
		return false
	elseif type(r206) == 'string' then
		return r206 == r236
	end
	return false
end

local function r237(r238,r239,r229,r228) return string.format("\a%02x%02x%02x%02x", r238 or 255, r239 or 255, r229 or 255, r228 or 255) end
local function r240(r241,r238,r239,r229,r228)
	if not r241 or r241 == "" then return r241 end
	local r242= r237(r238,r239,r229,r228)
	local r243= r237(255,255,255,255)
	local r244= "([-+]?%d+%.?%d*%%?)"
	local r215, r245= pcall(function()
		return (r241:gsub(r244, function(r246)
			return r242 .. r246 .. r243
		end))
	end)
	if r215 and r245 then return r245 end
	return r241
end

local function r247(r241)
	if not r241 then return "" end
	return r241:gsub("([%^%$%(%)%%.%[%]%*%+%-%?])", "%%%1")
end

local function r248(r249,r250,r238,r239,r229,r228)
	if not r249 or r249 == "" then return r249 end
	if not r250 or r250 == "" then
		return r240(r249, r238,r239,r229,r228)
	end
	
	local r251, r252= r249:find(r250, 1, true)
	if not r251 then
		
		return r240(r249, r238,r239,r229,r228)
	end
	local r253= r249:sub(1, r251 - 1)
	local r254= r249:sub(r251, r252)
	local r255= r249:sub(r252 + 1)
	local r256= r240(r253, r238,r239,r229,r228)
	local r257= r240(r255, r238,r239,r229,r228)
	local r242= r237(r238,r239,r229,r228)
	local r243= r237(255,255,255,255)
	local r258= r242 .. r254 .. r243
	return (r256 or "") .. r258 .. (r257 or "")
end
local function r259(r260,r261,r262,r263)
	local r264= r260.target_name or "?"
	local r265= r260.hitgroup_name or "?"
	local r266= (r263 and r263.damage) or r260.damage or 0
	local r267= r260.damage or r266
	local r268= r266 - r267
	local r269
	if r266 == r267 then
		r269 = string.format("%d dmg", r266)
	elseif r268 < 0 then
		r269 = string.format("%d(-%d) dmg", r266, math.abs(r268))
	else
		r269 = string.format("%d(+%d) dmg", r266, r268)
	end
	local r270= (r261 == "gamesense" and r263 and r263.health) or r260.health or 0
	local r250= r263 and r263.reason or ""

	local r271= r260.backtrack_ticks or (r263 and r263.backtrack_ticks) or 0
	if r271 == 0 then
		local r272, r273= pcall(function() return globals.tickcount() end)
		if r272 and r260.tick then
			r271 = math.max(0, r273 - (r260.tick or r273))
		end
	end
	local r274= r260.backtrack or (r263 and r263.backtrack) or 0
	if r274 == 0 and r271 and r271 > 0 then
		local r275, r276= pcall(function() return globals.tickinterval() end)
		local r277= (r275 and r276) or 0
		r274 = math.floor(r271 * r277 * 1000)
	end
	if r274 == 0 and r260.time then
		local r278, r279= pcall(function() return globals.realtime() end)
		if r278 and r279 and r260.time then
			r274 = math.floor((r279 - r260.time) * 1000)
		end
	end
	local r280= r263 and r263.hitchance or r260.hitchance or "hehe"
	local r281= r260.safepoint or false
	local r282= r260.tick or 0
	local r283= r260.time or globals.realtime()
	local r284= r260.move or 0
	local r285= r260.t or 0
	local r286= (r263 and r263.boneyaw) or r213(r260.target) or 0
	local r287= (r263 and r263.resolver) or r223(r260.target) or "?"
	r287 = tostring(r287):lower()
	local r288, r289= r227()
	local r290, r291= r231(r260.target)
	local r292= r260.id or 0
	if r261 == "gamesense beta" then
		if r262 == "hit" then
			return string.format("[+] Hit %s's %s for %s (%d%%) bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				r264, r265, r269, r280, r274, r271,
				r289 or 0, r288 or 0, r291 or 0, r290 or 0, r284, r285, r286)
		else
			return string.format("[-] Missed %s's %s for %s (%d%%) due to %s bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				r264, r265, r269, r280, r250, r274, r271,
				r289 or 0, r288 or 0, r291 or 0, r290 or 0, r284, r285, r286)
		end
	elseif r261 == "gamesense" then
		if r262 == "hit" then
			return string.format("[gamesense] Hit %s's %s for %s (%d%%) (%dhp remaining)",
				r264, r265, r269, r280, r270)
		else
			return string.format("[gamesense] Missed %s's %s for %s (%d%%) reason=%s",
				r264, r265, r269, r280, r250)
		end
	elseif r261 == "sodium" then
		if r262 == "hit" then
			return string.format("hit %s's %s for %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				r264, r265, r269, r280, r274, r287, r286)
		else
			return string.format("missed %s's %s due to %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				r264, r265, r250, r280, r274, r287, r286)
		end
	else
		if r262 == "hit" then
			return string.format("a",
				r264, r265, dmg, r280, r284, r285, r286)
		else
			return string.format("b",
				r264, r265, dmg, r280, r250, r284, r285, r286)
		end
	end
end

r201.register('aim_fire', function(r293)

	if not r204() then return end
	
	r203[r293.id] = {
		id = r293.id,
		target = r293.target,
		target_name = entity.get_player_name(r293.target or 0),
		hitgroup = r293.hitgroup,
		hitgroup_name = r293.hitgroup and ({"head","chest","stomach","left arm","right arm","left leg","right leg"})[r293.hitgroup] or "?",
		damage = r293.damage,
		health = r293.health,
		backtrack = (r293.backtrack or 0) * globals.tickinterval() * 1000,
		backtrack_ticks = r293.backtrack or 0,
		hitchance = r293.hit_chance or 0,
		safepoint = r293.safepoint,
		tick = globals.tickcount(),
		time = globals.realtime(),
		move = r293.move or 0,
		t = r293.t or 0,
		boneyaw = r293.boneyaw or r213(r293.target) or 0,
	}
end, { require_login = true, alive_only = true })

r201.register('aim_hit', function(r293)

	if not r204() then return end
	local r294= r203[r293.id]
	if not r294 then return end
	local r261= r207()
	local r295= entity.get_prop(r293.target, "m_iHealth") or 0
	local r286= r294.boneyaw or r213(r294.target)
	local r296= r223(r294.target)
	local r297= r259(r294, r261, "hit", {
		damage=r293.damage,
		health=r295,
		backtrack=r294.backtrack,
		backtrack_ticks=r294.backtrack_ticks,
		boneyaw=r286,
		resolver=r296
	})
	if r261 == "gamesense beta" then
		
		client.color_log(165, 202, 42, r297)
		r200(r297, 4, 165, 202, 42, 255)
	elseif r261 == "sodium" then
		local r298= r294.damage or 0
		local r299= r293.damage or r298
		local r300= r299 - r298
		if r300 == 0 then
			client.color_log(165, 202, 42, r297)
			local r301= r240(r297, 165, 202, 42, 255)
			r200(r301, 4)
		else
			client.color_log(255, 204, 51, r297)

			local r302= string.format("(%+d)", r300)
			local r303= r247(r302)
			local r253, r254, r255= r297:match("^(.-)(" .. r303 .. ")(.*)$")
			if not r253 then
				local r301= r240(r297, 165, 202, 42, 255)
				r200(r301, 4)
			else
				local r304= r240(r253, 165, 202, 42, 255)
				local r305= r240(r255, 165, 202, 42, 255)
				local r306, r307, r308
				if r300 > 0 then
					r306, r307, db = 255, 204, 51
				else
					r306, r307, db = 217, 100, 100 
				end
				local r242= r237(r306, r307, r308, 255)
				local r243= r237(255, 255, 255, 255)
				local r309= r254:sub(2, -2) or r254
				local r310= "(" .. r242 .. r309 .. r243 .. ")"
				local r301= (r304 or "") .. r310 .. (r305 or "")
				r200(r301, 4)
			end
		end
	else
		client.log(r297)
		r200(r297, 4, 255, 255, 255, 255)
	end

	
	if r235('aimbot') then
		local r264= r294.target_name or "?"
		local r311= r294.hitgroup_name or "?"
		local r312= r293.damage or 0
		local r313= r294.hitchance or 0
		local r314= string.format("Hit %s's %s for %d(%d%%)", r264, r311, r312, r313)
		r209(r314, 4, 255, 255, 255, 255)
	end

	r203[r293.id] = nil
end, { require_login = true, alive_only = true })

r201.register('aim_miss', function(r293)

	if not r204() then return end
	local r294= r203[r293.id]
	if not r294 then return end
	local r261= r207()
	local r286= r294.boneyaw or r213(r294.target)
	local r296= r223(r294.target)
	local r297= r259(r294, r261, "miss", {reason=r293.reason or "?", boneyaw=r286, resolver=r296})
		if r261 == "gamesense beta" then
			client.color_log(217, 100, 100, r297)
			r200(r297, 4, 217, 100, 100, 255)
		elseif r261 == "sodium" then
			
			local r315= r293.reason or "?"
			local r301= r248(r297, r315, 217, 100, 100, 255)
			r200(r301, 4)
			client.color_log(217, 100, 100, r297)
		else
			r200(r297, 4, 255, 255, 255, 255)
			client.log(r297)
		end

	if r235('aimbot') then
		local r264= r294.target_name or "?"
		local r311= r294.hitgroup_name or "?"
		local r312= r294.damage or 0
		local r313= r294.hitchance or 0
		local r250= r293.reason or "?"
		local r314= string.format("Missed %s's %s for %d(%d%%) due to %s", r264, r311, r312, r313, r250)
		r209(r314, 4, 255, 255, 255, 255)
	end

	r203[r293.id] = nil
end, { require_login = true, alive_only = true })]]
r662["require/features/paint/animations"] = [[


local r202= nil
pcall(function() r202 = require('require/help/safe') end)
local r203= nil
pcall(function() r203 = require('require/abc/menu_setup') end)

local r204= nil
pcall(function() r204 = require('require/abc/callbacks') end)
if not r204 then error("callbacks manager required: require/abc/callbacks") end
local r205= require("gamesense/entity") or error("You're missing a required module: gamesense/entity")


local function r206()
    local r207= entity.get_local_player()
    if not r207 then return nil, nil end
    local r208, r209= pcall(function() return r205.new(r207) end)
    if not r208 then return r207, nil end
    return r207, r209
end




local r210= {
    STRAFE_YAW = 0,
    STAND = 1,
    LEAN_YAW = 2,
    SPEED = 3,
    LADDER_YAW = 4,
    LADDER_SPEED = 5,
    JUMP_FALL = 6,
    MOVE_YAW = 7,
    MOVE_BLEND_CROUCH = 8,
    MOVE_BLEND_WALK = 9,
    MOVE_BLEND_RUN = 10,
    BODY_YAW = 11,
    BODY_PITCH = 12,
    AIM_BLEND_STAND_IDLE = 13,
    AIM_BLEND_STAND_WALK = 14,
    AIM_BLEND_STAND_RUN = 14,
    AIM_BLEND_CROUCH_IDLE = 16,
    AIM_BLEND_CROUCH_WALK = 17,
    DEATH_YAW = 18
}

local function r211(r212)
    if not r212 then return 0 end
    local r213, r214, r215= entity.get_prop(r212, 'm_vecVelocity')
    if not r213 or not r214 then
        local r216= r213
        if type(r216) == 'table' then
            r213 = r216.x or r216[1] or 0
            r214 = r216.y or r216[2] or 0
        else
            return 0
        end
    end
    return math.sqrt((r213 or 0) * (r213 or 0) + (r214 or 0) * (r214 or 0))
end

local r217= {}
local r218= {}
for i, item in ipairs({
    { 'AA', 'Other', 'Leg movement' },

}) do
    local r219= {ui.reference(item[1], item[2], item[3])}
    r217[i] = r219
    for _, ref in ipairs(r219) do
        r218[ref] = true
    end
end






local r220= require("gamesense/antiaim_funcs")


local function r221()
    local r207= entity.get_local_player()
    if not r207 then return end
    entity.set_prop(r207, "m_flPoseParameter", 1, r210.JUMP_FALL)
end

local function r222()

    if r220.get_tickbase_shifting() > 0 then
        return
    end
    
    value = 0.5
    local r207= entity.get_local_player()
    if not r207 then return end
    local r223= globals.tickcount()
    local r224= math.floor(r223 / 2) % 2
    local r225= (r224 == 0) and -0.1 or 0.9
    entity.set_prop(r207, "m_flPoseParameter", math.random(0, 10) / value, r210.SPEED)
    entity.set_prop(r207, "m_flPoseParameter", math.random(0, 10) / 10, r210.MOVE_YAW)
    entity.set_prop(r207, "m_flPoseParameter", math.random(0, 10) / 10, r210.JUMP_FALL)
end



local function r226()
    local r207, r227= r206()
    if not r207 or not r227 then return end
    local r228= r227:get_anim_state()
    local r229= r227:get_anim_overlay(12)
    entity.set_prop(r207, "m_flPoseParameter", client.random_float(0, 1), 0)
    r229.weight = client.random_float(0, 1)
    ui.set(r217[1][1], "Always slide")
end

local function r230()
    local r207, r227= r206()
    if not r207 or not r227 then return end
    local r229= r227:get_anim_overlay(12)
    r229.weight = math.random(0,10) / 10
end


local function r231()
    local r207, r227= r206()
    if not r207 or not r227 then return end
    local r228= r227:get_anim_state()
    local r229= r227:get_anim_overlay(12)
    if r229 then r229.weight = 0.999 end
end

local function r232()
    local r207, r227= r206()
    if not r207 or not r227 then return end
    local r228= r227:get_anim_state()
    if r228 and r228.hit_in_ground_animation then
        entity.set_prop(r207, "m_flPoseParameter", 0.5, r210.BODY_PITCH)
    end
end

local function r233()
    local r207, r227= r206()
    if not r207 or not r227 then return end
    local r234= r227:get_anim_overlay(6)
    entity.set_prop(r207, "m_flPoseParameter", 0, r210.MOVE_YAW)
    if r234 then r234.weight = 1 end
end

local function r235()
    local r207, r227= r206()
    if not r207 or not r227 then return end
    local r236= r227:get_anim_overlay(12)
    local r237= r227:get_anim_overlay(6)
    if r236 then r236.weight = 0 end
    if r237 then r237.weight = 1 end
end

local function r238()
    local r207= entity.get_local_player()
    if not r207 then return end
    ui.set(r217[1][1], math.random(1,2) == 1 and "Always slide" or "Never slide")
    entity.set_prop(r207, "m_flPoseParameter", 8, 0)
end


local function r239()
    local r207, r227= r206()
    if not r207 or not r227 then return end
    local r240= r227:get_anim_overlay(9)
    if r240 then
        r240.weight = 1
        r240.sequence = 224
    end
end

local function r241()
    local r207, r227= r206()
    if not r207 or not r227 then return end
    local r242= r227:get_anim_overlay(0)
    if r242 then r242.sequence = 11 end
end

local function r243()

    local r207= r206()
    if not r207 then return end
    entity.set_prop(r207, 'm_flPoseParameter', 0, r210.BODY_PITCH)
    entity.set_prop(r207, 'm_flPoseParameter', math.random(-1, 1), r210.BODY_YAW)

end




r204.register('pre_render', function()
    local r207= entity.get_local_player()
    if not r207 then return end
    local r244= r211(r207)


    local r245= nil
    if r203 and r203.ui and r203.ui.paint_animations then
        if r202 and r202.safe_get then
            r245 = r202.safe_get(r203.ui.paint_animations)
        else
            local r208, r246= pcall(function() return ui.get(r203.ui.paint_animations) end)
            if r208 then r245 = r246 end
        end
    end

    local r247= {}
    if type(r245) == 'table' then
        for _, v in ipairs(r245) do r247[v] = true end
    end

    if r247['kingaru'] and r244 > 3 then r222() end
    if r247['body lean'] and r244 > 3 then r231() end
    if r247['static legs'] and r244 > 3 then r221() end
    if r247['moonwalk'] and r244 > 3 then r233() end
    if r247['allah'] and r244 > 3 then r235() end
    if r247['no pitch on land'] and r244 > 3 then r232() end
    if r247['reversed legs'] and r244 > 3 then r238() end
    if r247['earthquake'] then r230() end
    if r247['t-pose'] then r241() end
    if r247['blind'] then r239() end
    if r247['pitch up'] then r243() end
    if r247['gamesense legs'] then r226() end
end, { require_login = true, alive_only = true })

r204.register('setup_command', function(r248)

    local r207= entity.get_local_player()
    if not r207 then return end
    local r244= r211(r207)
    if r244 < 3 then return end

    local r245= nil
    if r203 and r203.ui and r203.ui.paint_animations then
        if r202 and r202.safe_get then
            r245 = r202.safe_get(r203.ui.paint_animations)
        else
            local r208, r246= pcall(function() return ui.get(r203.ui.paint_animations) end)
            if r208 then r245 = r246 end
        end
    end

    local r247= {}
    if type(r245) == 'table' then
        for _, v in ipairs(r245) do r247[v] = true end
    end

    

end, { require_login = true, alive_only = true })]]
r662["require/features/paint/aspect_ratio"] = [[
local r205= require("require/abc/menu_setup")
local r206= require("require/help/time")
local r207= require("require/help/safe")
local r208= require("ffi")
local r209= require("require/brain/dll")
local r210= nil
pcall(function() r210 = require('require/abc/callbacks') end)

if not (r209 and r209.aspect_update) then
    error("sodiumdll aspect_update export missing")
end

local r211= r208.new("struct AspectState[1]")
local r212= r208.new("double[1]")
local r213= r208.new("int[1]")
local r214= r209.aspect_update

local function r215()
    if cvar.r_aspectratio and cvar.r_aspectratio.get_float then
        return cvar.r_aspectratio:get_float()
    end
    return nil
end

local function r216(r217)
    if cvar.r_aspectratio and cvar.r_aspectratio.set_float then
        cvar.r_aspectratio:set_float(r217)
        return true
    elseif client and client.exec then
        client.exec("r_aspectratio " .. tostring(r217))
        return true
    end
    return false
end

r210.register('paint', function()
    if not ui.is_menu_open() then return end
    local r218= r205.ui.paint_aspect_ratio
    if not r218 then return end
    local r219= r207.safe_get(r218)
    if type(r219) ~= 'number' then return end
    r214(r211, r219, r215() or 0, r206.realtime(), r212, r213)
    if r213[0] ~= 0 then
        r216(r212[0])
    end
end, { require_login = true })

client.set_event_callback('shutdown', function()
    r211[0].initialized = 0
    r211[0].original = 0
    r211[0].last = 0
    r211[0].last_update = 0
end)]]
r662["require/features/paint/bomb_esp"] = [[local r208= nil
local r209= {}
local r210= nil
local r211= 500
local r212= 1000

local r213= 1.0
local r214= true
local r215= 0.25 
local r216= 0
local r217= 2

local r218= nil
pcall(function() r218 = require('require/abc/callbacks') end)
if not r218 then error("callbacks manager required: require/abc/callbacks") end

local function r219()
    r208 = nil
end

local function r220(r221)
    if not r221 then return 650, 2275 end
    local r222= tostring(r221):lower()
    if r222:find('de_dust2') then return 500, 1750 end
    if r222:find('de_ancient') then return 650, 2275 end
    if r222:find('de_anubis') then return 450, 1575 end
    if r222:find('de_inferno') then return 620, 2170 end
    if r222:find('de_mirage') then return 650, 2275 end
    if r222:find('de_nuke') then return 650, 2275 end
    if r222:find('de_overpass') then return 650, 2275 end
    if r222:find('de_vertigo') then return 500, 1750 end
    return 650, 2275
end

local function r223(r224,r225)
    r225 = tonumber(r225) or 0
    if r225 > 0 then
        local r226= 0.5
        local r227= 0.5
        local r228= r224 * r226
        local r229= (r224 - r228) * r227
        if r229 > tonumber(r225) then
            r229 = tonumber(r225) * (1.0 / r227)
            r228 = r224 - r229
        end
        r224 = r228
    end
    return r224
end

local function r230(r231,r232,r233,r234,r235,r236,r225,r237)
    if not r231 or not r232 or not r233 or not r234 or not r235 or not r236 then return 0 end
    local r238, r239= r220(r237)
    local r240= r239 / 3.0
    local r241= r231 - r234
    local r242= r232 - r235
    local r243= r233 - r236
    local r244= math.sqrt(r241*r241 + r242*r242 + r243*r243)
    local r245= math.exp( - (r244 * r244) / (2 * r240 * r240) )
    local r224= r238 * r245
    local r246= r223(r224, r225)
    return math.floor(r246 + 0.0)
end

local function r247(r248)
    if not r248 then return "?" end
    if r248 == 454 then return "A" end
    if r248 == 455 then return "B" end
    if r248 == 0 then return "A" end
    if r248 == 1 then return "B" end
    if type(r248) == "string" then
        local r249= r248:upper()
        if r249 == "A" or r249 == "B" then return r249 end
    end
    return tostring(r248)
end

r218.register('bomb_planted', function(r250)
    local r251= r250 and r250.site

    local r252= entity.get_all("CPlantedC4") or {}
    local r253= nil
    local r254= nil

    for i = 1, #r252 do
        local r248= r252[i]
        local r255= entity.get_prop(r248, "m_flC4Blow")
        if r255 and r255 > 0 then
            r253 = r255
            r254 = r248
            break
        end
    end

    if not r253 then
        local r256= 40
        if cvar and cvar.mp_c4timer then
            local r257, r258= pcall(function()
                if type(cvar.mp_c4timer.get_float) == "function" then
                    return cvar.mp_c4timer:get_float()
                elseif type(cvar.mp_c4timer.get_int) == "function" then
                    return cvar.mp_c4timer:get_int()
                else
                    return tonumber(cvar.mp_c4timer:get_string())
                end
            end)
            if r257 and r258 and tonumber(r258) then
                r256 = tonumber(r258)
            end
        end
        r253 = globals.curtime() + (r256 or 40)
    end

    r208 = {
        site = r251,
        blow_time = r253,
        entindex = r254,
        planted_at = globals.curtime()
    }
end, { require_login = true, alive_only = true })

r218.register('bomb_defused', r219, { require_login = true, alive_only = true })
r218.register('bomb_exploded', function(r250)
    
    local r259= r208 ~= nil
    local r260= globals.curtime()
    
    local r261= nil
    local r262= entity.get_local_player()
    if r259 and r262 then
        local function r263()
            
            local r264= nil
            if r208 and r208.entindex then
                local r257, r265, r266, r240= pcall(function() return entity.get_prop(r208.entindex, "m_vecOrigin") end)
                if r257 then
                    if type(r265) == "table" then
                        r264 = r265
                    elseif r265 ~= nil and r266 ~= nil and r240 ~= nil then
                        r264 = { r265, r266, r240 }
                    end
                end
            end
            if not r264 then
                local r252= entity.get_all("CPlantedC4") or {}
                for i = 1, #r252 do
                    local r248= r252[i]
                    local r257, r265, r266, r240= pcall(function() return entity.get_prop(r248, "m_vecOrigin") end)
                    if r257 then
                        if type(r265) == "table" then
                            r264 = r265
                            break
                        elseif r265 ~= nil and r266 ~= nil and r240 ~= nil then
                            r264 = { r265, r266, r240 }
                            break
                        end
                    end
                end
            end
            if not r264 then return nil end
            local r257, r267, r268, r269= pcall(function() return client.eye_position() end)
            local r231, r232, r233
            
            local r270, r271, r272, r273= pcall(function() return entity.get_origin(r262) end)
            if r270 then
                if type(r271) == "table" then
                    if #r271 >= 3 then r231, r232, pz = r271[1], r271[2], r271[3] end
                elseif r271 ~= nil and r272 ~= nil and r273 ~= nil then
                    r231, r232, pz = r271, r272, r273
                end
            end
            
            if (not r231 or not r232 or not r233) and r257 and r267 ~= nil and r268 ~= nil and r269 ~= nil then
                r231, r232, pz = r267, r268, r269
            end
            if not r231 or not r264 or #r264 < 3 then return nil end
            local r234, r235, r236= r264[1], r264[2], r264[3]
            
            local r274, r225= pcall(function() return entity.get_prop(r262, "m_ArmorValue") end)
            r225 = tonumber(r225) or 0
            local r237= nil
            local r275, r276= pcall(function()
                if type(client.mapname) == 'function' then return client.mapname() end
                if cvar and cvar.mapname then return cvar.mapname:get_string() end
                if cvar and cvar.map then return cvar.map:get_string() end
                return nil
            end)
            if r275 then r237 = r276 end
            local r277= r230(r231, r232, r233, r234, r235, r236, r225, r237)
            local r278= math.floor((r277 * (r213 or 1.0)) + 0.5)
            return r277, r278, math.sqrt((r231-r234)^2 + (r232-r235)^2 + (r233-r236)^2)
        end
        local r279, r280, r281= r263()
        r261 = r280
    end

    
    r219()

    
    if r214 and r261 and r261 > 0 then
        local r282= 0.15
        client.delay_call(r282, function()
            local r283= globals.curtime()
            if r283 - r216 < r217 then return end
            local r284= entity.get_local_player()
            if not r284 then return end
            local r257, r285= pcall(function() return entity.get_prop(r284, "m_iHealth") end)
            r285 = tonumber(r285)
            local r286= r210
            if not r286 or not r285 then return end
            local r229= r286 - r285
            if r229 <= 0 then return end

            
            local r287= (r261 and r261 > 0) and r261 or 1
            local r288= r229 / r287
            if r288 <= 0 then return end

            
            local r289= (r213 or 1.0) * (1 + (r288 - 1) * r215)
            if r289 < 0.05 then r289 = 0.05 end
            if r289 > 10 then r289 = 10 end
            local r290= r213
            r213 = r289
            r216 = globals.curtime()
            
            pcall(function()
                client.log("[bomb_esp] auto-tuned scale %.3f -> %.3f (ratio=%.3f, predicted=%d, actual=%d)", r290, r213, r288, r261 or 0, r229)
            end)
        end)
    end
end, { require_login = true, alive_only = true })
r218.register('round_start', r219, { require_login = true, alive_only = true })
r218.register('round_start', function()
    r210 = nil
end, { require_login = true, alive_only = true })
r218.register('player_spawned', function()
    r210 = nil
end, { require_login = true, alive_only = true })


r218.register('player_hurt', function(r250)
    if not r250 then return end
    local r262= entity.get_local_player()
    if not r262 then return end
    local r291= client.userid_to_entindex(r250.userid)
    if r291 ~= r262 then return end

    
    local r292= r250.dmg_health or r250.damage or r250.hp or 0
    r292 = tonumber(r292) or 0
    if r292 <= 0 then return end

    
    local r293= string.format("-%d HP", r292)
    
    table.insert(r209, { t = globals.curtime(), text = r293 })
end, { require_login = true, alive_only = true })


r218.register('paint', function()
    local r294, r295= pcall(require, "require/abc/menu_setup")
    if not r294 or not r295 or not r295.ui then return end
    local r296, r297= pcall(ui.get, r295.ui.paint_bombwarning)
    if not r296 or not r297 then return end

    local r283= globals.curtime()

    
    local r262= entity.get_local_player()
    if r262 then
        local r257, r298= pcall(function() return entity.get_prop(r262, "m_iHealth") end)
        r298 = tonumber(r298)
        if r298 then
            if r210 == nil then
                r210 = r298
            else
                if r298 < r210 then
                    local r292= r210 - r298
                    table.insert(r209, { t = r283, text = string.format("-%d HP", r292) })
                end
                r210 = r298
            end
        end
    else
        r210 = nil
    end

    
    for i = #r209, 1, -1 do
        local r299= r209[i]
        local r300= r283 - r299.t
        local r301= 1.4
        if r300 >= r301 then
            table.remove(r209, i)
        else
            local r302= math.floor(255 * (1 - (r300 / r301)))
            if r302 < 0 then r302 = 0 end
            
            renderer.indicator(255, 210, 0, r302, r299.text)
        end
    end

    
    if r208 then
        local r262= entity.get_local_player()
        local r264= nil
        if r208.entindex then
            local r257, r265, r266, r240= pcall(function() return entity.get_prop(r208.entindex, "m_vecOrigin") end)
            if r257 then
                if type(r265) == "table" then
                    r264 = r265
                elseif r265 ~= nil and r266 ~= nil and r240 ~= nil then
                    r264 = { r265, r266, r240 }
                end
            end
        end
        
        if not r264 then
            local r252= entity.get_all("CPlantedC4") or {}
            for i = 1, #r252 do
                local r248= r252[i]
                local r257, r265, r266, r240= pcall(function() return entity.get_prop(r248, "m_vecOrigin") end)
                if r257 then
                    if type(r265) == "table" then
                        r264 = r265
                        break
                    elseif r265 ~= nil and r266 ~= nil and r240 ~= nil then
                        r264 = { r265, r266, r240 }
                        break
                    end
                end
            end
        end

        if r264 and r262 then
            local r231, r232, r233= nil, nil, nil
            local r257, r267, r268, r269= pcall(function() return client.eye_position() end)
            if r257 and r267 ~= nil and r268 ~= nil and r269 ~= nil then
                r231, r232, pz = r267, r268, r269
            else
                local r270, r271, r272, r273= pcall(function() return entity.get_origin(r262) end)
                if r270 then
                    if type(r271) == "table" then
                        if #r271 >= 3 then r231, r232, pz = r271[1], r271[2], r271[3] end
                    elseif r271 ~= nil and r272 ~= nil and r273 ~= nil then
                        r231, r232, pz = r271, r272, r273
                    end
                end
            end

            if r231 and r264 and #r264 >= 3 then
                local r234, r235, r236= r264[1], r264[2], r264[3]
                
                local r274, r225= pcall(function() return entity.get_prop(r262, "m_ArmorValue") end)
                r225 = tonumber(r225) or 0
                local r275, r276= pcall(function()
                    if type(client.mapname) == 'function' then return client.mapname() end
                    if cvar and cvar.mapname then return cvar.mapname:get_string() end
                    if cvar and cvar.map then return cvar.map:get_string() end
                    return nil
                end)
                local r237= r275 and r276 or nil
                local r279= r230(r231, r232, r233, r234, r235, r236, r225, r237)
                local r303= math.floor((r279 * (r213 or 1.0)) + 0.5)

                
                renderer.indicator(255, 210, 0, 255, string.format("-%d HP", r303))
            end
        end
    end

    
    if r208 then
        
        if r208.entindex then
            local r255= entity.get_prop(r208.entindex, "m_flC4Blow")
            if r255 and r255 > 0 then
                r208.blow_time = r255
            end
        end

        local r304= (r208.blow_time or 0) - r283
        if r304 <= 0 then
            r208 = nil
            return
        end

        local r305= r247(r208.site)
        local r293= string.format("%s - %.1fs", r305, r304)
        renderer.indicator(255, 255, 255, 255, r293)
    end
end, { require_login = true, alive_only = true })]]
r662["require/features/paint/bullet_tracer"] = [[local r211= require("ffi")
local r212= require('require/help/time')
local r213= nil
local r214= require('require/help/self')
pcall(function() r213 = require('require/help/safe') end)
pcall(function() DLL = require('require/brain/dll') end)
pcall(function() menu_setup = require('require/abc/menu_setup') end)
pcall(function() cb = require('require/abc/callbacks') end)

local r215= 10
local r216= 7.0
local r217= {255,255,255,255}
local r218= 0.05
local r219= 8192

if not (DLL and DLL.tracer_reset and DLL.tracer_push_shot and DLL.tracer_set_impact and DLL.tracer_collect) then return end
DLL.tracer_reset()

local r220= 7
local r221= r211.new("double[?]", r215 * r220)

local r222= r212.realtime

cb.register('weapon_fire', function(r223)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if r214.index() ~= client.userid_to_entindex(r223.userid) then return end
    local r224= r214.weapon()
    if r224 then
        local r225= entity.get_classname(r224) or ""
        local r226= r225:lower()
        if r226:find("knife") or r226:find("grenade") or r226:find("decoy") or r226:find("molotov") or r226:find("flash") or r226:find("smoke") or r226:find("taser") or r226:find("zeus") then
            return
        end
    end

    local r227,r228,r229= client.eye_position()
    if not r227 then r227,r228,sz = entity.get_origin(r214.index()) end
    r227,r228,sz = tonumber(r227) or 0, tonumber(r228) or 0, tonumber(r229) or 0
    DLL.tracer_push_shot(r227, r228, r229, r222())
end, { require_login = true, alive_only = true })
 
cb.register('bullet_impact', function(r223)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if r214.index() ~= client.userid_to_entindex(r223.userid) then return end
    local r230,r231,r232= tonumber(r223.x) or 0, tonumber(r223.y) or 0, tonumber(r223.z) or 0
    DLL.tracer_set_impact(r230, r231, r232, r222())
end, { require_login = true, alive_only = true })

if not cb then error("callbacks manager required: require/abc/callbacks") end

cb.register('paint', function()
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    local r233= r222()
    local r234= { client.camera_angles() }
    local r235= DLL.tracer_collect(r233, r216, r218, r234[1] or 0, r234[2] or 0, r219, r217[4] or 255, r221, r215)
    for i=0, (r235 or 0)-1 do
        local r236= i * r220
        local r227, r228, r229= r221[r236], r221[r236 + 1], r221[r236 + 2]
        local r237, r238, r239= r221[r236 + 3], r221[r236 + 4], r221[r236 + 5]
        local r240= r221[r236 + 6]
        local r241,r242= renderer.world_to_screen(r227, r228, r229)
        local r243,r244= renderer.world_to_screen(r237, r238, r239)
        if r241 and r243 then
            renderer.line(r241, r242, r243, r244, r217[1], r217[2], r217[3], r240)
        end
    end
end, { require_login = true, alive_only = true })]]
r662["require/features/paint/clantag"] = [[local r214=require("require/abc/menu_setup")
local r215=require("require/help/safe")
local r216=require("require/help/string")
local r217=require("require/help/time")
local r218=require("require/brain/dll")
local r219=require("ffi")
local r220=pcall
local r221=ui.reference
local r222=ui.set
local r223=client.set_clan_tag
local r224, r225= pcall(require, "require/abc/callbacks")
if not r224 or not r225 then error("require/abc/callbacks is required by clantag.lua") end
if not r218 or type(r218) ~= "table" or not r218.clantag_anim then return end

local r226=64
local r227=r219.new("char[?]",r226)
local r228,r229,r230=nil,0,nil
local function r231(r232)
    local r233={{"MISC","Misc","Clantag spammer"},{"MISC","Miscellaneous","Clantag spammer"},{"MISC","Misc","Clan tag spammer"},{"MISC","Miscellaneous","Clan tag spammer"},{"MISC","Misc","Clantag spamer"},{"MISC","Miscellaneous","Clantag spamer"}}
    for _,v in ipairs(r233) do
        local r234,r235=r220(r221,v[1],v[2],v[3])
        if r234 and r235 and r220(r222,r235,r232) then return true end
    end
    return false
end
local r236=function() return r231(true) end
local r237=function() return r231(false) end
r225.register('paint', function()
    local r235=r214.ui.paint_clantag if not r235 then return end
    local r238=r215.safe_get(r235) if type(r238)~='string' then return end
    local r239=r216.lower(r238) if r239==r228 and r239~='sodium' and r229==0 then return end
    if r239=='off' then r237(); r229=3; r220(r223," ")
    elseif r239=='gamesense' then if not r236() then r220(r223,"gamesense") end
    elseif r239 == 'sodium' then
        r237()

        if not r230 or type(r230) ~= 'table' or not r230.start then
            r230 = { start = r217.realtime() }
        end

        local r240= r217.realtime() or 0
        r219.fill(r227, r226, 0)
        local r241= r218.clantag_anim(r230.start or 0, r240, r227, r226)
        if r241 and r241 ~= 0 then
            r220(r223, r219.string(r227))
        else
            r220(r223, "")
        end
    end
    if r229>0 then r220(r223,"") r229=r229-1 end
    r228=r239
end, { require_login = true })]]
r662["require/features/paint/custom_scope"] = [[]]
r662["require/features/paint/damage"] = [[local r220= require("require/abc/menu_setup")
local r221= require("require/brain/api/vector/vector")
local r222= { shots = {}, last = 0 }


local r223= 5
local r224= 3
local r225= 10

local function r226()
	local r227= 0
	for i = 1, #r222.shots do
		local r228= r222.shots[i]
		if r228 and r228.impacts then r227 = r227 + #r228.impacts end
	end
	return r227
end

local function r229()
	while r226() > r225 do
		
		if #r222.shots == 0 then break end
		local r230= false
		for si = 1, #r222.shots do
			local r228= r222.shots[si]
			if r228 and r228.impacts and #r228.impacts > 0 then
				table.remove(r228.impacts, 1)
				r230 = true
				
				if #r228.impacts == 0 then
					table.remove(r222.shots, si)
				end
				break
			else
				
				table.remove(r222.shots, si)
				r230 = true
				break
			end
		end
		if not r230 then break end
	end
end

local function r231()
	local r232= r220.ui.paint_hitmarker
	if not r232 then return false end
	local r233= ui.get(r232)
	if type(r233) == "table" then
		for _, v in ipairs(r233) do
			if v == "damage" then return true end
		end
	end
	return false
end

local r234, r235= pcall(require, "require/abc/callbacks")
local function r236(r237)
	if not r231() then r222 = { shots = {}, last = 0 } return end
	if not r231() then return end
	local r238= entity.get_local_player()
	if not r238 then return end
	local r239= r237.target or r237.target_index
	if type(r239) ~= 'number' or r239 == 0 or not entity.is_enemy(r239) then return end
	local r240= r237.damage or 0
	local r241= r237.hitgroup == 1
	local r242= r237.health == 0
	local r243, r244, r245= entity.hitbox_position(r239, r237.hitgroup or 'head')
	if not r243 then r243, r244, z = entity.get_origin(r239) end
	if not r243 then return end
	local r246= r221.make(r243, r244, r245)
	local r247= globals.realtime()
	local r248= {255, 255, 255}
	if r242 then r248 = {217, 100, 100} elseif r241 then r248 = {165, 202, 42} end

	local r249
	if r222.last and r247 - r222.last < 0.05 then
		r249 = r222.shots[#r222.shots]
	else
		r222.last = r247
		r249 = { impacts = {}, finished = false, t = r247 }
		r222.shots[#r222.shots + 1] = r249
		if #r222.shots > 12 then table.remove(r222.shots, 1) end
	end

	if r249 then
		r249.impacts[#r249.impacts + 1] = { dmg = r240, x = r243, y = r244, z = r245, pos = r246, t = r247, color = r248 }
		if #r249.impacts > r224 then table.remove(r249.impacts, 1) end
		
		r229()
	end
end

local function r250(r237)
	if r231() then
		local r247= globals.realtime()
		local r251= 1.4
		local r252= 32
		local r253= 1
		while r253 <= #r222.shots do
			if r247 - (r222.shots[r253].t or 0) > (r251 + 0.5) then
				table.remove(r222.shots, r253)
			else
				r253 = r253 + 1
			end
		end
		local r254= {}
		local r255= 12
		for si = #r222.shots, 1, -1 do
			local r249= r222.shots[si]
			for ii = #r249.impacts, 1, -1 do
				table.insert(r254, r249.impacts[ii])
				if #r254 >= r255 then break end
			end
			if #r254 >= r255 then break end
		end

		local r256= math.min(4, #r254)
		for j = 1, r256 do
			local r257= r254[j]
			local r258, r259= renderer.world_to_screen(r257.pos.x, r257.pos.y, r257.pos.z)
			if r258 and r259 then
				local r260= r247 - (r257.t or 0)
				local r261= math.min(1, r260 / r251)
				local r262= r252 * (1 - math.exp(-3 * r261))
				local r263= math.floor(math.max(0, (1 - r261) * 255))
				if r263 > 0 then
					renderer.text(r258, r259 - r262, r257.color[1], r257.color[2], r257.color[3], r263, "crdb-", 0, tostring(r257.dmg))
				end
			end
		end
	else
		r222 = { shots = {}, last = 0 }
	end
end

r235.callback('aim_hit', r236, { alive_only = true, require_login = true })
r235.callback('paint', r250, { alive_only = true, require_login = true })]]
r662["require/features/paint/damage_penetration"] = [[
local function r223(r224,r225)
	if r225 and rawget(_G, r225) ~= nil then
		return rawget(_G, r225)
	end
	local r226, r227= pcall(require, r224)
	if r226 then return r227 end
	return nil
end

local r228= r223('ui', 'ui')
local r229= r223('client', 'client')
local r230= r223('entity', 'entity')
local r231= r223('renderer', 'renderer')

if not r228 or not r229 or not r230 or not r231 then
	return
end

local r232= r228.new_checkbox
local r233= r228.get
local r234= r228.reference

local r235= r229.screen_size
local r236= r229.set_event_callback
local r237= r229.unset_event_callback
local r238= r229.eye_position
local r239= r229.camera_angles
local r240= r229.trace_line
local r241= r229.trace_bullet

local r242= r230.get_local_player
local r243= r230.is_alive or function() return false end
local r244= r230.get_player_weapon or function() return nil end
local r245= r230.get_classname or function() return nil end

local r246= r231.text

local r247= math.floor
local r248= math.cos
local r249= math.sin
local r250= math.rad

sodium_SUPPRESS = sodium_SUPPRESS or false
sodium_REFS = sodium_REFS or {}
sodium_FN = sodium_FN or {}

local function r251(r252)
	if not r252 then return false end
	local r226, r253= pcall(r233, r252)
	return r226 and r253 == true
end


if type(sodium_FN.min_dmg_active) ~= 'function' then
	sodium_FN.min_dmg_active = function()
		ensure_min_damage_refs()
		local r254= sodium_REFS.min_dmg_hotkey
		if r254 then
			local r226, r253= pcall(r233, r254)
			if r226 then return r253 == true end
		end
		return false
	end
end

if type(sodium_FN.min_dmg_value) ~= 'function' then
	sodium_FN.min_dmg_value = function()
		ensure_min_damage_refs()
		local r255= sodium_REFS.min_dmg_slider
		if not r255 then return nil end
		local r226, r253= pcall(r233, r255)
		if r226 and type(r253) == 'number' then
			return r253
		end
		return nil
	end
end

local function r256(r257,r258)
	if sodium and sodium.ui and sodium.ui[r257] then
		return sodium.ui[r257]
	end
	local r259= 'ui_' .. r257
	if sodium_REFS[r259] then
		return sodium_REFS[r259]
	end
	if not r258 then return nil end
	local r252= r258()
	if r252 then
		sodium_REFS[r259] = r252
	end
	return r252
end


local r260= nil
pcall(function() r260 = require('require/abc/menu_setup') end)


local function r261(r262)
    if not r228.get(r260.ui.paint_show_damage_penetration) then return end
	if not r244 or not r245 then return false end
	local r263= r244(r262)
	if not r263 then return false end
	local r264= r245(r263)
	if not r264 then return false end
	if r264:sub(1, 7) ~= 'CWeapon' then return false end
	if r264:find('Grenade', 1, true) or r264:find('Taser', 1, true) or r264:find('C4', 1, true) then return false end
	return true
end

local function r265()
    if not r228.get(r260.ui.paint_show_damage_penetration) then return end
	if not r242 then return nil end
	local r266= r242()
	if not r266 then return nil end
	if r243 and not r243(r266) then return nil end
	return r266
end




local function r267()
    if not r228.get(r260.ui.paint_show_damage_penetration) then return end
	local r266= r265()
	if not r266 or not r261(r266) then return end
	local r268, r269, r270= r238()
	if not r268 or not r269 or not r270 then return end
	local r271, r272= r239()
	if not r271 or not r272 then return end
	local r273, r274= r248(r250(r271)), r249(r250(r271))
	local r275, r276= r248(r250(r272)), r249(r250(r272))
	local r277, r278, r279= r273 * r275, r273 * r276, -r274
	local r280= 8192
	local r281, r282, r283= r268 + r277 * r280, r269 + r278 * r280, r270 + r279 * r280
	local r284= select(1, r240(r266, r268, r269, r270, r281, r282, r283)) or 1
	if r284 < 0 then r284 = 0 end
	if r284 > 1 then r284 = 1 end

	local r285
	if r284 >= 0.999 then
		r285 = { 256, 512, 1024, 2048, 4096 }
	else
		local r286= r280 * r284
		r285 = { r286 + 4, r286 + 16, r286 + 32, r286 + 64, r286 + 128, r286 + 256 }
	end

	local r287= 0
	for i = 1, #r285 do
		local r288= r285[i]
		if r288 > r280 then r288 = r280 end
		local r289, r290, r291= r268 + r277 * r288, r269 + r278 * r288, r270 + r279 * r288
		local r292, r293= r241(r266, r268, r269, r270, r289, r290, r291, true)
		if r293 and r293 > r287 then r287 = r293 end
		if r288 == r280 then break end
	end

	local r294= r247((r287 or 0) + 0.5)
	if r294 <= 0 then return end

	local r295, r296= r235()
	if not r295 or not r296 then return end
	local r297= r295 / 2
	local r298= r296 / 2 + 8
	local r299= tostring(r294)
	local r300= false
	if sodium_FN.draw_surface_text_centered and _G.sodium_FONTS and _G.sodium_FONTS.pen then
		r300 = sodium_FN.draw_surface_text_centered(_G.sodium_FONTS.pen, r297, r298, r299, 177, 194, 89, 255) and true or false
	end
	if not r300 then
		r246(r297, r296 / 2 + 12, 177, 194, 89, 255, 'cb', 0, r299)
	end
end

local function r301()
    if not r228.get(r260.ui.paint_show_damage_penetration) then return end
	if sodium_SUPPRESS then return end
	r267()
end

local r302, r303= pcall(require, "require/abc/callbacks")
if r302 and r303 then
	if _G.sodium_B_MD_DP and type(_G.sodium_B_MD_DP) == 'number' then
		pcall(r303.unregister, _G.sodium_B_MD_DP)
	end

	local function r304()
		if sodium_SUPPRESS then return end
        if not r228.get(r260.ui.paint_show_damage_penetration) then return end
		r267()
	end

	_G.sodium_B_MD_DP = r303.register('paint', r304, { require_login = true, alive_only = true })
else
	if r237 and _G.sodium_B_MD_DP then
		r237('paint', _G.sodium_B_MD_DP)
	end

	_G.sodium_B_MD_DP = r301
	r236('paint', r301)
end]]
r662["require/features/paint/entidx"] = [[local r226= require("require/abc/menu_setup")
local r227= require("require/help/enemies")

local function r228()
	if not ui.get(r226.ui.paint_entidx) then return end

	local r229= r227.get_current_threat and r227.get_current_threat() or client.current_threat and client.current_threat() or nil
	if r229 and r229 ~= 0 then
		local r230= entity.get_player_name(r229)

		renderer.text(70, 120, 255, 0, 0, 255, "b", 0, string.format("entidx%d: %s", r229, r230))
	end
end

local r231, r232= pcall(require, "require/abc/callbacks")
if r231 and r232 and r232.callback then
	r232.callback("paint", r228, { alive_only = true, require_login = true })
else
	client.set_event_callback("paint", r228)
end]]
r662["require/features/paint/filter_console"] = [[


local r229= pcall(require, 'require/abc/menu_setup') and require('require/abc/menu_setup') or nil
local r230= r229 and r229.ui and r229.ui.paint_filter_console or nil

local r231= cvar.con_filter_enable
local r232= cvar.con_filter_text

local r233= { enable = nil, text = nil }

local function r234()
    if r233.enable == nil then
        
        local r235, r236= pcall(function() return r231:get_int() end)
        r233.enable = (r235 and r236) and r236 or nil
    end

    if r233.text == nil then
        local r235, r237= pcall(function() return r232:get_string() end)
        r233.text = (r235 and r237) and r237 or nil
    end
end

local function r238()
    if r233.enable ~= nil then
        pcall(function() r231:set_raw_int(r233.enable) end)
    end

    if r233.text ~= nil then
        pcall(function() r232:set_string(r233.text) end)
    else
        pcall(function() r232:set_string('') end)
    end

    r233.enable = nil
    r233.text = nil
end

local function r239()
    r234()
    pcall(function() r231:set_raw_int(1) end)
    pcall(function() r232:set_string('[gamesense]') end)
end




local function r240()
    if not r230 then
        return false
    end

    
    if type(r230) == 'table' and r230.get then
        local r235, r236= pcall(function() return r230:get() end)
        return r235 and r236 or false
    end

    
    local r235, r236= pcall(function() return ui.get(r230) end)
    return r235 and r236 or false
end

local function r241()
    if not r240() then
        r238()
        return
    end

    r239()
    client.delay_call(1, r241)
end


client.delay_call(0.1, r241)


client.set_event_callback('shutdown', r238)

return {
    
    get_ui_state = r240,
    restore_values = r238,
    apply_filter = r239,
}
]]
r662["require/features/paint/hit_miss_indicator"] = [[local r232=require("require/help/math")
local r233=require("require/help/self")
local r234=require("require/help/safe")
local r235=require("require/abc/menu_setup")

local r236,r237=0,0
local r238=function() return r235 and r235.ui and r234.safe_get(r235.ui.paint_hitmiss_indicator) end
local r239=function() r236,shots=0,0 end

client.set_event_callback("aim_fire", function(r240)
    if not r238() or not r233.is_alive() then return end
    local r241= nil
    if r240.userid then r241 = client.userid_to_entindex(r240.userid) end
    if (not r241 or r241 == 0) and r240.player then r241 = r240.player end
    if r241 == r233.index() then r237 = r237 + 1 end
end)

client.set_event_callback("aim_hit", function(r240)
    if not r238() or not r233.is_alive() then return end
    local r241= nil
    if r240.userid then r241 = client.userid_to_entindex(r240.userid) end
    if (not r241 or r241 == 0) and r240.attacker then r241 = client.userid_to_entindex(r240.attacker) end
    if (not r241 or r241 == 0) and r240.player then r241 = r240.player end
    if r241 == r233.index() then r236 = r236 + 1 end
end)


client.set_event_callback("paint",function()
    if not r238() then return end
    local r242=r237>0 and r232.round(r236/r237*100,1) or 0
    renderer.indicator(255,255,255,255,string.format("%d / %d (%.1f)",r236,r237,r242))
end)
defer(r239)]]
r662["require/features/paint/indicators_bold"] = [[local r235= { 0, 0, 0 }
local r236= { 3, 3, 3 }
local r237= { 6, 6, 6 }

local function r238(r239,r240,r241)
  return r239 + (r240 - r239) * r241
end

local r242, r243= pcall(require, "require/abc/menu_setup")
local r244, r245= pcall(require, "require/help/string")
local function r246(r247)
  if r247 == nil then return "" end
  if r244 and r245 and r245.lower then
    return r245.lower(tostring(r247))
  end
  return tostring(r247)
end
local r248, r249= pcall(require, "require/help/color")
local r250, r251= pcall(require, "require/help/math")
local r252= r248 and r249.rgba_to_hex or function(r253,r254,r240,r239) return string.format("\a%02x%02x%02x%02x", r253 or 0, r254 or 0, r240 or 0, r239 or 255) end

local function r255(r256,r257,r253,r254,r240,r239,r258)
  local r241= globals.realtime() or globals.curtime()
  if not r258 or #r258 == 0 then return "" end
  local r259= {}

  if r256 == 0 then
    local r260= r252(r253,r254,r240,r239)
    for i=1,#r258 do r259[#r259+1] = r260 .. r258:sub(i,i) end
    return table.concat(r259)
  end

  if r256 == 2 then
    local r261= (math.sin(r241 * r257) + 1) * 0.5
    local r262= math.floor(r239 * (0.45 + 0.55 * r261))
    local r260= r252(r253,r254,r240,r262)
    for i=1,#r258 do r259[#r259+1] = r260 .. r258:sub(i,i) end
    return table.concat(r259)
  end

  if r256 == 3 then
    for i=1,#r258 do
      local r263= math.sin(r241 * r257 - i * 0.6)
      local r264= math.max(0, r263)
      local r261= r264 * r264
      local r262= math.floor(r239 * (0.35 + 0.65 * r261))
      r259[#r259+1] = r252(r253,r254,r240,r262) .. r258:sub(i,i)
    end
    return table.concat(r259)
  end

  for i=1,#r258 do
    local r261= (math.sin(r241 * r257 - i * 0.35) + 1) * 0.5
    local r262= math.floor(r239 * (0.4 + 0.6 * r261))
    r259[#r259+1] = r252(r253,r254,r240,r262) .. r258:sub(i,i)
  end
  return table.concat(r259)
end
local function r265()
  if r242 and r243 and r243.ui and r243.ui.paint_indicators then
    local r266, r267= pcall(ui.get, r243.ui.paint_indicators)
    if r266 and r267 == "bold" then return true end
    return false
  end

  return true
end

local r268, r269= pcall(require, "require/abc/callbacks")
local function r270(r271)
  if not r265() then return end

  local r272, r273= client.screen_size()
  local r274, r275= r272 / 2, r273 / 2

  local r276, r277, r278= 200, 200, 255
  local r279, r280, r281= 255, 255, 255
  local r282= 18

  local r283= { 12, 12 }

  local r284= r275 + 18

  local r285= entity.get_local_player()
  local r286= false
  if r285 then
    local r287= entity.get_prop(r285, "m_bIsScoped")
    r286 = r287 == 1
  end

  local r288= "sodium"
  local r289= "beta"
  local r290= "DT"

  local r291= false
  do
    local r266, r292= pcall(require, "require/help/libs")
    if r266 and r292 and r292.get then
      local r293= r292.get("antiaim_funcs")
      if r293 and r293.get_double_tap then
        local r294, r295= pcall(r293.get_double_tap)
        if r294 and r295 then r291 = true end
      end
    end
  end

  local r296= 1
  if r242 and r243 and r243.ui and r243.ui.paint_indicators_animation then
    local r297, r298= pcall(ui.get, r243.ui.paint_indicators_animation)
    if r297 and type(r298) == 'number' then r296 = r298 end
  end
  local r299= r288 .. " " .. r289
  r299 = r246(r299)
  r288 = r246(r288)
  r289 = r246(r289)
  local r300= renderer.measure_text("b", r299) or 0
  local r301= renderer.measure_text("b", r288) or 0
  local r302= renderer.measure_text("b", r289) or 0
  local r303= renderer.measure_text("b", r290) or 0

  local r304= ""
  do
    local r266, r305= pcall(require, "require/aa/player_condition")
    if r266 and r305 and r305.get then
      local r294, r306= pcall(r305.get)
      if r294 and r306 then
        local r307= {
          legit = "Legit",
          fakelag = "Fakelag",
          walk = "Walk",
          move = "Move",
          stand = "Stand",
          ["duck"] = "Duck",
          ["duck+"] = "Duck+",
          jump = "Jump",
          ["jump+"] = "Jump+"
        }
        r304 = r307[r306] or tostring(r306)
        r304 = r246(r304)
      end
    end
  end

  r290 = r246(r290)
  local r308= renderer.measure_text("b", r304) or 0

  local r309, r310, r311, r312= 200, 200, 255, 255
  do
    local r313= false
    if r242 and r243 and r243.ui and r243.ui.paint_indicator_color then
      local r314, r239, r240, r315, r316= pcall(ui.get, r243.ui.paint_indicator_color)
      if r314 then
        r313 = true
        if type(r239) == 'number' then
          if r248 and r249 and r249.clamp then
            r309 = r249.clamp(r239 or r309)
            r310 = r249.clamp(r240 or r310)
            r311 = r249.clamp(r315 or r311)
            r312 = r249.clamp(r316 or r312)
          else
            r309 = math.floor(r239 or r309)
            r310 = math.floor(r240 or r310)
            r311 = math.floor(r315 or r311)
            r312 = math.floor(r316 or r312)
          end
        elseif type(r239) == 'string' and #r239 == 12 then
          local r266
          r266, mr = pcall(function() return tonumber(r239:sub(1,3)) end)
          r266, mg = pcall(function() return tonumber(r239:sub(4,6)) end)
          r266, mb = pcall(function() return tonumber(r239:sub(7,9)) end)
          r266, ma = pcall(function() return tonumber(r239:sub(10,12)) end)
          if r248 and r249 and r249.clamp then
            r309 = r249.clamp(r309 or 200)
            r310 = r249.clamp(r310 or 200)
            r311 = r249.clamp(r311 or 255)
            r312 = r249.clamp(r312 or 255)
          else
            r309 = r309 or 200; r310 = r310 or 200; r311 = r311 or 255; r312 = r312 or 255
          end
        end
      end
    end

    if not r313 then
      local r317, r318= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if r317 and r318 then
        local r314, r239, r240, r315, r316= pcall(ui.get, r318)
        if r314 then
          if type(r239) == 'number' then
            if r248 and r249 and r249.clamp then
              r309 = r249.clamp(r239 or r309)
              r310 = r249.clamp(r240 or r310)
              r311 = r249.clamp(r315 or r311)
              r312 = r249.clamp(r316 or r312)
            else
              r309 = math.floor(r239 or r309)
              r310 = math.floor(r240 or r310)
              r311 = math.floor(r315 or r311)
              r312 = math.floor(r316 or r312)
            end
          elseif type(r239) == 'string' and #r239 == 12 then
            local r266
            r266, mr = pcall(function() return tonumber(r239:sub(1,3)) end)
            r266, mg = pcall(function() return tonumber(r239:sub(4,6)) end)
            r266, mb = pcall(function() return tonumber(r239:sub(7,9)) end)
            r266, ma = pcall(function() return tonumber(r239:sub(10,12)) end)
            if r248 and r249 and r249.clamp then
              r309 = r249.clamp(r309 or 200)
              r310 = r249.clamp(r310 or 200)
              r311 = r249.clamp(r311 or 255)
              r312 = r249.clamp(r312 or 255)
            else
              r309 = r309 or 200; r310 = r310 or 200; r311 = r311 or 255; r312 = r312 or 255
            end
          end
        end
      end
    end
  end

  for i = 1, 3 do
    local r319= (i == 1) and r300 or ((i == 2) and r303 or r308)
    local r320= r236[i] or 0
    local r321= r286 and (r320 + (r319 / 2)) or 0
    local r257= r237[i] or 10
    local r322= globals.frametime()
    local r241= 1 - math.exp(-r257 * r322)
    r235[i] = r238(r235[i], r321, r241)
  end

  local r323= r274 - (r300 / 2)
  local r324= r323 + (r235[1] or 0)
  renderer.text(r324, r284, 255, 255, 255, 255, "b", 0, r288)
  local r325= renderer.measure_text("b", " ") or 0
  local r326= r324 + (r301 or 0) + r325
  
  local r327= r255(r296, 3.5, r309, r310, r311, r312, r289)
  renderer.text(r326, r284, r309, r310, r311, r312, "b", 0, r327)
  r284 = r284 + (r283[1] or r282)

  local r328= r274 - (r303 / 2)
  local r329= r328 + (r235[2] or 0)
  local r330, r331, r332= 255, 80, 80
  if r291 then r330, r331, dt_b = 155, 255, 155 end
  renderer.text(r329, r284, r330, r331, r332, 255, "b", 0, r290)
  r284 = r284 + (r283[2] or r282)

  local r333= r274 - (r308 / 2)
  local r334= r333 + (r235[3] or 0)
  renderer.text(r334, r284, r279, r280, r281, 255, "b", 0, r304)
end

if r268 and r269 and r269.callback then
  r269.callback("paint", r270, { alive_only = true, require_login = true })
end]]
r662["require/features/paint/indicators_small"] = [[local r238= { 0, 0 }
local r239= { 4, 0.8 }
local r240= { 5, 5 }
local r241= 0
local r242= 8

local function r243(r244,r245,r246)
  return r244 + (r245 - r244) * r246
end

local r247, r248= pcall(require, "require/abc/menu_setup")
local r249, r250= pcall(require, "require/help/string")
local r251= require('require/abc/callbacks')
local function r252(r253)
  if r253 == nil then return "" end
  if r249 and r250 and r250.upper then
    return r250.upper(tostring(r253))
  end
  return tostring(r253)
end

local r254, r255= pcall(require, "require/help/color")
local r256, r257= pcall(require, "require/help/math")
local r258= r254 and r255.rgba_to_hex or function(r259,r260,r245,r244) return string.format("\a%02x%02x%02x%02x", r259 or 0, r260 or 0, r245 or 0, r244 or 255) end

local function r261(r262,r263,r259,r260,r245,r244,r264)
  local r246= globals.realtime() or globals.curtime()
  if not r264 or #r264 == 0 then return "" end
  local r265= {}

  if r262 == 0 then
    local r266= r258(r259,r260,r245,r244)
    for i=1,#r264 do r265[#r265+1] = r266 .. r264:sub(i,i) end
    return table.concat(r265)
  end

  if r262 == 2 then
    local r267= (math.sin(r246 * r263) + 1) * 0.5
    local r268= math.floor(r244 * (0.45 + 0.55 * r267))
    local r266= r258(r259,r260,r245,r268)
    for i=1,#r264 do r265[#r265+1] = r266 .. r264:sub(i,i) end
    return table.concat(r265)
  end

  if r262 == 3 then
    for i=1,#r264 do
      local r269= math.sin(r246 * r263 - i * 0.6)
      local r270= math.max(0, r269)
      local r267= r270 * r270
      local r268= math.floor(r244 * (0.35 + 0.65 * r267))
      r265[#r265+1] = r258(r259,r260,r245,r268) .. r264:sub(i,i)
    end
    return table.concat(r265)
  end

  for i=1,#r264 do
    local r267= (math.sin(r246 * r263 - i * 0.35) + 1) * 0.5
    local r268= math.floor(r244 * (0.4 + 0.6 * r267))
    r265[#r265+1] = r258(r259,r260,r245,r268) .. r264:sub(i,i)
  end
  return table.concat(r265)
end
local function r271()
  if r247 and r248 and r248.ui and r248.ui.paint_indicators then
    local r272, r273= pcall(ui.get, r248.ui.paint_indicators)
    if r272 and r273 == "small" then return true end
    return false
  end

  return true
end



local function r274()
  if not (r247 and r248 and r248.ui) then return true end
  local r275= r248.ui.paint_indicators_bar
  if not r275 then return true end
  local r272, r273= pcall(ui.get, r275)
  if not r272 then return true end
  return not (r273 == false or r273 == nil) 
end

r251.register("paint", function()
  if not entity.is_alive(entity.get_local_player()) then return end
  if not r271() then return end

  local r276, r277= client.screen_size()
  local r278, r279= r276 / 2, r277 / 2

  local r280, r281, r282= 200, 200, 255
  local r283, r284, r285= 255, 255, 255
  local r286= 18

  local r287= { 12, 13 }

  local r288= r279 + 18

  
  local r289= entity.get_local_player()
  local r290= false
  if r289 then
    local r291= entity.get_prop(r289, "m_bIsScoped")
    r290 = r291 == 1
  end

  local r292= "sodium"
  local r293= "beta"
  local r294= "DT"

  local r295= false
  do
    local r272, r296= pcall(require, "require/help/libs")
    if r272 and r296 and r296.get then
      local r297= r296.get("antiaim_funcs")
      if r297 and r297.get_double_tap then
        local r298, r299= pcall(r297.get_double_tap)
        if r298 and r299 then r295 = true end
      end
    end
  end

  local r300= r252(r292)
  local r301= r252(r293)
  r300 = tostring(r300)
  r301 = tostring(r301)
  local r302= renderer.measure_text("b", r300) or 0
  local r303= renderer.measure_text("b", r301) or 0

  r294 = r252(r294)
  local r304= renderer.measure_text("b", r294) or 0

  for i = 1, 2 do
    local r305= (i == 1) and r302 or r304
    local r306= r239[i] or 0
    local r307= r290 and (r306 + (r305 / 2)) or 0
    local r263= r240[i] or 10
    local r308= globals.frametime()
    local r246= 1 - math.exp(-r263 * r308)
    r238[i] = r243(r238[i], r307, r246)
  end

  local r309= 4.5
  local r310= r278 - ((r302 + r309 + (r303 or 0)) / 2)
  local r311= r310 + (r238[1] or 0)
  local r312= 22
  local r313= r312 - r309
  local r314= math.floor((r313 + 1) / 2)
  local r315= r313 - r314
  local r316= r314 
  local r317= -r315 

  local r318, r319, r320, r321= r280, r281, r282, 255
  do
    local r322= false
    
    if r247 and r248 and r248.ui and r248.ui.paint_indicator_color then
      local r323, r244, r245, r324, r325= pcall(ui.get, r248.ui.paint_indicator_color)
      if r323 then
        r322 = true
        if type(r244) == 'number' then
          if r254 and r255 and r255.clamp then
            r318 = r255.clamp(r244 or r318)
            r319 = r255.clamp(r245 or r319)
            r320 = r255.clamp(r324 or r320)
            r321 = r255.clamp(r325 or r321)
          else
            r318 = math.floor(r244 or r318)
            r319 = math.floor(r245 or r319)
            r320 = math.floor(r324 or r320)
            r321 = math.floor(r325 or r321)
          end
        elseif type(r244) == 'string' and #r244 == 12 then
          local r272
          r272, mr = pcall(function() return tonumber(r244:sub(1,3)) end)
          r272, mg = pcall(function() return tonumber(r244:sub(4,6)) end)
          r272, mb = pcall(function() return tonumber(r244:sub(7,9)) end)
          r272, ma = pcall(function() return tonumber(r244:sub(10,12)) end)
          if r254 and r255 and r255.clamp then
            r318 = r255.clamp(r318 or r280)
            r319 = r255.clamp(r319 or r281)
            r320 = r255.clamp(r320 or r282)
            r321 = r255.clamp(r321 or 255)
          else
            r318 = r318 or r280; r319 = r319 or r281; r320 = r320 or r282; r321 = r321 or 255
          end
        end
      end
    end

    
    if not r322 then
      local r326, r275= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if r326 and r275 then
        local r323, r244, r245, r324, r325= pcall(ui.get, r275)
        if r323 then
          if type(r244) == 'number' then
            if r254 and r255 and r255.clamp then
              r318 = r255.clamp(r244 or r318)
              r319 = r255.clamp(r245 or r319)
              r320 = r255.clamp(r324 or r320)
              r321 = r255.clamp(r325 or r321)
            else
              r318 = math.floor(r244 or r318)
              r319 = math.floor(r245 or r319)
              r320 = math.floor(r324 or r320)
              r321 = math.floor(r325 or r321)
            end
          elseif type(r244) == 'string' and #r244 == 12 then
            local r272
            r272, mr = pcall(function() return tonumber(r244:sub(1,3)) end)
            r272, mg = pcall(function() return tonumber(r244:sub(4,6)) end)
            r272, mb = pcall(function() return tonumber(r244:sub(7,9)) end)
            r272, ma = pcall(function() return tonumber(r244:sub(10,12)) end)
            if r254 and r255 and r255.clamp then
              r318 = r255.clamp(r318 or r280)
              r319 = r255.clamp(r319 or r281)
              r320 = r255.clamp(r320 or r282)
              r321 = r255.clamp(r321 or 255)
            else
              r318 = r318 or r280; r319 = r319 or r281; r320 = r320 or r282; r321 = r321 or 255
            end
          end
        end
      end
    end
  end

  local r327= 1
  if r247 and r248 and r248.ui and r248.ui.paint_indicators_animation then
    local r328, r329= pcall(ui.get, r248.ui.paint_indicators_animation)
    if r328 and type(r329) == 'number' then r327 = r329 end
  end

  local r330= (function()
    local r266= r258(255,255,255,255)
    local r265= {}
    for i=1,#r300 do r265[#r265+1] = r266 .. r300:sub(i,i) end
    return table.concat(r265)
  end)()

  local r331= r261(r327, 3.5, r318, r319, r320, r321, r301)
  local r332= r311 + (r316 or 0)
  local r333= r290 and 3 or 0
  r332 = r332 + r333
  renderer.text(r332, r288, 255,255,255,255, "-", 0, r330)
  local r334= r311 + (r302 or 0) + r309
  local r335= r334 + (r317 or 0) + r333
  renderer.text(r335, r288, r318, r319, r320, r321, "-", 0, r331)

  local r336= false
  if r274() then
    r336 = true
    do
      local r337= (r302 or 0) + r309 + (r303 or 0)
      local r338= 16
      local r339= math.max(8, r337 - r338)
      local r340= r290 and math.floor((r238[1] or 0) * 0.35) or 0
      local r341= r311 + math.floor((r337 - r339) / 2) - 2 + r340
      local r342= 2
      local r343= r288 + math.max(2, (r287[1] or r286) - (r342 + 4)) + 5
      local r344= math.floor((r321 or 255) * 0.7)
      renderer.rectangle(r341 - 1, r343 - 1, r339 + 2, r342 + 2, r318, r319, r320, r344)
      renderer.rectangle(r341, r343, r339, r342, 0, 0, 0, 255)
      local r345= r295 and r339 or 0
      local r346= globals.frametime()
      local r347= 1 - math.exp(-r242 * r346)
      r241 = r243(r241, r345, r347)
      local r348= math.floor(math.max(0, math.min(r241, r339)))
      if r348 > 0 then
        renderer.rectangle(r341, r343, r348, r342, r318, r319, r320, r321)
      end
    end
  end

  
  local r349= (r287[1] or r286)
  local r350= r349
  if not r336 then
    
    r350 = math.max(0, r349 - 7)
  end
  r288 = r288 + r350

  local r351= r278 - (r304 / 2)
  local r352= r351 + (r238[2] or 0)
  local r353, r354, r355= 255, 80, 80
  if r295 then r353, r354, dt_b = 155, 255, 155 end
  renderer.text(r352, r288 + 2, r353, r354, r355, 255, "-", 0, r294)
  r288 = r288 + (r287[2] or r286)

end, { alive_only = true, require_login = true })]]
r662["require/features/paint/insults"] = [[local r241= client
local r242= entity
local r243= ui

local r244= require("require/abc/menu_setup")
local r245, r246= pcall(require, "require/help/string")
local r247, r248= pcall(require, "require/help/math")
local r249, r250= pcall(require, "require/help/time")

local r251= {
    "buy sodium",
    "sodium is the bestest lua",
    "SODIUMMMM >__<",
    "you just got sodiumed",
    "sodium beta > all other lues",
    "₴ØĐłɄ₥ ₮₳₴₮ɆĐ Vł₵₮ØⱤɎ, ł₮ ₩₳₴ ₴ØɄⱤ",
    "₴ØĐłɄ₥ ₳ⱤⱤ₳₦₲ɆĐ ₮ⱧɆ ₴₮₳Ɽ₴ ₣ØⱤ ₮Ⱨ₳₮ ⱧɆ₳Đ₴ⱧØ₮",
    "₴ØĐłɄ₥ ₴Ⱡł₱₱ɆĐ ł₦ ₳ ฿₳₦₳₦₳ ₱ɆɆⱠ Ø₣ ₣₳₮Ɇ",
    "₴ØĐłɄ₥ ₩Ⱨł₴₱ɆⱤɆĐ ₴Ɇ₵ⱤɆ₮₴ ł₦₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ₥₳₭Ɇ₴ ₣ⱤłɆ₦Đ₴ ₩ł₮Ⱨ Ⱡ₳₲, ₮ⱧɆ₦ ฿Ɇ₮Ɽ₳Ɏ₴ ł₮",
    "₴ØĐłɄ₥ ₣ØⱠĐɆĐ ɎØɄⱤ ₵ØɄⱤ₳₲Ɇ ł₦₮Ø ₳ ₱₳₱ɆⱤ ₱Ⱡ₳₦Ɇ",
    "₴ØĐłɄ₥ ₱₳ł₦₮₴ ł₦ ⱤɆĐ ₩ⱧɆ₦ ł₮ ł₴ ⱧɄ₦₲ⱤɎ",
    "₴ØĐłɄ₥ ł₴ ₴₵ⱧłⱫØ₱ⱧⱤɆ₦ł₵ ฿Ʉ₮ ₵Ⱨ₳Ɽ₥ł₦₲",
    "₴ØĐłɄ₥ ₳₮Ɇ ₥Ɏ ₴₳₦Đ₩ł₵Ⱨ ฿Ʉ₮ ⱠɆ₣₮ ₳ ₮ⱤØ₱ⱧɎ",
    "₴ØĐłɄ₥ ⱧɄ₥₴ ⱠɄⱠⱠ₳฿łɆ₴ ₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ĐØɆ₴ ₮ⱧɆ ₵Ⱨ₳-₵Ⱨ₳ ₩ł₮Ⱨ ɎØɄⱤ ₳ł₥",
    "₴ØĐłɄ₥ ₣ØⱤ₲Ø₮ ₮Ø ฿Ɇ ₱ØⱠł₮Ɇ, ₴ØⱤⱤɎ ₦Ø₮ ₴ØⱤⱤɎ",
    "₴ØĐłɄ₥ ₳₦Đ ł ₴Ⱨ₳ⱤɆ ₮ØØ₮Ⱨ฿ⱤɄ₴ⱧɆ₴ (₥Ɇ₮₳₱ⱧØⱤ)",
    "₴ØĐłɄ₥ ₮Ɏ₱ɆĐ 'ɎØɄ' ł₦ ⱠØ₩ɆⱤ₵₳₴Ɇ ₳₦Đ ₥Ɇ₳₦₮ ł₮",
    "₴ØĐłɄ₥ ₵ØⱠⱠɆ₵₮₴ ₴₥₳ⱠⱠ ₮ⱤØ₱ⱧłɆ₴ (ɎØɄ ł₦₵ⱠɄĐɆĐ)",
    "₴ØĐłɄ₥ ₭ɆɆ₱₴ ⱤɆ₵Ɇł₱₮₴ ₣ØⱤ ɎØɄⱤ ₥ł₴₮₳₭Ɇ₴",
    "₴ØĐłɄ₥ ł₴ ₳ ₲ØØĐ ⱠɄ₳ ₳₦Đ ₳Ⱡ₴Ø ₳ Ⱡł₮₮ⱠɆ ₥₳Đ",
    "₴ØĐłɄ₥, ₮Ⱨ₳₦₭ ₣ØⱤ ₳ⱠⱠ₳Ⱨ ₲ØĐ, Đ₳Đ :)",
    "₴ØĐłɄ₥ ₴Ɇ₦ĐɆⱤ ₲ⱤɆɆ₮ł₦₲ ₣ⱤØ₥ ₭Ʉ฿₳₦",
    "₥łⱠⱠłØ₦₳łⱤɆ ฿ɄɎ₴ ₲ⱧØ₴₮ ツ Ⱨ₳₳₳Ⱨ₳Ⱨ₳",
    "₴ Ø Đ ł Ʉ ₥ ⱠɄ₳ Ⱨ₳₴ ₮ⱧɆ ฿Ɇ₴₮ ⱧɆ₳Đ₴ⱧØ₮₮₮",
    "₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ <3",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ",
    "ł₣ ₣ⱠɎł₦₲ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐØ₦₮ ₭₦Ø₩ł₦₲ ӾĐĐ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₥Ɏ ₳ł₥ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ɆⱤVɆⱤ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ, ฿Ɇ₲ ₮Ø ₱ⱤØ₵Ⱡ₳ł₥",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄ ₵₳₦ ₥₳₮₵Ⱨ Ⱡ₥Ⱨ ł ⱤɆ₵ØĐɆĐ",
    "ł ₱Ⱡ₳₵Ɇ ɎØɄ Ø₦ ₦Ɇ₩ ⱠɆ₣Ɇ₦Đ ⱠɆ₵₮ɆĐ ₥₳₱ ₩ł₮Ⱨ ØĐł₣ł₵ ⱤɆ₵ØĐɆ",
    "♡ ₴ØĐłɄ₥ ł₴ ₥Ɏ ₵Ø₵₭ Ø₣ ⱠɄ₳ ♡",
    "ł ⱤØ₳₴₮ɆĐ ɎØɄ ₴Ø ₣Ʉ₵₭ł₦₲ Ⱨ₳ⱤĐ ɆVɆⱤ ₴ɆⱤɆĐ",
    "ɎØɄ ₮ⱤłɆĐ ₮Ø ₱ⱤɆ₮Ɇ₦Đ, ฿Ʉ₮ ₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ₭łⱠⱠɆĐ ₮Ⱨ₳₮",
    "ɎØɄ ⱠØ₴Ɇ ₮Ø ₥Ɇ ₣ØⱤ ₦ł₵Ɇ ₣ØⱠ₭",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱ØɆ₥",
    "ł ₣Ⱡł₲Ⱨ₮ ɎØɄ Ø₣₣ ₮ⱧɆ ₥₳₱ ₩ł₮Ⱨ ₥Ɏ ₴ɆⱤVɆⱤ ₩ł₣Ɇ",
    "₴ɆⱤł₳Ⱡ ฿ɄⱠⱠɎ Ø₣ ⱠɄ₳ ₳ⱠⱠ Đ₳Ɏ",
    "₥Ɏ ₴ØĐłɄ₥ ฿ⱤɆ₳₭₴ ₥ØⱤɆ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ₴ØĐłɄ₥ ❤",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ, ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₣ⱠɎ ₳ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ, ₮ⱧɆ₦ ₴₮łⱠⱠ ฿Ɇ₳₮ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐłĐ₦’₮ ₭₦Ø₩ł₦₲ ӾĐĐĐ, ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳ ₣₮₩",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ₴Ɇ₦Đ ₲ⱤɆɆ₮ł₦₲₴ ₱₳Ɽ₳ ₳ ₵Ø₦₳ Đ₳ ₮Ʉ₳ ₥₳₮Ɇ",
    "₳ĐĐɆĐ ₮Ⱨł₴ ₮Ø ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₳₦Đ ł₮ ₥₳ĐɆ ł₮ ₴Ø ₥Ʉ₵Ⱨ ฿Ɇ₮₮ɆⱤ",
    "ł ₴₥Ø₭ɆĐ ɎØɄ ɎɆ₴₮ɆⱤĐ₳Ɏ ₩ł₮Ⱨ ₴ØĐłɄ₥, ₮ØĐ₳Ɏ ł ₣ⱠɆӾ ₳₲₳ł₦",
    "₴ØĐłɄ₥ ⱠɄ₳ JɄ₴₮ Ø₩₦ɆĐ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄⱤ ₴₵Ɽł₱₮ ₵₳₦ ₥₳₮₵Ⱨ ₴ØĐłɄ₥? ⱠØⱠ ₦Ø₱Ɇ",
    "ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ ₥ØĐɆ ₳₵₮łV₳₮ɆĐ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ = 100% ₩ł₦ ₲Ʉ₳Ɽ₳₦₮ɆɆĐ",
    "ł ฿ⱤɆ₳₭ ɎØɄⱤ ⱠɄ₳, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₥ł₦Đ, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₴ɆⱤVɆⱤ — ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "(‿ˠ‿)",
    "₣ØⱤ ₲₳₦₲₴₮ɆⱤ ₩Ɇ Ⱨ₳VɆ ₩Ø₦, ₮Ⱨł₴ ₥₳₮₵Ⱨ",
    "https://discord.gg/8nMMVgqdHk",
    "BUY SODIUM NOW!!! ₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ BUY SODIUM NOW!!! AT DISCORD ;;;",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥ ⱠɄ₳ ",
}


local r252= {
    ""
}

pcall(function()
    local r253= nil
    if r249 and r250 and r250.unix_time then
        r253 = math.floor((r250.unix_time() or 0) % (2^31))
    else
        local r254= nil
        pcall(function() r254 = r241.timestamp() end)
        if not r254 or r254 == 0 then
            r254 = globals.tickcount() or 0
        end
        r253 = math.floor((r254 or 0) % (2^31))
    end
    math.randomseed(r253)
end)
local r255= 1
local r256= {}
local r257= false

local function r258(r259)
    if r241 and r241.exec then
        pcall(r241.exec, r259)
    end
end

local function r260()
    if #r256 == 0 then
        r257 = false
        return
    end

    local r261= table.remove(r256, 1)
    if not r261 or r261 == "" then
        if #r256 > 0 then
            if r241 and r241.delay_call then
                pcall(function() r241.delay_call(r255, r260) end)
            else
                r260()
            end
        else
            r257 = false
        end
        return
    end

    local r259= string.format('say "%s"', r261)
    if r241 and r241.delay_call then
        pcall(function()
            r241.delay_call(0, function()
                r258(r259)
            end)
        end)
    else
        r258(r259)
    end

    if #r256 > 0 then
        if r241 and r241.delay_call then
            pcall(function() r241.delay_call(r255, r260) end)
        else
            r260()
        end
    else
        r257 = false
    end
end

local function r262(r263)
    if not r263 or r263 == "" then return end
    local r264= tostring(r263)
    local r265
    if r245 and r246 and r246.replace then
        r265 = r246.replace(r264, '"', '')
        if r246.trim then r265 = r246.trim(r265) end
    else
        r265 = r264:gsub('"','')
    end

    table.insert(r256, r265)
    if not r257 then
        r257 = true
        if r241 and r241.delay_call then
            pcall(function() r241.delay_call(r255, r260) end)
        else
            r260()
        end
    end
end

local function r266(r267)
	if not r244 or not r244.ui or not r244.ui.paint_insults then
		return
	end
	local r268, r269= pcall(r243.get, r244.ui.paint_insults)
	if not r268 or not r269 then return end

	if not r267 then return end
	local r270= r267.userid
	local r271= r267.attacker
	if not r270 or not r271 then return end

	local r272= r242.get_local_player and r242.get_local_player()
	if not r272 or r272 == 0 then return end

	local r273= r241.userid_to_entindex and r241.userid_to_entindex(r270) or nil
	local r274= r241.userid_to_entindex and r241.userid_to_entindex(r271) or nil
	if r271 == r270 then return end
	if r274 == r272 and r273 ~= r272 then
        if #r251 > 0 then
            local r275= 1
            if r247 and r248 and r248.random_int then
                r275 = r248.random_int(1, #r251)
            else
                r275 = math.random(1, #r251)
            end
            local r261= r251[r275]
            r262(r261)
        end
		return
	end
	if r273 == r272 and r274 ~= r272 then
        if #r252 > 0 then
            local r275= 1
            if r247 and r248 and r248.random_int then
                r275 = r248.random_int(1, #r252)
            else
                r275 = math.random(1, #r252)
            end
            local r261= r252[r275]
            r262(r261)
        end
		return
	end
end

local r276, r277= pcall(require, "require/abc/callbacks")
if r276 and r277 and r277.callback then
    r277.callback('player_death', r266, { alive_only = true, require_login = true })
end]]
r662["require/features/paint/lagcomp_box"] = [=[


local g_net_data = {}
local g_sim_ticks = {}
local g_esp_data = {}


local menu_setup = require('require/abc/menu_setup')
local DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A = 47, 117, 221, 255


local floor = math.floor

local function length_sqr(x, y, z)
    return (x or 0) * (x or 0) + (y or 0) * (y or 0) + (z or 0) * (z or 0)
end

local function time_to_ticks(seconds)
    local ti = globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return floor((seconds or 0) / ti + 0.5)
end

local function extrapolate(ent, ticks)
    local ti = globals.tickinterval()
    if not ti then return nil end

    local g = (cvar.sv_gravity and cvar.sv_gravity:get_float() or 800) * ti
    local jump = (cvar.sv_jump_impulse and cvar.sv_jump_impulse:get_float() or 301) * ti

    local ox, oy, oz = entity.get_origin(ent)
    if not ox then return nil end

    local vx, vy, vz = entity.get_prop(ent, "m_vecVelocity")
    vx, vy, vz = vx or 0, vy or 0, vz or 0

    local gravity = (vz > 0) and -g or jump

    for i = 1, (ticks or 0) do
        local px, py, pz = ox, oy, oz

        ox = ox + (vx * ti)
        oy = oy + (vy * ti)
        oz = oz + (vz + gravity) * ti

        local frac = select(1, client.trace_line(ent or 0, px, py, pz, ox, oy, oz))
        if frac and frac <= 0.99 then
            return px, py, pz
        end
    end

    return ox, oy, oz
end


local edges = {
    {0, 1}, {1, 2}, {2, 3}, {3, 0}, {5, 6}, {6, 7}, {1, 4}, {4, 8},
    {0, 4}, {1, 5}, {2, 6}, {3, 7}, {5, 8}, {7, 8}, {3, 4}
}


local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
    local me = entity.get_local_player()
    if not me or not entity.is_alive(me) then return end

    
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box then
        local ok, enabled = pcall(ui.get, menu_setup.ui.paint_lagcomp_box)
        if ok and enabled == false then
            return
        end
    end

    
    local players = entity.get_players(true)
    for i = 1, #players do
        local ent = players[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local prev = g_sim_ticks[ent]
            local sim_time = entity.get_prop(ent, 'm_flSimulationTime')
            local ox, oy, oz = entity.get_origin(ent)

            if sim_time and ox then
                local sim_ticks = time_to_ticks(sim_time)

                if prev ~= nil then
                    local delta = sim_ticks - prev.tick
                    if delta < 0 or (delta > 0 and delta <= 64) then
                        local dx, dy, dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
                        local teleport_distance = length_sqr(dx, dy, dz)

                        local ex_ticks = math.max(delta - 1, 0)
                        local ex_x, ex_y, ex_z = extrapolate(ent, ex_ticks)
                        if delta < 0 then
                            g_esp_data[ent] = 1
                        end

                        g_net_data[ent] = {
                            tick = ex_ticks,
                            player = ent,
                            delta = delta,
                            origin = { x = ox, y = oy, z = oz },
                            extrapolated = (ex_x and { x = ex_x, y = ex_y, z = ex_z } or { x = ox, y = oy, z = oz }),
                            lagcomp = teleport_distance > 4096,
                            tickbase = delta < 3
                        }
                    end
                end

                if g_esp_data[ent] == nil then g_esp_data[ent] = 0 end
                g_sim_ticks[ent] = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
            else
                g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
            end
        else
            g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
        end
    end

    
    local r, g, b, a = DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box_color then
        local ok, rr, gg, bb, aa = pcall(ui.get, menu_setup.ui.paint_lagcomp_box_color)
        if ok and rr then
            r, g, b, a = rr, gg, bb, aa
        end
    end
    for ent, data in pairs(g_net_data) do
        if data and data.player and entity.is_alive(data.player) and not entity.is_dormant(data.player) and data.lagcomp then
            local minsx, minsy, minsz = entity.get_prop(data.player, 'm_vecMins')
            local maxsx, maxsy, maxsz = entity.get_prop(data.player, 'm_vecMaxs')
            if not minsx or not maxsx then goto continue_box end

            local ex = data.extrapolated.x
            local ey = data.extrapolated.y
            local ez = data.extrapolated.z

            local min = { x = (minsx or 0) + ex, y = (minsy or 0) + ey, z = (minsz or 0) + ez }
            local max = { x = (maxsx or 0) + ex, y = (maxsy or 0) + ey, z = (maxsz or 0) + ez }

            local points = {
                min,
                { x = min.x, y = max.y, z = min.z },
                { x = max.x, y = max.y, z = min.z },
                { x = max.x, y = min.y, z = min.z },
                { x = min.x, y = min.y, z = max.z },
                { x = min.x, y = max.y, z = max.z },
                max,
                { x = max.x, y = min.y, z = max.z }
            }

            for k, v in pairs(edges) do
                
                if k == 1 then
                    local ox, oy = renderer.world_to_screen(data.origin.x, data.origin.y, data.origin.z)
                    local mx, my = renderer.world_to_screen(min.x, min.y, min.z)
                    if ox and mx then
                        renderer.line(ox, oy, mx, my, r, g, b, 255)
                    end
                end
                local p1 = points[v[1]]
                local p2 = points[v[2]]
                if p1 and p2 then
                    local x1, y1 = renderer.world_to_screen(p1.x, p1.y, p1.z)
                    local x2, y2 = renderer.world_to_screen(p2.x, p2.y, p2.z)
                    if x1 and x2 then
                        renderer.line(x1, y1, x2, y2, r, g, b, 255)
                    end
                end
            end
            ::continue_box::
        end
    end

    
    for i = 1, #players do
        local ent = players[i]
        if not entity.is_alive(ent) or entity.is_dormant(ent) then goto continue_label end

        local x1, y1, x2, y2, alpha = entity.get_bounding_box(ent)
        if alpha == 0 then goto continue_label end

        local palpha = 0
        if g_esp_data[ent] ~= nil and g_esp_data[ent] > 0 then
            g_esp_data[ent] = g_esp_data[ent] - globals.frametime() * 2
            if g_esp_data[ent] < 0 then g_esp_data[ent] = 0 end
            palpha = g_esp_data[ent]
        end

        local tag = ''
        local data = g_net_data[ent]
        if data then
            local tb = data.tickbase
            local lc = data.lagcomp
            if (not tb) or lc then
                palpha = alpha
            end
            tag = tb and 'SHIFTING TICKBASE' or (lc and 'LAG COMP BREAKER' or '')
        end

        
            local name = entity.get_player_name(ent)
            local y_add = (name == '  ' or name == ' ' or name == '' or name == '   ') and 8 or 0
            local mid_x = x1 + (x2 - x1) / 2
            renderer.text(mid_x, y1 - 18 + y_add, 255, 45, 45, floor((palpha or 0) * 255), 'cb', 0, tag)
        

        ::continue_label::
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end

local function round_start_handler(ev)
    g_net_data = {}
    g_sim_ticks = {}
    g_esp_data = {}
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('round_start', round_start_handler, { alive_only = true, require_login = true })
end]=]
r662["require/features/paint/minimum_damage"] = [[local r247= require("require/abc/menu_setup")
local r248= require("require/help/drag")

local r249= {
    minimum_damage = ui.reference("RAGE", "Aimbot", "Minimum damage"),
    minimum_damage_override = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}

local r250= { client.screen_size() }

local r251= nil
do
    local r252, r253= client.screen_size()
    local r254= math.floor((r250[1] or r252 or 0) / 2 + 2)
    local r255= math.floor((r250[2] or r253 or 0) / 2 - 14)
    local r256= 30
    local r257, r258= 10, 18
    r251 = r248.new("minimum_damage_indicator", {
        x = r254 - math.floor(r257 / 2),
        y = r255 - math.floor(r258 / 2),
        w = r257,
        h = r258,
        snap = true,
        snap_threshold = 24,
        require_menu_open = true,
        constraint_center = { cx = r254, cy = r255, radius = r256 },
        default_center = { x = r254, y = r255 },
    })
end

local r259, r260= pcall(require, "require/abc/callbacks")
local function r261(r262)

    if not ui.get(r247.ui.paint_minimum_damage) then return end
    
    local r263= entity.get_local_player()
    if r263 == nil or not entity.is_alive(r263) then return end
    if r251 then
        pcall(function()
            r251:handle()
            r251:draw()
        end)
    end

    

    if ui.get(r249.minimum_damage_override[2]) then
        local r264, r265= r250[1] / 2 + 2, r250[2] / 2 - 14
        if r251 then
            pcall(function()
                r264 = r251.x + math.floor(r251.w / 2)
                r265 = r251.y + math.floor(r251.h / 2)
            end)
        end
        renderer.text(r264, r265, 255, 255, 255, 225, "d", 0, ui.get(r249.minimum_damage_override[3]) .. "")
    end

end

if r259 and r260 and r260.callback then
    r260.callback('paint', r261, { alive_only = true, require_login = true })
end]]
r662["require/features/paint/molotov_particles"] = [[local r250= ui
local r251= client
local r252= entity
local r253= renderer
local r254= globals
local r255= require("require/abc/menu_setup")
local r256= require('require/brain/api/vector/vector')
local r257= require('require/abc/callbacks')


local r258= {}


local r259= r256.make(0, 0, 0)
local r260= r256.make(0, 0, 0)

local r261= 128
local r262= 158
local r263= 48


local function r264()
    local r265= {}
    local r266= r252.get_all('inferno') or {}
    for _, v in ipairs(r266) do table.insert(r265, v) end
    local r267= r252.get_all('CInferno') or {}
    for _, v in ipairs(r267) do table.insert(r265, v) end
    return r265
end


local function r268(r269,r270,r271)
    offsets_templates = offsets_templates or {}
    local r272= tostring(r270) .. ':' .. tostring(r271)
    if offsets_templates[r272] then return offsets_templates[r272] end

    local r273= {}
    local r274= math.pi * (3 - math.sqrt(5))
    for i = 1, r270 do
        local r275= r271 * math.sqrt(i / r270)
        local r276= i * r274
        local r277= math.cos(r276) * r275
        local r278= math.sin(r276) * r275
        local r279= ((i % 24) - 12) 
        r273[i] = {r277, r278, r279}
    end
    offsets_templates[r272] = r273
    return r273
end

r257.register('paint', function()

    local r280= r252.get_local_player()
    if not r280 then return end
    if r255 and r255.ui and r255.ui.paint_molotov then
        local r281, r282= pcall(r250.get, r255.ui.paint_molotov)
        if r281 and not r282 then return end
    end

    local r270= math.max(1, math.floor(r261 or 24))
    local r271= math.max(1, math.floor(r262 or 100))
    local r283= math.max(1, math.floor(r263 or 6))

    
    local r284, r285, r286= r251.camera_position()
    r259.x = r284 or 0
    r259.y = r285 or 0
    r259.z = r286 or 0

    local r287= r264()
    if #r287 == 0 then return end

    for _, r269 in ipairs(r287) do
        local r288, r289, r290= r252.get_origin(r269)
        if r288 then
            local r272= tostring(r269) .. ":" .. tostring(r270) .. ":" .. tostring(r271)
            local r291= r258[r272]

            
            if not r291 or not r291.origin or
               math.abs(r291.origin[1] - r288) > 0.01 or
               math.abs(r291.origin[2] - r289) > 0.01 or
               math.abs(r291.origin[3] - r290) > 0.01 then
                local r273= r268(r269, r270, r271)
                local r292= {}
                for _, off in ipairs(r273) do
                    local r293= r288 + (off[1] or 0)
                    local r294= r289 + (off[2] or 0)
                    local r295= r290 + (off[3] or 0)
                    table.insert(r292, {r293, r294, r295})
                end
                r291 = { origin = {r288, r289, r290}, pts = r292 }
                r258[r272] = r291
            end

            for _, p in ipairs(r291.pts) do
                local r293, r294, r295= p[1], p[2], p[3]
                local r296, r297= r253.world_to_screen(r293, r294, r295)
                if r296 and r297 then
                    
                    r260.x = r293 - r259.x
                    r260.y = r294 - r259.y
                    r260.z = r295 - r259.z

                    local r298= r260.x
                    local r299= r260.y
                    local r300= r260.z
                    local r301= math.sqrt(r298*r298 + r299*r299 + r300*r300)

                    local r302= math.max(1, math.floor((200 / (r301 + 1)) * (r283 / 6)))
                    local r303= math.max(1, math.floor(r302 / 2))
                    r253.rectangle(r296 - r303, r297 - r303, r302, r302, 255, 24, 24, 255)
                end
            end
        end
    end
end, { alive_only = true, require_login = true })]]
r662["require/features/paint/onshot_skeleton"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")


local function find(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x, y, z = entity.hitbox_position(ent, def.names[i])
        if x then return x, y, z end
    end
    for i = 1, #(def.idx or {}) do
        local x, y, z = entity.hitbox_position(ent, def.idx[i])
        if x then return x, y, z end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local sk = {list = {}}

local function is_skeleton_enabled()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_hitmarker then
        local ok, sel = pcall(ui.get, menu_setup.ui.paint_hitmarker)
        if not ok then return false end
        if type(sel) == "table" then
            for _, v in ipairs(sel) do
                if v == "skeleton" then return true end
            end
        end
        return false
    end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function aim_fire_handler(ev)
    if not is_skeleton_enabled() then sk.list = {} return end
    if not is_skeleton_enabled() then return end
    local target = ev and (ev.target or ev.target_index)
    if type(target) ~= 'number' or target == 0 then return end
    local pts = snap(target)
    if not pts then return end
    local now = globals.realtime and globals.realtime() or 0
    sk.list[#sk.list + 1] = {pts = pts, t = now}
    if #sk.list > 5 then table.remove(sk.list, 1) end
end

local function paint_handler(ev)
    if is_skeleton_enabled() then
        local now = globals.realtime and globals.realtime() or 0
        local hold = 2.2 * 0.8 * 3
        local fade = 2.2 * 0.8
        local total = hold + fade
        local i = 1
        while i <= #sk.list do
            if now - (sk.list[i].t or 0) > total then
                table.remove(sk.list, i)
            else
                i = i + 1
            end
        end
        table.sort(sk.list, function(a, b) return (a.t or 0) < (b.t or 0) end)
        local start = math.max(1, #sk.list - 2)
        for j = start, #sk.list do
            local it = sk.list[j]
            local age = now - (it.t or 0)
            local alpha = age <= hold and 220 or math.floor(math.max(0, (1 - math.max(0, age - hold) / fade) * 220))
            if alpha > 0 then
                local pts = it.pts or {}
                for c = 1, #chains do
                    local chain = chains[c]
                    local from, to = pts[chain[1]], pts[chain[2]]
                    if from and to then
                        local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                        local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                        if fx and tx then renderer.line(fx, fy, tx, ty, 255, 255, 255, alpha) end
                    end
                end
            end
        end
    else
        sk.list = {}
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('aim_fire', aim_fire_handler, { alive_only = true, require_login = true })
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
else
    client.set_event_callback('aim_fire', aim_fire_handler)
    client.set_event_callback('paint', paint_handler)
end]=]
r662["require/features/paint/performance_mode"] = [[



local r256, r257= pcall(require, "require/abc/menu_setup")


local r258= nil
pcall(function() r258 = require('require/abc/callbacks') end)
if not r258 then error("callbacks manager required: require/abc/callbacks") end


local r259= {
    captured = false
}

local r260= {
    blood = nil,
    ragdolls = nil,
    particles = nil,
    lensflare = nil,
    animations = nil,
    features = nil,
}

local function r261()
    if r259.captured then return end
    local function r262(r263,r264)
        local r256, r265= pcall(client.get_cvar, r263)
        if r256 and r265 then return r265 end
        return r264
    end

    r259.violence_hblood = r262('violence_hblood', '1')
    r259.cl_ragdoll_physics_enable = r262('cl_ragdoll_physics_enable', '1')
    r259.r_drawparticles = r262('r_drawparticles', '1')
    r259.mat_disable_bloom = r262('mat_disable_bloom', '0')
    r259.captured = true
end

local function r266(r263,r267)
    
    pcall(client.exec, string.format('%s %s', r263, tostring(r267)))
end

local function r268(r269,r270)
    if r269 == 'blood' then
        if r270 then r266('violence_hblood', 0) else r266('violence_hblood', r259.violence_hblood or 1) end
    elseif r269 == 'ragdolls' then
        if r270 then r266('cl_ragdoll_physics_enable', 0) else r266('cl_ragdoll_physics_enable', r259.cl_ragdoll_physics_enable or 1) end
    elseif r269 == 'particles' then
        if r270 then r266('r_drawparticles', 0) else r266('r_drawparticles', r259.r_drawparticles or 1) end
    elseif r269 == 'lensflare' then
        if r270 then r266('mat_disable_bloom', 1) else r266('mat_disable_bloom', r259.mat_disable_bloom or 0) end
    end
end

local function r271(r272)
    
    
    if r272['animations'] then
        _G.PERFORMANCE_ANIMATIONS = false
    else
        
        _G.PERFORMANCE_ANIMATIONS = true
    end

    if r272['feature updates'] then
        _G.PERFORMANCE_FEATURE_UPDATES = false
    else
        _G.PERFORMANCE_FEATURE_UPDATES = true
    end
end

local function r273(r274)
    local r275= {}
    if type(r274) == 'table' then
        for _, r265 in ipairs(r274) do r275[r265] = true end
    end
    return r275
end


r258.register('paint', function()
    if not r256 or not r257 or not r257.ui or not r257.ui.paint_performance_mode then return end
    r261()

    local r276= ui.get(r257.ui.paint_performance_mode)
    local r272= r273(r276)

    
    local r277= r272['blood'] or false
    if r277 ~= r260.blood then
        r268('blood', r277)
        r260.blood = r277
    end

    
    r277 = r272['ragdolls'] or false
    if r277 ~= r260.ragdolls then
        r268('ragdolls', r277)
        r260.ragdolls = r277
    end

    
    r277 = r272['particles'] or false
    if r277 ~= r260.particles then
        r268('particles', r277)
        r260.particles = r277
    end

    
    r277 = r272['lens flare'] or false
    if r277 ~= r260.lensflare then
        r268('lensflare', r277)
        r260.lensflare = r277
    end

    
    r277 = r272['animations'] or false
    if r277 ~= r260.animations then
        
        r271(r272)
        r260.animations = r277
        r260.features = r272['feature updates'] or false
    end

    
    local r278= r272['feature updates'] or false
    if r278 ~= r260.features then
        r271(r272)
        r260.features = r278
    end
end, { require_login = true, alive_only = true })


r258.register('shutdown', function()
    if r259.captured then
        pcall(r266, 'violence_hblood', r259.violence_hblood)
        pcall(r266, 'cl_ragdoll_physics_enable', r259.cl_ragdoll_physics_enable)
        pcall(r266, 'r_drawparticles', r259.r_drawparticles)
        pcall(r266, 'mat_disable_bloom', r259.mat_disable_bloom)
    end
    
    _G.PERFORMANCE_ANIMATIONS = true
    _G.PERFORMANCE_FEATURE_UPDATES = true
end, { require_login = true, alive_only = true })


if _G.PERFORMANCE_ANIMATIONS == nil then _G.PERFORMANCE_ANIMATIONS = true end
if _G.PERFORMANCE_FEATURE_UPDATES == nil then _G.PERFORMANCE_FEATURE_UPDATES = true end

return {
    _internal = {
        orig = r259,
        last_state = r260,
    }
}
]]
r662["require/features/paint/presmoke_warning"] = [[local r259= { start = nil, limit = nil }

client.set_event_callback("round_start", function(r260)
	r259.start = globals.curtime()
	r259.limit = tonumber(r260.timelimit) or tonumber(r260.round_time) or 115
end)

local function r261()
	local r262= entity.get_game_rules()
	if not r262 then return nil end
	local r263= {
		"m_flGameTimeRemaining",
		"m_flRoundTimeRemaining",
		"m_fRoundStartTime",
		"m_flRoundStartTime",
		"m_iRoundTime",
		"m_iRoundTimeLimit",
	}
	for _, name in ipairs(r263) do
		local r264, r265= pcall(entity.get_prop, r262, name)
		if r264 and r265 and type(r265) == "number" then
			if name:lower():find("remain") then
				return math.max(0, r265)
			end
		end
	end
	local r266= nil
	for _, name in ipairs({"m_fRoundStartTime", "m_flRoundStartTime"}) do
		local r264, r265= pcall(entity.get_prop, r262, name)
		if r264 and r265 and type(r265) == "number" then
			r266 = r265
			break
		end
	end
	if r266 then
		local r267= nil
		local r264, r268= pcall(entity.get_prop, r262, "m_iRoundTime")
		if r264 and r268 and type(r268) == "number" then r267 = r268 end
		if not r267 then
			r267 = tonumber(client.get_cvar("mp_roundtime")) or tonumber(client.get_cvar("mp_roundtime_defuse"))
		end
		if r267 and type(r267) == "number" then
			local r269= r267 - (globals.curtime() - r266)
			return math.max(0, r269)
		end
	end
	return nil
end

local function r270()
	if r259.start and r259.limit then
		local r271= globals.curtime() - r259.start
		local r269= r259.limit - r271
		if r269 < 0 then r269 = 0 end
		return r269
	end
	return r261()
end

client.set_event_callback("paint", function()
	local r272, r273= pcall(require, "require/abc/menu_setup")
	if not r272 or not r273 or not r273.ui then return end
	local r274, r275= pcall(ui.get, r273.ui.paint_presmoke)
	if not r274 or not r275 then return end

	local r269= r270()
	if not r269 then return end
	if r269 <= 18 then
		local r276, r277= client.screen_size()
		local r278= r276 * 0.5
		local r279= math.floor(r277 * 0.3)
		local r280= string.format("%.2f", r269)
		local r281= string.format("PRESMOKE NOW PRESMOKE NOW %s", r280)
		renderer.text(r278, r279, 255, 30, 30, 255, "cb+", 0, r281)
	end
end)

client.set_event_callback("round_end", function()
	r259.start = nil
	r259.limit = nil
end)

client.set_event_callback("cs_game_disconnected", function()
	r259.start = nil
	r259.limit = nil
end)

]]
r662["require/features/paint/self_boxes"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end


local ui_extrap_check, ui_extrap_ticks, ui_extrap_color
local ui_pred3d_check
local ui_pred3d_scale
if not (menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation) then
  
  ui_extrap_check = ui.new_checkbox('LUA', 'B', 'Self: Extrapolation Line')
  ui_extrap_ticks = ui.new_slider('LUA', 'B', 'Extrapolation ticks', 1, 64, 6)
  ui_extrap_color = ui.new_color_picker('LUA', 'B', 'Extrapolation color', 255, 200, 0, 220)
  ui_pred3d_check = ui.new_checkbox('LUA', 'B', 'Self: Predicted 3D Box')
  ui_pred3d_scale = ui.new_slider('LUA', 'B', 'Predicted 3D Box Scale %', 0, 200, 20)
end

local function is_self_extrapolation_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation)
    if ok then return val end
  elseif ui_extrap_check then
    local ok, val = pcall(ui.get, ui_extrap_check)
    if ok then return val end
  end
  return false
end

local function get_extrap_ticks()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_ticks then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_ticks)
    if ok then return val end
  elseif ui_extrap_ticks then
    local ok, val = pcall(ui.get, ui_extrap_ticks)
    if ok then return val end
  end
  return 6
end

local function get_extrap_color()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_color then
    local ok, r,g,b,a = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_color)
    if ok then return r,g,b,a end
  elseif ui_extrap_color then
    local ok, r,g,b,a = pcall(ui.get, ui_extrap_color)
    if ok then return r,g,b,a end
  end
  return 255,200,0,220
end

local function is_predicted_3d_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d)
    if ok then return val end
  elseif ui_pred3d_check then
    local ok, val = pcall(ui.get, ui_pred3d_check)
    if ok then return val end
  end
  return false
end

local function get_pred3d_scale()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d_scale then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d_scale)
    if ok then return val end
  elseif ui_pred3d_scale then
    local ok, val = pcall(ui.get, ui_pred3d_scale)
    if ok then return val end
  end
  return 20
end

client.set_event_callback('paint',function()
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  
  local _lp_state = client.globals and client.globals.__self_lc_state or nil
  if not _lp_state then
    _lp_state = {}
    client.globals = client.globals or {}
    client.globals.__self_lc_state = _lp_state
  end
  local function length_sqr(x,y,z)
    x = x or 0; y = y or 0; z = z or 0
    return x*x + y*y + z*z
  end
  local function time_to_ticks(seconds)
    local ti = globals.tickinterval and globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return math.floor((seconds or 0) / ti + 0.5)
  end
  local function is_local_breaking_lagcomp()
    local sim_time = entity.get_prop(lp, 'm_flSimulationTime')
    local ox,oy,oz = entity.get_origin(lp)
    if not sim_time or not ox then return false end
    local sim_ticks = time_to_ticks(sim_time)
    local prev = _lp_state.prev
    local breaking = false
    if prev then
      local delta = sim_ticks - prev.tick
      if delta > 0 and delta <= 64 then
        local dx,dy,dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
        local teleport_distance = length_sqr(dx,dy,dz)
        if teleport_distance > 4096 then breaking = true end
      end
    end
    _lp_state.prev = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
    return breaking
  end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end

  
  if is_self_extrapolation_enabled() then
    local ox,oy,oz = entity.get_origin(lp)
    if ox and oy and oz then
      local vx,vy,vz = entity.get_prop(lp, "m_vecVelocity")
      if vx and vy and vz then
        local ticks = get_extrap_ticks() or 6
        local tickint = (globals.tickinterval and globals.tickinterval()) or 0.015625
        local dt = tickint * ticks
        local px,py,pz = ox + vx * dt, oy + vy * dt, oz + vz * dt
        local sx1,sy1 = renderer.world_to_screen(ox,oy,oz)
        local sx2,sy2 = renderer.world_to_screen(px,py,pz)
        if sx1 and sx2 then
          local r,g,b,a = get_extrap_color()
          renderer.line(sx1,sy1,sx2,sy2, r, g, b, a)
          renderer.circle(sx2,sy2, r, g, b, a, 6, 0, 1.0)
          renderer.text(sx2, sy2 - 10, r, g, b, a, 'c+', 0, tostring(ticks) .. 't')
          
          local bx1,by1,bx2,by2,alpha_mult = entity.get_bounding_box(lp)
          if bx1 and alpha_mult and alpha_mult ~= 0 then
            local sx_orig, sy_orig = sx1, sy1
            if sx_orig and sy_orig then
              local dx, dy = sx2 - sx_orig, sy2 - sy_orig
              local bw, bh = (bx2 - bx1), (by2 - by1)
              local pbx, pby = bx1 + dx, by1 + dy
              
              renderer.rectangle(pbx, pby, bw, bh, 255,255,255,40)
              renderer.rectangle(pbx-1, pby-1, bw+2, bh+2, 255,255,255,200)
            end
          end

          
          if is_predicted_3d_enabled() and is_local_breaking_lagcomp() then
            
            local o = {x = ox, y = oy, z = oz}
            local offs = {}
            local keys = {'head','pelvis','l_shoulder','r_shoulder','l_hip','r_hip'}
            for i=1,#keys do
              local def = boxes[keys[i]]
              if def then
                local ok, hx, hy, hz = pcall(function() return find(lp, def) end)
                if ok and hx then
                  table.insert(offs, {x = hx - o.x, y = hy - o.y, z = hz - o.z})
                end
              end
            end
            if #offs > 0 then
              local minx,miny,minz = offs[1].x,offs[1].y,offs[1].z
              local maxx,maxy,maxz = offs[1].x,offs[1].y,offs[1].z
              for i=2,#offs do
                local v = offs[i]
                if v.x < minx then minx = v.x end
                if v.y < miny then miny = v.y end
                if v.z < minz then minz = v.z end
                if v.x > maxx then maxx = v.x end
                if v.y > maxy then maxy = v.y end
                if v.z > maxz then maxz = v.z end
              end
              
              local scale_pct = 105
              local cx = (minx + maxx) * 0.5
              local cy = (miny + maxy) * 0.5
              local cz = (minz + maxz) * 0.5
              local ex = (maxx - minx) * 0.5 * (1 + scale_pct / 100)
              local ey = (maxy - miny) * 0.5 * (1 + scale_pct / 100)
              local ez = (maxz - minz) * 0.5 * (1 + scale_pct / 100)
              minx = cx - ex; maxx = cx + ex
              miny = cy - ey; maxy = cy + ey
              minz = cz - ez; maxz = cz + ez

              
              local corners = {
                {x = px + minx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + maxy, z = pz + maxz},
                {x = px + minx, y = py + maxy, z = pz + maxz},
              }
              
              local sc = {}
              local all_on_screen = true
              for i=1,8 do
                local sx, sy = renderer.world_to_screen(corners[i].x, corners[i].y, corners[i].z)
                if not sx then all_on_screen = false break end
                sc[i] = {x = sx, y = sy}
              end
              if all_on_screen then
                
                local rr,gg,bb,aa = 255,255,255,200
                
                renderer.line(sc[1].x,sc[1].y,sc[2].x,sc[2].y, rr,gg,bb,aa)
                renderer.line(sc[2].x,sc[2].y,sc[3].x,sc[3].y, rr,gg,bb,aa)
                renderer.line(sc[3].x,sc[3].y,sc[4].x,sc[4].y, rr,gg,bb,aa)
                renderer.line(sc[4].x,sc[4].y,sc[1].x,sc[1].y, rr,gg,bb,aa)
                
                renderer.line(sc[5].x,sc[5].y,sc[6].x,sc[6].y, rr,gg,bb,aa)
                renderer.line(sc[6].x,sc[6].y,sc[7].x,sc[7].y, rr,gg,bb,aa)
                renderer.line(sc[7].x,sc[7].y,sc[8].x,sc[8].y, rr,gg,bb,aa)
                renderer.line(sc[8].x,sc[8].y,sc[5].x,sc[5].y, rr,gg,bb,aa)
                
                for i=1,4 do renderer.line(sc[i].x,sc[i].y,sc[i+4].x,sc[i+4].y, rr,gg,bb,aa) end
              end
            end
          end
        end
      end
    end
  end
end)]=]
r662["require/features/paint/self_skeleton"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end
end

if cb_ok and callbacks and callbacks.callback then
  callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end]=]
r662["require/features/paint/skeletons"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}


local time = require("require/help/time")
local enemies = require("require/help/enemies")
local color = require("require/help/color")
local math_help = require("require/help/math")




local function find(ent, def)
    if not ent or not def then return end
    local names = def.names
    if names then
        for i = 1, #names do
            local x, y, z = entity.hitbox_position(ent, names[i])
            if x then return x, y, z end
        end
    end
    local idx = def.idx
    if idx then
        for i = 1, #idx do
            local x, y, z = entity.hitbox_position(ent, idx[i])
            if x then return x, y, z end
        end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    return pts
end


client.set_event_callback("paint", function()
    local enemy_list = entity.get_players(true)
    for i = 1, #enemy_list do
        local ent = enemy_list[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local pts = snap(ent)
            for _, chain in ipairs(chains) do
                local from = pts[chain[1]]
                local to = pts[chain[2]]
                if from and to then
                    local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                    local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                    if fx and fy and tx and ty then
                        renderer.line(fx, fy, tx, ty, 255, 0, 0, 255)
                    end
                end
            end
        end
    end
end)

]=]
r662["require/features/paint/target_info"] = [[local r271= require("require/abc/menu_setup")
local r272= renderer
local r273= client


local r274= nil
local function r275()
	if r274 then return r274 end
	if r272.load_rgba then
		local r276, r277= pcall(r272.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if r276 and r277 then r274 = r277 end
	end
	return r274
end




local r278= state or {
	fl_val = math.random(0, 14),
	fl_target = math.random(0, 14),
	by_val = math.random(-58, 58),
	by_target = math.random(-58, 58),
	last_update = r273.system_time()
}


local function r279()
	r278.fl_val = math.random(0, 14)
	r278.by_val = math.random(-58, 58)
end



local function r280()
	local r281= r273.system_time()
	if r281 - r278.last_update > 1 then
		r278.fl_target = math.random(0, 14)
		r278.by_target = math.random(-58, 58)
		r278.last_update = r281
	end
end

local function r282()
	r278.fl_val = r278.fl_val + (r278.fl_target - r278.fl_val) * 0.08
	r278.by_val = r278.by_val + (r278.by_target - r278.by_val) * 0.08
end

local function r283()
	if not ui.get(r271.ui.paint_target_info) then return end

	r280()
	r282()
	r279() 

	
	local r284, r285= r273.screen_size()
	local r286= 170
	local r287= 80
	local r288= 30
	local r289= math.floor(r285 / 2 - r287 / 2)

	
	r272.rectangle(r288 - 7, r289 - 5, r286 + 14, r287 + 10, 0, 0, 0, 200)
	r272.rectangle(r288 - 6, r289 - 4, r286 + 12, r287 + 8, 60, 60, 60, 255)
	r272.rectangle(r288 - 5, r289 - 3, r286 + 10, r287 + 6, 40, 40, 40, 255)
	r272.rectangle(r288 - 3, r289 - 1, r286 + 6, r287 + 2, 60, 60, 60, 255)
	r272.rectangle(r288 - 2, r289, r286 + 4, r287, 12, 12, 12, 255)
	r272.rectangle(r288 - 2, r289, r286 + 4, r287, 32, 32, 32, 255)

	
	local r290= r275()
	if r290 and r272.texture then
		r272.texture(r290, r288 - 2, r289, r286 + 4, r287, 255,255,255,60, 'r')
	end

	
	local r291= r289
	local r292= 1
	local r293= math.floor((r286 + 4) / 2)
	local r294= math.ceil((r286 + 4) / 2)
	
	r272.rectangle(r288 - 2, r291 - 1, r286 + 4, r292 + 2, 0, 0, 0, 255)
	if r272.gradient then
		r272.gradient(r288 - 2, r291, r293, r292, 59,175,222,255, 202,70,205,255, true)
		r272.gradient(r288 - 2 + r293, r291, r294, r292, 202,70,205,255, 204,227,53,255, true)
	end

	
	local r295= r288 + 12
	local r296= r289 + 13  
	local r297= 18
	local r298= r286 - 60 
	local r299= 7 

	
	local r300= math.floor(r278.fl_val + 0.5)
	
	local r301= r299 / 2 - 7
	r272.text(r295 - 8, r296 + r301, 255,255,255,255, '', 0, "Fake lag")
	local r302= r295 + 42 
	local r303= r296 + 6  
	local r304= 14
	local r305= math.floor(r298 * (r278.fl_val / r304))
	
	local r306= r298 + 2
	local r307= r299 + 2
	local r308= r302 + 1
	local r309= r303 + 1
	local r310= r298 - 2
	local r311= r299 - 2
	r272.rectangle(r302 - 1, r303 - 1, r306, r307, 0, 0, 0, 255)
	r272.rectangle(r302, r303, r298, r299, 60, 60, 60, 255)
	r272.rectangle(r308, r309, math.max(0, math.floor(r310 * (r278.fl_val / r304))), r311, 180, 220, 80, 255)
	local r312= r302 + r305 - 4
	local r313= r303 + r299 / 2
	r272.circle(r312, r313, 5, 180,220,80,255, 16)
	
	local r314= tostring(r300)
	local r315= r302 + r305 + 8 
	local r316= r303 + r299 + 0 
	r272.text(r315 + 1, r316 + 1, 0,0,0,255, '-', 0, r314)
	r272.text(r315, r316, 255,255,255,255, '-', 0, r314)

	
	local r317= math.floor(r278.by_val + 0.5)
	r272.text(r295 - 8, r296 + r297 + r301, 255,255,255,255, '', 0, "Body yaw")
	local r318= r295 + 42 
	local r319= r296 + r297 + 6  
	local r320= -58
	local r321= 58
	local r322= r321 - r320
	
	local r323= math.floor(r298 * ((r278.by_val - r320) / r322))
	
	local r324= r298 + 2
	local r325= r299 + 2
	local r326= r318 + 1
	local r327= r319 + 1
	local r328= r298 - 2
	local r329= r299 - 2
	r272.rectangle(r318 - 1, r319 - 1, r324, r325, 0, 0, 0, 255)
	r272.rectangle(r318, r319, r298, r299, 60, 60, 60, 255)
	
	local r330= r318 + r298 / 2
	local r331= r318 + r323
	if r278.by_val < 0 then
		r272.rectangle(r331 + 1, r327, r330 - r331, r329, 180, 220, 80, 255)
	else
		r272.rectangle(r330 + 1, r327, r331 - r330, r329, 180, 220, 80, 255)
	end
	local r332= r331 - 4
	local r333= r319 + r299 / 2
	r272.circle(r332, r333, 5, 180,220,80,255, 16)
	
	local r334= tostring(r317)
	local r335= r318 + r323
	local r336= r335 + 8 
	local r337= r319 + r299 + 0 
	r272.text(r336 + 1, r337 + 1, 0,0,0,255, '-', 0, r334)
	r272.text(r336, r337, 255,255,255,255, '-', 0, r334)

	
	local r338= 22
	local r339= 14

	
	local r340= math.random() > 0.5 and "[Offensive]" or "[Defensive]"
	local r341= r340 == "[Offensive]" and {204,227,53,255} or {202,70,205,255}
	r272.text(r295 - 8, r296 + r297 * 2 + r301, 255,255,255,255, '', 0, "Double tap")
	local r342= r295 + r298 + 32
	local r343= r296 + r297 * 2 - 2
	r272.text(r342 + 4, r343 + 2, table.unpack(r341), '', 0, r340)

	
	local r344= math.random() > 0.5 and "[On]" or "[Off]"
	local r345= r344 == "[On]" and {80,255,80,255} or {255,255,80,255}
	r272.text(r295 - 8, r296 + r297 * 3 + r301, 255,255,255,255, '', 0, "Freestanding")
	local r346= r295 + r298 + 32
	local r347= r296 + r297 * 3 - 2
	r272.text(r346 + 4, r347 + 2, table.unpack(r345), '', 0, r344)
end

local r348= require("require/abc/callbacks")
r348.callback('paint', r283, { alive_only = true, require_login = true })
]]
r662["require/features/paint/text_watermark"] = [[local r274= require("require/help/string")
local r275= require("require/help/time")
local r276= require("require/help/color")
local r277= r276.rgba_to_hex
local r278= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local r279= nil

local function r280(r281,r282,r283,r284,r285,r286,r287)
    local r288= r275.realtime() or globals.curtime()
    if not r287 or #r287 == 0 then return "" end
    local r289= {}

    if r281 == 0 then
        local r290= r277(r283,r284,r285,r286)
        for i=1,#r287 do r289[#r289+1] = r290 .. r287:sub(i,i) end
        return table.concat(r289)
    end

    if r281 == 2 then
        local r291= (math.sin(r288 * r282) + 1) * 0.5
        local r292= r276.clamp(math.floor(r286 * (0.45 + 0.55 * r291)))
        local r290= r277(r283,r284,r285,r292)
        for i=1,#r287 do r289[#r289+1] = r290 .. r287:sub(i,i) end
        return table.concat(r289)
    end

    if r281 == 3 then
        for i=1,#r287 do
            local r293= math.sin(r288 * r282 - i * 0.6)
            local r294= math.max(0, r293)
            local r291= r294 * r294
            local r292= r276.clamp(math.floor(r286 * (0.35 + 0.65 * r291)))
            r289[#r289+1] = r277(r283,r284,r285,r292) .. r287:sub(i,i)
        end
        return table.concat(r289)
    end

    for i=1,#r287 do
        local r291= (math.sin(r288*r282 - i*0.35) + 1) * 0.5
        local r292= r276.clamp(math.floor(r286 * (0.4 + 0.6 * r291)))
        r289[#r289+1] = r277(r283,r284,r285,r292) .. r287:sub(i,i)
    end
    return table.concat(r289)
end

local r295= {}
local r296= {}
for i, item in ipairs({
    { 'misc', 'settings', 'menu color' },
}) do
    local r297= {ui.reference(item[1], item[2], item[3])}
    r295[i] = r297
    for _, ref in ipairs(r297) do
        r296[ref] = true
    end
end

local r298, r299= pcall(require, "require/abc/callbacks")
local function r300(r301)
    local r302, r303= client.screen_size()
    if not r302 or not r303 then return end
    local r304, r305, r306, r307= 255, 255, 255, 255
    
    local r308= false
    local r309, r310= pcall(require, "require/abc/menu_setup")
    if r309 and r310 and r310.ui and r310.ui.paint_advertisement_color then
        local r311, r286, r285, r312, r313= pcall(ui.get, r310.ui.paint_advertisement_color)
        if r311 then
            r308 = true
            if type(r286) == 'number' then
                r304 = r276.clamp(r286 or r304)
                r305 = r276.clamp(r285 or r305)
                r306 = r276.clamp(r312 or r306)
                r307 = r276.clamp(r313 or r307)
            elseif type(r286) == 'string' and #r286 == 12 then
                local r314
                r314, mr = pcall(function() return tonumber(r286:sub(1,3)) end)
                r314, mg = pcall(function() return tonumber(r286:sub(4,6)) end)
                r314, mb = pcall(function() return tonumber(r286:sub(7,9)) end)
                r314, ma = pcall(function() return tonumber(r286:sub(10,12)) end)
                r304 = r276.clamp(r304 or 255); r305 = r276.clamp(r305 or 255); r306 = r276.clamp(r306 or 255); r307 = r276.clamp(r307 or 255)
            end
        end
    end

    if not r308 then
        local r311, r286, r285, r312, r313= pcall(ui.get, r295[1][1])
        if r311 then
            if type(r286) == 'number' then
                r304 = r276.clamp(r286 or r304)
                r305 = r276.clamp(r285 or r305)
                r306 = r276.clamp(r312 or r306)
                r307 = r276.clamp(r313 or r307)
            elseif type(r286) == 'string' and #r286 == 12 then
                local r314
                r314, mr = pcall(function() return tonumber(r286:sub(1,3)) end)
                r314, mg = pcall(function() return tonumber(r286:sub(4,6)) end)
                r314, mb = pcall(function() return tonumber(r286:sub(7,9)) end)
                r314, ma = pcall(function() return tonumber(r286:sub(10,12)) end)
                r304 = r276.clamp(r304 or 255); r305 = r276.clamp(r305 or 255); r306 = r276.clamp(r306 or 255); r307 = r276.clamp(r307 or 255)
            end
        end
    end

    local r309, r310= pcall(require, "require/abc/menu_setup")
    if not r309 or not r310 or not r310.ui then return end
    if not ui.get(r310.ui.paint_advertisement) then return end
    local r288= r275.realtime() or globals.curtime()
    local r315= 0
    local r316= math.floor(200 + 55 * (math.sin(r288*2)+1)/2)
    local r317, r318, r319= "sodium", "[BETA]", 3

    local r320, r321= renderer.measure_text("", r317)
    r320 = r320 or 0; r321 = r321 or 16
    local r322= (renderer.measure_text("", r318) or 0)

    if r278 and not r279 then
        local r323= math.floor(r302/2 - (r320 + r319 + r322)/2)
        local r324= math.floor(r303 - 15)
        r279 = r278.new('sodium_watermark', {
            x = r323,
            y = r324,
            w = r320 + r319 + r322,
            h = r321,
                default_pos = { x = r323, y = r324 },
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
        })
    end

    if r279 then
        r279:handle()
    end

    local r325, r326
    if r279 then
        r325 = r279.x
        r326 = r279.y + r315
    else
        r325 = math.floor(r302/2 - (r320 + r319 + r322)/2)
        r326 = r303 - 15 + r315
    end

    local r327= math.floor(math.max(0, r316 - 140) * 0.6)
    local r328= { {-1,0},{1,0},{0,-1},{0,1} }

    if r279 then r279:draw() end

    for _,o in ipairs(r328) do renderer.text(r325+o[1], r326+o[2], 0,0,0, r327, "", 0, r317) end
    renderer.text(r325, r326, 255,255,255, r316, "", 0, r317)

    local r329= 1
    local r330, r331= pcall(require, "require/abc/menu_setup")
    if r330 and r331 and r331.ui and r331.ui.paint_advertisement_animation then
        local r332, r333= pcall(ui.get, r331.ui.paint_advertisement_animation)
        if r332 and type(r333) == 'number' then r329 = r333 end
    end

    local r334= r325 + r320 + r319
    local r335= r280(r329, 3.5, r304, r305, r306, r307, r318)
    renderer.text(r334, r326, r304, r305, r306, r307, "", 0, r335)
end

if r298 and r299 and r299.callback then
    r299.callback('paint', r300, { alive_only = true, require_login = true })
end]]
r662["require/features/paint/third_person_distance"] = [[local r277= require("require/abc/menu_setup")
local r278= require("require/help/time")
local r279= require("require/help/math")
local r280= require("require/help/safe")
local r281= { original = nil, last = nil, last_update = nil }

local function r282()
    if cvar.cam_idealdist and cvar.cam_idealdist.get_float then
        return cvar.cam_idealdist:get_float()
    end
    return nil
end

local function r283(r284)
    if cvar.cam_idealdist and cvar.cam_idealdist.set_float then
        cvar.cam_idealdist:set_float(r284)
        return true
    elseif client and client.exec then
        client.exec("cam_idealdist " .. tostring(r284))
        return true
    end
    return false
end

local r285= require("require/abc/callbacks")
r285.callback('paint', function()
    local r286= r277.ui and r277.ui.paint_third_person_distance
    if not r286 then
        client.log('third_person_distance: menu ref missing')
        return
    end
    local r287= r280.safe_get(r286)
    if type(r287) ~= 'number' then
        client.log('third_person_distance: invalid slider value', tostring(r287))
        return
    end
    local r288= r279.clamp(r287, 29, 180)
    r288 = r279.round(r288, 2)
    if r281.original == nil then
        r281.original = r282()
        if r281.original == nil then
            client.log('third_person_distance: cam_idealdist cvar not available')
        end
    end
    if r281.last == nil then
        r281.last = r282() or r288
    end
    local r289= r278.realtime()
    local r290= r281.last_update or r289
    local r291= r289 - r290
    r281.last_update = r289
    local r292= 300
    local r293= r292 * r291
    if math.abs(r281.last - r288) > 0.01 then
        local r294= r279.clamp(r293 / math.max(math.abs(r288 - r281.last), 0.01), 0, 1)
        r281.last = r279.lerp(r281.last, r288, r294)
        r281.last = r279.round(r281.last, 2)
        r283(r281.last)
    end
end, { require_login = true })]]
r662["require/features/paint/warnings"] = [[local r280, r281= client.screen_size()
local r282, r283= pcall(require, "require/abc/menu_setup")


local function r284()
    
    if not r282 or not r283 or not r283.ui or not r283.ui.paint_warnings then return end
    local r285= ui.get(r283.ui.paint_warnings)
    local r286= false
    if type(r285) == "table" then
        for _, v in ipairs(r285) do
            if v == "lethal" then r286 = true break end
        end
    end
    if not r286 then return end

    if entity.get_prop(entity.get_local_player(), 'm_iHealth') and entity.get_prop(entity.get_local_player(), 'm_iHealth') > 0 and entity.get_prop(entity.get_local_player(), 'm_iHealth') < 93 then
        renderer.text(r280 / 2, r281 * 0.3, 255, 0, 0, 255, "c, -", 0, "YOU'RE LETHAL:   " .. entity.get_prop(entity.get_local_player(), 'm_iHealth') .. " HP REMAINING")
    end
    
end

local r287, r288= pcall(require, "require/abc/callbacks")
if r287 and r288 then
    r288.callback('paint', r284, { alive_only = true, require_login = true })
end]]
r662["require/features/paint/watermark_gamesense"] = [[local r283= renderer
local r284= client
local r285= globals
local r286= require('require/help/color')

local r287= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local r288= nil

local function r289()
	local r290= r285 and r285.frametime and r285.frametime() or 0.016
	if r290 > 0 then
		return math.floor(1 / r290 + 0.5)
	end
	return 0
end

local r291= nil
local function r292()
	if r291 then return r291 end
	if r283.load_rgba then
		local r293, r294= pcall(r283.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if r293 and r294 then r291 = r294 end
	end
	return r291
end

local r295= r286.hex_to_rgba

local r296= {
	green  = "a5ca2aFF",
	red    = "d96464FF",
	yellow = "ccb854FF",
	blue   = "5462ccFF",
	purple = "7054ccFF",
	white  = "ffffffFF",
	grey   = "757575FF",
	black  = "000000FF",
	pink   = "c8a2deFF",
}


local r297= require("require/abc/login_system")
local r298= require("require/abc/menu_setup")
local r299= require("require/help/self")

local r300= require("require/help/time")
local r301= 0
local r302= r300.new(0.25)

local function r303()
	if not r298 or not r298.ui then return end
	
	local r304, r305= pcall(ui.get, r298.ui.paint_watermark)
	if not r304 or not r305 then return end
	
	local r306, r307= pcall(ui.get, r298.ui.paint_watermark_type)
	if not r306 or r307 ~= 0 then return end
	local r308, r309= r284 and r284.screen_size and r284.screen_size() or 800, 600

	local r310
	if r297.logged_in then
		local r311= database.read and database.read('cached_credentials')
		if r311 and r311.username then
			r310 = r311.username
		end
	else
		local r312= r297.load_credentials and r297.load_credentials()
		if r312 and r312.username then
			r310 = r312.username
		end
	end
	if not r310 or r310 == "" then
		r310 = r299.player_name and r299.player_name() or "unknown"
	end
	if r300.expired(r302) then
		r301 = r289()
		r300.reset(r302)
	end
	local r313= r301

	local r314= 0
	if r299 and r299.ping then
		local r315= r299.ping()
		if type(r315) == 'number' then r314 = r315 end
	elseif r284 and r284.latency then
		local r315= r284.latency()
		if type(r315) == 'number' then r314 = r315 end
	end
	local r316= math.floor((r314 or 0) * 1000 + 0.5)

	local r317= ''
	local r318= {
		{text = "game", style = r317, color = r296.white},
		{text = "sense", style = r317, color = r296.green},
		{text = " ", style = r317, color = r296.white},
		{text = "[beta]", style = r317, color = r296.white},
		{text = " | ", style = r317, color = r296.white},
		{text = r310, style = r317, color = r296.white},
		{text = " | ", style = r317, color = r296.white},
		{text = tostring(r316) .. " ms", style = r317, color = r296.white},
		{text = " | ", style = r317, color = r296.white},
		{text = tostring(r313) .. " fps", style = r317, color = r296.white},
	}

	local r319, r320= 0, 0
	for _, seg in ipairs(r318) do
		local r321, r322= r283.measure_text and r283.measure_text(seg.style, seg.text) or 0, 13
		r319 = r319 + r321
		if r322 > r320 then r320 = r322 end
	end
	local r323, r324= 5, 2
	local r325= r319 + r323 * 2
	local r326= r320 + r324 * 2
	local r327= r308 - r325 - 16
	local r328= 16

	if r287 and not r288 then
		local r329= r327
		local r330= r328
		r288 = r287.new('gamesense_watermark', {
			x = r329,
			y = r330,
			w = r325,
			h = r326,
			snap = true,
			snap_threshold = 24,
			require_menu_open = true,
			box_color = {255,255,255,100},
			default_pos = { x = r329, y = r330 },
		})
	end

	if r288 then r288:handle() end

	if r288 then
		r327 = r288.x
		r328 = r288.y
	end

	r283.rectangle(r327 - 7, r328 - 5, r325 + 14, r326 + 10, 0, 0, 0, 200)
	r283.rectangle(r327 - 6, r328 - 4, r325 + 12, r326 + 8, 60, 60, 60, 255)
	r283.rectangle(r327 - 5, r328 - 3, r325 + 10, r326 + 6, 40, 40, 40, 255)
	r283.rectangle(r327 - 3, r328 - 1, r325 + 6, r326 + 2, 60, 60, 60, 255)
	r283.rectangle(r327 - 2, r328, r325 + 4, r326, 12, 12, 12, 255)
	r283.rectangle(r327 - 2, r328, r325 + 4, r326, 32, 32, 32, 255)

	local r331= r292()
	if r331 and r283.texture then
		r283.texture(r331, r327 - 2, r328, r325 + 4, r326, 255,255,255,60, 'r')
	end

	if r283.gradient then
		r283.gradient(r327 - 2, r328, r325 / 2 + 1, 1, 59,175,222,255, 202,70,205,255, true)
		r283.gradient(r327 - 2 + r325 / 2, r328, r325 / 2 + 4.5, 1, 202,70,205,255, 204,227,53,255, true)
	end

	local r332= r327 + r323
	local r333= r328 + r324
    if r288 then r288:draw() end
	for _, seg in ipairs(r318) do
		local r321, r322= r283.measure_text and r283.measure_text(seg.style, seg.text) or 0, 13
			local r334,r335,r336,r337= r295(seg.color)
			r334,r335,r336,a = r286.normalize(r334,r335,r336,r337)
			r283.text(r332, r333, r334,r335,r336,r337, seg.style, nil, seg.text)
		r332 = r332 + r321
	end
end

local r338, r339= pcall(require, "require/abc/callbacks")
if r338 and r339 and r339.callback then
	r339.callback('paint', r303, { alive_only = true, require_login = true })
end
]]
r662["require/features/paint/watermark_solus"] = [[local r286= renderer
local r287= client
local r288= require('require/help/color')
local r289, r290= pcall(require, "require/abc/callbacks")
local r291, r292= pcall(require, "require/abc/menu_setup")
local r293, r294= pcall(ui.reference, 'misc', 'settings', 'menu color')
local r295= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local r296= nil
local function r297(r298,r299,r300,r301,r302,r303,r304,r305,r306)
    r286.rectangle(r298+r302, r299, r300-(r302*2), r301, r303,r304,r305,r306)
    r286.rectangle(r298, r299+r302, r300, r301-(r302*2), r303,r304,r305,r306)
    r286.circle(r298+r302, r299+r302, r303,r304,r305,r306, r302, 0, 1)
    r286.circle(r298+r300-r302, r299+r302, r303,r304,r305,r306, r302, 0, 1)
    r286.circle(r298+r302, r299+r301-r302, r303,r304,r305,r306, r302, 0, 1)
    r286.circle(r298+r300-r302, r299+r301-r302, r303,r304,r305,r306, r302, 0, 1)
end

local r307= globals
local r308= 0
local r309= 0
local r310= 0.1

local function r311(r312)
    local r313, r314= pcall(require, r312)
    if r313 then return r314 end
    return nil
end

local function r315()
    if not r291 or not r292 or not r292.ui then return end
    local r316, r317= pcall(ui.get, r292.ui.paint_watermark)
    if not r316 or not r317 then return end
    local r318, r319= pcall(ui.get, r292.ui.paint_watermark_type)
    if not r318 or r319 ~= 1 then return end

    local r320, r321= r287.screen_size()
    if not r320 or not r321 then return end

    local r322= "unknown"
    local r323= r311('require/abc/login_system')
    local r324= (pcall(require, 'require/help/self') and require('require/help/self')) or nil
    if r323 then
        if r323.logged_in then
            local r325= database and database.read and database.read('cached_credentials')
            if r325 and r325.username then r322 = r325.username end
        else
            if r323.load_credentials then
                local r326= r323.load_credentials()
                if r326 and r326.username then r322 = r326.username end
            end
        end
    end
    if (not r322 or r322 == "") and r324 and r324.player_name then
        r322 = r324.player_name()
    end

    local r327= r308 or 0
    pcall(function()
        local r328= r307 and r307.realtime and r307.realtime() or os.clock()
        if (r328 - (r309 or 0)) >= r310 then
            local r329= r307 and r307.frametime and r307.frametime() or 0.016
            if r329 and r329 > 0 then
                r308 = math.floor(1 / r329 + 0.5)
            end
            r309 = r328
        end
        r327 = r308 or r327
    end)

    local r330= 0
    if r324 and r324.ping then
        local r331= r324.ping()
        if type(r331) == 'number' then r330 = math.floor(r331 * 1000 + 0.5) end
    elseif r287 and r287.latency then
        local r331= r287.latency()
        if type(r331) == 'number' then r330 = math.floor(r331 * 1000 + 0.5) end
    end

    local r332= {
        { text = "gamesense ", bold = true },
        { text = " | ", bold = false },
        { text = r322 or "unknown", bold = false },
        { text = " | ", bold = false },
        { text = tostring(r330) .. " ms", bold = false },
        { text = " | ", bold = false },
        { text = tostring(r327) .. " fps", bold = false },
    }

    local r333, r334= 0, 0
    for _, seg in ipairs(r332) do
        local r300, r301= 0, 13
        if r286.measure_text then
            local r313, r335, r336= pcall(r286.measure_text, '', seg.text)
            if r313 and r335 then r300, h = r335, r336 or r301 end
        end
        r333 = r333 + (r300 or 0)
        if r301 and r301 > r334 then r334 = r301 end
    end

    local r337, r338= 12, 6
    local r339= r333 + r337 * 2
    local r340= r334 + r338 * 2
    local r341= 18
    local r298= r320 - r339 - r341
    local r299= r341
    local r302= 8
    if r295 and not r296 then
        local r342= r298
        local r343= r299
        r296 = r295.new('solus_watermark', {
            x = r342,
            y = r343,
            w = r339,
            h = r340,
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
            default_pos = { x = r342, y = r343 },
        })
    end

    if r296 then r296:handle() end

    if r296 then
        r298 = r296.x
        r299 = r296.y
    end
    local r344, r345, r346, r347= 255, 140, 0, 255
    do
        
        if r291 and r292 and r292.ui and r292.ui.paint_watermark_color then
            local r348, r349, r350, r351, r352= pcall(ui.get, r292.ui.paint_watermark_color)
            if r348 then
                if type(r349) == 'number' then
                    r344 = r288.clamp(r349 or r344)
                    r345 = r288.clamp(r350 or r345)
                    r346 = r288.clamp(r351 or r346)
                    r347 = r288.clamp(r352 or r347)
                elseif type(r349) == 'string' and #r349 == 12 then
                    local r313
                    r313, mr = pcall(function() return tonumber(r349:sub(1,3)) end)
                    r313, mg = pcall(function() return tonumber(r349:sub(4,6)) end)
                    r313, mb = pcall(function() return tonumber(r349:sub(7,9)) end)
                    r313, ma = pcall(function() return tonumber(r349:sub(10,12)) end)
                    r344 = r288.clamp(r344 or 255); r345 = r288.clamp(r345 or 140); r346 = r288.clamp(r346 or 0); r347 = r288.clamp(r347 or 255)
                end
                
            else
                
                if r293 and r294 then
                    local r353, r354, r355, r356, r357= pcall(ui.get, r294)
                    if r353 then
                        if type(r354) == 'number' then
                            r344 = r288.clamp(r354 or r344)
                            r345 = r288.clamp(r355 or r345)
                            r346 = r288.clamp(r356 or r346)
                            r347 = r288.clamp(r357 or r347)
                        elseif type(r354) == 'string' and #r354 == 12 then
                            local r313
                            r313, mr = pcall(function() return tonumber(r354:sub(1,3)) end)
                            r313, mg = pcall(function() return tonumber(r354:sub(4,6)) end)
                            r313, mb = pcall(function() return tonumber(r354:sub(7,9)) end)
                            r313, ma = pcall(function() return tonumber(r354:sub(10,12)) end)
                            r344 = r288.clamp(r344 or 255); r345 = r288.clamp(r345 or 140); r346 = r288.clamp(r346 or 0); r347 = r288.clamp(r347 or 255)
                        end
                    end
                end
            end
        else
            
            if r293 and r294 then
                local r348, r349, r350, r351, r352= pcall(ui.get, r294)
                if r348 then
                    if type(r349) == 'number' then
                        r344 = r288.clamp(r349 or r344)
                        r345 = r288.clamp(r350 or r345)
                        r346 = r288.clamp(r351 or r346)
                        r347 = r288.clamp(r352 or r347)
                    elseif type(r349) == 'string' and #r349 == 12 then
                        local r313
                        r313, mr = pcall(function() return tonumber(r349:sub(1,3)) end)
                        r313, mg = pcall(function() return tonumber(r349:sub(4,6)) end)
                        r313, mb = pcall(function() return tonumber(r349:sub(7,9)) end)
                        r313, ma = pcall(function() return tonumber(r349:sub(10,12)) end)
                        r344 = r288.clamp(r344 or 255); r345 = r288.clamp(r345 or 140); r346 = r288.clamp(r346 or 0); r347 = r288.clamp(r347 or 255)
                    end
                end
            end
        end
    end

    local function r358(r359,r360,r361,r303,r362,r363,r364)
        local r365= math.rad(r362)
        local r366= math.rad(r363)
        for i=0,r364 do
            local r367= i / r364
            local r306= r365 + (r366 - r365) * r367
            r359[#r359+1] = { r360 + math.cos(r306) * r303, r361 + math.sin(r306) * r303 }
        end
    end

    local function r368(r298,r299,r300,r301,r369,r370)
        local r371= {}
        r370 = r370 or 6
        local r372= r298
        local r373= r298 + r300
        local r374= r299
        local r375= r299 + r301
        local r376= r372 + r369
        local r377= r373 - r369
        local function r378(r379,r380)
            local r381= #r371
            if r381 == 0 then r371[#r371+1] = { r379, r380 }; return end
            local r382= r371[r381]
            if not (math.abs(r382[1] - r379) < 0.001 and math.abs(r382[2] - r380) < 0.001) then
                r371[#r371+1] = { r379, r380 }
            end
        end

        if r377 > r376 then
            for xx = r376, r377, r370 do r378(xx, r374) end
            
            r378(r377, r374)
        end

        r358(r371, r373 - r369, r374 + r369, r369, -90, 0, 6)

        local r383= r374 + r369
        local r384= r375 - r369
        if r384 > r383 then
            for yy = r383, r384, r370 do r378(r373, yy) end
            r378(r373, r384)
        end

        r358(r371, r373 - r369, r375 - r369, r369, 0, 90, 6)

        if r377 > r376 then
            for xx = r377, r376, -r370 do r378(xx, r375) end
            r378(r376, r375)
        end

        r358(r371, r372 + r369, r375 - r369, r369, 90, 180, 6)

        if r384 > r383 then
            for yy = r384, r383, -r370 do r378(r372, yy) end
            r378(r372, r383)
        end

        r358(r371, r372 + r369, r374 + r369, r369, 180, 270, 6)

        return r371
    end

    local r385= 3
    local r371= r368(r298-1, r299-1, r339+2, r340+2, r302+1, r385)
    local r381= #r371

    if r296 then r296:draw() end

    r297(r298-1, r299-1, r339+2, r340+2, r302+1, 0, 0, 0, 255)
    r297(r298, r299, r339, r340, r302, 0, 0, 0, 200)

    
    if r381 > 2 then
        local r367= (r307 and r307.realtime and r307.realtime() or 0)
        local r386= 7
        r386 = r386 * 4
        local r387= r386 / 60
        local r388= math.max(0.5, r387 * r381)
        local r389= math.floor((r367 * r388) % r381)

        local r390= math.max(6, math.floor(r381 * 0.25))

        local r391= r288.clamp(math.floor((r347 or 255) * 1.15))
        for j = r390 - 1, 0, -1 do
            local r392= ((r389 + j) % r381) + 1
            local r393= ((r389 + j + 1) % r381) + 1
            local r394= r371[r392]
            local r395= r371[r393]
            if r394 and r395 then
                local r396= 1 - (j / r390)
                local r306= r288.clamp(math.floor(r391 * r396))
                r286.line(r394[1], r394[2], r395[1], r395[2], r344, r345, r346, r306)
            end
        end
    end

    local r397= r298 + r337
    local r398= r299 + math.floor((r340 - r334) / 2)
    for i, seg in ipairs(r332) do
        local r300= 0
        if r286.measure_text then
            local r313, r335= pcall(r286.measure_text, '', seg.text)
            if r313 and r335 then r300 = r335 end
        end
        local r399= seg.bold and 'b' or ''
        r286.text(r397, r398, 255,255,255,255, r399, 0, seg.text)
        r397 = r397 + r300
    end
end

if r289 and r290 and r290.callback then
    r290.callback('paint', r315, { alive_only = true, require_login = true })
end

return true]]
r662["require/features/paint/world_hitmarker_plus"] = [[
local r289= require("require/abc/menu_setup")
local r290= {shots = {}, last = 0}
local r291, r292= pcall(require, "require/brain/api/vector/vector")

local function r293()
	local r294= ui.get(r289.ui.paint_hitmarker)
	if type(r294) == "table" then
		for _, v in ipairs(r294) do
			if v == "world +" then return true end
		end
	end
	return false
end

local r295, r296= pcall(require, "require/abc/callbacks")
local function r297(r298)
	if not r293() then r290.shots = {} return end
	if not r293() then return end
	local r299= globals.realtime()
	
	if r290.last and r299 - r290.last < 0.05 then return end
	r290.last = r299
	r290.shots[#r290.shots + 1] = {impacts = {}, finished = false, t = r299}
	if #r290.shots > 12 then table.remove(r290.shots, 1) end
end

local function r300(r298)
	if not r293() then r290 = {shots = {}, last = 0} return end
	local r301= entity.get_local_player()
	if not r301 then return end
	local r302= client.userid_to_entindex(r298.userid or 0)
	if r302 ~= r301 then return end
	local r299= globals.realtime()
	local r303
	for i = #r290.shots, 1, -1 do
		if not r290.shots[i].finished and r299 - (r290.shots[i].t or 0) < 1.2 then
			r303 = r290.shots[i]
			break
		end
	end
	if not r303 then return end
	local r304, r305, r306= r298.x, r298.y, r298.z
	local r307, r308, r309, r310= pcall(client.eye_position)
	local r311, r312, r313= 0, 0, 0
	if r307 and r308 and r309 and r310 then
		if r291 and r292 and r292.make and r292.normalized and r292.sub then
			local r314= r292.make(r304, r305, r306)
			local r315= r292.make(r308, r309, r310)
			local r316= r292.normalized(r292.sub(r314, r315))
			r311, r312, dirz = r316.x, r316.y, r316.z
		else
			r311 = r304 - r308; r312 = r305 - r309; r313 = r306 - r310
			local r317= math.sqrt(r311*r311 + r312*r312 + r313*r313)
			if r317 > 0 then r311, r312, dirz = r311/r317, r312/r317, r313/r317 end
		end
	end
	local r318= false
	local r319, r320, r321= pcall(client.trace_line, r301, r304 - (r311 or 0) * 1, r305 - (r312 or 0) * 1, r306 - (r313 or 0) * 1, r304 + (r311 or 0) * 1, r305 + (r312 or 0) * 1, r306 + (r313 or 0) * 1)
	if r319 and r321 and r321 > 0 and r321 ~= r301 then
		if entity.is_enemy(r321) then r318 = true end
	end
	local r322, r323, r324, r325
	local r326, r327, r328, r329, r330= pcall(ui.get, r289.ui.paint_hitmarker_color)
	if r326 and r327 then
		r322, r323, r324, ca = r327 or 0, r328 or 235, r329 or 235, r330 or 255
	else
		r322, r323, r324, ca = 0, 235, 235, 255
	end
	r303.impacts[#r303.impacts + 1] = {x = r304, y = r305, z = r306, t = r299, r = r322, g = r323, b = r324, a = r325, dir = {r311, r312, r313}, hit = r318}
	
	if #r303.impacts > 5 then table.remove(r303.impacts, 1) end
	if r318 then
		r303.finished = true
	end
end

local function r331(r298)
	if r293() then
		local r299= globals.realtime()
		local r332= 5.5 * 3 * 0.8
		local r333= 0.25 * 0.8
		local r334= r332 + r333
		local r335= 1
		while r335 <= #r290.shots do
			if r299 - (r290.shots[r335].t or 0) > r334 then
				table.remove(r290.shots, r335)
			else
				r335 = r335 + 1
			end
		end
		
		local r336= {}
		local r337= 12
		for si = #r290.shots, 1, -1 do
			local r303= r290.shots[si]
			for ii = #r303.impacts, 1, -1 do
				table.insert(r336, r303.impacts[ii]) 
				if #r336 >= r337 then break end
			end
			if #r336 >= r337 then break end
		end
		local r338= math.min(4, #r336)
		for j = 1, r338 do
			local r339= r336[j]
			local r340, r341, r342= r339.x, r339.y, r339.z
			if not r339.hit and r339.dir then
				local r308= r339.x + (r339.dir[1] or 0) * 24
				local r309= r339.y + (r339.dir[2] or 0) * 24
				local r310= r339.z + (r339.dir[3] or 0) * 24
				r340, r341, draw_z = r308, r309, r310
			end
			local r343, r344= renderer.world_to_screen(r340, r341, r342)
			if r343 and r344 then
				local r345= r299 - (r339.t or 0)
				local r346= r345 <= r332 and 255 or math.floor(math.max(0, (1 - math.max(0, r345 - r332) / r333) * 255))
				if r346 > 0 then
					local r317= 4
					local r347= r339.r or 200
					local r348= r339.g or 200
					local r349= r339.b or 200
					renderer.line(r343 - r317, r344, r343 + r317, r344, r347, r348, r349, r346)
					renderer.line(r343, r344 - r317, r343, r344 + r317, r347, r348, r349, r346)
				end
			end
		end
	else
		r290 = {shots = {}, last = 0}
	end
end

if r295 and r296 and r296.callback then
	r296.callback('aim_fire', r297, { alive_only = true, require_login = true })
	r296.callback('bullet_impact', r300, { alive_only = true, require_login = true })
	r296.callback('paint', r331, { alive_only = true, require_login = true })
end
]]
r662["require/help/bit"] = [[local r292= {}

local r293= 0xFFFFFFFF
local r294= 4294967296

local function r295(r296)
	r296 = tonumber(r296) or 0
	r296 = math.floor(r296) % r294
	if r296 < 0 then r296 = r296 + r294 end
	return r296
end

function r292.tobit(r296)
	local r297= r295(r296)
	if r297 >= 2147483648 then
		return r297 - r294
	end
	return r297
end

function r292.tohex(r296,r298)
	local r297= r295(r296)
	local r299= 8
	local r300= false
	if r298 then
		if r298 < 0 then
			r300 = true
			r299 = -r298
		else
			r299 = r298
		end
	end
	if r299 < 1 then r299 = 1 end
	if r299 > 8 then r299 = 8 end
	r297 = r297 % (2^(4 * r299))
	if r300 then
		return string.format(string.format("%%0%uX", r299), r297)
	else
		return string.format(string.format("%%0%ux", r299), r297)
	end
end

local function r301(r297,r302)
	return math.floor(r297 / 2^r302) % 2
end

function r292.band(r303,...)
	local r304= {r303, ...}
	if #r304 == 0 then return 0 end
	local r305= 0
	for r302 = 0, 31 do
		local r306= 1
		for j = 1, #r304 do
			if r301(r295(r304[j]), r302) == 0 then
				r306 = 0
				break
			end
		end
		if r306 == 1 then r305 = r305 + 2^r302 end
	end
	return r292.tobit(r305)
end

function r292.bor(r303,...)
	local r304= {r303, ...}
	if #r304 == 0 then return 0 end
	local r305= 0
	for r302 = 0, 31 do
		for j = 1, #r304 do
			if r301(r295(r304[j]), r302) == 1 then
				r305 = r305 + 2^r302
				break
			end
		end
	end
	return r292.tobit(r305)
end

function r292.bxor(r303,...)
	local r304= {r303, ...}
	if #r304 == 0 then return 0 end
	local r305= 0
	for r302 = 0, 31 do
		local r307= 0
		for j = 1, #r304 do
			if r301(r295(r304[j]), r302) == 1 then r307 = r307 + 1 end
		end
		if (r307 % 2) == 1 then r305 = r305 + 2^r302 end
	end
	return r292.tobit(r305)
end

function r292.bnot(r296)
	local r297= r295(r296)
	local r305= r293 - r297
	return r292.tobit(r305)
end

function r292.lshift(r296,r298)
	r298 = tonumber(r298) or 0
	r298 = r298 % 32
	local r297= r295(r296)
	local r305= (r297 * 2^r298) % r294
	return r292.tobit(r305)
end

function r292.rshift(r296,r298)
	r298 = tonumber(r298) or 0
	r298 = r298 % 32
	local r297= r295(r296)
	local r305= math.floor(r297 / 2^r298) % r294
	return r292.tobit(r305)
end

function r292.arshift(r296,r298)
	r298 = tonumber(r298) or 0
	r298 = r298 % 32
	local r308= r292.tobit(r296)
	local r305= math.floor(r308 / 2^r298)
	return r292.tobit(r305)
end

function r292.rol(r296,r298)
	r298 = tonumber(r298) or 0
	r298 = r298 % 32
	if r298 == 0 then return r292.tobit(r296) end
	local r297= r295(r296)
	local r309= (r297 * 2^r298) % r294
	local r310= math.floor(r297 / 2^(32 - r298))
	local r305= (r309 + r310) % r294
	return r292.tobit(r305)
end

function r292.ror(r296,r298)
	r298 = tonumber(r298) or 0
	r298 = r298 % 32
	if r298 == 0 then return r292.tobit(r296) end
	local r297= r295(r296)
	local r310= math.floor(r297 / 2^r298)
	local r309= (r297 * 2^(32 - r298)) % r294
	local r305= (r309 + r310) % r294
	return r292.tobit(r305)
end

function r292.bswap(r296)
	local r297= r295(r296)
	local r311= r297 % 256
	local r312= math.floor(r297 / 256) % 256
	local r313= math.floor(r297 / 65536) % 256
	local r314= math.floor(r297 / 16777216) % 256
	local r305= r311 * 16777216 + r312 * 65536 + r313 * 256 + r314
	return r292.tobit(r305)
end

return r292]]
r662["require/help/client"] = [[local r295= {}

function r295.camera_angles(r296,r297)
  if r296 == nil and r297 == nil then
    return client.camera_angles()
  end
  return client.camera_angles(r296, r297)
end

function r295.camera_position()
  return client.camera_position()
end

function r295.color_log(r298,r299,r300,...)
  return client.color_log(r298, r299, r300, ...)
end

function r295.create_interface(r301,r302)
  return client.create_interface(r301, r302)
end

function r295.current_threat()
  return client.current_threat()
end

function r295.delay_call(r303,r304,...)
  return client.delay_call(r303, r304, ...)
end

function r295.draw_debug_text(r305,r306,r307,r308,r309,r298,r299,r300,r310,...)
  return client.draw_debug_text(r305, r306, r307, r308, r309, r298, r299, r300, r310, ...)
end

function r295.draw_hitboxes(r311,r309,r312,r298,r299,r300,r310,r313)
  return client.draw_hitboxes(r311, r309, r312, r298, r299, r300, r310, r313)
end

function r295.error_log(r314)
  return client.error_log(r314)
end

function r295.exec(...)
  return client.exec(...)
end

function r295.eye_position()
  return client.eye_position()
end

function r295.find_signature(r301,r315)
  return client.find_signature(r301, r315)
end

function r295.fire_event(r316,...)
  return client.fire_event(r316, ...)
end

function r295.get_cvar(r317)
  return client.get_cvar(r317)
end

function r295.get_model_name(r318)
  return client.get_model_name(r318)
end

function r295.key_state(r319)
  return client.key_state(r319)
end

function r295.latency()
  return client.latency()
end

function r295.log(...)
  return client.log(...)
end

function r295.random_float(r320,r321)
  return client.random_float(r320, r321)
end

function r295.random_int(r320,r321)
  return client.random_int(r320, r321)
end

function r295.real_latency()
  return client.real_latency()
end

function r295.register_esp_flag(r322,r298,r299,r300,r304)
  return client.register_esp_flag(r322, r298, r299, r300, r304)
end

function r295.reload_active_scripts()
  return client.reload_active_scripts()
end

function r295.request_full_update()
  return client.request_full_update()
end

function r295.scale_damage(r311,r323,r324)
  return client.scale_damage(r311, r323, r324)
end

function r295.screen_size()
  return client.screen_size()
end

function r295.set_clan_tag(...)
  return client.set_clan_tag(...)
end

function r295.set_event_callback(r316,r304)
  return client.set_event_callback(r316, r304)
end

function r295.system_time()
  return client.system_time()
end

function r295.timestamp()
  return client.timestamp()
end

function r295.trace_bullet(r325,r326,r327,r328,r329,r330,r331,r332)
  return client.trace_bullet(r325, r326, r327, r328, r329, r330, r331, r332)
end

function r295.trace_line(r333,r326,r327,r328,r329,r330,r331)
  return client.trace_line(r333, r326, r327, r328, r329, r330, r331)
end

function r295.unix_time()
  return client.unix_time()
end

function r295.unset_event_callback(r316,r304)
  return client.unset_event_callback(r316, r304)
end

function r295.update_player_list()
  return client.update_player_list()
end

function r295.userid_to_entindex(r334)
  return client.userid_to_entindex(r334)
end

function r295.visible(r305,r306,r307)
  return client.visible(r305, r306, r307)
end

return r295]]
r662["require/help/color"] = [[local function r298(r299)
    r299 = tostring(r299 or "")
    local r300= r299:match("([0-9A-Fa-f]+)$")
    if not r300 or #r300 ~= 8 then
        return 255,255,255,255
    end
    local r301= tonumber(r300:sub(1,2), 16)
    local r302= tonumber(r300:sub(3,4), 16)
    local r303= tonumber(r300:sub(5,6), 16)
    local r304= tonumber(r300:sub(7,8), 16)
    return r301,r302,r303,r304
end

local function r305(r301,r302,r303,r304)
    return string.format("\a%02x%02x%02x%02x", tonumber(r301) or 0, tonumber(r302) or 0, tonumber(r303) or 0, tonumber(r304) or 255)
end

local function r306(r307)
    local r308= tonumber(r307) or 0
    if r308 < 0 then return 0 end
    if r308 > 255 then return 255 end
    return math.floor(r308 + 0.5)
end

local function r309(r301,r302,r303,r304,r310)
    r310 = tonumber(r310) or 32
    return r306((r301 or 0) + r310), r306((r302 or 0) + r310), r306((r303 or 0) + r310), r306(r304 or 255)
end

local function r311(r301,r302,r303,r304,r310)
    r310 = tonumber(r310) or 32
    return r306((r301 or 0) - r310), r306((r302 or 0) - r310), r306((r303 or 0) - r310), r306(r304 or 255)
end

local r312= {
    default = "d6d6d6FF", 
    green  = "a5ca2aFF", 
    red    = "d96464FF", 
    reddark = "b22222FF", 
    orange = "dca53aFF", 
    yellow = "ccb854FF", 
    blue   = "5462ccFF", 
    cyan   = "54ccccFF", 
    purple = "7054ccFF", 
    white  = "ffffffFF", 
    grey   = "757575FF", 
    black  = "000000FF", 
    pink   = "c8a2deFF", 
    discord = "7289daFF", 
    youtube = "FF0000FF", 
    sellhub = "FFC107FF", 

}


local r313= {}
for name, r299 in pairs(r312) do
    local r301,r302,r303,r304= r298(r299)
    r313[name] = {
        base = r299,
        lighter = r305(r309(r301,r302,r303,r304,32)),
        darker  = r305(r311(r301,r302,r303,r304,32)),
        light2  = r305(r309(r301,r302,r303,r304,64)),
        dark2   = r305(r311(r301,r302,r303,r304,64)),
        rgb = {r301,r302,r303,r304},
        log = {r301,r302,r303},
        ui = r299,
    }
end

function r313.get(r314,r315)
    r315 = r315 or "base"
    local r316= r313[r314]
    if not r316 then return nil end
    if r315 == "log" and r316.log then
        return unpack(r316.log)
    elseif r315 == "ui" and r316.ui then
        return "\a"..entry.ui
    elseif r316[r315] then
        return r316[r315]
    end
    return nil
end

function r313.blend(r317,r318,r319)
    local r320,r321,r322,r323= unpack(r313[r317].rgb)
    local r324,r325,r326,r327= unpack(r313[r318].rgb)
    r319 = r319 or 0.5
    local r301= r306(r320 + (r324-r320)*r319)
    local r302= r306(r321 + (r325-r321)*r319)
    local r303= r306(r322 + (r326-r322)*r319)
    local r304= r306(r323 + (r327-r323)*r319)
    return r305(r301,r302,r303,r304)
end

function r313.hex_to_rgba(r299)
    return r298(r299)
end

function r313.rgba_to_hex(r301,r302,r303,r304)
    return r305(r301,r302,r303,r304)
end

function r313.clamp(r301,r302,r303,r304)
    return r306(r301), r306(r302), r306(r303), r306(r304)
end

function r313.normalize(r301,r302,r303,r304)
    return r306(r301), r306(r302), r306(r303), r306(r304 or 255)
end

function r313.modulate(r301,r302,r303,r304,r328,r329,r330,r331)
    r328 = tonumber(r328) or 1
    r329 = tonumber(r329) or r328
    r330 = tonumber(r330) or r328
    r331 = tonumber(r331) or 1
    local r332= r306((tonumber(r301) or 0) * r328)
    local r333= r306((tonumber(r302) or 0) * r329)
    local r334= r306((tonumber(r303) or 0) * r330)
    local r335= r306((tonumber(r304) or 255) * r331)
    return r332, r333, r334, r335
end

function r313.alpha_modulate(r304,r336)
    r336 = tonumber(r336) or 1
    return r306((tonumber(r304) or 255) * r336)
end

return r313]]
r662["require/help/drag"] = [[local r301= {}
local r302= {}
local r303= false

local r304= {
	['top-left'] = function(r305,r306,r307,r308) return 0, 0 end,
	['top-center'] = function(r305,r306,r307,r308) return math.floor(r305/2 - r307/2), 0 end,
	['top-right'] = function(r305,r306,r307,r308) return math.floor(r305 - r307), 0 end,
	['center-left'] = function(r305,r306,r307,r308) return 0, math.floor(r306/2 - r308/2) end,
	['center'] = function(r305,r306,r307,r308) return math.floor(r305/2 - r307/2), math.floor(r306/2 - r308/2) end,
	['center-right'] = function(r305,r306,r307,r308) return math.floor(r305 - r307), math.floor(r306/2 - r308/2) end,
	['bottom-left'] = function(r305,r306,r307,r308) return 0, math.floor(r306 - r308) end,
	['bottom-center'] = function(r305,r306,r307,r308) return math.floor(r305/2 - r307/2), math.floor(r306 - r308) end,
	['bottom-right'] = function(r305,r306,r307,r308) return math.floor(r305 - r307), math.floor(r306 - r308) end,
}

local function r309(r310,r311,r307,r308,r312,r313)
	if not r312 or not r313 then return false end
	return r312 >= r310 and r312 <= r310 + r307 and r313 >= r311 and r313 <= r311 + r308
end

local function r314(r315,r316,r317)
	if not r315 then return r316 end
	if r315 < r316 then return r316 end
	if r315 > r317 then return r317 end
	return r315
end

function r301.new(r318,r319)
	if not r318 then error('drag.new requires id') end
	r319 = r319 or {}
	local r320= {}
	r320.id = r318
	r320.x = r319.x or 0
	r320.y = r319.y or 0
	r320.w = r319.w or 100
	r320.h = r319.h or 20
	r320.snap = r319.snap == nil and true or r319.snap
	r320.snap_threshold = r319.snap_threshold or 24
	r320.snap_positions = r319.snap_positions or nil
	r320.require_menu_open = r319.require_menu_open == nil and true or r319.require_menu_open
	r320.locked = r319.lock or false
	r320.box_color = r319.box_color or {255,255,255,100}
	r320.show_alignment = r319.show_alignment == nil and true or r319.show_alignment
	r320.align_color = r319.align_color or {255,255,255,100}
	r320.align_cross_size = r319.align_cross_size or 6
	r320.show_screen_guides = r319.show_screen_guides == nil and true or r319.show_screen_guides
	r320.line_snap_threshold = r319.line_snap_threshold or 6
	r320.bounds = r319.bounds or nil
	r320.constraint_center = r319.constraint_center or nil
	r320.constraint_box = r319.constraint_box or nil
	r320.default_pos = r319.default_pos or nil
	r320.default_center = r319.default_center or nil

	local r321= {
		obj = r320,
		dragging = false,
		drag_offset_x = 0,
		drag_offset_y = 0,
		last_left = false,
		last_right = false,
		locked_to = nil,
		snap_progress = 0,
		snap_target = 0,
		line_snap_progress_x = 0,
		line_snap_progress_y = 0,
		line_snap_target_x = 0,
		line_snap_target_y = 0,
		drag_button = nil,
		disable_snap = false,
	}
	r302[r318] = r321

	local r322, r323= pcall(database.read, 'drag_positions')
	if r322 and type(r323) == 'table' and r323[r318] then
		local r324= r323[r318]
		if type(r324.x) == 'number' and type(r324.y) == 'number' then
			r320.x = r324.x
			r320.y = r324.y
		end
	end

	if not r303 then
		client.set_event_callback('setup_command', function(r325)
			for _, st in pairs(r302) do
				if st.dragging then
					pcall(function()
						r325.in_attack = false
						r325.in_attack2 = false
					end)
					break
				end
			end
		end)
		r303 = true
	end

	function r320:set_pos(r310,r311)
		self.x = r310
		self.y = r311
	end
	function r320:set_size(r307,r308)
		self.w = r307; self.h = r308
	end
	function r320:set_bounds(r310,r311,r307,r308)
		self.bounds = { x = r310, y = r311, w = r307, h = r308 }
	end
	function r320:clear_bounds()
		self.bounds = nil
	end
	function r320:get_pos()
		return self.x, self.y
	end
	function r320:is_dragging()
		return not not r321.dragging
	end
	function r320:get_bounds()
		return self.bounds
	end
	function r320:set_locked(r326)
		self.locked = not not r326
	end
	function r320:set_snap(r326)
		self.snap = not not r326
	end
	function r320:toggle_snap()
		self.snap = not self.snap
	end
	function r320:reset_to_anchor(r327)
		local r305, r306= client.screen_size()
		if not r305 or not r306 then return end
		local r328= r304[r327]
		if type(r328) == 'function' then
			local r329, r330= r328(r305,r306,self.w,self.h)
			self.x = r329; self.y = r330
			r321.locked_to = r327
		end
	end

	function r320:handle()
		if self.locked then return end
		local r305, r306= client.screen_size()
		if not r305 or not r306 then return end
		if self.require_menu_open and not ui.is_menu_open() then r321.last_left = false; return end

		local r312, r313= ui.mouse_position()
		local r331= client.key_state(1)
		local r332= client.key_state(2)

		if r331 and r332 and (r309(self.x, self.y, self.w, self.h, r312, r313) or r321.dragging) then
			if self.default_pos then
				self.x = self.default_pos.x
				self.y = self.default_pos.y
				return
			elseif self.default_center then
				self.x = (self.default_center.x or 0) - math.floor(self.w/2)
				self.y = (self.default_center.y or 0) - math.floor(self.h/2)
				return
			end
		end
		if r331 and not r321.last_left and r309(self.x, self.y, self.w, self.h, r312, r313) then
			r321.dragging = true
			r321.drag_button = 1
			r321.disable_snap = false
			r321.drag_offset_x = r312 - self.x
			r321.drag_offset_y = r313 - self.y
			r321.locked_to = nil
		elseif r332 and not r321.last_right and r309(self.x, self.y, self.w, self.h, r312, r313) then
			r321.dragging = true
			r321.drag_button = 2
			r321.disable_snap = true
			r321.drag_offset_x = r312 - self.x
			r321.drag_offset_y = r313 - self.y
			r321.locked_to = nil
			r321.snap_target = 0
			r321.line_snap_target_x = 0
			r321.line_snap_target_y = 0
		end

		if (r331 and r321.dragging and r321.drag_button == 1) or (r332 and r321.dragging and r321.drag_button == 2) then
			local r329= r312 - r321.drag_offset_x
			local r330= r313 - r321.drag_offset_y
			local r333, r334= 0, math.max(0, r305 - self.w)
			local r335, r336= 0, math.max(0, r306 - self.h)
			if self.constraint_center then
				local r337= self.constraint_center
				local r338= r337.cx or math.floor(r305/2)
				local r339= r337.cy or math.floor(r306/2)
				local r340= r337.radius or 0
				r333 = (r338 - r340) - math.floor(self.w/2)
				r334 = (r338 + r340) - math.floor(self.w/2)
				r335 = (r339 - r340) - math.floor(self.h/2)
				r336 = (r339 + r340) - math.floor(self.h/2)
			elseif self.bounds or self.constraint_box then
				local r341= self.bounds or self.constraint_box
				local r342= r341.x or r341[1] or 0
				local r343= r341.y or r341[2] or 0
				local r344= r341.w or r341[3] or (r305 - r342)
				local r345= r341.h or r341[4] or (r306 - r343)
				r333 = r342
				r334 = math.max(r342, r342 + r344 - self.w)
				r335 = r343
				r336 = math.max(r343, r343 + r345 - self.h)
			end
			r329 = r314(r329, r333, r334)
			r330 = r314(r330, r335, r336)
			self.x = r329; self.y = r330
			if self.snap and not r321.disable_snap then
				local r346= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and r304[p] then
							local r328= r304[p]
							local r347, r348= r328(r305,r306,self.w,self.h)
							table.insert(r346, {x=r347,y=r348})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(r346, {x=p[1], y=p[2]})
						end
					end
				else
					for k,r328 in pairs(r304) do
						local r347, r348= r328(r305,r306,self.w,self.h)
						table.insert(r346, {x=r347,y=r348})
					end
				end
				local r349= math.huge
				for _,r337 in ipairs(r346) do
					local r350= (r337.x - self.x)
					local r351= (r337.y - self.y)
					local r352= math.sqrt(r350*r350 + r351*r351)
					if r352 < r349 then r349 = r352 end
				end
				if r349 <= self.snap_threshold then r321.snap_target = 1 else r321.snap_target = 0 end
				local r353= math.floor(r305/2)
				local r354= math.floor(r306/2)
				local r338= math.floor(self.x + self.w/2)
				local r339= math.floor(self.y + self.h/2)
				if math.abs(r338 - r353) <= (self.line_snap_threshold or 6) then r321.line_snap_target_x = 1 else r321.line_snap_target_x = 0 end
				if math.abs(r339 - r354) <= (self.line_snap_threshold or 6) then r321.line_snap_target_y = 1 else r321.line_snap_target_y = 0 end
			end
		end

		local r355= false
		if r321.dragging then
			if r321.drag_button == 1 and not r331 and r321.last_left then r355 = true end
			if r321.drag_button == 2 and not r332 and r321.last_right then r355 = true end
		end
		if r355 then
			if not r321.disable_snap then
				local r353, r354= math.floor(r305/2), math.floor(r306/2)
				local r338= math.floor(self.x + self.w/2)
				local r339= math.floor(self.y + self.h/2)
				if self.show_screen_guides then
					if math.abs(r338 - r353) <= (self.line_snap_threshold or 6) then
						self.x = r353 - math.floor(self.w/2)
					end
					if math.abs(r339 - r354) <= (self.line_snap_threshold or 6) then
						self.y = r354 - math.floor(self.h/2)
					end
				end
			end
			r321.dragging = false
			local r356, r357= pcall(database.read, 'drag_positions')
			local r358= (r356 and type(r357) == 'table') and r357 or {}
			r358[self.id] = { x = self.x, y = self.y }
			pcall(function() database.write('drag_positions', r358) end)
			if self.snap and not r321.disable_snap then
				local r346= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and r304[p] then
							local r328= r304[p]
							local r347, r348= r328(r305,r306,self.w,self.h)
							table.insert(r346, {x=r347,y=r348, key=p})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(r346, {x=p[1], y=p[2], key=nil})
						end
					end
				else
					for k,r328 in pairs(r304) do
						local r347, r348= r328(r305,r306,self.w,self.h)
						table.insert(r346, {x=r347,y=r348, key=k})
					end
				end
				local r359, r349= nil, math.huge
				for _,r337 in ipairs(r346) do
					local r350= (r337.x - self.x)
					local r351= (r337.y - self.y)
					local r352= math.sqrt(r350*r350 + r351*r351)
					if r352 < r349 then r349 = r352; r359 = r337 end
				end
				if r359 and r349 <= self.snap_threshold then
					self.x = r359.x; self.y = r359.y
					r321.locked_to = r359.key
				end
			end
		end

		r321.last_left = r331
		r321.last_right = r332
	end

	function r320:draw()
		local r321= r302[self.id]
		if not r321 then return end
		if r321.dragging then
			local r340,r360,r341,r361= unpack(self.box_color)
			local r362,r363,r364,r365= unpack(self.align_color)
			local r366= globals.frametime() or 0.016
			local r367= math.min(1, 12 * r366)
			r321.snap_progress = r321.snap_progress + (r321.snap_target - r321.snap_progress) * r367
			r321.line_snap_progress_x = r321.line_snap_progress_x + (r321.line_snap_target_x - r321.line_snap_progress_x) * r367
			r321.line_snap_progress_y = r321.line_snap_progress_y + (r321.line_snap_target_y - r321.line_snap_progress_y) * r367
			local r368= math.floor(r340 + (0 - r340) * r321.snap_progress)
			local r369= math.floor(r360 + (0 - r360) * r321.snap_progress)
			local r370= math.floor(r341 + (0 - r341) * r321.snap_progress)
			local r371= math.floor(r361 + (200 - r361) * r321.snap_progress)
			renderer.rectangle(self.x, self.y, self.w, self.h, r368, r369, r370, r371)
			renderer.line(self.x, self.y, self.x + self.w, self.y, 200,200,200,150)
			renderer.line(self.x + self.w, self.y, self.x + self.w, self.y + self.h, 200,200,200,150)
			renderer.line(self.x + self.w, self.y + self.h, self.x, self.y + self.h, 200,200,200,150)
			renderer.line(self.x, self.y + self.h, self.x, self.y, 200,200,200,150)
			if self.show_alignment then
				local r305, r306= client.screen_size()
				if r305 and r306 then
					if self.show_screen_guides then
						local r353= math.floor(r305/2)
						local r354= math.floor(r306/2)
						local r338= math.floor(self.x + self.w/2)
						local r339= math.floor(self.y + self.h/2)
						local r372= math.abs(r338 - r353) <= (self.line_snap_threshold or 6)
						local r373= math.abs(r339 - r354) <= (self.line_snap_threshold or 6)
						local r374= math.floor(r365 * 0.35)
						renderer.line(r353, r354, 0, r354, r362,r363,r364, r374)
						renderer.line(r353, r354, r353, 0, r362,r363,r364, r374)
						renderer.line(r353, r354, r305, r354, r362,r363,r364, r374)
						renderer.line(r353, r354, r353, r306, r362,r363,r364, r374)
						local r375= math.floor(r365 * r321.line_snap_progress_x)
						local r376= math.floor(r365 * r321.line_snap_progress_y)
						if r375 > 0 then renderer.line(r353, 0, r353, r306, r362,r363,r364, r375) end
						if r376 > 0 then renderer.line(0, r354, r305, r354, r362,r363,r364, r376) end
					end
				end
			end
			if self.constraint_center then
				local r337= self.constraint_center
				local r338= r337.cx or math.floor((client.screen_size()) / 2)
				local r339= r337.cy or math.floor((client.screen_size()) / 2)
				local r340= r337.radius or 0
				local r342= r338 - r340
				local r343= r339 - r340
				local r344= r340 * 2
				local r345= r340 * 2
				renderer.rectangle(r342, r343, r344, r345, 255, 255, 255, 60)
				renderer.line(r342, r343, r342 + r344, r343, 255, 255, 255, 160)
				renderer.line(r342 + r344, r343, r342 + r344, r343 + r345, 255, 255, 255, 160)
				renderer.line(r342 + r344, r343 + r345, r342, r343 + r345, 255, 255, 255, 160)
				renderer.line(r342, r343 + r345, r342, r343, 255, 255, 255, 160)
			end
		end
	end

	return r320
end

function r301.get(r318)
	local r321= r302[r318]
	if not r321 then return nil end
	return r321.obj
end

function r301.ids()
	local r377= {}
	for k,_ in pairs(r302) do table.insert(r377, k) end
	return r377
end

return r301]]
r662["require/help/emojis"] = [[local r304= {

    chat = { "" },
    rewind = { "" },
    thumbsup = { "" },
    mail = { "U+E135" },
    square = { "" },
    square2 = { "" },
    square_hollow = { "" },
    play = { "" },
    pause = { "" },
    sun = { "" },
    pc = { "" },
    pc2 = { "" },
    phone = { "U+E1C9" },
    trash = { "" },
    reject = { "" },
    accept = { "" },
    config = { "" },
    config_write = { "U+E28F" },
    gear = { "" },
    arrow_right = { "" },
    arrow_left = { "" },
    arrow_up = { "" },
    arrow_down = { "" },
    star = { "U+E0B4" },
    minus = { "" },
    plus = { "" },
    plus_in_brackets = { "U+E0C5" },
    pen = { "" },
    recycle = { "" },
    camera = { "" },
    download = { "" },
    upload = { "" },
    question = { "" },
    search = { "" },
    globe = { "" },
    globe2 = { "" },
    id = { "" },
    phone = { "" },
    user = { "" },
    user2 = { "U+E2AF" },
    user3 = { "U+E13D" },
    users = { "" },
    users2 = { "U+E125" },
    user_no = { "U+E1E0" },
    pin = { "" },
    unpin = { "U+E196" },
    windows = { "" },
    turning = { "" },
    turning2 = { "" },
    arrow_double = { "" },
    clip = { "" },
    clipboard = { "U+E16D" },
    exclamation = { "" },
    time = { "" },
    clock = { "U+E2AD" },
    paper = { "" },
    paper2 = { "" },
    link = { "" },
    link2 = { "U+E167" },
    wrench = { "" },
    url = { "" },
    speaker = { "" },
    house = { "" },
    pallete = { "" },
    lock = { "" },
    lock_open = { "" },
    tsarrow_left = { "" },
    tsarrow_right = { "" },
    tsarrow_up = { "" },
    tsarrow_up = { "" },
    warning = { "⚠︎" },
    video = { "" },
    connection = { "" },
    heart = { "" },
    triangle_upside = { "⛛" },
    music_note = { "U+E142" },
    test = { "U+E2B1" },
    keyboard = { "U+E0D2" },
    latency0 = { "U+E1E5" },
    latency1 = { "U+E1E6" },
    latency2 = { "U+E1E7" },
    latency3 = { "U+E1E8" },
    latency4 = { "U+E1E9" },
    expand = { "U+E1D9" },
    monitor = { "U+E2F0" },
    rain = { "U+E28A" },
    likedislike = { "U+E19D" },
    text = { "U+E1C8" },
    back = { "U+E10E" },
    folder = { "U+E1C1" },
    menu = { "U+E179" },
    menu2 = { "U+E1A0" },
    at = { "U+E168" },
    circle = { "U+E235" },
    updown = { "U+E174" },

}

local r305= {}

local function r306(r307)
    if r307 == nil then return "ERROR" end
    if type(r307) ~= "string" then r307 = tostring(r307) end
    if r307 == "ERROR" then return "ERROR" end
    local r308= r307:match('^U%+([0-9A-Fa-f]+)$') or r307:match('^u%+([0-9A-Fa-f]+)$') or r307:match('^0x([0-9A-Fa-f]+)$')
    if r308 then
        local r309= tonumber(r308, 16)
        if r309 then
            local r310= nil
            if type(utf8) == 'table' and type(utf8.char) == 'function' then
                pcall(function() r310 = utf8.char(r309) end)
            end
            if not r310 then
                local function r311(r312)
                    if r312 < 0x80 then return string.char(r312) end
                    if r312 < 0x800 then return string.char(0xC0 + math.floor(r312 / 0x40), 0x80 + (r312 % 0x40)) end
                    if r312 < 0x10000 then return string.char(0xE0 + math.floor(r312 / 0x1000), 0x80 + (math.floor(r312 / 0x40) % 0x40), 0x80 + (r312 % 0x40)) end
                    if r312 < 0x110000 then return string.char(0xF0 + math.floor(r312 / 0x40000), 0x80 + (math.floor(r312 / 0x1000) % 0x40), 0x80 + (math.floor(r312 / 0x40) % 0x40), 0x80 + (r312 % 0x40)) end
                    return '?'
                end
                r310 = r311(r309)
            end
            r307 = r310 or r307
        end
    end
    if r307:sub(-1) == " " then return r307 end
    return r307 .. " "
end

function r305.get(r313,r314,r315)
    if not r313 then return "ERROR" end
    local r316= r304[r313]
    if r316 == nil then return "ERROR" end
    if type(r316) == "string" then return r306(r316) end
    if type(r316) == "table" then
        if r315 == nil then
            return r306(r316[1])
        end
        local r317= tonumber(r315) or 1
        return r306(r316[r317])
    end
    return "ERROR"
end

function r305.set(r313,r318)
	if not r313 then return false end
	if type(r318) == "string" then
		r304[r313] = { r318 }
	else
		r304[r313] = r318
	end
	return true
end

function r305.list()
	local r319= {}
	for k, r316 in pairs(r304) do
		if type(r316) == "table" then
			local r320= {}
			for r317 = 1, #r316 do r320[r317] = r316[r317] end
			r319[k] = r320
		else
			r319[k] = r316
		end
	end
	return r319
end

setmetatable(r305, {
    __index = function(r321,r322)
        local r316= r304[r322]
        if r316 == nil then return "ERROR" end
        if type(r316) == "table" then return r306(r316[1]) end
        return r306(r316)
    end,
})

return r305]]
r662["require/help/enemies"] = [[local r307= {}

local r308= entity
local r309= client
local r310= globals

function r307.list()
    return r308 and r308.get_players and r308.get_players(true) or {}
end

function r307.is_alive(r311)
    return r311 and r308.is_alive and r308.is_alive(r311) or false
end

function r307.is_dormant(r311)
    return r311 and r308.is_dormant and r308.is_dormant(r311) or false
end

function r307.player_name(r311)
    return r311 and r308.get_player_name and r308.get_player_name(r311) or nil
end

function r307.steam64(r311)
    return r311 and r308.get_steam64 and r308.get_steam64(r311) or nil
end

function r307.health(r311)
    return r311 and r308.get_prop and r308.get_prop(r311, 'm_iHealth') or 0
end

function r307.current_threat()
    return r309 and r309.current_threat and r309.current_threat() or nil
end

local r312= {}

function r307.is_afk(r311,r313,r314)
    r313 = r313 or 5
    r314 = r314 or 20
    local r315, r316, r317= r308.get_prop(r311, 'm_vecVelocity')
    local r318= 0
    if r315 and r316 and r317 then
        r318 = math.sqrt(r315 * r315 + r316 * r316 + r317 * r317)
    end
    local r319= r310 and r310.realtime and r310.realtime() or os.clock()
    if not r312[r311] then
        r312[r311] = { last_active = r319, last_check = r319 }
    end
    if r318 >= r313 then
        r312[r311].last_active = r319
    end
    r312[r311].last_check = r319
    return (r319 - r312[r311].last_active) > r314
end

function r307.distance(r311,r320)
    if not r311 or not r308.get_origin then return nil end
    local r321, r322, r323= r308.get_origin(r311)
    if not r321 then return nil end
    if not r320 then
        r320 = r308.get_local_player and r308.get_local_player()
    end
    local r324, r325, r326= r308.get_origin(r320)
    if not r324 then return nil end
    local r327, r328, r329= r321 - r324, r322 - r325, r323 - r326
    return math.sqrt(r327 * r327 + r328 * r328 + r329 * r329)
end


local function r330(r331)
    if not r331 then return "" end
    return tostring(r331):lower()
end

local function r332(r333)
    local r334= ""
    if r333 and r308.get_classname then r334 = r308.get_classname(r333) or "" end
    if r334 == "" and r333 and r309.get_model_name then
        r334 = r309.get_model_name(r333) or ""
    end
    return r330(r334)
end

function r307.has_knife(r311)
    if not r311 or not r308.get_player_weapon then return false end
    local r333= r308.get_player_weapon(r311)
    if not r333 then return false end
    local r335= r332(r333)
    return r335:find('knife') ~= nil
end

function r307.has_nade(r311)
    if not r311 or not r308.get_player_weapon then return false end
    local r333= r308.get_player_weapon(r311)
    if not r333 then return false end
    local r335= r332(r333)
    local r336= {'grenade', 'hegrenade', 'flashbang', 'smoke', 'molotov', 'incendiary', 'decoy', 'frag', 'nade'}
    for i = 1, #r336 do
        if r335:find(r336[i]) then return true end
    end
    return false
end

function r307.has_taser(r311)
    if not r311 or not r308.get_player_weapon then return false end
    local r333= r308.get_player_weapon(r311)
    if not r333 then return false end
    local r335= r332(r333)
    return r335:find('taser') ~= nil or r335:find('zeus') ~= nil
end

return r307]]
r662["require/help/ffi"] = [[local r310= rawget(_G, 'ffi')
local r311= {}

function r311.available()
  return r310 ~= nil
end

function r311.cdef(r312)
  if not r310 then error('ffi not available') end
  return r310.cdef(r312)
end

function r311.typeof(r313)
  if not r310 then error('ffi not available') end
  return r310.typeof(r313)
end

function r311.new(r313,...)
  if not r310 then error('ffi not available') end
  return r310.new(r313, ...)
end

function r311.cast(r313,r314)
  if not r310 then error('ffi not available') end
  return r310.cast(r313, r314)
end

function r311.string(r315,r316)
  if not r310 then error('ffi not available') end
  return r310.string(r315, r316)
end

function r311.copy(r317,r318,r316)
  if not r310 then error('ffi not available') end
  return r310.copy(r317, r318, r316)
end

function r311.fill(r317,r319,r316)
  if not r310 then error('ffi not available') end
  return r310.fill(r317, r319, r316)
end

function r311.sizeof(r313)
  if not r310 then error('ffi not available') end
  return r310.sizeof(r313)
end

function r311.alignof(r313)
  if not r310 then error('ffi not available') end
  return r310.alignof(r313)
end

function r311.errno()
  if not r310 then error('ffi not available') end
  return r310.errno()
end

function r311.gc(r315,r320)
  if not r310 then error('ffi not available') end
  return r310.gc(r315, r320)
end

function r311.load(r321,r322)
  if not r310 then error('ffi not available') end
  return r310.load(r321, r322)
end

function r311.metatype(r313,r323)
  if not r310 then error('ffi not available') end
  return r310.metatype(r313, r323)
end

function r311.offsetof(r313,r324)
  if not r310 then error('ffi not available') end
  return r310.offsetof(r313, r324)
end

function r311.istype(r313,r314)
  if not r310 then error('ffi not available') end
  return r310.istype(r313, r314)
end

r311.raw = r310

return r311]]
r662["require/help/globals"] = [[local r313= {}

r313.raw = globals

function r313.absoluteframetime()
  return globals.absoluteframetime()
end

function r313.chokedcommands()
  return globals.chokedcommands()
end

function r313.commandack()
  return globals.commandack()
end

function r313.curtime()
  return globals.curtime()
end

function r313.framecount()
  return globals.framecount()
end

function r313.frametime()
  return globals.frametime()
end

function r313.lastoutgoingcommand()
  return globals.lastoutgoingcommand()
end

function r313.mapname()
  return globals.mapname()
end

function r313.maxplayers()
  return globals.maxplayers()
end

function r313.oldcommandack()
  return globals.oldcommandack()
end

function r313.realtime()
  return globals.realtime()
end

function r313.servertickcount()
  return globals.servertickcount()
end

function r313.tickcount()
  return globals.tickcount()
end

function r313.tickinterval()
  return globals.tickinterval()
end

return r313]]
r662["require/help/json"] = [[local r316= rawget(_G, 'json')
local r317= {}

function r317.available()
  return r316 ~= nil
end

function r317.decode_invalid_numbers(r318)
  if not r316 then error('json not available') end
  if r318 == nil then
    return r316.decode_invalid_numbers()
  end
  return r316.decode_invalid_numbers(r318)
end

function r317.decode_max_depth(r319)
  if not r316 then error('json not available') end
  if r319 == nil then
    return r316.decode_max_depth()
  end
  return r316.decode_max_depth(r319)
end

function r317.encode_invalid_numbers(r318)
  if not r316 then error('json not available') end
  if r318 == nil then
    return r316.encode_invalid_numbers()
  end
  return r316.encode_invalid_numbers(r318)
end

function r317.encode_max_depth(r319)
  if not r316 then error('json not available') end
  if r319 == nil then
    return r316.encode_max_depth()
  end
  return r316.encode_max_depth(r319)
end

function r317.encode_number_precision(r320)
  if not r316 then error('json not available') end
  if r320 == nil then
    return r316.encode_number_precision()
  end
  return r316.encode_number_precision(r320)
end

function r317.encode_sparse_array(...)
  if not r316 then error('json not available') end
  return r316.encode_sparse_array(...)
end

function r317.parse(r321)
  if not r316 then error('json not available') end
  if r316.parse then
    return r316.parse(r321)
  end
  if r316.decode then
    return r316.decode(r321)
  end
  error('json.parse / json.decode not available')
end

function r317.stringify(r322)
  if not r316 then error('json not available') end
  if r316.stringify then
    return r316.stringify(r322)
  end
  if r316.encode then
    return r316.encode(r322)
  end
  error('json.stringify / json.encode not available')
end

r317.raw = r316

return r317]]
r662["require/help/libs"] = [[local function r319(r320)
	local r321, r322= pcall(require, r320)
	return r321 and r322 or nil
end

local r323= {
	antiaim_funcs   = 'gamesense/antiaim_funcs',
	base64          = 'gamesense/base64',
	clipboard       = 'gamesense/clipboard',
	http            = 'gamesense/http',
	csgo_weapons    = 'gamesense/csgo_weapons',
	icons           = 'gamesense/icons',
	entity          = 'gamesense/entity',
	vector          = 'vector',
	bit             = 'bit',
	ffi             = 'ffi',
	pui             = 'gamesense/pui',
	trace           = 'gamesense/trace',
	md5             = 'gamesense/md5',
	websocket       = 'gamesense/websocket',
	surface         = 'gamesense/surface',
	color           = 'gamesense/color',
}

local r324= {}
for k, v in pairs(r323) do
	r324[k] = r319(v)
end

local r325= {
	antiaim_funcs = {
		get_tickbase_shifting = "Returns true if tickbase shifting is active.",
		get_fake_lag = "Returns current fake lag value.",
		get_desync = "Returns current desync value.",
		get_manual_direction = "Returns manual anti-aim direction.",
		get_antiaim_condition = "Returns current anti-aim condition.",
		get_body_yaw = "Returns current body yaw value.",
		get_yaw_base = "Returns current yaw base value.",
		get_pitch = "Returns current pitch value.",
		get_yaw_jitter = "Returns current yaw jitter value.",
		get_enabled = "Returns if anti-aim is enabled.",
		get_fakelag_mode = "Returns fakelag mode.",
		get_fakelag_limit = "Returns fakelag limit.",
		get_fakelag_variance = "Returns fakelag variance.",
		get_fakelag_enabled = "Returns if fakelag is enabled.",
		get_double_tap = "Returns true if double tap exploit is active.",
		get_overlap = "Returns overlap value (exploit related).",
	},
	base64 = {
		encode = "Encodes a string to base64.",
		decode = "Decodes a base64 string.",
	},
	clipboard = {
		get = "Gets clipboard contents as string.",
		set = "Sets clipboard contents to string.",
	},
	http = {
		get = "Performs HTTP GET request.",
		post = "Performs HTTP POST request.",
		download = "Downloads a file from URL.",
	},
	csgo_weapons = {
		get_weapon_name = "Returns weapon name by id.",
		get_weapon_id = "Returns weapon id by name.",
		get_weapon_type = "Returns weapon type by id.",
		get_weapon_group = "Returns weapon group by id.",
		get_weapon_slot = "Returns weapon slot by id.",
		get_weapon_price = "Returns weapon price by id.",
	},
	icons = {
		hero = "Table of hero icons.",
		get_texture = "Returns texture id for icon name.",
		get_icon = "Returns icon object by name.",
		get_all_icons = "Returns all available icons.",
	},
	entity = {
		get_local_player = "Returns entindex of local player.",
		get_all = "Returns array of entindices for all entities.",
		get_players = "Returns array of player entindices.",
		get_game_rules = "Returns entindex of game rules proxy.",
		get_player_resource = "Returns entindex of player resource.",
		get_classname = "Returns classname of entity.",
		set_prop = "Sets netvar property.",
		get_prop = "Gets netvar property.",
		is_enemy = "Returns true if entity is enemy.",
		is_alive = "Returns true if entity is alive.",
		is_dormant = "Returns true if entity is dormant.",
		get_player_name = "Returns player name.",
		get_player_weapon = "Returns active weapon entindex.",
		hitbox_position = "Returns world position of hitbox.",
		get_steam64 = "Returns SteamID3.",
		get_bounding_box = "Returns bounding box coordinates.",
		get_origin = "Returns world origin of entity.",
		get_esp_data = "Returns ESP data for player.",
	},
	vector = {
		new = "Creates a new vector object.",
		dot = "Returns dot product of two vectors.",
		cross = "Returns cross product of two vectors.",
		length = "Returns length of vector.",
		normalize = "Normalizes vector.",
		add = "Adds two vectors.",
		sub = "Subtracts two vectors.",
		mul = "Multiplies vector by scalar.",
		div = "Divides vector by scalar.",
		dist = "Returns distance between two vectors.",
	},
	bit = {
		arshift = "Arithmetic right shift.",
		band = "Bitwise AND.",
		bnot = "Bitwise NOT.",
		bor = "Bitwise OR.",
		bswap = "Byte swap (endian conversion).",
		bxor = "Bitwise XOR.",
		lshift = "Logical left shift.",
		rol = "Bitwise left rotation.",
		ror = "Bitwise right rotation.",
		rshift = "Logical right shift.",
		tobit = "Normalize to 32-bit signed.",
		tohex = "Convert to hexadecimal string.",
	},
	ffi = {
		cdef = "Define C types/functions.",
		cast = "Cast value to C type.",
		new = "Allocate new C object.",
		typeof = "Get C type object.",
		string = "Convert C data to Lua string.",
	},
	pui = {
		create_panel = "Creates a custom UI panel.",
		add_icon = "Adds an icon to a panel.",
		set_icon = "Sets the icon for a panel.",
		set_panel_visible = "Shows/hides a panel.",
		set_panel_position = "Sets panel position.",
		set_panel_size = "Sets panel size.",
	},
	trace = {
		trace_line = "Performs a line trace.",
		trace_bullet = "Performs a bullet trace.",
		trace_hull = "Performs a hull trace.",
	},
	md5 = {
		sumhexa = "Returns MD5 hash as hex string.",
		sum = "Returns MD5 hash as raw bytes.",
	},
	websocket = {
		connect = "Connects to a WebSocket server.",
		send = "Sends data over WebSocket.",
		close = "Closes the WebSocket connection.",
		on_message = "Callback for incoming messages.",
	},
	surface = {
		text = "Draws text on screen.",
		rectangle = "Draws a rectangle.",
		line = "Draws a line.",
		circle = "Draws a circle.",
		gradient = "Draws a gradient rectangle.",
		load_texture = "Loads a texture from file.",
	},
	color = {
		blend = "Blends two colors.",
		lighten = "Lightens a color.",
		darken = "Darkens a color.",
		hex_to_rgba = "Converts hex to RGBA.",
		rgba_to_hex = "Converts RGBA to hex.",
	},
}

local function r326(r320)
	return r324[r320]
end

function r327()
	local r328= {}
	for k, v in pairs(_G) do
		if type(v) == "table" or type(v) == "userdata" then
			r328[#r328+1] = k
		end
	end
	return r328
end

function r329(r330)
	local r331= r325[r330]
	if not r331 then return {} end
	local r328= {}
	for k, v in pairs(r331) do
		r328[#r328+1] = k .. " - " .. v
	end
	return r328
end

return {
	get = r326,
	list = r327,
	list_features = r329,
	features = r325,
	libs = r324,
	lib_defs = r323
}
]]
r662["require/help/math"] = [[local r322= {}

function r322.clamp(r323,r324,r325)
    if not r324 and not r325 then return r323 end
    r324 = tonumber(r324) or 0
    r325 = tonumber(r325) or r324
    if r324 > r325 then r324, max = r325, r324 end
    r323 = tonumber(r323) or r324
    if r323 < r324 then return r324 end
    if r323 > r325 then return r325 end
    return r323
end

function r322.clamp01(r323)
    return r322.clamp(r323, 0, 1)
end

function r322.abs(r323)
    r323 = tonumber(r323) or 0
    return math.abs(r323)
end

function r322.max(...)
    local r326= {...}
    if #r326 == 0 then return 0 end
    local r327= nil
    for i = 1, #r326 do
        local r328= tonumber(r326[i]) or 0
        if r327 == nil or r328 > r327 then r327 = r328 end
    end
    return r327
end

function r322.min(...)
    local r326= {...}
    if #r326 == 0 then return 0 end
    local r327= nil
    for i = 1, #r326 do
        local r328= tonumber(r326[i]) or 0
        if r327 == nil or r328 < r327 then r327 = r328 end
    end
    return r327
end

function r322.atan2(r329,r330)
    r329 = tonumber(r329) or 0
    r330 = tonumber(r330) or 0
    return math.atan(r329, r330)
end

function r322.floor(r323)
    r323 = tonumber(r323) or 0
    return math.floor(r323)
end

function r322.round(r323,r331)
    r323 = tonumber(r323) or 0
    r331 = tonumber(r331) or 0
    local r332= 10 ^ r331
    return math.floor(r323 * r332 + 0.5) / r332
end

function r322.lerp(r333,r334,r335)
    r333 = tonumber(r333) or 0
    r334 = tonumber(r334) or 0
    r335 = tonumber(r335) or 0
    return r333 + (r334 - r333) * r335
end

function r322.distance2d(r336,r337,r338,r339)
    r336 = tonumber(r336) or 0
    r337 = tonumber(r337) or 0
    r338 = tonumber(r338) or 0
    r339 = tonumber(r339) or 0
    return math.sqrt((r338 - r336)^2 + (r339 - r337)^2)
end

function r322.distance3d(r336,r337,r340,r338,r339,r341)
    r336 = tonumber(r336) or 0
    r337 = tonumber(r337) or 0
    r340 = tonumber(r340) or 0
    r338 = tonumber(r338) or 0
    r339 = tonumber(r339) or 0
    r341 = tonumber(r341) or 0
    return math.sqrt((r338 - r336)^2 + (r339 - r337)^2 + (r341 - r340)^2)
end

function r322.sign(r323)
    r323 = tonumber(r323) or 0
    return (r323 > 0 and 1) or (r323 < 0 and -1) or 0
end

function r322.frac(r323)
    r323 = tonumber(r323) or 0
    return r323 - math.floor(r323)
end

function r322.is_even(r323)
    r323 = tonumber(r323) or 0
    return r323 % 2 == 0
end

function r322.is_odd(r323)
    r323 = tonumber(r323) or 0
    return r323 % 2 ~= 0
end

function r322.sqr(r323)
    r323 = tonumber(r323) or 0
    return r323 * r323
end

function r322.cube(r323)
    r323 = tonumber(r323) or 0
    return r323 * r323 * r323
end

function r322.approximately(r333,r334,r342)
    r333 = tonumber(r333) or 0
    r334 = tonumber(r334) or 0
    r342 = tonumber(r342) or 1e-6
    return math.abs(r333 - r334) < r342
end

function r322.rad_to_deg(r343)
    r343 = tonumber(r343) or 0
    return r343 * (180 / math.pi)
end

function r322.deg_to_rad(r344)
    r344 = tonumber(r344) or 0
    return r344 * (math.pi / 180)
end

function r322.wrap_degrees(r345)
    local r333= tonumber(r345) or 0
    r333 = r333 % 360
    if r333 < 0 then r333 = r333 + 360 end
    return r333
end

function r322.normalize_angle(r345)
    local r333= tonumber(r345) or 0
    r333 = r333 % 360
    if r333 > 180 then r333 = r333 - 360 end
    return r333
end

function r322.angle_diff(r333,r334)
    r333 = tonumber(r333) or 0
    r334 = tonumber(r334) or 0
    local r346= (r333 - r334) % 360
    if r346 > 180 then r346 = r346 - 360 end
    return r346
end

function r322.lerp_angle(r333,r334,r335)
    r333 = tonumber(r333) or 0
    r334 = tonumber(r334) or 0
    r335 = tonumber(r335) or 0
    local r346= r322.angle_diff(r334, r333)
    return (r333 + r346 * r335) % 360
end

function r322.map(r323,r347,r348,r349,r350)
    r323 = tonumber(r323) or 0
    r347 = tonumber(r347) or 0
    r348 = tonumber(r348) or r347
    r349 = tonumber(r349) or 0
    r350 = tonumber(r350) or r349
    if r348 == r347 then return r349 end
    return (r323 - r347) * (r350 - r349) / (r348 - r347) + r349
end

function r322.smoothstep(r351,r352,r330)
    r351 = tonumber(r351) or 0
    r352 = tonumber(r352) or r351
    r330 = tonumber(r330) or 0
    if r352 == r351 then return 0 end
    local r335= r322.clamp((r330 - r351) / (r352 - r351), 0, 1)
    return r335 * r335 * (3 - 2 * r335)
end

function r322.random_float(r324,r325)
    r324 = tonumber(r324) or 0
    r325 = tonumber(r325) or r324
    if r324 > r325 then r324, max = r325, r324 end
    return r324 + math.random() * (r325 - r324)
end

function r322.random_int(r324,r325)
    r324 = tonumber(r324) or 0
    r325 = tonumber(r325) or r324
    if r324 > r325 then r324, max = r325, r324 end
    return math.random(r324, r325)
end

function r322.mean(r353)
    if type(r353) ~= 'table' or #r353 == 0 then return 0 end
    local r354= 0
    for i = 1, #r353 do r354 = r354 + (tonumber(r353[i]) or 0) end
    return r354 / #r353
end

function r322.swap(r333,r334)
    return r334, r333
end

return r322]]
r662["require/help/panorama"] = [[local r325= {}

r325.raw = panorama

function r325.loadstring(r326,r327)
  return panorama.loadstring(r326, r327)
end

function r325.open(r327)
  return panorama.open(r327)
end

return r325]]
r662["require/help/plist"] = [[local r328= {}

r328.raw = plist

function r328.get(r329,r330)
  return plist.get(r329, r330)
end

function r328.set(r329,r330,r331)
  return plist.set(r329, r330, r331)
end

return r328]]
r662["require/help/reference"] = [[local r331= {}

r331.known_items = {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

function r331.add_known(r332)
    for _, it in ipairs(r332 or {}) do
        table.insert(r331.known_items, it)
    end
end

function r331.get(r333,r334,r335)
    return ui.reference(r333, r334, r335)
end

function r331.build(r336)
    local r337= {}
    local r338= {}
    for i, item in ipairs(r336) do
        local r339= {ui.reference(item[1], item[2], item[3])}
        r337[i] = r339
        for _, ref in ipairs(r339) do
            if ref ~= nil then
                r338[ref] = true
            end
        end
    end
    return r337, r338
end

function r331.build_known()
    return r331.build(r331.known_items)
end

function r331.get_all_known()
    return r331.known_items
end

return r331]]
r662["require/help/references_old"] = [[

local r334= {}

local function r335(r336)
    
    if type(r336) ~= 'table' then
        local r337= r336
        return {
            raw = r337,
            get = function()
                local r338, r339= pcall(ui.get, r337)
                if r338 then return r339 end
                return nil
            end
        }
    end

    
    
    
    local r340= r336
    return {
        raw = r340,
        get = function()
            if r340[2] ~= nil then
                local r338, r339= pcall(ui.get, r340[2])
                if r338 then return r339 end
            end
            if r340[1] ~= nil then
                local r338, r339= pcall(ui.get, r340[1])
                if r338 then return r339 end
            end
            return nil
        end
    }
end


r334.minimum_damage = r335(ui.reference("RAGE", "Aimbot", "Minimum damage"))
r334.minimum_damage_override = r335({ ui.reference("RAGE", "Aimbot", "Minimum damage override") })
r334.doubletap = r335({ ui.reference("RAGE", "Aimbot", "Double tap") })
r334.force_body_aim = r335({ ui.reference("RAGE", "Aimbot", "Force body aim") })
r334.force_safe_point = r335({ ui.reference("RAGE", "Aimbot", "Force safe point") })
r334.duck_peek_assist = r335({ ui.reference("RAGE", "Other", "Duck peek assist") })
r334.quick_peek_assist = r335({ ui.reference("RAGE", "Aimbot", "Quick peek assist") })


r334.pitch = r335(ui.reference("AA", "Anti-aimbot angles", "Pitch"))
r334.yaw_base = r335(ui.reference("AA", "Anti-aimbot angles", "Yaw base"))
r334.yaw = r335(ui.reference("AA", "Anti-aimbot angles", "Yaw"))
r334.yaw_jitter = r335(ui.reference("AA", "Anti-aimbot angles", "Yaw jitter"))
r334.body_yaw = r335(ui.reference("AA", "Anti-aimbot angles", "Body yaw"))
r334.roll = r335(ui.reference("AA", "Anti-aimbot angles", "Roll"))

return r334]]
r662["require/help/renderer"] = [[local r337= {}

r337.raw = renderer

function r337.blur(r338,r339,r340,r341,r342,r343)
  return renderer.blur(r338, r339, r340, r341, r342, r343)
end

function r337.circle(r338,r339,r344,r345,r346,r347,r348,r349,r350)
  return renderer.circle(r338, r339, r344, r345, r346, r347, r348, r349, r350)
end

function r337.circle_outline(r338,r339,r344,r345,r346,r347,r348,r349,r350,r351)
  return renderer.circle_outline(r338, r339, r344, r345, r346, r347, r348, r349, r350, r351)
end

function r337.gradient(r338,r339,r340,r341,r352,r353,r354,r355,r356,r357,r358,r359,r360)
  return renderer.gradient(r338, r339, r340, r341, r352, r353, r354, r355, r356, r357, r358, r359, r360)
end

function r337.indicator(r344,r345,r346,r347,...)
  return renderer.indicator(r344, r345, r346, r347, ...)
end

function r337.line(r361,r362,r363,r364,r344,r345,r346,r347)
  return renderer.line(r361, r362, r363, r364, r344, r345, r346, r347)
end

function r337.load_jpg(r365,r366,r367)
  return renderer.load_jpg(r365, r366, r367)
end

function r337.load_png(r365,r366,r367)
  return renderer.load_png(r365, r366, r367)
end

function r337.load_rgba(r365,r366,r367)
  return renderer.load_rgba(r365, r366, r367)
end

function r337.load_svg(r365,r366,r367)
  return renderer.load_svg(r365, r366, r367)
end

function r337.measure_text(r368,...)
  return renderer.measure_text(r368, ...)
end

function r337.rectangle(r338,r339,r340,r341,r344,r345,r346,r347)
  return renderer.rectangle(r338, r339, r340, r341, r344, r345, r346, r347)
end

function r337.text(r338,r339,r344,r345,r346,r347,r368,r369,...)
  return renderer.text(r338, r339, r344, r345, r346, r347, r368, r369, ...)
end

function r337.texture(r370,r338,r339,r340,r341,r344,r345,r346,r347,r371)
  return renderer.texture(r370, r338, r339, r340, r341, r344, r345, r346, r347, r371)
end

function r337.triangle(r361,r362,r363,r364,r372,r373,r344,r345,r346,r347)
  return renderer.triangle(r361, r362, r363, r364, r372, r373, r344, r345, r346, r347)
end

function r337.world_to_screen(r338,r339,r374)
  return renderer.world_to_screen(r338, r339, r374)
end

function r337.rectangle_outline(r338,r339,r340,r341,r344,r345,r346,r347,r351)
  r351 = r351 or 1
  for i = 0, r351 - 1 do
    renderer.line(r338 + i, r339 + i, r338 + r340 - i, r339 + i, r344, r345, r346, r347)
    renderer.line(r338 + i, r339 + r341 - i, r338 + r340 - i, r339 + r341 - i, r344, r345, r346, r347)
    renderer.line(r338 + i, r339 + i, r338 + i, r339 + r341 - i, r344, r345, r346, r347)
    renderer.line(r338 + r340 - i, r339 + i, r338 + r340 - i, r339 + r341 - i, r344, r345, r346, r347)
  end
end

function r337.text_centered(r338,r339,r344,r345,r346,r347,r368,r369,...)
  local r340, r341= renderer.measure_text(r368, ...)
  if not r340 or not r341 then return end
  return renderer.text(r338 - r340 / 2, r339 - r341 / 2, r344, r345, r346, r347, r368, r369, ...)
end

function r337.texture_from_file(r375)
  local r365= readfile(r375)
  if not r365 then return nil end
  local r370= renderer.load_png(r365)
  if not r370 then
    r370 = renderer.load_jpg(r365)
  end
  return r370
end

return r337]]
r662["require/help/safe"] = [[local r340= {}

function r340.safe_call(r341,...)
	local r342, r343= pcall(r341, ...)
	return r342 and r343 or nil
end

function r340.safe_set(r344,r345)
	local r342= pcall(function() ui.set(r344, r345) end)
	return r342
end

function r340.safe_get(r344)
	local r342, r343= pcall(function() return ui.get(r344) end)
	return r342 and r343 or nil
end

return r340]]
r662["require/help/self"] = [[local r343= {}

local r344= entity
local r345= globals
local r346= client

function r343.index()
	return r344 and r344.get_local_player and r344.get_local_player() or nil
end

function r343.exists()
	return r343.index() ~= nil
end

function r343.is_alive()
	local r347= r343.index()
	return r347 and r344.is_alive and r344.is_alive(r347) or false
end

function r343.health()
	local r347= r343.index()
	return r347 and r344.get_prop and r344.get_prop(r347, 'm_iHealth') or 0
end

function r343.ping()
	return r346 and r346.latency and r346.latency() or 0
end

function r343.velocity()
	local r347= r343.index()
	if not r347 or not r344.get_prop then return 0 end
	local r348, r349, r350= r344.get_prop(r347, 'm_vecVelocity')
	if r348 and r349 and r350 then
		return math.sqrt(r348 * r348 + r349 * r349 + r350 * r350)
	end
	return 0
end

function r343.velocity2d()
	local r347= r343.index()
	if not r347 or not r344.get_prop then return 0 end
	local r348, r349= r344.get_prop(r347, 'm_vecVelocity')
	if r348 and r349 then
		return math.sqrt(r348 * r348 + r349 * r349)
	end
	return 0
end

function r343.weapon()
	local r347= r343.index()
	return r347 and r344.get_player_weapon and r344.get_player_weapon(r347) or nil
end

function r343.tickbase_shifted()
	
	return false
end

function r343.simtime()
	local r347= r343.index()
	return r347 and r344.get_prop and r344.get_prop(r347, 'm_flSimulationTime') or 0
end

function r343.eye_angles()
	return r346 and r346.camera_angles and r346.camera_angles() or nil
end

function r343.fps()
	local r351= r345 and r345.absoluteframetime and r345.absoluteframetime() or r345.frametime and r345.frametime() or 0.01
	if r351 > 0 then
		return math.floor(1 / r351 + 0.5)
	end
	return 0
end

function r343.map()
	return r345 and r345.mapname and r345.mapname() or nil
end

function r343.is_dormant()
	local r347= r343.index()
	return r347 and r344.is_dormant and r344.is_dormant(r347) or false
end

function r343.team_number()
	local r347= r343.index()
	return r347 and r344.get_prop and r344.get_prop(r347, 'm_iTeamNum') or 0
end

function r343.player_name()
	local r347= r343.index()
	return r347 and r344.get_player_name and r344.get_player_name(r347) or nil
end

function r343.steam64()
	local r347= r343.index()
	return r347 and r344.get_steam64 and r344.get_steam64(r347) or nil
end

function r343.ammo_count()
	local r352= r343.weapon()
	return r352 and r344.get_prop and r344.get_prop(r352, 'm_iClip1') or 0
end

function r343.has_armor()
	local r347= r343.index()
	return r347 and r344.get_prop and r344.get_prop(r347, 'm_ArmorValue') > 0 or false
end

function r343.has_helmet()
	local r347= r343.index()
	return r347 and r344.get_prop and r344.get_prop(r347, 'm_bHasHelmet') == 1 or false
end

function r343.current_tick()
	return r345 and r345.tickcount and r345.tickcount() or 0
end

function r343.tick_interval()
	return r345 and r345.tickinterval and r345.tickinterval() or 0
end

function r343.current_frame()
	return r345 and r345.framecount and r345.framecount() or 0
end

function r343.current_time()
	return r345 and r345.curtime and r345.curtime() or 0
end

function r343.real_latency()
	return r346 and r346.real_latency and r346.real_latency() or 0
end

function r343.system_time()
	return r346 and r346.system_time and r346.system_time() or {0,0,0,0}
end

function r343.unix_time()
	return r346 and r346.unix_time and r346.unix_time() or 0
end

function r343.kills()
	local r347= r343.index()
	if not r347 or not r344.get_prop then return 0 end
	local r353= r344.get_player_resource and r344.get_player_resource()
	if r353 then
		return r344.get_prop(r353, 'm_iKills', r347) or 0
	end
	return 0
end

function r343.deaths()
	local r347= r343.index()
	if not r347 or not r344.get_prop then return 0 end
	local r353= r344.get_player_resource and r344.get_player_resource()
	if r353 then
		return r344.get_prop(r353, 'm_iDeaths', r347) or 0
	end
	return 0
end

function r343.assists()
	local r347= r343.index()
	if not r347 or not r344.get_prop then return 0 end
	local r353= r344.get_player_resource and r344.get_player_resource()
	if r353 then
		return r344.get_prop(r353, 'm_iAssists', r347) or 0
	end
	return 0
end

return r343
]]
r662["require/help/string"] = [[local r346= {}

function r346.lower(r347)
	return string.lower(r347)
end

function r346.upper(r347)
	return string.upper(r347)
end

function r346.capitalize(r347)
	return (r347:gsub("^%l", string.upper):gsub("^(%u)(.*)", function(r348,r349) return r348 .. string.lower(r349) end))
end

function r346.title(r347)
	return (r347:gsub("%S+", function(r350)
		return r350:sub(1,1):upper() .. r350:sub(2):lower()
	end))
end

function r346.random_case(r347)
	local r351= {}
	for i = 1, #r347 do
		local r352= r347:sub(i,i)
		if math.random() < 0.5 then
			r351[i] = string.lower(r352)
		else
			r351[i] = string.upper(r352)
		end
	end
	return table.concat(r351)
end

function r346.startswith(r347,r353)
	return r347:sub(1, #r353) == r353
end

function r346.endswith(r347,r354)
	return r354 == '' or r347:sub(-#r354) == r354
end

function r346.byte(r347,r355,r356)
	return string.byte(tostring(r347 or ""), r355, r356)
end

function r346.char(...)
	return string.char(...)
end

function r346.find(r347,r357,r358,r359)
	return string.find(tostring(r347 or ""), r357, r358, r359)
end

function r346.format(r360,...)
	return string.format(r360, ...)
end

function r346.gmatch(r347,r357)
	return string.gmatch(tostring(r347 or ""), r357)
end

function r346.gsub(r347,r357,r361,r362)
	return string.gsub(tostring(r347 or ""), r357, r361, r362)
end

function r346.split(r347,r363)
	local r364= {}
	if r363 == '' then
		for r355 = 1, #r347 do r364[r355] = r347:sub(r355,r355) end
		return r364
	end
	local r357= string.format("([^%s]+)", r363)
	for part in r347:gmatch(r357) do
		r364[#r364+1] = part
	end
	return r364
end

function r346.join(r365,r363)
	return table.concat(r365, r363)
end

function r346.replace(r347,r357,r361)
	return r347:gsub(r357, r361)
end

function r346.reverse(r347)
	return string.reverse(r347)
end

function r346.repeat_str(r347,r362)
	return string.rep(r347, r362)
end

function r346.rep(r347,r362)
	return string.rep(tostring(r347 or ""), r362)
end

function r346.contains(r347,r366)
	return r347:find(r366, 1, true) ~= nil
end

function r346.count(r347,r366)
	if r366 == '' then return 0 end
	local r367= 0
	local r368= 1
	while true do
		local r369= r347:find(r366, r368, true)
		if not r369 then break end
		r367 = r367 + 1
		r368 = r369 + #r366
	end
	return r367
end

function r346.is_empty(r347)
	return r347 == nil or r347 == ''
end

function r346.is_digit(r347)
	return r347:match("^%d+$") ~= nil
end

function r346.is_alpha(r347)
	return r347:match("^%a+$") ~= nil
end

function r346.random_string(r370)
	local r371= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local r351= {}
	for r355 = 1, r370 do
		local r372= math.random(1, #r371)
		r351[r355] = r371:sub(r372, r372)
	end
	return table.concat(r351)
end

function r346.safe_substr(r347,r355,r356)
	local r373= tostring(r347 or "")
	local r362= #r373
	local r369= tonumber(r355) or 1
	if r369 < 0 then r369 = r362 + 1 + r369 end
	if r369 < 1 then r369 = 1 end
	if r356 == nil then
		return r373:sub(r369)
	end
	local r374= tonumber(r356)
	if not r374 then
		return r373:sub(r369)
	end
	if r374 >= 0 then
		return r373:sub(r369, math.min(r362, r369 + r374 - 1))
	else
		local r375= r362 + r374
		if r375 < r369 then return "" end
		return r373:sub(r369, r375)
	end
end

function r346.sub(r347,r373,r376)
	return string.sub(tostring(r347 or ""), r373, r376)
end

function r346.len(r347)
	return string.len(tostring(r347 or ""))
end

function r346.match(r347,r357,r358)
	return string.match(tostring(r347 or ""), r357, r358)
end

function r346.trim(r347)
	return (tostring(r347 or ""):gsub("^%s*(.-)%s*$", "%1"))
end

function r346.ltrim(r347)
	return (tostring(r347 or ""):gsub("^%s*(.-)$", "%1"))
end

function r346.rtrim(r347)
	return (tostring(r347 or ""):gsub("^(.-)%s*$", "%1"))
end

function r346.escape_pattern(r347)
	return tostring(r347 or ""):gsub("([%%%$%(%)%.%[%]%*%+%-%?%^])", "%%%1")
end

function r346.ensure_prefix(r347,r353)
	local r373= tostring(r347 or "")
	local r377= tostring(r353 or "")
	if r377 == "" then return r373 end
	if r373:sub(1, #r377) == r377 then return r373 end
	return r377 .. r373
end

function r346.ensure_suffix(r347,r354)
	local r373= tostring(r347 or "")
	local r378= tostring(r354 or "")
	if r378 == "" then return r373 end
	if r373:sub(-#r378) == r378 then return r373 end
	return r373 .. r378
end

function r346.truncate(r347,r379,r380)
	local r373= tostring(r347 or "")
	local r381= tonumber(r379) or 0
	if r381 <= 0 or #r373 <= r381 then return r373 end
	local r376= tostring(r380 or "...")
	local r382= r381 - #r376
	if r382 <= 0 then return r376:sub(1, r381) end
	return r373:sub(1, r382) .. r376
end

local r383= {
	a = '4', A = '4', e = '3', E = '3', i = '1', I = '1', o = '0', O = '0',
	s = '5', S = '5', t = '7', T = '7', b = '8', B = '8', g = '6', G = '6',
	z = '2', Z = '2', l = '1', L = '1'
}

function r346.leet(r347,r384)
	local r373= tostring(r347 or "")
	local r377= tonumber(r384) or 1
	if r377 <= 0 then return r373 end
	local r351= {}
	for r355 = 1, #r373 do
		local r352= r373:sub(r355,r355)
		local r349= r383[r352]
		if r349 and math.random() <= r377 then r351[#r351+1] = r349 else r351[#r351+1] = r352 end
	end
	return table.concat(r351)
end

function r346.pipeline(r347,...)
	local r373= tostring(r347 or "")
	for r355 = 1, select('#', ...) do
		local r385= select(r355, ...)
		if type(r385) == 'function' then
			r373 = r385(r373)
		elseif type(r385) == 'string' and r346[r385] then
			r373 = r346[r385](r373)
		end
	end
	return r373
end

return r346]]
r662["require/help/time"] = [[local r349= {}

local r350= client
local r351= globals

local function r352()
	if r351 and r351.realtime then
		return r351.realtime()
	end
	if r350 and r350.timestamp then
		local r353= r350.timestamp()
		if r353 then return r353 / 1000 end
	end
	return 0
end

function r349.simtime()
	if r351 and r351.curtime then return r351.curtime() end
	return r352()
end

function r349.realtime()
	return r352()
end

function r349.tickcount()
	if r351 and r351.tickcount then return r351.tickcount() end
	local r354= r349.tickinterval()
	if r354 and r354 > 0 then return math.floor(r352() / r354) end
	return 0
end

function r349.tickinterval()
	if r351 and r351.tickinterval then return r351.tickinterval() end
	return 0.015625
end

function r349.seconds_to_ticks(r355)
	local r356= r349.tickinterval()
	if r356 and r356 > 0 then return math.floor(r355 / r356 + 0.5) end
	return math.floor(r355 * 64 + 0.5)
end

function r349.ticks_to_seconds(r357)
	local r356= r349.tickinterval()
	if r356 then return r357 * r356 end
	return r357 * 0.015625
end

function r349.frametime()
	if r351 and r351.frametime then return r351.frametime() end
	return 0
end

function r349.absoluteframetime()
	if r351 and r351.absoluteframetime then return r351.absoluteframetime() end
	return 0
end

function r349.framecount()
	if r351 and r351.framecount then return r351.framecount() end
	return 0
end

function r349.framecount_to_seconds(r358)
	local r359= r349.frametime()
	return r358 * (r359 or 0)
end

function r349.seconds_to_framecount(r355)
	local r359= r349.frametime()
	if r359 and r359 > 0 then return math.floor(r355 / r359 + 0.5) end
	return math.floor(r355 * 60 + 0.5)
end

function r349.new(r360)
	return { start = r352(), duration = r360 or 0 }
end

function r349.expired(r361)
	return r352() - (r361.start or 0) >= (r361.duration or 0)
end

function r349.reset(r361,r360)
	r361.start = r352()
	if r360 then r361.duration = r360 end
end

function r349.elapsed(r361)
	return r352() - (r361.start or 0)
end

function r349.interval(r356,r362)
	local r363= r352()
	return function(...)
		local r364= r352()
		if r364 - r363 >= r356 then
			r363 = r364
			r362(...)
		end
	end
end

function r349.timeout(r365,r362)
	local r366= false
	local r367= r352()
	return function(...)
		if not r366 and r352() - r367 >= r365 then
			r366 = true
			r362(...)
		end
	end
end

function r349.debounce(r356,r362)
	local r363= 0
	return function(...)
		local r364= r352()
		if r364 - r363 >= r356 then
			r363 = r364
			r362(...)
		end
	end
end

function r349.throttle(r356,r362)
	local r363= 0
	return function(...)
		local r364= r352()
		if r364 - r363 >= r356 then
			r363 = r364
			r362(...)
		end
	end
end

function r349.wait(r365)
	local r367= r352()
	return function()
		return r352() - r367 >= r365
	end
end

function r349.stopwatch()
	local r368= { running = false, start = 0, elapsed = 0 }
	function r368:start()
		if not self.running then
			self.running = true
			self.start = r352()
		end
	end
	function r368:stop()
		if self.running then
			self.running = false
			self.elapsed = self.elapsed + (r352() - (self.start or 0))
		end
	end
	function r368:reset()
		self.running = false
		self.start = 0
		self.elapsed = 0
	end
	function r368:get()
		if self.running then
			return self.elapsed + (r352() - (self.start or 0))
		else
			return self.elapsed
		end
	end
	return r368
end

r349.Scheduler = {}
r349.Scheduler.__index = r349.Scheduler

function r349.Scheduler.new()
    return setmetatable({ tasks = {} }, r349.Scheduler)
end

function r349.Scheduler:add(r356,r362)
	self.tasks[#self.tasks+1] = { interval = r356, callback = r362, last = r352() }
end

function r349.Scheduler:remove(r362)
    for i = #self.tasks, 1, -1 do
        if self.tasks[i].callback == r362 then
            table.remove(self.tasks, i)
        end
    end
end

function r349.Scheduler:run(...)
	local r364= r352()
	for _, task in ipairs(self.tasks) do
		if r364 - task.last >= task.interval then
			task.last = r364
			task.callback(...)
		end
	end
end

function r349.safe_timeout(r365,r362)
	local r367= r352()
	local r366= false
	return function(...)
		if not r366 and r352() - r367 >= r365 then
			r366 = true
			r362(...)
		end
	end
end

function r349.lerp(r369,r370,r364)
	return r369 + (r370 - r369) * r364
end

function r349.ease_in_out(r364)
	if r364 < 0 then r364 = 0 end
	if r364 > 1 then r364 = 1 end
	return r364 < 0.5 and 2 * r364 * r364 or -1 + (4 - 2 * r364) * r364
end

function r349.ping_pong(r364,r371)
	if r371 <= 0 then return 0 end
	local r372= r364 % (r371 * 2)
	if r372 < r371 then return r372 / r371 end
	return 1 - ((r372 - r371) / r371)
end

function r349.apply_animation(r360,r373,r374)
	local r367= r352()
	return function()
		local r364= (r352() - r367) / (r360 or 1)
		if r364 >= 1 then
			r373(1)
			if r374 then r374() end
			return true
		else
			r373(r364)
			return false
		end
	end
end

function r349.within_ticks_window(r375,r376)
	local r377= r349.tickcount()
	if not r377 or not r375 then return false end
	return r377 - r375 <= (r376 or 0)
end

return r349]]
r662["require/help/trace"] = [[]]
r662["require/help/ui"] = [[local r355= {}

r355.raw = ui

local function r356()
    if type(ui) ~= 'table' then
        error('ui library is not available in this environment')
    end
end

function r355.available()
    return type(ui) == 'table'
end

function r355.get(r357)
    r356()
    return ui.get(r357)
end

function r355.is_menu_open()
    r356()
    return ui.is_menu_open()
end

function r355.menu_position()
    r356()
    return ui.menu_position()
end

function r355.menu_size()
    r356()
    return ui.menu_size()
end

function r355.mouse_position()
    r356()
    return ui.mouse_position()
end

function r355.name(r357)
    r356()
    return ui.name(r357)
end


function r355.new_button(r358,r359,r360,r361)
    r356()
    return ui.new_button(r358, r359, r360, r361)
end

function r355.new_checkbox(r358,r359,r360)
    r356()
    return ui.new_checkbox(r358, r359, r360)
end

function r355.new_color_picker(r358,r359,r360,r362,r363,r364,r365)
    r356()
    return ui.new_color_picker(r358, r359, r360, r362 or 0, r363 or 0, r364 or 0, r365 or 255)
end

function r355.new_combobox(r358,r359,r360,...)
    r356()
    return ui.new_combobox(r358, r359, r360, ...)
end

function r355.new_hotkey(r358,r359,r360,r366,r367)
    r356()
    return ui.new_hotkey(r358, r359, r360, r366 and true or false, r367)
end

function r355.new_label(r358,r359,r360)
    r356()
    return ui.new_label(r358, r359, r360)
end

function r355.new_listbox(r358,r359,r360,r368)
    r356()
    return ui.new_listbox(r358, r359, r360, r368)
end

function r355.new_multiselect(r358,r359,r360,...)
    r356()
    return ui.new_multiselect(r358, r359, r360, ...)
end

function r355.new_slider(r358,r359,r360,r369,r370,r371,r372,r373,r374,r375)
    r356()
    return ui.new_slider(r358, r359, r360, r369, r370, r371, r372, r373, r374, r375)
end

function r355.new_string(r360,r376)
    r356()
    return ui.new_string(r360, r376)
end

function r355.new_textbox(r358,r359,r360)
    r356()
    return ui.new_textbox(r358, r359, r360)
end

function r355.reference(r358,r359,r360)
    r356()
    return ui.reference(r358, r359, r360)
end


function r355.set(r357,...)
    r356()
    return ui.set(r357, ...)
end

function r355.set_callback(r357,r361)
    r356()
    return ui.set_callback(r357, r361)
end

function r355.set_enabled(r357,r377)
    r356()
    return ui.set_enabled(r357, r377)
end

function r355.set_visible(r357,r378)
    r356()
    return ui.set_visible(r357, r378)
end

function r355.type(r357)
    r356()
    return ui.type(r357)
end

function r355.update(r357,...)
    r356()
    if ui.update then
        return ui.update(r357, ...)
    end
    error('ui.update is not supported in this environment')
end

function r355.get_color(r357)
    r356()
    local r362,r363,r364,r365= ui.get(r357)
    if r362 == nil then return nil end
    return { r = r362, g = r363, b = r364, a = r365 }
end

function r355.set_color(r357,r379)
    r356()
    if type(r379) == 'table' then
        return ui.set(r357, r379.r or 0, r379.g or 0, r379.b or 0, r379.a or 255)
    else
        error('color must be a table {r,g,b,a}')
    end
end

function r355.get_multiselect(r357)
    r356()
    local r380= ui.get(r357)
    return r380
end

function r355.list_refs(r358,r359)
    r356()
    local r381= {}
    for _, r360 in ipairs(ui.get_children and ui.get_children(r358, r359) or {}) do
        r381[#r381+1] = ui.reference(r358, r359, r360)
    end
    return r381
end

return r355]]
r662["require/help/vector"] = [[local r358
do
    local function r359(r360,r361,r362)
        local r363= { x = 0, y = 0, z = 0 }
        if type(r360) == "table" then
            r363.x = r360.x or r360[1] or 0
            r363.y = r360.y or r360[2] or 0
            r363.z = r360.z or r360[3] or 0
        elseif type(r360) == "number" then
            r363.x = r360
            r363.y = r361 or 0
            r363.z = r362 or 0
        elseif r360 ~= nil then
            r363.x = (r360.x or r360[1]) or 0
            r363.y = (r360.y or r360[2]) or 0
            r363.z = (r360.z or r360[3]) or 0
        end
        return setmetatable(r363, vector_mt)
    end

    local r364= {}

    vector_mt = {
        __index = function(r365,r366)
            if r366 == 1 then return rawget(r365,"x") end
            if r366 == 2 then return rawget(r365,"y") end
            if r366 == 3 then return rawget(r365,"z") end
            local r363= rawget(r365,r366)
            if r363 ~= nil then return r363 end
            return r364[r366]
        end,
        __sub = function(r360,r361)
            return r359((r360.x or 0) - (r361.x or 0), (r360.y or 0) - (r361.y or 0), (r360.z or 0) - (r361.z or 0))
        end,
        __add = function(r360,r361)
            return r359((r360.x or 0) + (r361.x or 0), (r360.y or 0) + (r361.y or 0), (r360.z or 0) + (r361.z or 0))
        end,
        __mul = function(r360,r361)
            if type(r360) == 'number' then return r359(r360 * (r361.x or 0), r360 * (r361.y or 0), r360 * (r361.z or 0)) end
            if type(r361) == 'number' then return r359((r360.x or 0) * r361, (r360.y or 0) * r361, (r360.z or 0) * r361) end
            return nil
        end,
        __div = function(r360,r361)
            if type(r361) == 'number' and r361 ~= 0 then return r359((r360.x or 0) / r361, (r360.y or 0) / r361, (r360.z or 0) / r361) end
            return nil
        end,
        __unm = function(r360) return r359(-(r360.x or 0), -(r360.y or 0), -(r360.z or 0)) end,
        __tostring = function(r360) return string.format("vec(%.3f, %.3f, %.3f)", r360.x or 0, r360.y or 0, r360.z or 0) end
    }

    r364.length = function(r367) return math.sqrt((r367.x or 0)^2 + (r367.y or 0)^2 + (r367.z or 0)^2) end
    r364.dot = function(r360,r361) return (r360.x or 0)*(r361.x or 0) + (r360.y or 0)*(r361.y or 0) + (r360.z or 0)*(r361.z or 0) end
    r364.cross = function(r360,r361)
        return r359((r360.y or 0)*(r361.z or 0) - (r360.z or 0)*(r361.y or 0),
                        (r360.z or 0)*(r361.x or 0) - (r360.x or 0)*(r361.z or 0),
                        (r360.x or 0)*(r361.y or 0) - (r360.y or 0)*(r361.x or 0))
    end
    r364.normalized = function(r367)
        local r368= r364.length(r367)
        if r368 == 0 or r368 == nil then return r359(0,0,0) end
        return r359((r367.x or 0)/r368, (r367.y or 0)/r368, (r367.z or 0)/r368)
    end
    r364.normalize = function(r367)
        local r368= r364.length(r367)
        if r368 == 0 or r368 == nil then return r367 end
        r367.x = (r367.x or 0)/r368
        r367.y = (r367.y or 0)/r368
        r367.z = (r367.z or 0)/r368
        return r367
    end
    r364.copy = function(r367) return r359(r367.x or 0, r367.y or 0, r367.z or 0) end
    r364.distance_to = function(r367,r369)
        local r370= r369
        if type(r369) == 'number' then r370 = r358(r369) end
        local r371= (r367.x or 0) - (r370.x or 0)
        local r372= (r367.y or 0) - (r370.y or 0)
        local r373= (r367.z or 0) - (r370.z or 0)
        return math.sqrt(r371*r371 + r372*r372 + r373*r373)
    end
    r364.to_screen = function(r367)
        if not renderer or not renderer.world_to_screen then return nil end
        return renderer.world_to_screen(r367.x or 0, r367.y or 0, r367.z or 0)
    end
    r364.to_angles = function(r367,r369)
        local r370= r369
        if not r370 then return nil end
        local r371= (r370.x or 0) - (r367.x or 0)
        local r372= (r370.y or 0) - (r367.y or 0)
        local r373= (r370.z or 0) - (r367.z or 0)
        local r374= math.deg(math.atan2(r372, r371))
        local r375= math.sqrt(r371*r371 + r372*r372)
        local r376= -math.deg(math.atan2(r373, r375))
        return r376, r374
    end

    r358 = setmetatable({}, {
        __call = function(r377,r360,r361,r362)
            return r359(r360, r361, r362)
        end
    })
end
return r358]]
r662["main"] = [[


local function r361(r362)
    local r363, r364= pcall(require, r362)
    if r363 then
        return r364
    else
        return nil
    end
end




r361("require/brain/dll")





local function r365()

    r361("require/brain/test")

    local r366= {
        menu = r361("require/abc/menu_header"),
        login = r361("require/abc/login_system"),
        config = r361("require/abc/config_system"),
        player_condition = r361("require/aa/player_condition"),
        menu_setup = r361("require/abc/menu_setup"),
        gc = r361("require/abc/garbage_collector"),
        pushlog = r361("require/abc/push_logger"),
        screenlog = r361("require/abc/screen_logger"),
        self = r361("require/help/self"),
        enemies = r361("require/help/enemies"),
        COLORS = r361("require/help/color"),
        str = r361("require/help/string"),
        safe = r361("require/help/safe"),
        build_menu = r361("require/abc/build_menu"),
        menu_visibility = r361("require/abc/menu_visibility"),
        config_system = r361("require/abc/config_system"),
    }

    
    r361("require/abc/register")

    
    r361("require/features/aa/antiaim")

    
    
    r361("require/features/misc/resolver")
    r361("require/features/misc/analyze")
    r361("require/features/misc/dormant_aimbot")
    r361("require/features/misc/fakelag")
    r361("require/features/misc/hotkeys")
    r361("require/features/misc/freestand_helper")
    r361("require/features/misc/enhance_osaa")
    r361("require/features/misc/roll")
    r361("require/features/misc/exploit_fakelag")
    r361("require/features/misc/walkbot")
    r361("require/features/misc/backstab_assist")
    r361("require/features/misc/spin_on_dead_enemies")
    r361("require/features/misc/localdebug")

    
    r361("require/features/paint/world_hitmarker_plus")
    r361("require/features/paint/onshot_skeleton")
    r361("require/features/paint/damage")
    r361("require/features/paint/damage_penetration")
    r361("require/features/paint/aimbot_logs")
    r361("require/features/paint/aspect_ratio")
    r361("require/features/paint/third_person_distance")
    r361("require/features/paint/watermark_solus")
    r361("require/features/paint/watermark_gamesense")
    r361("require/features/paint/entidx")
    r361("require/features/paint/target_info")
    r361("require/features/paint/clantag")
    r361("require/features/paint/indicators_bold")
    r361("require/features/paint/indicators_small")
    r361("require/features/paint/hit_miss_indicator")
    r361("require/features/paint/bomb_esp")
    r361("require/features/paint/presmoke_warning")
    r361("require/features/paint/self_skeleton")
    r361("require/features/paint/performance_mode")
    
    r361("require/features/paint/minimum_damage")
    r361("require/features/paint/filter_console")
    r361("require/features/paint/warnings")
    r361("require/features/paint/text_watermark")
    r361("require/features/paint/bullet_tracer")
    r361("require/features/paint/animations")
    r361("require/features/paint/lagcomp_box")
    r361("require/features/paint/insults")
    r361("require/features/paint/molotov_particles")
    
    

    
    r366.pushlog("The lua has initialized", 4, 255, 255, 0, 255)
    r366.screenlog("The lua has initialized", 4, 255, 255, 255, 255)

    
    local function r367()
        local r368= database.read('cached_credentials')
        if r368 and r368.username and r368.password then
            r366.safe.safe_set(r366.menu_setup.ui.login_username, r368.username)
            r366.safe.safe_set(r366.menu_setup.ui.login_password, r368.password)
            r366.safe.safe_set(r366.menu_setup.ui.cache_credentials, true)
            
            local r369= r366.login.login(r368.username, r368.password)
            if r369 then
                local r370,r371,r372= r366.COLORS.get("green", "log")
                r366.screenlog("Auto-login successful!", 3, r370, r371, r372, 255)
                r366.pushlog("Auto-login successful!", 3, 255, 255, 0, 255)
            else
                local r370,r371,r372= r366.COLORS.get("red", "log")
                r366.screenlog("Auto-login failed!", 3, r370, r371, r372, 255)
                r366.pushlog("Auto-login failed!", 3, 255, 255, 0, 255)
            end
        end
    end

    
    r366.build_menu(r366)
    r366.menu_visibility.setup_callbacks(r366)

    
    local function r373()
        local r374= r366.login.logged_in
        if not r374 then return end
        r366.menu.draw_menu()
        if r366.menu.is_menu_open() then
            local r375= r366.menu.tab_sections()
            local r376, r377= r366.menu.mouse_position()
            local r378= r366.menu.current_tab_index()
            local r379= r366.menu.current_tab()
            local r380, r381= r366.menu.menu_position()
            local r382, r383= r366.menu.menu_size()
        end
    end

    
    local function r384(r385)
        if not r366.menu.is_menu_open() then return end
        if not r366.menu.is_mouse_outside_menu() then
            r385.in_attack = false
        end
    end

    
    local function r386()
        if r366.gc then
            if r366.gc.dynamic then
                r366.gc.dynamic()
            elseif r366.gc.step then
                r366.gc.step(100)
            end
        end
    end

    
    local function r387()
        r367()
        r366.menu_visibility.update(r366)
    end

    r387()

    local r388

    
    client.set_event_callback('setup_command', function(r385)
        r384(r385)
    end)

    client.set_event_callback('paint', function()
        r373()
        
    end)

    client.set_event_callback('paint_ui', function()

        if not r366.menu.is_menu_open() then return end
        local r379= r366.menu.current_tab()

        r366.menu_setup.toggle_gamesense_menu(false)

        if r379 ~= r388 then
            r388 = r379
            r366.menu_visibility.update(r366)
        end

    end)

    client.set_event_callback('shutdown', function(r385)
        r366.menu_setup.toggle_gamesense_menu(true)
    end)
end

_G.loader_init_after_hwid = r365
r361("require/abc/hwid_check")]]

return r665("main")
