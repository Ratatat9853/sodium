
local u743= {}
local u744= {}
local u745= require

local function u746(u747)
    if u744[u747] then
        return u744[u747]
    end

    local u748= u743[u747]
    if not u748 then
        return u745(u747)
    end
    local u749= {}
    setmetatable(u749, { __index = _G })
    u749.require = u746

    local u750, u751
    if type(setfenv) == "function" then
        u750, err = load(u748, u747)
        if not u750 then
            error("Failed to load module: " .. u747 .. " (" .. tostring(u751) .. ")")
        end
        setfenv(u750, u749)
    else
        u750, err = load(u748, u747, nil, u749)
        if not u750 then
            error("Failed to load module: " .. u747 .. " (" .. tostring(u751) .. ")")
        end
    end

    local u752= u750()
    u744[u747] = u752 or true
    return u744[u747]
end

u743["require/aa/player_condition"] = [[
local u127= require("require/help/libs")
local u128= u127.get("antiaim_funcs")
local u129= u127.get("entity") or u129
local u130= u127.get("bit") or u130
local u131= require('require/abc/menu_setup')
local u132= { last_air = false, last_tick = 0, last_cond = nil }

local function u133(u134)
    if u134 == 'global' then return true end
    if not u131 or not u131.ui then return true end
    local u135= 'enable_' .. u134
    local u136= u131.ui[u135]
    if not u136 then
        return true
    end
    local u137, u138= pcall(ui.get, u136)
    return u137 and u138 == true
end


local function u139()
    local u140= u129.get_local_player()
    if not u140 or not u129.is_alive(u140) then
        return nil
    end
    
    if client.key_state(0x45) then
        if u133('legit') then return "legit" end
    end

    local u141= false
    if u128 and u128.get_double_tap then
        u141 = u128.get_double_tap()
    else
        u141 = true
    end

    if u141 == false then
        if u133('fakelag') then return "fakelag" end
    end

    if misc_gs_hotkey_slowmotion and ui.get(misc_gs_hotkey_slowmotion) == true then
        if u133('walk') then return "walk" end
    end
    
    if client.key_state(0x10) then
        local u142, u143= u129.get_prop(u140, 'm_vecVelocity')
        local u144= math.sqrt((u142 or 0)^2 + (u143 or 0)^2)
        if u144 >= 20 and u144 <= 140 then
            if u133('walk') then return "walk" end
        end
    end

    local u142, u143= u129.get_prop(u140, 'm_vecVelocity')
    local u144= math.sqrt((u142 or 0)^2 + (u143 or 0)^2)
    local u145= u129.get_prop(u140, 'm_flDuckAmount') > 0.5
    local u146= u130.band(u129.get_prop(u140, 'm_fFlags') or 0, 1) == 1
    local u147= globals.tickcount()

    if not u146 then
        if u145 then
            u132.last_air = true
            u132.last_tick = u147
            u132.last_cond = "jump+"
            if u133('jump+') then return "jump+" end
        else
            u132.last_air = true
            u132.last_tick = u147
            u132.last_cond = "jump"
            if u133('jump') then return "jump" end
        end
    else
        if u132.last_air and (u147 - u132.last_tick <= 2) then
            if u132.last_cond and u133(u132.last_cond) then
                return u132.last_cond
            end
        end
        u132.last_air = false
        u132.last_cond = nil
    end

    if u145 then
        if u144 >= 2 then
            if u133('duck+') then return "duck+" end
        else
            if u133('duck') then return "duck" end
        end
    else
        if u144 >= 2 then
            if u133('move') then return "move" end
        else
            if u133('stand') then return "stand" end
        end
    end

    return "global"
end

return {
    get = u139
}]]
u743["require/abc/build_menu"] = [[tab = {
    "RAGE",
    "AA",
    "LEGIT",
    "VISUALS",
    "MISC",
    "PLIST",
    "CONFIG",
    "LUA"
}

cont = {
    {
        "Aimbot",
        "Other"
    },
    {
        "Anti-aimbot angles",
        "Fake lag",
        "Other"
    },
    {},
    {
        "Player ESP",
        "Other ESP",
        "Colored models",
        "Effects"
    },
    {},
    {},
    {},
    {
        "A",
        "B",
    }
}

local u130= {
    "global",
    "stand",
    "move",
    "duck",
    "duck+",
    "jump",
    "jump+",
    "walk",
    "fakelag",
    "legit",
}

local u131= require("require/abc/menu_setup")
local u132= require("require/help/color")
local u133= require("require/abc/screen_logger")
local u134= require("require/help/emojis")

local function u135(u136)
    local u137= 'inDGnidgdisgndsin'

    local function u138()
        local u139= database.read(u137)
        return type(u139) == 'table' and u139 or {}
    end

    local function u140(u139)
        database.write(u137, u139)
    end

    local function u141(u139,u142)
        for i = 1, #u139 do if u139[i] == u142 then return i end end
        return nil
    end

    local function u143()
        if not (u136 and u136.menu_setup and u136.menu_setup.ui and u136.menu_setup.ui.paint_logger) then
            return false
        end
        local u144, u145= pcall(ui.get, u136.menu_setup.ui.paint_logger)
        if not u144 or not u145 then return false end
        if type(u145) == 'table' then
            for _, v in ipairs(u145) do
                if tostring(v) == 'config' then return true end
            end
            return false
        else
            return tostring(u145) == 'config'
        end
    end

    local function u146(u147)
        local u148= u138()
        if #u148 == 0 then u148 = {'(empty)'} end
            if u131.ui.cfg_listbox then
                pcall(ui.set_visible, u131.ui.cfg_listbox, false)
            end
            u131.ui.cfg_listbox = u131.register_ui(
                ui.new_listbox(tab[2], cont[2][1], 'Configs', u148),
                { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
            )
        if u147 then
            local u149= u141(u148, u147)
            if u149 then ui.set(u131.ui.cfg_listbox, u149-1) end
        end
    end
 
    
    
    
    u131.ui.cache_credentials = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("pin") .. u132.get("default", "ui") .. 'Cache credentials'),
        { requires_login = false, key = 'cache_credentials', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    u131.ui.login_username = u131.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Username', 'username'),
        { requires_login = false, key = 'login_username', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    u131.ui.login_password = u131.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Password', 'password'),
        { requires_login = false, key = 'login_password', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    u131.ui.login_howto_header = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], u132.get("grey", "ui") .. '───────[ ' .. u132.get("white", "ui") .. 'How to ' .. u132.get("green", "ui") .. 'log in' .. u132.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'login_howto_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.login_console_register = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], u132.get("grey", "ui") .. '1. In console -> "register ' .. u132.get("green", "ui") .. 'user' .. u132.get("grey", "ui") .. ' ' .. u132.get("red", "ui") .. 'pass' .. u132.get("grey", "ui") .. ' ' .. u132.get("blue", "ui") .. 'code' .. u132.get("grey", "ui") .. '"'),
        { requires_login = false, key = 'login_console_register', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.login_menu_credentials = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], u132.get("grey", "ui") .. '2. Write password & username in the menu.'),
        { requires_login = false, key = 'login_menu_credentials', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.login_press_login = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], u132.get("grey", "ui") .. '3. Press log in and enjoy ' .. u132.get("green", "ui") .. 'premium features' .. u132.get("grey", "ui") .. '.'),
        { requires_login = false, key = 'login_press_login', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.login_spacer1 = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer1', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.reset_header = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], u132.get("grey", "ui") .. '───────[ ' .. u132.get("white", "ui") .. 'How to ' .. u132.get("yellow", "ui") .. 'reset pass' .. u132.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'reset_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.reset_step1 = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], u132.get("grey", "ui") .. '1. Write username -> press reset.'),
        { requires_login = false, key = 'reset_step1', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.reset_step2 = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], u132.get("grey", "ui") .. '2. Login with your oldest password.'),
        { requires_login = false, key = 'reset_step2', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.login_spacer2 = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer2', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.support_header = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], u132.get("grey", "ui") .. '───────[ ' .. u132.get("red", "ui") .. 'Support & Other' .. u132.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'support_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.support_discord = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], u132.get("grey", "ui") .. '1. Join the ' .. u132.get("discord", "ui") .. 'discord ' .. u132.get("grey", "ui") .. 'for support.'),
        { requires_login = false, key = 'support_discord', tab = 'AA', visible = true, config_type = 'label' }
    )

    u131.ui.login_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("lock_open") .. u132.get("default", "ui") .. 'Login', function()
            local u150= u136.safe.safe_get(u131.ui.login_username)
            local u151= u136.safe.safe_get(u131.ui.login_password)
            local u152= u136.safe.safe_get(u131.ui.cache_credentials)
            if u150 ~= '' and u151 ~= '' then
                local u153= u136.login.login(u150, u151)
                if u153 then
                    u136.pushlog("Welcome back, " .. u136.str.capitalize(u150) .. ". You logged in successfully.", 3, 75, 145, 55, 255)
                    if u152 then
                        database.write('cached_credentials', { username = u150, password = u151 })
                    else
                        database.write('cached_credentials', nil)
                    end
                    local u154,u155,u156= u132.get("green", "log")
                    u136.screenlog("Login successful!", 4, u154, u155, u156, 255)
                else
                    local u154,u155,u156= u132.get("red", "log")
                    u136.screenlog("Login failed!", 4, u154, u155, u156, 255)
                end
            end
                if u136.menu_visibility and u136.menu_visibility.update then
                    u136.menu_visibility.update(u136)
                end
        end),
        { requires_login = false, key = 'login_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    u131.ui.logout_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][3], u132.get("red", "ui") .. u134.get("lock") .. u132.get("default", "ui") .. 'Logout', function()
            u136.login.logout()
            local u154,u155,u156= u132.get("red", "log")
            u136.screenlog("Logged out!", 4, u154, u155, u156, 255)
                if u136.menu_visibility and u136.menu_visibility.update then
                    u136.menu_visibility.update(u136)
                end
        end),
        { requires_login = true, key = 'logout_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    u131.ui.reset_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][1], u132.get("yellow", "ui") .. u134.get("warning") .. u132.get("default", "ui") .. 'Reset', function()
            local u150= u136.safe.safe_get(u131.ui.login_username)
            u136.login.reset_password(u150)
            local u154,u155,u156= u132.get("yellow", "log")
            u136.screenlog("Password reset.", 4, u154, u155, u156, 255)
            u136.pushlog("Password reset for user: " .. u150, 5, 255, 255, 0, 255)
                if u136.menu_visibility and u136.menu_visibility.update then
                    u136.menu_visibility.update(u136)
                end
        end),
        { requires_login = true, key = 'reset_button', tab = 'AA', visible = true, config_type = 'button' }
    )

    u131.ui.discord_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][3], u132.get("discord", "ui") .. u134.get("chat") .. u132.get("default", "ui") .. 'Discord', function()
            local u157= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            u136.safe.safe_set(u157, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://discord.gg/a2bFbVWWg9')
        end),
        { requires_login = true, key = 'discord_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    u131.ui.youtube_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][3], u132.get("youtube", "ui") .. u134.get("play") .. u132.get("default", "ui") .. 'YouTube', function()
            local u157= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            u136.safe.safe_set(u157, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://www.youtube.com/@vile-gs/videos')
        end),
        { requires_login = true, key = 'youtube_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    u131.ui.sellhub_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][3], u132.get("sellhub", "ui") .. u134.get("folder") .. u132.get("default", "ui") .. 'Sellhub', function()
            local u157= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            u136.safe.safe_set(u157, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://sodium.sellhub.cx/#products-list')
        end),
        { requires_login = true, key = 'sellhub_button', tab = 'AA', visible = true, config_type = 'button' }
    )


    
    
    
    u131.ui.condition_label = u131.register_ui(
        ui.new_label(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("menu") .. u132.get("default", "ui") .. 'Condition', unpack(u130)),
        { requires_login = true, key = 'condition_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.condition = u131.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nCondition', unpack(u130)),
        { requires_login = true, key = 'condition', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    u131.ui.condition_label2 = u131.register_ui(
        ui.new_label(tab[2], cont[2][1], '\ncondition label'),
        { requires_login = true, key = 'condition_label2', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.misc_resolver = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("wrench") .. u132.get("default", "ui") .. 'Resolver'),
        { requires_login = true, key = 'misc_resolver', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    u131.ui.misc_ragebot = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("arrow_double") .. u132.get("default", "ui") .. 'Ragebot'),
        { requires_login = true, key = 'misc_ragebot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    u131.ui.misc_dormantaimbot = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("time") .. u132.get("default", "ui") .. 'Dormant aimbot'),
        { requires_login = true, key = 'misc_dormantaimbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    u131.ui.misc_dormantaimbot_key = u131.register_ui(
        ui.new_hotkey(tab[2], cont[2][1], '\ndormant aimbot key', true),
        { requires_login = true, key = 'misc_dormantaimbot_key', tab = 'MISC', visible = true, config_type = 'hotkey' }
    )
    u131.ui.misc_dormantaimbot_value = u131.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\ndormant aimbot value', 60, 100, 0, true, '%'),
        { requires_login = true, key = 'misc_dormantaimbot_value', tab = 'MISC', visible = true, config_type = 'slider' }
    )
    u131.ui.misc_exploit_fakelag = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("latency3") .. u132.get("default", "ui") .. 'Limit exploit fakelag'),
        { requires_login = true, key = 'misc_exploit_fakelag', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    u131.ui.misc_walkbot = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("arrow_up") .. u132.get("default", "ui") .. 'Walkbot'),
        { requires_login = true, key = 'misc_walkbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    u131.ui.misc_backstab = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("triangle_upside") .. u132.get("default", "ui") .. 'Backstab Assist'),
        { requires_login = true, key = 'misc_backstab', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    u131.ui.misc_spindead = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("turning2") .. u132.get("default", "ui") .. 'Spin on dead enemies'),
        { requires_login = true, key = 'misc_spindead', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    u131.ui.aa_gskey_freestandh = u131.register_ui(
        ui.new_label(tab[2], cont[2][3], u132.get("green", "ui") .. u134.get("turning2") .. u132.get("default", "ui") .. 'Freestand'),
        { requires_login = false, key = 'aa_gskey_freestandh', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.aa_gskey_freestand = u131.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'freestand', true),
        { requires_login = true, key = 'aa_gskey_freestand', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    u131.ui.aa_gskey_slowmotionh = u131.register_ui(
        ui.new_label(tab[2], cont[2][3], u132.get("green", "ui") .. u134.get("gear") .. u132.get("default", "ui") .. 'Slowmotion'),
        { requires_login = false, key = 'aa_gskey_slowmotionh', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.aa_gskey_slowmotion = u131.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'slowmotion', true),
        { requires_login = true, key = 'aa_gskey_slowmotion', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    u131.ui.aa_gskey_edgeyawh = u131.register_ui(
        ui.new_label(tab[2], cont[2][3], u132.get("green", "ui") .. u134.get("recycle") .. u132.get("default", "ui") .. 'Edge Yaw'),
        { requires_login = false, key = 'aa_gskey_edgeyawh', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.aa_gskey_edgeyaw = u131.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'edge yaw', true),
        { requires_login = true, key = 'aa_gskey_edgeyaw', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    u131.ui.aa_gskey_onshoth = u131.register_ui(
        ui.new_label(tab[2], cont[2][3], u132.get("green", "ui") .. u134.get("arrow_double") .. u132.get("default", "ui") .. 'On-shot aa'),
        { requires_login = false, key = 'aa_gskey_onshoth', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.aa_gskey_onshot = u131.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'on-shot aa', true),
        { requires_login = true, key = 'aa_gskey_onshot', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    
    for _, cond in ipairs(u130) do
        local u158= 'enable_' .. cond
        u131.ui[u158] = u131.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("accept") .. u132.get("default", "ui") .. 'Enable ' .. cond),
            { requires_login = true, key = u158, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        u131.ui['pitch_' .. cond] = u131.register_ui(
            ui.new_combobox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("triangle_upside") .. u132.get("default", "ui") .. 'Pitch', 'off', 'up', 'down', 'minimal', 'ideal'),
            { requires_login = true, key = 'pitch_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        u131.ui['yaw_base_' .. cond] = u131.register_ui(
            ui.new_combobox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("recycle") .. u132.get("default", "ui") .. 'Yaw Base', 'target', 'view', 'threat', 'distance', 'smart'),
            { requires_login = true, key = 'yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        u131.ui['yaw_' .. cond] = u131.register_ui(
            ui.new_combobox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("turning2") .. u132.get("default", "ui") .. 'Yaw', 'off', 'spin', '180', '3way', 'ideal'),
            { requires_login = true, key = 'yaw_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        u131.ui['label1_' .. cond] = u131.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label1_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        u131.ui['body_yaw_base_' .. cond] = u131.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Base', -90, 90, 0, true, '°'),
            { requires_login = true, key = 'body_yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        u131.ui['body_yaw_left_' .. cond] = u131.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Left', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_left_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        u131.ui['body_yaw_right_' .. cond] = u131.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Right', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_right_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        u131.ui['randomize_yaw_' .. cond] = u131.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Randomize Yaw', 0, 30, 0, true, '%', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'randomize_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        u131.ui['label2_' .. cond] = u131.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label2_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        u131.ui['yaw_jitter_' .. cond] = u131.register_ui(
            ui.new_combobox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("turning") .. u132.get("default", "ui") .. 'Yaw Jitter', 'off', 'center', 'skitter'),
            { requires_login = true, key = 'yaw_jitter_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        u131.ui['yaw_jitter_base_' .. cond] = u131.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Yaw Jitter - Base', 0, 120, 0, true, '°', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'yaw_jitter_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        u131.ui['body_yaw_mode_' .. cond] = u131.register_ui(
            ui.new_combobox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("gear") .. u132.get("default", "ui") .. 'Body Yaw Mode', 'off', 'static', 'opposite', 'jitter'),
            { requires_login = true, key = 'body_yaw_mode_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        u131.ui['static_body_yaw_' .. cond] = u131.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Static Body Yaw', -58, 58, 0, true, '°'),
            { requires_login = true, key = 'static_body_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        u131.ui['body_yaw_value_' .. cond] = u131.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw Value', 1, 3, 2, true, '', 2, {
                [1] = 'left', [2] = 'back', [3] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_value_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        u131.ui['delay_' .. cond] = u131.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Delay', 0, 17, 1, true, 't', 1, {
                [0] = 'jitter'
            }),
            { requires_login = true, key = 'delay_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        u131.ui['label3_' .. cond] = u131.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label3_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        u131.ui['fifty_fifty_' .. cond] = u131.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("question") .. u132.get("default", "ui") .. '50/50'),
            { requires_login = true, key = 'fifty_fifty_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        u131.ui['only_flip_on_0_choke_' .. cond] = u131.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("time") .. u132.get("default", "ui") .. 'Only Flip on 0 Choke'),
            { requires_login = true, key = 'only_flip_on_0_choke_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        u131.ui['aa_label_space' .. cond] = u131.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n abc'),
            { requires_login = true, key = 'aa_label_space', tab = 'AA', visible = true, config_type = 'label' }
        )
        u131.ui['aa_label_combo' .. cond] = u131.register_ui(
            ui.new_label(tab[2], cont[2][1], 'Send state -> state'),
            { requires_login = true, key = 'aa_label_combo', tab = 'AA', visible = true, config_type = 'label' }
        )
        u131.ui['send_combo' .. cond] = u131.register_ui(
            ui.new_combobox(tab[2], cont[2][1], '\n', unpack(u130)),
            { requires_login = true, key = 'send_combo' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        u131.ui['send_button' .. cond] = u131.register_ui(
            ui.new_button(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("upload") .. u132.get("default", "ui") .. 'Send', function() end),
            { requires_login = true, key = 'send_button', tab = 'AA', visible = true, config_type = 'button' }
        )

    end


    
    
    
    u131.ui.fakelag_mode = u131.register_ui(
        ui.new_combobox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("gear") .. u132.get("default", "ui") .. 'Mode', 'defensive', 'stealer', 'fakelag', 'settings'),
        { requires_login = true, key = 'fakelag_mode', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    u131.ui.fakelag_defensive = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("turning2") .. u132.get("default", "ui") .. 'Defensive'),
        { requires_login = true, key = 'fakelag_defensive', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    u131.ui.fakelag_force = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("exclamation") .. u132.get("default", "ui") .. 'Force'),
        { requires_login = true, key = 'fakelag_force', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    u131.ui.fakelag_fakedef = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("globe") .. u132.get("default", "ui") .. 'Unmatched.gg'),
        { requires_login = true, key = 'fakelag_fakedef', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    u131.ui.fakelag_force_on = u131.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("clip") .. u132.get("default", "ui") .. 'Force whilst', 'peek', 'reload', 'shot', 'damaged'),
        { requires_login = true, key = 'fakelag_force_on', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    
    
    
    u131.ui.cfg_load_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("arrow_double") .. u132.get("default", "ui") .. 'Load', function()
            local u148= u138()
            local u149= ui.get(u131.ui.cfg_listbox)
            local u159= u148[(u149 or 0) + 1]
            local u160= ui.get(u131.ui.cfg_input_box)
            local u142= (u159 and u159 ~= '(empty)' and u159 ~= '') and u159 or u160

            if u142 and u142 ~= '' and u142 ~= '(empty)' then
                local u161= require("require/abc/config_system")
                local function u162()
                    if not u131.ui.cfg_selection then return nil end
                    local u144, u163= pcall(ui.get, u131.ui.cfg_selection)
                    if not u144 or not u163 or type(u163) ~= 'table' or #u163 == 0 then return nil end
                    local u164= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local u165= {}
                    for _, v in ipairs(u163) do
                        local u139= u164[tostring(v)]
                        if u139 then u165[#u165+1] = u139 end
                    end
                    if #u165 == 0 then return nil end
                    return u165
                end
                local u166= u162()
                u161.load(u142, u166)
                u136.screenlog('[Config] Loaded config: ' .. u142, 4, 120, 180, 255, 255)
                if u136 and u136.pushlog and u143() then
                    u136.pushlog('Loaded config: ' .. u142, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for load.')
                if u136 and u136.pushlog and u143() then
                    u136.pushlog('No config name selected for load.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_load_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    u131.ui.cfg_save_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("config") .. u132.get("default", "ui") .. 'Save', function()
            local u148= u138()
            local u149= ui.get(u131.ui.cfg_listbox)
            local u159= u148[(u149 or 0) + 1]
            local u160= ui.get(u131.ui.cfg_input_box)
            local u142= (u159 and u159 ~= '(empty)' and u159 ~= '') and u159 or u160

            if u142 and u142 ~= '' then
                local u161= require("require/abc/config_system")
                local function u162()
                    if not u131.ui.cfg_selection then return nil end
                    local u144, u163= pcall(ui.get, u131.ui.cfg_selection)
                    if not u144 or not u163 or type(u163) ~= 'table' or #u163 == 0 then return nil end
                    local u164= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local u165= {}
                    for _, v in ipairs(u163) do
                        local u139= u164[tostring(v)]
                        if u139 then u165[#u165+1] = u139 end
                    end
                    if #u165 == 0 then return nil end
                    return u165
                end
                local u166= u162()
                u161.save(u142, u166)
                local u148= u138()
                if not u141(u148, u142) then
                    u148[#u148+1] = u142
                    u140(u148)
                end
                u146(u142)
                u136.screenlog('[Config] Saved config: ' .. u142, 4, 120, 180, 255, 255)
                if u136 and u136.pushlog and u143() then
                    u136.pushlog('Saved config: ' .. u142, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name provided for save.')
                if u136 and u136.pushlog and u143() then
                    u136.pushlog('No config name provided for save.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_save_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    u131.ui.cfg_create_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("plus") .. u132.get("default", "ui") .. 'Create', function()
            local u160= ui.get(u131.ui.cfg_input_box)
            if not u160 or u160 == '' then
                client.error_log('[Config] No config name provided for create.')
                if u136 and u136.pushlog and u143() then
                    u136.pushlog('No config name provided for create.', 4, 255, 255, 255, 255)
                end
                return
            end

            local u148= u138()
            if u141(u148, u160) then
                client.error_log('[Config] Config with that name already exists: ' .. u160)
                if u136 and u136.pushlog and u143() then
                    u136.pushlog('Config already exists: ' .. u160, 4, 255, 255, 255, 255)
                end
                return
            end

            local u161= require("require/abc/config_system")
            local function u162()
                if not u131.ui.cfg_selection then return nil end
                local u144, u163= pcall(ui.get, u131.ui.cfg_selection)
                if not u144 or not u163 or type(u163) ~= 'table' or #u163 == 0 then return nil end
                local u164= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local u165= {}
                for _, v in ipairs(u163) do
                    local u139= u164[tostring(v)]
                    if u139 then u165[#u165+1] = u139 end
                end
                if #u165 == 0 then return nil end
                return u165
            end
            local u166= u162()
            u161.save(u160, u166)
            u148[#u148+1] = u160
            u140(u148)
            u146(u160)
            u136.screenlog('[Config] Created config: ' .. u160, 4, 120, 180, 255, 255)
            if u136 and u136.pushlog and u143() then
                u136.pushlog('Created config: ' .. u160, 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_create_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    u131.ui.cfg_delete_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][1], u132.get("red", "ui") .. u134.get("trash") .. u132.get("default", "ui") .. 'Delete', function()
            local u148= u138()
            local u149= ui.get(u131.ui.cfg_listbox)
            local u159= u148[(u149 or 0) + 1]
            local u160= ui.get(u131.ui.cfg_input_box)
            local u142= (u159 and u159 ~= '(empty)' and u159 ~= '') and u159 or u160

            if u142 and u142 ~= '' and u142 ~= '(empty)' then
                local u161= require("require/abc/config_system")
                u161.delete(u142)
                local u148= u138()
                local u149= u141(u148, u142)
                if u149 then
                    table.remove(u148, u149)
                    u140(u148)
                end
                u146()
                u136.screenlog('[Config] Deleted config: ' .. u142, 4, 255, 80, 80, 255)
                if u136 and u136.pushlog and u143() then
                    u136.pushlog('Deleted config: ' .. u142, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for delete.')
                if u136 and u136.pushlog and u143() then
                    u136.pushlog('No config name selected for delete.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_delete_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    u131.ui.cfg_refresh_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("turning") .. u132.get("default", "ui") ..'Refresh', function()
            u146()
            u136.screenlog('[Config] Refreshed config list.', 4, 120, 180, 255, 255)
            if u136 and u136.pushlog and u143() then
                u136.pushlog('Refreshed config list.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_refresh_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    
    local u161= require("require/abc/config_system")
    local u167, u168= pcall(require, 'gamesense/clipboard')
    local u169= u168
    if not u167 or not u169 then
        u169 = {
            set = function(u170) end,
            get = function() return '' end,
        }
    end


    u131.ui.cfg_export_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("upload") .. u132.get("default", "ui") .. 'Export', function()
            local function u162()
                if not u131.ui.cfg_selection then return nil end
                local u144, u163= pcall(ui.get, u131.ui.cfg_selection)
                if not u144 or not u163 or type(u163) ~= 'table' or #u163 == 0 then return nil end
                local u164= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local u165= {}
                for u170, v in ipairs(u163) do
                    local u139= u164[tostring(v)]
                    if u139 then u165[#u165+1] = u139 end
                end
                if #u165 == 0 then return nil end
                return u165
            end
            local u166= u162()
            local u171= u161.build(u166)
            u169.set(u171)
            client.log('[Config] Exported config string:')
            client.log(u171)
            u136.screenlog('[Config] Exported config string to clipboard and console.', 4, 120, 180, 255, 255)
            if u136 and u136.pushlog and u143() then
                u136.pushlog('Exported config string to clipboard.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_export_button', tab = 'CFG', visible = true, config_type = 'button' }
    )

    u131.ui.cfg_import_button = u131.register_ui(
        ui.new_button(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("download") .. u132.get("default", "ui") .. 'Import', function()
            local u172= u169.get()
            if u172 and u172 ~= '' then
                local function u162()
                    if not u131.ui.cfg_selection then return nil end
                    local u144, u163= pcall(ui.get, u131.ui.cfg_selection)
                    if not u144 or not u163 or type(u163) ~= 'table' or #u163 == 0 then return nil end
                    local u164= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local u165= {}
                    for u170, v in ipairs(u163) do
                        local u139= u164[tostring(v)]
                        if u139 then u165[#u165+1] = u139 end
                    end
                    if #u165 == 0 then return nil end
                    return u165
                end
                local u166= u162()
                u161.apply(u172, u166)
                u136.screenlog('[Config] Imported config string from clipboard.', 4, 120, 180, 255, 255)
                if u136 and u136.pushlog and u143() then
                    u136.pushlog('Imported config string from clipboard.', 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config string found in clipboard.')
                if u136 and u136.pushlog and u143() then
                    u136.pushlog('No config string found in clipboard for import.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_import_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    u131.ui.cfg_selection = u131.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\n selection', 'antiaim', 'paint', 'misc'),
        { requires_login = true, key = 'cfg_selection', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    u131.ui.cfg_input_box = u131.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Config name'),
        { requires_login = true, key = 'cfg_input_box', tab = 'CFG', visible = true, config_type = 'textbox' }
    )
    u131.ui.cfg_listbox = u131.register_ui(
        ui.new_listbox(tab[2], cont[2][1], 'Configs', {}),
        { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    u146()

    u131.ui.cfg_cloud_apply = u131.register_ui(
        ui.new_button(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("globe") .. u132.get("default", "ui") .. ' Apply cloud', function()
            local u144, u163= pcall(ui.get, u131.ui.cfg_cloud)
            if not u144 then
                client.log('cfg_cloud_apply: failed to read selection')
                return
            end

            local u173= { 'Reset', 'Defensive', 'Unmatched', 'Community' }
            local u142= nil

            if type(u163) == 'number' then
                local u149= u163 + 1
                u142 = u173[u149]
            elseif type(u163) == 'table' then
                if #u163 > 0 and type(u163[1]) == 'number' then
                    u142 = u173[u163[1] + 1]
                else
                    u142 = tostring(u163[1])
                end
            else
                u142 = tostring(u163)
            end

            if not u142 or u142 == '' then
                client.log('cfg_cloud_apply: no selection')
                return
            end

            local u174, u175= pcall(require, 'require/abc/config_cloud')
            if not u174 or not u175 then
                client.log('cfg_cloud_apply: failed to load config_cloud module')
                return
            end

            local u176= u175[u142]
            if not u176 then
                client.log('cfg_cloud_apply: no cloud config string for', tostring(u142))
                return
            end

            local u177, u161= pcall(require, 'require/abc/config_system')
            if not u177 or not u161 or not u161.apply then
                client.log('cfg_cloud_apply: config_system.apply not available')
                return
            end

            u161.apply(u176)
            client.log('cfg_cloud_apply: applied cloud config', tostring(u142))
        end),
        { requires_login = true, key = 'cfg_cloud_apply', tab = 'AA', visible = true, config_type = 'button' }
    )

    u131.ui.cfg_cloud = u131.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'Cloud', { u132.get("red", "ui") .. 'Reset', u132.get("reddark", "ui") .. 'Defensive', u132.get("yellow", "ui") .. 'Unmatched', u132.get("grey", "ui") .. 'Community'}),
        { requires_login = true, key = 'cfg_cloud', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    u131.ui.fakelag_stealer = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("download") .. u132.get("default", "ui") .. 'Stealer' .. u132.get("blue", "ui") .. ' [BETA]' ),
        { requires_login = true, key = 'fakelag_stealer', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    u131.ui.fakelag_stealer_type = u131.register_ui(
        ui.new_combobox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("gear") .. u132.get("default", "ui") .. 'Type', 'mimic', 'import'),
        { requires_login = true, key = 'fakelag_stealer_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    u131.ui.fakelag_stealer_target = u131.register_ui(
        ui.new_combobox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("id") .. u132.get("default", "ui") .. 'Target', 'threat', 'closest', 'random', 'best kdas'),
        { requires_login = true, key = 'fakelag_stealer_target', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    u131.ui.fakelag_stealer_list = u131.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'target list', {'-'}),
        { requires_login = true, key = 'fakelag_stealer_list', tab = 'AA', visible = true, config_type = 'listbox' }
    )
    u131.ui.fakelag_stealer_refresh = u131.register_ui(
        ui.new_button(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("refresh") .. u132.get("default", "ui") .. 'Refresh', function() end),
        { requires_login = true, key = 'fakelag_stealer_refresh', tab = 'AA', visible = true, config_type = 'button' }
    )
    u131.ui.fakelag_stealer_steal = u131.register_ui(
        ui.new_button(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("clip") .. u132.get("default", "ui") .. 'Steal', function() end),
        { requires_login = true, key = 'fakelag_stealer_steal', tab = 'AA', visible = true, config_type = 'button' }
    )
    u131.ui.fakelag_fakelag = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("latency3") .. u132.get("default", "ui") .. 'Fakelag'),
        { requires_login = true, key = 'fakelag_fakelag', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    u131.ui.fakelag_fakelag_type = u131.register_ui(
        ui.new_combobox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("gear") .. u132.get("default", "ui") .. 'Type', 'gamesense', 'sodium'),
        { requires_login = true, key = 'fakelag_fakelag_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    u131.ui.fakelag_fakelag_amount = u131.register_ui(
        ui.new_combobox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("plus") .. u132.get("default", "ui") .. 'Amount', 'dynamic', 'maximum', 'fluctuate'),
        { requires_login = true, key = 'fakelag_fakelag_amount', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    u131.ui.fakelag_fakelag_variance = u131.register_ui(
        ui.new_slider(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("recycle") .. u132.get("default", "ui") .. 'Variance', 0, 100, 0, true, '%'),
        { requires_login = true, key = 'fakelag_fakelag_variance', tab = 'AA', visible = true, config_type = 'slider' }
    )
    u131.ui.fakelag_fakelag_limit = u131.register_ui(
        ui.new_slider(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("lock") .. u132.get("default", "ui") .. 'Limit', 1, 15, 1, true, 't'),
        { requires_login = true, key = 'fakelag_fakelag_limit', tab = 'AA', visible = true, config_type = 'slider' }
    )
    u131.ui.fakelag_fakelag_type2 = u131.register_ui(
        ui.new_combobox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("config") .. u132.get("default", "ui") .. 'Preset', 'jitter', 'max'),
        { requires_login = true, key = 'fakelag_fakelag_type2', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    u131.ui.fakelag_settings_freestanding = u131.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("turning2") .. u132.get("default", "ui") .. 'Freestanding options', 'static', 'zero pitch', 'defensive', 'side flip', 'pitch flip'),
        { requires_login = true, key = 'fakelag_settings_freestanding', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    u131.ui.fakelag_settings_enhance_onshot = u131.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("arrow_double") .. u132.get("default", "ui") .. 'Enhance on-shot aa', 'defensive', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_enhance_onshot', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    u131.ui.fakelag_settings_antibrute = u131.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("exclamation") .. u132.get("default", "ui") .. 'Antibrute', 'defensive', 'flip', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_antibrute', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    u131.ui.fakelag_settings_roll_checkbox = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], '\nuse roll'),
        { requires_login = true, key = 'fakelag_settings_roll_checkbox', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    u131.ui.fakelag_settings_roll_label = u131.register_ui(
        ui.new_label(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("recycle") .. u132.get("default", "ui") .. 'Roll'),
        { requires_login = false, key = 'label_roll', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.fakelag_settings_roll = u131.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nroll', 0, 45, 0, true, '°'),
        { requires_login = true, key = 'fakelag_settings_roll', tab = 'AA', visible = true, config_type = 'slider' }
    )
    u131.ui.fakelag_settings_side = u131.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nside', 1, 3, 1, true, '', 1, {
            [1] = 'left', [2] = 'swap', [3] = 'right'
        }),
        { requires_login = true, key = 'fakelag_settings_side', tab = 'AA', visible = true, config_type = 'slider' }
    )

    
    
    
    u131.ui.paint_advertisement = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nadvertisement', true),
        { requires_login = true, key = 'paint_advertisement', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_advertisement_animation = u131.register_ui(
        ui.new_slider(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("speaker") .. u132.get("default", "ui") .. 'Advertisement', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_advertisement_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    u131.ui.paint_advertisement_color = u131.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'rizz546456', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_advertisement_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    u131.ui.paint_watermark = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nwatermark'),
        { requires_login = true, key = 'paint_watermark', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_watermark_type = u131.register_ui(
        ui.new_slider(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("text") .. u132.get("default", "ui") .. 'Watermark', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_watermark_type', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    u131.ui.paint_watermark_color = u131.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'sigma9745', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_watermark_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    u131.ui.label_space2 = u131.register_ui(
        ui.new_label(tab[2], cont[2][1], '\n abc'),
        { requires_login = false, key = 'label_space2', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.label_space3 = u131.register_ui(
        ui.new_label(tab[2], cont[2][1], u132.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space3', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.paint_entidx = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'entidx'),
        { requires_login = true, key = 'paint_entidx', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_target_info = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'target info'),
        { requires_login = true, key = 'paint_target_info', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_filter_console = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'filter console'),
        { requires_login = true, key = 'paint_filter_console', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_minimum_damage = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'minimum damage'),
        { requires_login = true, key = 'paint_minimum_damage', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_show_damage_penetration = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'show damage penetration'),
        { requires_login = true, key = 'paint_show_damage_penetration', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_hitmiss_indicator = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'hit/miss indicator'),
        { requires_login = true, key = 'paint_hitmiss_indicator', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_self_skeleton = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'self skeleton'),
        { requires_login = true, key = 'paint_self_skeleton', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_bullet_tracer = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'bullet tracer'),
        { requires_login = true, key = 'paint_bullet_tracer', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_lagcomp_box = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lagcomp box'),
        { requires_login = true, key = 'paint_lagcomp_box', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_lagcomp_box_color = u131.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'lagcomp box color', 47, 117, 221, 255),
        { requires_login = true, key = 'paint_lagcomp_box_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    u131.ui.paint_presmoke = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'presmoke warning'),
        { requires_login = true, key = 'paint_presmoke', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_bombwarning = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'c4 warning'),
        { requires_login = true, key = 'paint_bombwarning', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_insults = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'insults'),
        { requires_login = true, key = 'paint_insults', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_rainbow_esp = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'rainbow esp'),
        { requires_login = true, key = 'paint_rainbow_esp', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_molotov = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'molotov particles'),
        { requires_login = true, key = 'paint_molotov', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_lag_record = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lag record'),
        { requires_login = true, key = 'paint_lag_record', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.label_space4 = u131.register_ui(
        ui.new_label(tab[2], cont[2][1], u132.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space4', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.paint_clantag = u131.register_ui(
        ui.new_combobox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("id") .. u132.get("default", "ui") .. 'Clantag', 'off', 'gamesense', 'sodium'),
        { requires_login = true, key = 'paint_clantag', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    u131.ui.paint_aimbot_logs = u131.register_ui(
        ui.new_combobox(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("clipboard") .. u132.get("default", "ui") .. 'Aimbot logs', 'off', 'gamesense', 'gamesense beta', 'sodium'),
        { requires_login = true, key = 'paint_aimbot_logs', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    u131.ui.label_space1 = u131.register_ui(
        ui.new_label(tab[2], cont[2][1], '\nextra space'),
        { requires_login = false, key = 'label_space1', tab = 'AA', visible = true, config_type = 'label' }
    )
    
    u131.ui.paint_indicators_enable = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n enable'),
        { requires_login = true, key = 'paint_indicators_enable', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_indicators_label = u131.register_ui(
        ui.new_label(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("pallete") .. u132.get("default", "ui") .. 'Indicators'),
        { requires_login = false, key = 'paint_indicators_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.paint_indicators = u131.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nIndicators', 'off', 'small', 'bold'),
        { requires_login = true, key = 'paint_indicators', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    u131.ui.paint_indicator_color = u131.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_indicator_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    u131.ui.paint_indicators_bar = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n bar'),
        { requires_login = true, key = 'paint_indicators_bar', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_indicators_animation = u131.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_indicators_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    u131.ui.paint_logger_checkbox = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n abc'),
        { requires_login = true, key = 'paint_logger_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_logger_label = u131.register_ui(
        ui.new_label(tab[2], cont[2][1], u132.get("green", "ui") .. u134.get("pen") .. u132.get("default", "ui") .. 'Logger'),
        { requires_login = false, key = 'paint_logger_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    u131.ui.paint_logger = u131.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\nLogger', 'aimbot', 'config', 'anti-aim', 'other'),
        { requires_login = true, key = 'paint_logger', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    u131.ui.paint_logger_color = u131.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_logger_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    u131.ui.paint_logger_animation = u131.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_logger_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    u131.ui.paint_hitmarker = u131.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("reject") .. u132.get("default", "ui") .. 'Hitmarkers', 'world +', 'skeleton', 'damage'),
        { requires_login = true, key = 'paint_hitmarker', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    u131.ui.paint_hitmarker_color = u131.register_ui(
        ui.new_color_picker(tab[2], cont[2][2], '\n + color', 0, 225, 225, 255),
        { requires_login = true, key = 'paint_hitmarker_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    u131.ui.paint_warnings = u131.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("warning") .. u132.get("default", "ui") .. 'Warnings', 'lethal', 'cant fire', 'low bullets'),
        { requires_login = true, key = 'paint_warnings', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    u131.ui.paint_performance_mode = u131.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("latency4") .. u132.get("default", "ui") .. 'Performance mode', 'blood', 'ragdolls', 'particles', 'lens flare', 'animations', 'feature updates'),
        { requires_login = true, key = 'paint_performance_mode', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    u131.ui.paint_animations = u131.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], u132.get("green", "ui") .. u134.get("turning2") .. u132.get("default", "ui") .. 'Animations', 'kingaru', 'body lean', 'gamesense legs', 'moonwalk', 'allah', 'static legs', 'no pitch on land', 'reversed legs', 'earthquake', 't-pose', 'blind', 'pitch up'),
        { requires_login = true, key = 'paint_animations', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    u131.ui.paint_aspect_ratio_checkbox = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], u132.get("green", "ui") .. u134.get("expand") .. u132.get("default", "ui") .. 'Aspect ratio'),
        { requires_login = true, key = 'paint_aspect_ratio_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_aspect_ratio = u131.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\naspect ratio', 0, 300, 0, true, '', 0.01, {
            [0] = 'default', [125] = '5:4', [133] = '4:3', [150] = '3:2', [160] = '16:10', [177] = '16:9'
        }),
        { requires_login = true, key = 'paint_aspect_ratio', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    u131.ui.paint_third_person_distance_checkbox = u131.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], u132.get("green", "ui") .. u134.get("camera") .. u132.get("default", "ui") .. 'Third person distance'),
        { requires_login = true, key = 'paint_third_person_distance_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    u131.ui.paint_third_person_distance = u131.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\nthird person distance', 30, 166, 150, true, '', 1, {
            [150] = 'default'
        }),
        { requires_login = true, key = 'paint_third_person_distance', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    
    
    
    
    local u178= {
        checkbox = 'c',
        slider = 's',
        combobox = 'o',
        multiselect = 'm',
    }
    for key, item in pairs(u131.ui) do
        for u170, entry in ipairs(u131.registered_items or {}) do
            if entry.key == key and entry.config_type and u178[entry.config_type] then
                u161.register(key, item, u178[entry.config_type], entry.tab)
            end
        end
    end
end

return u135]]
u743["require/abc/callbacks"] = [[




local u133= {}

local u134= 1
local u135= {}          
local u136= {}      
local u137= {}   

local function u138()
	local u139, u140= pcall(require, "require/abc/login_system")
	if not u139 or not u140 then return false end
	return u140.logged_in == true
end

local function u141(u142)
	if not u142 then return true end
	if u142.menu_only and not (ui and ui.is_menu_open and ui.is_menu_open()) then return false end
	if u142.alive_only then
		local u143= (entity and entity.get_local_player) and entity.get_local_player()
		if not u143 or not entity.is_alive(u143) then return false end
	end
	if u142.require_login then
		if not u138() then return false end
	end
	return true
end

local function u144(u145)
	return function(u146)
		local u147= u136[u145]
		if not u147 then return end
		local u148= {}
		for i=1,#u147 do u148[i] = u147[i] end
		for i=1,#u148 do
			local u149= u148[i]
			local u150= u135[u149]
			if u150 and u150.wrapper then
				local u139, u151= pcall(u150.wrapper, u146)
				if not u139 then
					local u152= nil
					pcall(function()
						u152 = debug.getinfo(u150.user_fn, "Sln")
					end)
					local u153= u152 and u152.short_src or "<unknown>"
					local u154= u152 and (u152.linedefined or -1) or -1
					pcall(client.error_log, string.format("callback[%d] error: %s (source=%s:%d)", u149, tostring(u151), u153, u154))
				end
			end
		end
	end
end



function callbacks.register(u145,u155,u156,u157,u158)
	if type(u145) ~= 'string' then error('event must be a string') end
	if type(u155) ~= 'function' then error('callback must be a function') end

	local u142= nil
	if type(u156) == 'table' then u142 = u156
	else
		u142 = { menu_only = (u156 == true), alive_only = (u157 == true), require_login = (u158 == true) }
	end

	local u149= u134; u134 = u134 + 1
	local u159= function(u146)
		if u141(u142) then
			return u155(u146)
		end
	end

	u135[u149] = { event = u145, wrapper = u159, user_fn = u155, opts = u142 }
	u136[u145] = u136[u145] or {}
	u136[u145][#u136[u145] + 1] = u149

	
	if not u137[u145] then
		local u160= u144(u145)
		u137[u145] = u160
		pcall(client.set_event_callback, u145, u160)
	end

	return u149
end

function callbacks.callback(u145,u156,u157,u158,u161)
	if type(u156) == 'function' then
		return u133.register(u145, u156, u157)
	end
	if type(u161) == 'function' then
		local u155= u161
		local u142= { menu_only = (u156 == true), alive_only = (u157 == true), require_login = (u158 == true) }
		return u133.register(u145, u155, u142)
	end
	error('invalid callback signature')
end

function callbacks.unregister(u149)
	local u150= u135[u149]
	if not u150 then return false end
	local u145= u150.event
	u135[u149] = nil
	local u162= u136[u145]
	if u162 then
		for i=#u162,1,-1 do if u162[i] == u149 then table.remove(u162, i) end end
		if #u162 == 0 then
			u136[u145] = nil
			local u160= u137[u145]
			if u160 then pcall(client.unset_event_callback, u145, u160) end
			u137[u145] = nil
		end
	end
	return true
end

function callbacks.clear_all()
	for u145, u160 in pairs(u137) do
		pcall(client.unset_event_callback, u145, u160)
	end
	u135 = {}
	u136 = {}
	u137 = {}
end

function callbacks._list()
	return { regs = u135, by_event = u136 }
end

pcall(function()
	if lua and lua.defer then
		lua.defer(u133.clear_all)
	else
		pcall(client.set_event_callback, 'shutdown', u133.clear_all)
	end
end)

return u133
]]
u743["require/abc/config_cloud"] = [[local u136= {
    Reset = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfbW92ZXx0PW98dj1vZmYKeWF3X2Zha2VsYWd8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wK3x0PXN8dj0wCmZha2VsYWdfc2V0dGluZ3Nfc2lkZXx0PXN8dj0xCnBpdGNoX21vdmV8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbW92ZXx0PXN8dj0wCmZha2VsYWdfZm9yY2Vfb258dD1tfHY9CmZha2VsYWdfZGVmZW5zaXZlfHQ9Y3x2PWZhbHNlCnlhd193YWxrfHQ9b3x2PW9mZgpzdGF0aWNfYm9keV95YXdfZmFrZWxhZ3x0PXN8dj0wCnBpdGNoX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfanVtcHx0PXN8dj0yCmJvZHlfeWF3X21vZGVfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXArfHQ9c3x2PTIKeWF3X2ppdHRlcl9iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfYmFzZV9kdWNrK3x0PW98dj10YXJnZXQKb25seV9mbGlwX29uXzBfY2hva2VfZHVjayt8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PWZhbHNlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9MApib2R5X3lhd19sZWZ0X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19zdGFuZHx0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19nbG9iYWx8dD1zfHY9MApwaXRjaF9kdWNrfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PW9mZgp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRhcmdldApmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wfHQ9c3x2PTAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PQpzZW5kX2NvbWJvanVtcHx0PW98dj1nbG9iYWwKc2VuZF9jb21ib2p1bXArfHQ9b3x2PWdsb2JhbApvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj1mYWxzZQpzdGF0aWNfYm9keV95YXdfbW92ZXx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVjayt8dD1zfHY9MAp5YXdfYmFzZV9nbG9iYWx8dD1vfHY9dGFyZ2V0CmVuYWJsZV9sZWdpdHx0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PQpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9kdWNrK3x0PXN8dj0yCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfdmFsdWVfbGVnaXR8dD1zfHY9Mgpib2R5X3lhd19iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfanVtcCt8dD1vfHY9b2ZmCmRlbGF5X3dhbGt8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdHlwZTJ8dD1vfHY9aml0dGVyCnlhd19sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9zdGFuZHx0PXN8dj0wCmVuYWJsZV9qdW1wK3x0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZmFrZWxhZ3x0PW98dj1nbG9iYWwKeWF3X2ppdHRlcl9iYXNlX2R1Y2t8dD1zfHY9MApmaWZ0eV9maWZ0eV9qdW1wfHQ9Y3x2PWZhbHNlCnBpdGNoX2xlZ2l0fHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfc3RhbmR8dD1zfHY9MAp5YXdfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfanVtcHx0PW98dj1vZmYKYm9keV95YXdfcmlnaHRfZHVja3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVjayt8dD1zfHY9MApib2R5X3lhd19tb2RlX3dhbGt8dD1vfHY9b2ZmCmJvZHlfeWF3X3JpZ2h0X2p1bXArfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10YXJnZXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj1mYWxzZQp5YXdfanVtcHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV93YWxrfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19nbG9iYWx8dD1zfHY9MApmaWZ0eV9maWZ0eV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfbW92ZXx0PW98dj1vZmYKeWF3X2Jhc2VfanVtcCt8dD1vfHY9dGFyZ2V0CnBpdGNoX2R1Y2srfHQ9b3x2PW1pbmltYWwKYm9keV95YXdfbW9kZV9qdW1wK3x0PW98dj1vZmYKc2VuZF9jb21ib2R1Y2t8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfZmFrZWxhZ3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVja3x0PW98dj1vZmYKZmFrZWxhZ19zdGVhbGVyX3RhcmdldHx0PW98dj10aHJlYXQKZmlmdHlfZmlmdHlfZHVjayt8dD1jfHY9ZmFsc2UKb25seV9mbGlwX29uXzBfY2hva2VfanVtcHx0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTAKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0wCmRlbGF5X2R1Y2srfHQ9c3x2PTEKYm9keV95YXdfbW9kZV9sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfZHVja3x0PXN8dj0yCmVuYWJsZV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PW9mZgp5YXdfYmFzZV9zdGFuZHx0PW98dj10YXJnZXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PW9mZgp5YXdfaml0dGVyX3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2xlZ2l0fHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19iYXNlX2xlZ2l0fHQ9b3x2PXRhcmdldApzdGF0aWNfYm9keV95YXdfd2Fsa3x0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X2Zha2VsYWd8dD1zfHY9MApkZWxheV9kdWNrfHQ9c3x2PTEKZmFrZWxhZ19zZXR0aW5nc19yb2xsfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2xpbWl0fHQ9c3x2PTEKZmFrZWxhZ19mYWtlbGFnX3ZhcmlhbmNlfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2Ftb3VudHx0PW98dj1keW5hbWljCmZha2VsYWdfZmFrZWxhZ190eXBlfHQ9b3x2PWdhbWVzZW5zZQpyYW5kb21pemVfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9nbG9iYWx8dD1zfHY9MApyYW5kb21pemVfeWF3X3dhbGt8dD1zfHY9MApjZmdfc2VsZWN0aW9ufHQ9bXx2PWFudGlhaW0KYm9keV95YXdfdmFsdWVfbW92ZXx0PXN8dj0yCmZpZnR5X2ZpZnR5X21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfbW92ZXx0PWN8dj1mYWxzZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ3x0PWN8dj1mYWxzZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfd2Fsa3x0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9zdGFuZHx0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZHVjayt8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnlhd19qaXR0ZXJfanVtcCt8dD1vfHY9b2ZmCnlhd19iYXNlX2p1bXB8dD1vfHY9dGFyZ2V0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKcGl0Y2hfanVtcCt8dD1vfHY9b2ZmCnlhd19kdWNrfHQ9b3x2PW9mZgpkZWxheV9qdW1wK3x0PXN8dj0xCmRlbGF5X3N0YW5kfHQ9c3x2PTEKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj0wCmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVja3x0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10YXJnZXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9MApib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgpib2R5X3lhd19sZWZ0X2dsb2JhbHx0PXN8dj0wCmRlbGF5X21vdmV8dD1zfHY9MQpkZWxheV9qdW1wfHQ9c3x2PTEKZW5hYmxlX2p1bXB8dD1jfHY9ZmFsc2UKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PTAKYm9keV95YXdfbGVmdF9qdW1wK3x0PXN8dj0wCnlhd19tb3ZlfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PWZhbHNlCmZha2VsYWdfZmFrZWRlZnx0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX2dsb2JhbHx0PW98dj1vZmYKZmlmdHlfZmlmdHlfanVtcCt8dD1jfHY9ZmFsc2UKY29uZGl0aW9ufHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X21vdmV8dD1zfHY9MApkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PWZhbHNl0000',
    Defensive = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9dHJ1ZQp5YXdfd2Fsa3x0PW98dj0xODAKc3RhdGljX2JvZHlfeWF3X2Zha2VsYWd8dD1zfHY9MApwaXRjaF9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXB8dD1zfHY9Mgpib2R5X3lhd19tb2RlX3N0YW5kfHQ9b3x2PWppdHRlcgpib2R5X3lhd192YWx1ZV9qdW1wK3x0PXN8dj0yCnlhd19qaXR0ZXJfYmFzZV9mYWtlbGFnfHQ9c3x2PTAKeWF3X2Jhc2VfZHVjayt8dD1vfHY9dGhyZWF0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2srfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PXRydWUKZGVsYXlfbGVnaXR8dD1zfHY9MQp5YXdfc3RhbmR8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVja3x0PXN8dj0wCmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKcGl0Y2hfZHVja3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfZHVjayt8dD1vfHY9aml0dGVyCnlhd19iYXNlX21vdmV8dD1vfHY9dGhyZWF0CmZha2VsYWdfbW9kZXx0PW98dj1zZXR0aW5ncwpwaXRjaF93YWxrfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9iYXNlX2p1bXB8dD1zfHY9MTIwCnNlbmRfY29tYm93YWxrfHQ9b3x2PWdsb2JhbApmYWtlbGFnX3NldHRpbmdzX2ZyZWVzdGFuZGluZ3x0PW18dj1zdGF0aWMJemVybyBwaXRjaAlkZWZlbnNpdmUJc2lkZSBmbGlwCnNlbmRfY29tYm9qdW1wfHQ9b3x2PWdsb2JhbApzZW5kX2NvbWJvanVtcCt8dD1vfHY9Z2xvYmFsCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXArfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9dHJ1ZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PWRlZmVuc2l2ZQlyb2xsCWppdHRlcgpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9MgpzZW5kX2NvbWJvbGVnaXR8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfbGVnaXR8dD1zfHY9LTU4Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTQKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9MApyYW5kb21pemVfeWF3X2R1Y2srfHQ9c3x2PTAKYm9keV95YXdfbW9kZV93YWxrfHQ9b3x2PXN0YXRpYwpib2R5X3lhd19yaWdodF9qdW1wK3x0PXN8dj0zNwpvbmx5X2ZsaXBfb25fMF9jaG9rZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmZha2VsYWdfc2V0dGluZ3NfYW50aWJydXRlfHQ9bXx2PQp5YXdfYmFzZV93YWxrfHQ9b3x2PXRocmVhdApmYWtlbGFnX3N0ZWFsZXJ8dD1jfHY9ZmFsc2UKZW5hYmxlX3N0YW5kfHQ9Y3x2PXRydWUKeWF3X2p1bXB8dD1vfHY9MTgwCmJvZHlfeWF3X2Jhc2Vfd2Fsa3x0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19zdGFuZHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZ2xvYmFsfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZHVja3x0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX21vdmV8dD1vfHY9aml0dGVyCnlhd19iYXNlX2p1bXArfHQ9b3x2PXRocmVhdApwaXRjaF9kdWNrK3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2p1bXB8dD1zfHY9MTgKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0tMwpkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjcKc2VuZF9jb21ib21vdmV8dD1vfHY9Z2xvYmFsCnJhbmRvbWl6ZV95YXdfbW92ZXx0PXN8dj0wCnBpdGNoX2p1bXB8dD1vfHY9ZG93bgp5YXdfYmFzZV9zdGFuZHx0PW98dj10aHJlYXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9zdGFuZHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2dsb2JhbHx0PWN8dj1mYWxzZQp5YXdfYmFzZV9sZWdpdHx0PW98dj10aHJlYXQKc3RhdGljX2JvZHlfeWF3X3dhbGt8dD1zfHY9MApib2R5X3lhd19yaWdodF9mYWtlbGFnfHQ9c3x2PTAKZGVsYXlfZHVja3x0PXN8dj01CmZha2VsYWdfc2V0dGluZ3Nfcm9sbHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19saW1pdHx0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ192YXJpYW5jZXx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19hbW91bnR8dD1vfHY9ZHluYW1pYwpmYWtlbGFnX2Zha2VsYWdfdHlwZXx0PW98dj1zb2RpdW0KcmFuZG9taXplX3lhd19qdW1wfHQ9c3x2PTAKeWF3X2ppdHRlcl9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKcmFuZG9taXplX3lhd193YWxrfHQ9c3x2PTAKY2ZnX3NlbGVjdGlvbnx0PW18dj1hbnRpYWltCmJvZHlfeWF3X3ZhbHVlX21vdmV8dD1zfHY9MgpmaWZ0eV9maWZ0eV9tb3ZlfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfYmFzZV9kdWNrK3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX21vdmV8dD1jfHY9dHJ1ZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0yNApmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV93YWxrfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCnNlbmRfY29tYm9kdWNrK3x0PW98dj1nbG9iYWwKYm9keV95YXdfcmlnaHRfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9qdW1wK3x0PW98dj1vZmYKeWF3X2Jhc2VfanVtcHx0PW98dj10aHJlYXQKb25seV9mbGlwX29uXzBfY2hva2VfbGVnaXR8dD1jfHY9dHJ1ZQpib2R5X3lhd19tb2RlX2R1Y2t8dD1vfHY9c3RhdGljCnN0YXRpY19ib2R5X3lhd19sZWdpdHx0PXN8dj0wCnBpdGNoX2p1bXArfHQ9b3x2PWRvd24KeWF3X2R1Y2t8dD1vfHY9MTgwCmRlbGF5X2p1bXArfHQ9c3x2PTMKZGVsYXlfc3RhbmR8dD1zfHY9NApmYWtlbGFnX2ZvcmNlfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X3JpZ2h0X2R1Y2srfHQ9c3x2PTQ0CmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0tMTUKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTE0Cnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9NTgKYm9keV95YXdfdmFsdWVfZ2xvYmFsfHQ9c3x2PTIKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApkZWxheV9tb3ZlfHQ9c3x2PTEKZGVsYXlfanVtcHx0PXN8dj0xCmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTQKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PS0xNgpib2R5X3lhd19sZWZ0X2p1bXArfHQ9c3x2PS05Cnlhd19tb3ZlfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PS0xNQpzdGF0aWNfYm9keV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3dhbGt8dD1jfHY9dHJ1ZQpmYWtlbGFnX2Zha2VkZWZ8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9nbG9iYWx8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmNvbmRpdGlvbnx0PW98dj1zdGFuZApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfbW92ZXx0PXN8dj00MgpkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PXRydWU00=',
    Unmatched = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9MgplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9ZmFsc2UKeWF3X3dhbGt8dD1vfHY9MTgwCnN0YXRpY19ib2R5X3lhd19mYWtlbGFnfHQ9c3x2PTAKcGl0Y2hfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9qdW1wfHQ9c3x2PTIKYm9keV95YXdfbW9kZV9zdGFuZHx0PW98dj1qaXR0ZXIKYm9keV95YXdfdmFsdWVfanVtcCt8dD1zfHY9Mgp5YXdfaml0dGVyX2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19iYXNlX2R1Y2srfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV9kdWNrK3x0PWN8dj10cnVlCnlhd19iYXNlX2Zha2VsYWd8dD1vfHY9dGFyZ2V0CnNlbmRfY29tYm9nbG9iYWx8dD1vfHY9Z2xvYmFsCnN0YXRpY19ib2R5X3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3dhbGt8dD1zfHY9MgplbmFibGVfd2Fsa3x0PWN8dj10cnVlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9LTM0CmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIxCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX3dhbGt8dD1zfHY9MApib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PWppdHRlcgpmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9ZG93bgp5YXdfaml0dGVyX2Jhc2VfanVtcHx0PXN8dj0xMjAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PXN0YXRpYwlkZWZlbnNpdmUKc2VuZF9jb21ib2p1bXB8dD1vfHY9Z2xvYmFsCnNlbmRfY29tYm9qdW1wK3x0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9ZmFsc2UKZmFrZWxhZ19zZXR0aW5nc19lbmhhbmNlX29uc2hvdHx0PW18dj1kZWZlbnNpdmUJcm9sbAlqaXR0ZXIKc3RhdGljX2JvZHlfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2Jhc2VfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF93YWxrfHQ9c3x2PTIzCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTIKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9NDQKcmFuZG9taXplX3lhd19kdWNrK3x0PXN8dj0wCmJvZHlfeWF3X21vZGVfd2Fsa3x0PW98dj1zdGF0aWMKYm9keV95YXdfcmlnaHRfanVtcCt8dD1zfHY9NTQKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10aHJlYXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj10cnVlCnlhd19qdW1wfHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3dhbGt8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfc3RhbmR8dD1zfHY9MApyYW5kb21pemVfeWF3X2dsb2JhbHx0PXN8dj0wCmZpZnR5X2ZpZnR5X2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9tb3ZlfHQ9b3x2PWppdHRlcgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9zdGFuZHx0PWN8dj10cnVlCmJvZHlfeWF3X2Jhc2VfanVtcHx0PXN8dj03CmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTI0CnJhbmRvbWl6ZV95YXdfZmFrZWxhZ3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfanVtcCt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9zdGFuZHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfanVtcCt8dD1zfHY9MApkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PWRvd24KeWF3X2Jhc2Vfc3RhbmR8dD1vfHY9dGhyZWF0Cnlhd19qaXR0ZXJfZmFrZWxhZ3x0PW98dj1vZmYKc2VuZF9jb21ib3N0YW5kfHQ9b3x2PWdsb2JhbApwaXRjaF9zdGFuZHx0PW98dj1kb3duCnlhd19qaXR0ZXJfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbGVnaXR8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV9nbG9iYWx8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfbGVnaXR8dD1vfHY9dGFyZ2V0CnN0YXRpY19ib2R5X3lhd193YWxrfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfZmFrZWxhZ3x0PXN8dj0wCmRlbGF5X2R1Y2t8dD1zfHY9NQpmYWtlbGFnX3NldHRpbmdzX3JvbGx8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfbGltaXR8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdmFyaWFuY2V8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfYW1vdW50fHQ9b3x2PWR5bmFtaWMKZmFrZWxhZ19mYWtlbGFnX3R5cGV8dD1vfHY9c29kaXVtCnlhd19qaXR0ZXJfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2dsb2JhbHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfd2Fsa3x0PXN8dj0wCmNmZ19zZWxlY3Rpb258dD1tfHY9YW50aWFpbQpib2R5X3lhd192YWx1ZV9tb3ZlfHQ9c3x2PTIKZmlmdHlfZmlmdHlfbW92ZXx0PWN8dj1mYWxzZQpkZWxheV9tb3ZlfHQ9c3x2PTMKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmZha2VsYWdfc3RlYWxlcl90eXBlfHQ9b3x2PW1pbWljCmJvZHlfeWF3X3JpZ2h0X3N0YW5kfHQ9c3x2PTQwCnBpdGNoX2R1Y2t8dD1vfHY9ZG93bgpmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQplbmFibGVfbW92ZXx0PWN8dj10cnVlCmVuYWJsZV9nbG9iYWx8dD1jfHY9ZmFsc2UKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApib2R5X3lhd19yaWdodF9tb3ZlfHQ9c3x2PTQyCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXArfHQ9b3x2PW9mZgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj10cnVlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1qaXR0ZXIKZGVsYXlfc3RhbmR8dD1zfHY9MQp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApwaXRjaF9qdW1wK3x0PW98dj1kb3duCmRlbGF5X2p1bXArfHQ9c3x2PTUKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQplbmFibGVfZmFrZWxhZ3x0PWN8dj1mYWxzZQpvbmx5X2ZsaXBfb25fMF9jaG9rZV9tb3ZlfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX21vdmV8dD1zfHY9MAp5YXdfZ2xvYmFsfHQ9b3x2PW9mZgpjYWNoZV9jcmVkZW50aWFsc3x0PWN8dj10cnVlCnJhbmRvbWl6ZV95YXdfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF9sZWdpdHx0PXN8dj0wCmRlbGF5X2dsb2JhbHx0PXN8dj0xCmRlbGF5X2p1bXB8dD1zfHY9MQpib2R5X3lhd19sZWZ0X2p1bXB8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2xlZnRfd2Fsa3x0PXN8dj0tMTYKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcCt8dD1zfHY9LTE4Cnlhd19kdWNrfHQ9b3x2PTE4MAp5YXdfYmFzZV9qdW1wK3x0PW98dj10aHJlYXQKeWF3X21vdmV8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVjayt8dD1zfHY9LTE1CmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKZmFrZWxhZ19mYWtlZGVmfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZ2xvYmFsfHQ9b3x2PW9mZgp5YXdfYmFzZV9qdW1wfHQ9b3x2PXRocmVhdApjb25kaXRpb258dD1vfHY9ZHVjaysKc2VuZF9jb21ib2R1Y2srfHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj00NAp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX2R1Y2srfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2Zha2VsYWd8dD1vfHY9b2ZmCmRlbGF5X2Zha2VsYWd8dD1zfHY9MQpzdGF0aWNfYm9keV95YXdfZHVjayt8dD1zfHY9MAp5YXdfaml0dGVyX2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXB8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X3dhbGt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfZmFrZWxhZ3x0PWN8dj1mYWxzZQpwaXRjaF9kdWNrK3x0PW98dj1kb3du0000',
    Community = '',
}
return u136]]
u743["require/abc/config_system"] = [[


local u139='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

local function u140(u141)
    return ((u141:gsub('.', function(u142)
        local u143,u139='',u142:byte()
        for i=8,1,-1 do u143=u143..(u139%2^i-u139%2^(i-1)>0 and '1' or '0') end
        return u143
    end)..'0000'):gsub('%d%d%d%d%d%d', function(u142)
        if (#u142 < 6) then return '' end
        return u139:sub(tonumber(u142,2)+1,tonumber(u142,2)+1)
    end)..({ '', '==', '=' })[#u141%3+1])
end

local function u144(u141)
    u141 = string.gsub(u141, '[^'..b..'=]', '')
    return (u141:gsub('.', function(u142)
        if u142 == '=' then return '' end
        local u143,u145='',(u139:find(u142)-1)
        for i=6,1,-1 do u143=u143..(u145%2^i-u145%2^(i-1)>0 and '1' or '0') end
        return u143
    end):gsub('%d%d%d%d%d%d%d%d', function(u142)
        if (#u142 ~= 8) then return '' end
        local u146=0
        for i=1,8 do u146=u146+(u142:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(u146)
    end))
end





local u147= database

local u148= {}
local u149= {}

local function u150(u151,u152,u153,u154)
    if not u151 or u151 == '' or not u152 or u149[u151] then return end
    u148[#u148+1] = { key = u151, ref = u152, type = u153, tab = u154 }
    u149[u151] = u148[#u148]
end

local function u155(u156)
    local function u157(u158,u156)
        if not u156 or #u156 == 0 then return true end
        if u158 == 'CFG' then return true end
        if not u158 then return true end
        for _, t in ipairs(u156) do if t == u158 then return true end end
        return false
    end

    local u159= { 'v=1' }
    for i = 1, #u148 do
        local u160= u148[i]
        if u157(u160.tab, u156) then
            local u161= u160.type
            local u162= ui.get(u160.ref)
            if u161 == 'c' then
                u159[#u159+1] = u160.key .. '|t=c|v=' .. (u162 and 'true' or 'false')
            elseif u161 == 's' then
                u159[#u159+1] = u160.key .. '|t=s|v=' .. tostring(u162 or 0)
            elseif u161 == 'o' then
                u159[#u159+1] = u160.key .. '|t=o|v=' .. tostring(u162 or '')
            elseif u161 == 'm' then
                if type(u162) == 'table' then
                    u159[#u159+1] = u160.key .. '|t=m|v=' .. table.concat(u162, '\t')
                end
            end
        end
    end
    return u140(table.concat(u159, '\n'))
end

local function u163(u164,u156)
    if not u164 or u164 == '' then return end
    local u165, u166= pcall(u144, u164)
    if not u165 or not u166 or u166 == '' then return end
    local function u157(u158,u156)
        if not u156 or #u156 == 0 then return true end
        if u158 == 'CFG' then return true end
        if not u158 then return true end
        for _, u161 in ipairs(u156) do if u161 == u158 then return true end end
        return false
    end
    for line in u166:gmatch('([^\n]+)') do
        if line ~= 'v=1' then
            local u151, u167, u168= line:match('^(.-)|t=(.)|v=(.*)$')
            if u151 and u167 and u168 then
                local u160= u149[u151]
                if u160 and u160.type == u167 and u157(u160.tab, u156) then
                    if u167 == 'c' then
                        ui.set(u160.ref, vseg == 'true')
                    elseif u167 == 's' then
                        local u169= tonumber(u168)
                        if u169 ~= nil then
                            ui.set(u160.ref, u169)
                        end
                    elseif u167 == 'o' then
                        pcall(ui.set, u160.ref, u168)
                    elseif u167 == 'm' then
                        local u170= {}
                        for token in u168:gmatch('[^\t]+') do u170[#u170+1] = token end
                        ui.set(u160.ref, u170)
                    end
                end
            end
        end
    end
end


local function u171(u172,u156)
    if not u172 or u172 == '' then return end
    local u164= u155(u156)
    u147.write('cfg:' .. u172, u164)
end


local function u173(u172,u156)
    if not u172 or u172 == '' then return end
    local u164= u147.read('cfg:' .. u172)
    if u164 then u163(u164, u156) end
end


local function u174(u172)
    if not u172 or u172 == '' then return end
    u147.write('cfg:' .. u172, nil)
end


local u175= {
    register = u150,
    build = u155,
    apply = u163,
    save = u171,
    load = u173,
    delete = u174,
}

return u175]]
u743["require/abc/garbage_collector"] = [[local u142= {}

local u143= {
    pause = 200,
    stepmul = 600,
    mode = "collect"
}

function gc.tune(u144)
	if type(u144) == "table" then
		if u144.pause then
			collectgarbage("setpause", u144.pause)
			u143.pause = u144.pause
		end
		if u144.stepmul then
			collectgarbage("setstepmul", u144.stepmul)
			u143.stepmul = u144.stepmul
		end
		if u144.mode then
			u143.mode = u144.mode
		end
	end
end

function gc.collect(u145)
	collectgarbage(u145 or u143.mode)
end

function gc.step(u146)
	return collectgarbage("step", u146 or 0)
end

function gc.stop()
	collectgarbage("stop")
end

function gc.restart()
	collectgarbage("restart")
end

function gc.memory()
	return collectgarbage("count")
end

function gc.status()
	return {
		memory = u142.memory(),
		pause = u143.pause,
		stepmul = u143.stepmul,
		mode = u143.mode
	}
end

local u147= 0
function gc.dynamic(u144)
	u144 = type(u144) == "table" and u144 or {}
	local u148= u144.min_interval or 0.6
	local u149= (globals and globals.realtime) and globals.realtime() or (u147 + u148)
	if u149 - u147 < u148 then
		return
	end
	u147 = u149

	local u146= u144.step_size or 20
	local u150= u144.full_threshold_kb or 65536
	local u151= u144.aggressive_threshold_kb or 12288

	local u152, u153= pcall(collectgarbage, "count")
	if not u152 or type(u153) ~= "number" then
		pcall(collectgarbage, "step", u146)
		return
	end

	if u153 >= u150 then
		pcall(collectgarbage, "collect")
		return
	end

	if u153 >= u151 then
		pcall(collectgarbage, "step", u146)
		pcall(collectgarbage, "step", u146)
		return
	end

	pcall(collectgarbage, "step", u146)
end

if lua and lua.defer then
	lua.defer(function()
		u142.collect()
	end)
end

return u142]]
u743["require/abc/hwid_check"] = [[local u145= require("ffi")
local u146= require("require/brain/dll")
local u147= 1
local u148= 1

local function u149()
    return globals.curtime and globals.curtime() or 0
end

local function u150()
    local shared= rawget(_G, "loader_shared")
    if not shared or type(shared) ~= "table" then
    return nil, "missing"
    end
    local u151= tonumber(shared.expires) or 0
    if u149() > u151 then
    return nil, "expired"
    end
    if type(shared.hwids) ~= "table" then
    return nil, "bad_hwids"
    end
    return shared, nil
end

local u152= false

local function u153()
    if not u146 or type(u146) ~= "table" or type(u146.get_hwid) ~= "function" then
        print("invalid hwid")
    return
    end

    local u154
    
    local u155, u156= pcall(u146.get_hwid)
    if u155 and u156 and u156 ~= u145.NULL then
    if type(u156) == "cdata" then
        local u157, u158= pcall(u145.string, u156)
        if u157 then u154 = u158 end
    else
        u154 = tostring(u156)
    end
    end

    if not u154 or u154 == "" then
        print("invalid hwid")
    end

    local shared, u159= u150()
    if not shared then
        print("invalid hwid")
    end

    local u160= shared.hwids
    local u161= false
    for i = 1, #u160 do
    local u162= tostring(u160[i] or "")
    if u162:find(tostring(u154), 1, true) then
        u161 = true
        break
    end
    end


    if u161 then
        local u163= rawget(_G, "loader_init_after_hwid")
        if not u152 and type(u163) == "function" then
        u152 = true
        local u164, u165= pcall(u163)
        if not u164 then
            print("invalid hwid")
        end
        end
    else
        print("invalid hwid")
    end
end

local u166= 0
local function u167()
    u166 = u166 + 1
    local shared= rawget(_G, "loader_shared")
    if shared then
    u153()
    return
    end
    if u166 > u147 then
        print("invalid hwid")
        return
    end

    if type(client.delay_call) == "function" then
        client.delay_call(u148, u167)
    else
        u153()
    end

end


u167()]]
u743["require/abc/login_system"] = [[local u148= {}


local function u149(u150)
	if client.hash_sha256 then
		return client.hash_sha256(u150)
	end
	
	return tostring(u150):reverse()
end


local u151= "acc_" .. "897ntv45ynvttyjt980745nyv0t485vn87t6"

local function u152()
	local u153= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local u154= ""
	for i = 1, 16 do
		local u155= math.random(1, #u153)
		u154 = u154 .. u153:sub(u155, u155)
	end
	return u154
end

function login_system.hash_password(u156,u154)
	return u149(u154 .. u156)
end

function login_system.verify_password(u156,u157,u154)
	return u148.hash_password(u156, u154) == u157
end

function login_system.get_hwid()
	
	return tostring(client.userid_to_entindex(client.userid_to_entindex(1)))
end

function login_system.store_credentials(u158,u156)
	local u154= u152()
	local u157= u148.hash_password(u156, u154)
	database.write("login_credentials", { username = u158, hash = u157, salt = u154 })
end

function login_system.load_credentials()
	return database.read("login_credentials")
end


function login_system.login(u158,u156)
	
	local u159= database.read(u151) or {}
	local u160= u159[u158]
	if u160 and u160.enabled ~= false then
		if u148.verify_password(u156, u160.hash, u160.salt) then
			u148.logged_in = true
			return true
		end
	end
	
	local u161= u148.load_credentials()
	if u161 and u161.username == u158 then
		if u148.verify_password(u156, u161.hash, u161.salt) then
			u148.logged_in = true
			return true
		end
	end
	u148.logged_in = false
	return false
end

function login_system.logout()
	u148.logged_in = false
end

function login_system.reset_password(u162)
	
	database.write("login_credentials", nil)
end



function login_system.is_valid_invite(u163)
	if not u163 or u163 == "" then
		return false, nil
	end
	local u164= database.read(u151 .. ":invites") or {}
	local u165= u164[u163]
	if not u165 then
		return false, nil
	end
	if u165.used then
		return false, u165
	end
	return true, u165
end

function login_system.add_account(u158,u156)
	local u154= u152()
	local u157= u148.hash_password(u156, u154)
	local u159= database.read(u151) or {}
	u159[u158] = { hash = u157, salt = u154, role = "user", enabled = true, orig_password = u156 }
	database.write(u151, u159)
end

function login_system.register_with_invite(u163,u158,u156)
	if not u163 or u163 == '' then return false, 'no invite provided' end
	local u164= database.read(u151 .. ":invites") or {}
	local u165= u164[u163]
	if not u165 then return false, 'invalid invite' end
	if u165.used then return false, 'invite already used' end

	u148.add_account(u158, u156)

	u165.used = true
	u165.used_by = u158
	u165.redeemed_at = client.unix_time()
	u164[u163] = u165
	database.write(u151 .. ":invites", u164)

	return true
end

function login_system.invalidate_invite(u163)
	local u164= database.read(u151 .. ":invites") or {}
	if u164[u163] then
		u164[u163] = nil
		database.write(u151 .. ":invites", u164)
		return true
	end
	return false
end

return u148
]]
u743["require/abc/menu_header"] = [[local u151, u152, u153= 1, 398, 49
local u154= 0.85 
local u155= { "AA", "PAINT", "MISC", "CFG" }
local u156= u155[u151]
local u157= {}
local u158= {
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS1.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS2.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS3.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS4.png"
}
local u159

local u160= {
    size = {
        x = 6,
        y = 6,
        w = 120,
        h = 72, 
    },
    skeet_cur_tab = 8,
}

local function u161()
    local u162= { ui.menu_position() }
    local u163= { ui.mouse_position() }
    if not u162[1] or not u162[2] or not u163[1] or not u163[2] then
        return u160.skeet_cur_tab
    end

    for i = 1, 9 do
        local u164= { u160.size.x, u160.size.y + u160.size.h * (i - 1) }
        if u163[1] >= u162[1] + u164[1]
           and u163[1] <= u162[1] + u160.size.w + u164[1]
           and u163[2] >= u162[2] + u164[2]
           and u163[2] <= u162[2] + u160.size.h + u164[2] then
            return i
        end
    end

    return u160.skeet_cur_tab
end

local function u165()
    if not renderer.load_png or not readfile then return end
    for i, path in ipairs(u158) do
        if not u157[i] then
            local u166= readfile(path)
            if u166 then
                u157[i] = renderer.load_png(u166, u152, u153)
            end
        end
    end
end


local function u167()
    local u168= ui.is_menu_open()
    local u169, u170= ui.menu_position()
    local u171, u172= ui.menu_size()
    u171 = u171-2
    u169 = u169+1
    if u168 and u169 and u170 and u171 and u172 then
        local u173= (u160.skeet_cur_tab == 2)
        local u174= math.floor(90 * u154)
        local u175= math.max(1, math.floor(4 * u154))
        local u176= math.max(1, math.floor(3 * u154))
        local u177= math.max(1, math.floor(2 * u154))
        local u178= math.max(0, math.floor(1 * u154))
        local u179= 0
        local u180= u169 + u175
        local u181= u170 - math.floor(7 * u154) - u174
        local u182= u171 - 2 * u175

        if u173 then
            renderer.rectangle(u180-u175*1.3, u181-8, u182+2*u175*1.5-1, u174+16, 12, 12, 12, 255)
            renderer.rectangle(u180-u176*1.5, u181-7, u182+2*u176*1.5, u174+14, 60, 60, 60, 255)
            renderer.rectangle(u180-u177*1.51, u181-6, u182+2*u177*2, u174+12, 40, 40, 40, 255)
            renderer.rectangle(u180-u178, u181-3, u182+2*u178, u174+6, 60, 60, 60, 255)
            renderer.rectangle(u180-u179, u181-2, u182+2*u179, u174+4, 12, 12, 12, 255)

            local u183= nil
            if renderer.load_rgba then
                local u184, u185= pcall(renderer.load_rgba,
                    string.char(
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
                    ), 4, 4)
                if u184 and u185 then u183 = u185 end
            end
            if u183 and renderer.texture then
                renderer.texture(u183, u180-u179, u181-2, u182+2*u179, u174+4, 255,255,255,255, 'r')
            end

            if renderer.gradient then
                renderer.gradient(u180-u179, u181-2, (u182+2*u179)/2+1, 1, 59,175,222,255, 202,70,205,255, true)
                renderer.gradient(u180-u179+(u182+2*u179)/2+1, u181-2, (u182+2*u179)/2-1, 1, 202,70,205,255, 204,227,53,255, true)
            end

            local u186= math.max(1, math.floor(2 * u154))
            local u187= u181 - math.floor(8 * u154)

            local u188= math.max(1, math.floor(5 * u154))
            local u189= 60
            renderer.circle(u180-u175+u188, u187+u186/2, u188, 59,175,222, u189, 16)
            renderer.circle(u180+u182-u175-u179-u188, u187+u186/2, u188, 204,227,53, u189, 16)
        end

        local u190= 4
        local u191= u181 + u174 / 2
        local u192, u193= ui.mouse_position()
        local u194= {}
        local u195= u174
            local u196= math.max(1, math.floor(59 * u154))
            local u197= math.max(1, math.floor(u152 * u154))
            local u198= math.max(1, math.floor(u153 * u154))
            local u199= u190 * u197 + (u190 - 1) * u196
            local u200= math.max(0, u182 * 0.5)
            local u201= u180 + u200 + (u182 - 2 * u200 - u199) / 2
            if u199 > u182 then
                u196 = math.max(0, math.floor((u182 - u190 * u197) / (u190 - 1)))
                u199 = u190 * u197 + (u190 - 1) * u196
                u201 = u180 + (u182 - u199) / 2
            end
        u165()
        local u202= u182 / u190
        for i=1,u190 do
            local u203= u180 + (i-1) * u202
            local u204= u181
            u194[i] = {x=u203, y=u204, w=u202, h=u195}
            if u173 then
                if u151 == i then
                    renderer.rectangle(u203, u204, u202, u195+1, 32,32,32, 85)
                end
                local u205= u203 + u202/2 - u197/2
                local u206= u204 + u195/2 - u198/2
                if u157[i] then
                    renderer.texture(u157[i], u205, u206, u197, u198, 255,255,255,255, "f")
                else
                    renderer.text(u205 + u197/2, u206 + u198/2, 255,255,255,255, '+c', 0, tostring(i))
                end
            end
        end

        local u207= client.key_state(1)
        if u168 and u192 and u193 and ui.is_menu_open() then
            if u207 and not prev_mouse_down then
                for i=1,u190 do
                    local u208= u194[i]
                    if u192 >= u208.x and u192 <= u208.x+u208.w and u193 >= u208.y and u193 <= u208.y+u208.h then
                        u151 = i
                        u156 = u155[u151]
                    end
                end
                local u209= { ui.menu_position() }
                if u209[1] and u209[2] then
                    for si = 1, 9 do
                        local u164= { u160.size.x, u160.size.y + u160.size.h * (si - 1) }
                        if u192 >= u209[1] + u164[1]
                           and u192 <= u209[1] + u160.size.w + u164[1]
                           and u193 >= u209[2] + u164[2]
                           and u193 <= u209[2] + u160.size.h + u164[2] then
                            u160.skeet_cur_tab = si
                            break
                        end
                    end
                end
            end
            prev_mouse_down = u207
        else
            prev_mouse_down = false
        end
        local u210= u161()
        local u211= u160.skeet_cur_tab or 0
        local u212= "Skeet sel: " .. tostring(u211)
        if u210 and u210 ~= u211 then
            u212 = u212 .. "  (hover: " .. tostring(u210) .. ")"
        end
        if u173 then
            if renderer.measure_text then
                pcall(function() renderer.measure_text(nil, u212) end)
            end
            renderer.text(u180 + 6, u181 + u174 + 6, 200,200,200,255, nil, 0, u212)
        end
    end
end

local function u213()
    if not ui.is_menu_open() then return false end
    local u192, u193= ui.mouse_position()
    local u214, u215= ui.menu_position()
    local u216, u217= ui.menu_size()
    local u174= math.floor(90 * u154)
    local u175= math.max(1, math.floor(4 * u154))
    local u180, u181, u182= u214 + u175, u215 - math.floor(7 * u154) - u174, u216 - 2 * u175
    return not (
        u192 >= u214 and u192 <= u214 + u216 and u193 >= u215 and u193 <= u215 + u217
        or u192 >= u180 and u192 <= u180 + u182 and u193 >= u181 and u193 <= u181 + u174
    )
end

return {
    current_tab = function() return u156 end,
    current_tab_index = function() return u151 end,
    tab_names = u155,
    tab_sections = function() return u159 end,
    menu_position = function() return ui.menu_position() end,
    menu_size = function() return ui.menu_size() end,
    is_menu_open = function() return ui.is_menu_open() end,
    mouse_position = function() return ui.mouse_position() end,
    is_mouse_outside_menu = u213,
    draw_menu = u167
}]]
u743["require/abc/menu_setup"] = [[local u154= {
    ui = {},
    registered_items = {},
}

function sodium.register_ui(u155,u156)
    
    
    
    if u156 and u156.key then
        for i = #u154.registered_items, 1, -1 do
            local u157= u154.registered_items[i]
            if u157 and u157.key == u156.key then
                
                pcall(function()
                    if u157.item then ui.set_visible(u157.item, false) end
                end)
                table.remove(u154.registered_items, i)
            end
        end
    end

    table.insert(u154.registered_items, {
        item = u155,
        key = u156.key,
        requires_login = u156.requires_login,
        tab = u156.tab,
        visible = u156.visible ~= false,
        config_type = u156.config_type,
        show_condition = u156.show_condition,
    })
    return u155
end

function sodium.update_visibility(u158)
    for _, u157 in ipairs(u154.registered_items) do
        local u159= u157.visible
        if u157.requires_login and not u158 then
            u159 = false
        end
        if u157.show_condition then
            u159 = u157.show_condition()
        end
        if u157.item then
            ui.set_visible(u157.item, u159)
        end
    end
end

function sodium.save_config()
    local u160= {}
    for _, u157 in ipairs(u154.registered_items) do
        if u157.key and u157.item then
            u160[u157.key] = ui.get(u157.item)
        end
    end
    return u160
end

function sodium.load_config(u161)
    for _, u157 in ipairs(u154.registered_items) do
        if u157.key and u157.item and u161[u157.key] ~= nil then
            ui.set(u157.item, u161[u157.key])
        end
    end
end

local u162= {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

local u163= {

    { 'Rage', 'other', 'accuracy boost' },
    { 'Rage', 'other', 'anti-aim correction' },
    { 'rage', 'other', 'automatic fire' },
    { 'Rage', 'other', 'automatic penetration' },
    { 'Rage', 'other', 'silent aim' },
    { 'Rage', 'other', 'remove recoil' },
    { 'Rage', 'other', 'reduce aimstep' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'log misses due to spread' },
    { 'Rage', 'other', 'low fps mitigations ' },
    { 'rage', 'other', 'delay shot' },
    { 'Rage', 'other', 'quick peek assist' },
    { 'Rage', 'other', 'quick peek assist mode' },
    { 'Rage', 'other', 'quick peek assist distance' },
    { 'Rage', 'other', 'reduce aim step' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'low fps mitigations' },
    { 'Rage', 'other', 'duck peek assist' },


}

function sodium.toggle_gamesense_menu(u159)
    u154.state = u154.state or {}
    u154.hidden_refs = u154.hidden_refs or {}
    for _, u157 in ipairs(u162) do
        local u164, u165, u166, u167, u168= pcall(ui.reference, u157[1], u157[2], u157[3], u157[4])
        if u164 then
            if u157[1] == 'AA' and u157[2] == 'Anti-aimbot angles' and u157[3] == 'Enabled' then
                u154.state.gs_enabled_ref = u165
                if u165 ~= nil and u159 then
                    if u154.state.gs_enabled_previous ~= nil then
                        ui.set(u165, u154.state.gs_enabled_previous)
                    end
                elseif u165 ~= nil and not u159 then
                    u154.state.gs_enabled_previous = ui.get(u165)
                    ui.set(u165, true)
                end
            end
            local u169= { u165, u166, u167, u168 }
            local u170= {}
            for _, ref in ipairs(u169) do
                if ref ~= nil then
                    ui.set_visible(ref, u159)
                    u170[#u170 + 1] = ref
                end
            end
            if not u159 and #u170 > 0 then
                table.insert(u154.hidden_refs, u170)
            end
        end
    end
    u154.state.gs_hidden = not u159
end

function sodium.toggle_rage_menu(u159)
    u154.state = u154.state or {}
    u154.hidden_rage_refs = u154.hidden_rage_refs or {}
    u154.hidden_rage_refs = {} 

    for _, u157 in ipairs(u163) do
        local u164, u165, u166, u167, u168= pcall(ui.reference, u157[1], u157[2], u157[3])
        if u164 then
            local u169= { u165, u166, u167, u168 }
            local u170= {}
            for _, ref in ipairs(u169) do
                if ref ~= nil then
                    pcall(function() ui.set_visible(ref, u159) end)
                    u170[#u170 + 1] = ref
                end
            end
            if not u159 and #u170 > 0 then
                table.insert(u154.hidden_rage_refs, u170)
            end
        end
    end
    u154.state.rage_hidden = not u159
end

return u154]]
u743["require/abc/menu_visibility"] = [[local u157= {
	"global",
	"stand",
	"move",
	"duck",
	"duck+",
	"jump",
	"jump+",
	"walk",
	"fakelag",
	"legit",
}

local u158= require("require/abc/login_system")

local function u159(u160)
	if u160.menu_setup and u160.menu_setup.refresh_cfg_listbox then
		u160.menu_setup.refresh_cfg_listbox()
	end

	if u160 and not u160.login then
		u160.login = u158
	end
	u160.menu_setup.toggle_gamesense_menu(false)
	u160.menu_setup.toggle_rage_menu(true)
	u160.menu_setup.update_visibility(u160.login and u160.login.logged_in)
	local u161= (u160.login and u160.login.logged_in) or false

	local u162= not u161
	local u163= (u160.menu_header and u160.menu_header.current_tab and u160.menu_header.current_tab()) or u160.menu.current_tab()
	 	
	ui.set_visible(u160.menu_setup.ui.login_howto_header, u162)
	ui.set_visible(u160.menu_setup.ui.login_console_register, u162)
	ui.set_visible(u160.menu_setup.ui.login_menu_credentials, u162)
	ui.set_visible(u160.menu_setup.ui.login_press_login, u162)
	ui.set_visible(u160.menu_setup.ui.login_spacer1, u162)
	ui.set_visible(u160.menu_setup.ui.reset_header, u162)
	ui.set_visible(u160.menu_setup.ui.reset_step1, u162)
	ui.set_visible(u160.menu_setup.ui.reset_step2, u162)
	ui.set_visible(u160.menu_setup.ui.login_spacer2, u162)
	ui.set_visible(u160.menu_setup.ui.support_header, u162)
	ui.set_visible(u160.menu_setup.ui.support_discord, u162)
	ui.set_visible(u160.menu_setup.ui.login_username, u162)
	ui.set_visible(u160.menu_setup.ui.login_password, u162)
	ui.set_visible(u160.menu_setup.ui.cache_credentials, u162)
	ui.set_visible(u160.menu_setup.ui.login_button, u162)
	ui.set_visible(u160.menu_setup.ui.reset_button, u162)
	ui.set_visible(u160.menu_setup.ui.discord_button, u162)
	ui.set_visible(u160.menu_setup.ui.youtube_button, u162)
	ui.set_visible(u160.menu_setup.ui.sellhub_button, u162)
	ui.set_visible(u160.menu_setup.ui.logout_button, u161 and u163 == "CFG")

	if u160.menu_setup.ui.condition then
		local u164= ui.get(u160.menu_setup.ui.condition)
		for _, cond in ipairs(u157) do
			local u165= u161 and u163 == "AA" and u164 == cond
			local u166= 'enable_' .. cond
			if u160.menu_setup.ui[u166] then
				ui.set_visible(u160.menu_setup.ui[u166], u165)
				local u167= u160.safe.safe_get(u160.menu_setup.ui[u166])

				local u168= u160.menu_setup.ui['yaw_' .. cond] and ui.get(u160.menu_setup.ui['yaw_' .. cond]) or nil
				local u169= u160.menu_setup.ui['yaw_jitter_' .. cond] and ui.get(u160.menu_setup.ui['yaw_jitter_' .. cond]) or nil
				local u170= u160.menu_setup.ui['body_yaw_mode_' .. cond] and ui.get(u160.menu_setup.ui['body_yaw_mode_' .. cond]) or nil
				local u171= u160.menu_setup.ui['delay_' .. cond] and ui.get(u160.menu_setup.ui['delay_' .. cond]) or nil
				ui.set_visible(u160.menu_setup.ui['pitch_' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['yaw_base_' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['yaw_' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['label1_' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['label2_' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['label3_' .. cond], u165 and u167)
				local u172= u165 and u167 and (u168 ~= 'off' and u168 ~= 'ideal' and u168 ~= '3way')
				ui.set_visible(u160.menu_setup.ui['body_yaw_base_' .. cond], u172)
				local u173= u165 and u167 and (u168 == '180' or u168 == '3way')
				ui.set_visible(u160.menu_setup.ui['body_yaw_left_' .. cond], u173)
				ui.set_visible(u160.menu_setup.ui['body_yaw_right_' .. cond], u173)
				local u174= u165 and u167 and (u168 ~= 'off' and u168 ~= 'ideal')
				ui.set_visible(u160.menu_setup.ui['randomize_yaw_' .. cond], u174)
				local u175= u165 and u167 and (u169 ~= 'off')
				ui.set_visible(u160.menu_setup.ui['yaw_jitter_base_' .. cond], u175)
				local u176= u165 and u167 and (u170 == 'static')
				ui.set_visible(u160.menu_setup.ui['static_body_yaw_' .. cond], u176)
				local u177= u165 and u167 and (u170 == 'jitter' and u171 and u171 <= 0)
				ui.set_visible(u160.menu_setup.ui['body_yaw_value_' .. cond], u177)
				local u178= u165 and u167 and (u170 == 'jitter')
				ui.set_visible(u160.menu_setup.ui['delay_' .. cond], u178)
				ui.set_visible(u160.menu_setup.ui['yaw_jitter_' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['body_yaw_mode_' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['fifty_fifty_' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['only_flip_on_0_choke_' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['aa_label_space' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['aa_label_combo' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['send_button' .. cond], u165 and u167)
				ui.set_visible(u160.menu_setup.ui['send_combo' .. cond], u165 and u167)
			end
		end
		ui.set_visible(u160.menu_setup.ui.condition, u161 and u163 == "AA")
		ui.set_visible(u160.menu_setup.ui.condition_label, u161 and u163 == "AA")
		ui.set_visible(u160.menu_setup.ui.condition_label2, u161 and u163 == "AA")


		ui.set_visible(u160.menu_setup.ui.fakelag_mode, u161 and u163 == "AA")
		if u160.menu_setup.ui.fakelag_mode then
			local u179= ui.get(u160.menu_setup.ui.fakelag_mode)
			local u180= u161 and u163 == "AA"
			local u181= u180 and u179 == "defensive"
			local u182= u160.safe.safe_get(u160.menu_setup.ui.fakelag_defensive) == true
			ui.set_visible(u160.menu_setup.ui.fakelag_defensive, u181)
			ui.set_visible(u160.menu_setup.ui.fakelag_force, u181 and u182)
			ui.set_visible(u160.menu_setup.ui.fakelag_force_on, u181 and u182)
			ui.set_visible(u160.menu_setup.ui.fakelag_fakedef, u181 and u182)

			local u183= u180 and u179 == "stealer"
			local u184= u160.safe.safe_get(u160.menu_setup.ui.fakelag_stealer) == true
			ui.set_visible(u160.menu_setup.ui.fakelag_stealer, u183)
			ui.set_visible(u160.menu_setup.ui.fakelag_stealer_type, u183 and u184)
			ui.set_visible(u160.menu_setup.ui.fakelag_stealer_target, u183 and u184)
			ui.set_visible(u160.menu_setup.ui.fakelag_stealer_list, u183 and u184)
			ui.set_visible(u160.menu_setup.ui.fakelag_stealer_refresh, u183 and u184)
			ui.set_visible(u160.menu_setup.ui.fakelag_stealer_steal, u183 and u184)

			local u185= u180 and u179 == "fakelag"
			local u186= u160.safe.safe_get(u160.menu_setup.ui.fakelag_fakelag) == true
			local u187= u160.safe.safe_get(u160.menu_setup.ui.fakelag_fakelag_type) == "sodium"
			ui.set_visible(u160.menu_setup.ui.fakelag_fakelag, u185)
			ui.set_visible(u160.menu_setup.ui.fakelag_fakelag_type, u185 and u186)
			ui.set_visible(u160.menu_setup.ui.fakelag_fakelag_amount, u185 and u186 and not u187)
			ui.set_visible(u160.menu_setup.ui.fakelag_fakelag_variance, u185 and u186 and not u187)
			ui.set_visible(u160.menu_setup.ui.fakelag_fakelag_limit, u185 and u186 and not u187)
			ui.set_visible(u160.menu_setup.ui.fakelag_fakelag_type2, u185 and u186 and u187)

			local u188= u180 and u179 == "settings"
			ui.set_visible(u160.menu_setup.ui.fakelag_settings_freestanding, u188)
			ui.set_visible(u160.menu_setup.ui.fakelag_settings_enhance_onshot, u188)
			ui.set_visible(u160.menu_setup.ui.fakelag_settings_antibrute, u188)
			ui.set_visible(u160.menu_setup.ui.fakelag_settings_roll_label, u188)
			ui.set_visible(u160.menu_setup.ui.fakelag_settings_roll_checkbox, u188)
			local u189= u188 and u160.safe.safe_get(u160.menu_setup.ui.fakelag_settings_roll_checkbox) == true
			ui.set_visible(u160.menu_setup.ui.fakelag_settings_roll, u189)
			ui.set_visible(u160.menu_setup.ui.fakelag_settings_side, u189)
		end

		local u190= u161 and u163 == "PAINT" and ui.get(u160.menu_setup.ui.paint_indicators_enable) == true
		local u191= u161 and u163 == "PAINT" and u190 and ui.get(u160.menu_setup.ui.paint_indicators) ~= "off"
		local u192= u161 and u163 == "PAINT" and u190 and ui.get(u160.menu_setup.ui.paint_indicators) == "small"
		ui.set_visible(u160.menu_setup.ui.paint_indicators, u190)
		ui.set_visible(u160.menu_setup.ui.paint_indicators_enable, u191)
		ui.set_visible(u160.menu_setup.ui.paint_indicators_animation, u191)
		ui.set_visible(u160.menu_setup.ui.paint_indicators_bar, u192)
		ui.set_visible(u160.menu_setup.ui.paint_indicator_color, u191)

		local u193= u161 and u163 == "PAINT" and ui.get(u160.menu_setup.ui.paint_advertisement) == true
		ui.set_visible(u160.menu_setup.ui.paint_advertisement_color, u193)

		local u194= u161 and u163 == "PAINT" and ui.get(u160.menu_setup.ui.paint_watermark) == true
		ui.set_visible(u160.menu_setup.ui.paint_watermark_color, u194)

		local u195= u161 and u163 == "MISC" and u160.safe.safe_get(u160.menu_setup.ui.misc_dormantaimbot) == true
		ui.set_visible(u160.menu_setup.ui.misc_dormantaimbot_key, u195)
		ui.set_visible(u160.menu_setup.ui.misc_dormantaimbot_value, u195)

		local u196= u161 and u163 == "PAINT" and u160.safe.safe_get(u160.menu_setup.ui.paint_logger_checkbox) == true
		ui.set_visible(u160.menu_setup.ui.paint_logger, u196)
		ui.set_visible(u160.menu_setup.ui.paint_logger_animation, u196)
		ui.set_visible(u160.menu_setup.ui.paint_logger_color, u196)

		local u197= u161 and u163 == "PAINT" and u160.safe.safe_get(u160.menu_setup.ui.paint_aspect_ratio_checkbox) == true
		ui.set_visible(u160.menu_setup.ui.paint_aspect_ratio, u197)

		local u198= u161 and u163 == "PAINT" and u160.safe.safe_get(u160.menu_setup.ui.paint_third_person_distance_checkbox) == true
		ui.set_visible(u160.menu_setup.ui.paint_third_person_distance, u198)

	end

	local u199= {
		'aa_gskey_freestand',
		'aa_gskey_freestandh',
		'aa_gskey_slowmotion',
		'aa_gskey_slowmotionh',
		'aa_gskey_edgeyaw',
		'aa_gskey_edgeyawh',
		'aa_gskey_onshot',
		'aa_gskey_onshoth',
	}
	for _, key in ipairs(u199) do
		if u160.menu_setup.ui[key] then
			ui.set_visible(u160.menu_setup.ui[key], tab_name == "AA")
		end
	end

	local u200= {
		'misc_resolver',
		'misc_ragebot',
		'misc_dormantaimbot',
		'misc_exploit_fakelag',
		'misc_walkbot',
		'misc_backstab',
		'misc_spindead',
	}
	for _, key in ipairs(u200) do
		if u160.menu_setup.ui[key] then
			ui.set_visible(u160.menu_setup.ui[key], tab_name == "MISC")
		end
	end

	local u201= {
		'paint_target_info',
		'label_space2',
		'label_space3',
		'label_space4',
		'paint_entidx',
		'paint_filter_console',
		'paint_minimum_damage',
		'paint_show_damage_penetration',
		'paint_hitmiss_indicator',
		'paint_self_skeleton',
		'paint_bullet_tracer',
		'paint_lagcomp_box',
		'paint_lagcomp_box_color',
		'paint_presmoke',
		'paint_bombwarning',
		'paint_insults',
		'paint_rainbow_esp',
		'paint_molotov',
		'paint_lag_record',
		'paint_advertisement',
		'paint_advertisement_animation',
		'paint_clantag',
		'paint_aimbot_logs',
		'paint_indicators_label',
		'paint_indicators_enable',
		'label_space1',
		'paint_watermark',
		'paint_watermark_type',
		'paint_logger_label',
		'paint_logger_checkbox',
		'paint_hitmarker',
		'paint_hitmarker_color',
		'paint_warnings',
		'paint_animations',
		'paint_performance_mode',
		'paint_aspect_ratio_checkbox',
		'paint_third_person_distance_checkbox',
	}
	for _, key in ipairs(u201) do
		if u160.menu_setup.ui[key] then
			ui.set_visible(u160.menu_setup.ui[key], tab_name == "PAINT")
		end
	end

		local u202= {
			'cfg_load_button',
			'cfg_save_button',
			'cfg_delete_button',
			'cfg_refresh_button',
			'cfg_create_button',
			'cfg_export_button',
			'cfg_import_button',
			'cfg_input_box',
			'cfg_listbox',
			'cfg_selection',
			'cfg_cloud',
			'cfg_cloud_apply',
		}
		for _, key in ipairs(u202) do
			if u160.menu_setup.ui[key] then
				ui.set_visible(u160.menu_setup.ui[key], u161 and u163 == "CFG")
			end
		end

end

local function u203(u160)
	local u204= {
		u160.menu_setup.ui.condition,
		u160.menu_setup.ui.fakelag_mode,
	}
	for _, item in ipairs(u204) do
		if item then
			ui.set_callback(item, function()
				u159(u160)
			end)
		end
	end

	for _, cond in ipairs(u157) do
		local u205= {
			'enable_' .. cond,
			'yaw_' .. cond,
			'yaw_jitter_' .. cond,
			'body_yaw_mode_' .. cond,
			'fifty_fifty_' .. cond,
			'only_flip_on_0_choke_' .. cond,
			'aa_label_space' .. cond,
			'aa_label_combo' .. cond,
			'send_button' .. cond,
			'send_combo' .. cond,
		}
		for _, key in ipairs(u205) do
			local u206= u160.menu_setup.ui[key]
			if u206 then
				ui.set_callback(u206, function()
					u159(u160)
				end)
			end
		end
	end

	local u207= {
		'fakelag_defensive',
		'fakelag_stealer',
		'fakelag_fakelag',
		'fakelag_fakelag_type',
		'fakelag_settings_roll_label',
		'fakelag_settings_roll_checkbox',
	}
	for _, key in ipairs(u207) do
		local u206= u160.menu_setup.ui[key]
		if u206 then
			ui.set_callback(u206, function()
				u159(u160)
			end)
		end
	end

	if u160.menu_setup.ui.paint_indicators then
		ui.set_callback(u160.menu_setup.ui.paint_indicators, function()
			u159(u160)
		end)
	end

	if u160.menu_setup.ui.paint_advertisement then
		ui.set_callback(u160.menu_setup.ui.paint_advertisement, function()
			u159(u160)
		end)
	end
	
	if u160.menu_setup.ui.paint_watermark then
		ui.set_callback(u160.menu_setup.ui.paint_watermark, function()
			u159(u160)
		end)
	end

	if u160.menu_setup.ui.misc_dormantaimbot then
		ui.set_callback(u160.menu_setup.ui.misc_dormantaimbot, function()
			u159(u160)
		end)
	end

	if u160.menu_setup.ui.paint_logger_checkbox then
		ui.set_callback(u160.menu_setup.ui.paint_logger_checkbox, function()
			u159(u160)
		end)
	end

	if u160.menu_setup.ui.paint_aspect_ratio_checkbox then
		ui.set_callback(u160.menu_setup.ui.paint_aspect_ratio_checkbox, function()
			u159(u160)
		end)
	end

	if u160.menu_setup.ui.paint_third_person_distance_checkbox then
		ui.set_callback(u160.menu_setup.ui.paint_third_person_distance_checkbox, function()
			u159(u160)
		end)
	end

	if u160.menu_setup.ui.paint_indicators_enable then
		ui.set_callback(u160.menu_setup.ui.paint_indicators_enable, function()
			u159(u160)
		end)
	end

	if u160.login and type(u160.login.add_state_callback) == 'function' then
		u160.login.add_state_callback(function()
			u159(u160)
		end)
	end
end

return {
	update = u159,
	setup_callbacks = u203
}]]
u743["require/abc/push_gamesense"] = [[local u160= renderer
local u161= globals
local u162= string.char

local u163= nil
local function u164()
    if u163 then return u163 end
    if u160.load_rgba then
        local u165, u166= pcall(u160.load_rgba,
            string.char(
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
            ), 4, 4)
        if u165 and u166 then u163 = u166 end
    end
    return u163
end


local function u167(u168,u169,u170,u171,u172,u173)
    local u174= u168 - 3
    local u175= u169 - 40
    local u176= u170 + 5
    local u177= u171 + 1
    u160.rectangle(u168 - 10, u169 - 48, u170 + 20, u171 + 16, 0, 0, 0, 200)
    u160.rectangle(u168 - 9, u169 - 47, u170 + 18, u171 + 14, 60, 60, 60, 255)
    u160.rectangle(u168 - 8, u169 - 46, u170 + 16, u171 + 12, 40, 40, 40, 255)
    u160.rectangle(u168 - 5, u169 - 43, u170 + 10, u171 + 6, 60, 60, 60, 255)
    u160.rectangle(u168 - 4, u169 - 42, u170 + 8, u171 + 4, 12, 12, 12, 255)
    u160.rectangle(u168 - 4, u169 - 42, u170 + 8, u171 + 4, 32, 32, 32, 255)
    local u178= u164()
    if u178 and u160.texture then
        u160.texture(u178, u174, u175, u176, u177, 255,255,255,u172, 'r')
    else
        u160.rectangle(u174, u175, u176, u177, 0, 0, 0, 0)
    end

    
    if u160.gradient then
        u160.gradient(u168 - 4, u169 - 42, u170 / 2 + 1, 1, 59, 175, 222, 255, 202, 70, 205, 255, true)
        u160.gradient(u168 - 4 + u170 / 2, u169 - 42, u170 / 2 + 8.5, 1, 202, 70, 205, 255, 204, 227, 53, 255, true)
    end
    u160.text(u168, u169 - 40, 255, 255, 255, 255, '', nil, u173)
end

return u167
]]
u743["require/abc/push_logger"] = [[local u163= renderer
local u164= globals
local u165= client
local u166= entity
local u167= table.insert
local u168= table.remove
local u169= math.floor
local u170= math.sqrt
local u171= string.char


local u172, u173= pcall(require, "require/abc/menu_setup")


local u174, u175= pcall(ui.reference, 'misc', 'settings', 'menu color')

local u176= {}
local u177= 5

local function u178(u179,u180,u181,u182,u183,u184)
    if #u176 >= u177 then
        u168(u176, 1)
    end
    u167(u176, {
        text = tostring(u179),
        duration = u180 or 5,
        color = { u181 or 255, u182 or 255, u183 or 255, u184 or 255 },
        timestamp = u164 and u164.curtime and u164.curtime() or os.clock(),
    })
end

local function u185(u186)
    local u187, u188, u189= pcall(u163.measure_text, '', u186)
    if u187 and type(u188) == 'number' then return u188, u189 or 0 end
    u187, u188, h = pcall(u163.measure_text, u186)
    if u187 and type(u188) == 'number' then return u188, u189 or 0 end
    return 0, 0
end

local function u190(u191,u192,u193)
    if u191 < u192 then return u192 end
    if u191 > u193 then return u193 end
    return u191
end


local function u194()
    if u172 and u173 and u173.ui and u173.ui.paint_logger then
        local u187, u195= pcall(ui.get, u173.ui.paint_logger)
        if u187 and u195 then return true end
        return false
    end
    
    return true
end


local function u196()
    if u172 and u173 and u173.ui and u173.ui.paint_logger_animation then
        local u187, u191= pcall(ui.get, u173.ui.paint_logger_animation)
        if u187 and type(u191) == 'number' then return u191 end
    end
    return 0
end


local u197, u198= pcall(require, "require/abc/push_modern")
local u199, u200= pcall(require, "require/abc/push_gamesense")


local function u201(u202)
    local u203= 80
    local u204= u202 - 80
    local u205= 40
    local u206= u202 / 2 - 300
    local u207= u202 - u206 - 10
    u207 = u190(u207, u203 + u205, u204 - u205)
    local u208= u207 - u205
    local u209= u207 + u205
    return u208, u209, u207
end

local function u210()
    if not u163 or not u163.text then return end
    if not u194() then return end

    local u211= u196() or 0
    local u212= u164 and u164.curtime and u164.curtime()
    local u213, u202= u165 and u165.screen_size and u165.screen_size() or 800, 600
    local u214= u202 * 0.5 + (u202 * 0.5 * 1.8)
    local u215= 0
    for i = #u176, 1, -1 do
        local u216= u176[i]
        local u217= (u216.timestamp + u216.duration) - u212
        if u217 <= 0 then
            u168(u176, i)
        else
            local u218, u219= u185(u216.text)
            local u220= (u211 == 1) and 4 or 2
            local u221= 2
            local u222= u213 / 2 - u218 / 2
            local u223= u214 + u215
            local u224= 5
            local u225= u169((u216.color[4] or 255) * math.min(1, (u217 / u216.duration) * u224))
            local u226= (u216.duration - u217)
            local u227= (u216.duration > 0 and u216.duration or 1)
            local u228= u226 / u227
            local u229= 6
            local u230= u190(u228 * u229, 0, 1)
            local u231= u230
            
            
            local u232= math.min(0.5, u227 * 0.25)
            if u217 <= u232 then
                local u233= u217 / u232 
                u231 = u190(u233, 0, 1)
            end
            if u211 == 1 then
                u198(u222, u223, u218, 13, u225, u216.text, u231)
                u215 = u215 + (u219 + u220 * 2 + u170(u221 / 10) * 4)
            else
                u200(u222, u223, u218, 13, u225, u216.text)
                u215 = u215 + (u219 + u220 * 2 + u170(u221 / 10) * 35)
            end
        end
    end
end

if u165 and u165.set_event_callback then
    u165.set_event_callback('paint', u210)
else
    
    u165.set_event_callback('paint', u210)
end

return u178
]]
u743["require/abc/push_modern"] = [[local u166= renderer
local u167= ui
local u168= math.floor

local u169, u170= pcall(require, "require/abc/menu_setup")
local u171, u172= pcall(u167.reference, 'misc', 'settings', 'menu color')

local function u173(u174,u175,u176,u177,u178,u179,u180,u181,u182)
    if not u178 or u178 <= 0 then
        u166.rectangle(u174, u175, u176, u177, u179,u180,u181,u182)
        return
    end
    u166.rectangle(u174 + u178, u175, u176 - (u178 * 2), u177, u179,u180,u181,u182)
    u166.rectangle(u174, u175 + u178, u176, u177 - (u178 * 2), u179,u180,u181,u182)
    u166.circle(u174 + u178, u175 + u178, u179,u180,u181,u182, u178, 0, 1)
    u166.circle(u174 + u176 - u178, u175 + u178, u179,u180,u181,u182, u178, 0, 1)
    u166.circle(u174 + u178, u175 + u177 - u178, u179,u180,u181,u182, u178, 0, 1)
    u166.circle(u174 + u176 - u178, u175 + u177 - u178, u179,u180,u181,u182, u178, 0, 1)
end

local function u183(u184,u185,u186,u187)
    local u188, u189, u190, u191= u184 or 255, u185 or 140, u186 or 0, u187 or 255
    
    if u169 and u170 and u170.ui and u170.ui.paint_logger_color then
        local u192, u193, u194, u195, u196= pcall(u167.get, u170.ui.paint_logger_color)
        if u192 then
            if type(u193) == 'number' then
                u188 = u168(u193 or u188)
                u189 = u168(u194 or u189)
                u190 = u168(u195 or u190)
                u191 = u168(u196 or u191)
            elseif type(u193) == 'string' and #u193 == 12 then
                local u197
                u197, mr = pcall(function() return tonumber(u193:sub(1,3)) end)
                u197, mg = pcall(function() return tonumber(u193:sub(4,6)) end)
                u197, mb = pcall(function() return tonumber(u193:sub(7,9)) end)
                u197, ma = pcall(function() return tonumber(u193:sub(10,12)) end)
                u188 = u188 or u184; u189 = u189 or u185; u190 = u190 or u186; u191 = u191 or u187
            end
            return u188, u189, u190, u191
        end
    end

    
    if u171 and u172 then
        local u192, u193, u194, u195, u196= pcall(u167.get, u172)
        if u192 then
            if type(u193) == 'number' then
                u188 = u168(u193 or u188)
                u189 = u168(u194 or u189)
                u190 = u168(u195 or u190)
                u191 = u168(u196 or u191)
            elseif type(u193) == 'string' and #u193 == 12 then
                local u197
                u197, mr = pcall(function() return tonumber(u193:sub(1,3)) end)
                u197, mg = pcall(function() return tonumber(u193:sub(4,6)) end)
                u197, mb = pcall(function() return tonumber(u193:sub(7,9)) end)
                u197, ma = pcall(function() return tonumber(u193:sub(10,12)) end)
                u188 = u188 or u184; u189 = u189 or u185; u190 = u190 or u186; u191 = u191 or u187
            end
        end
    end
    return u188, u189, u190, u191
end

local function u198(u174,u175,u176,u177,u199,u200,u201)
    local u202= u174 - 4
    local u203= u175 - 40
    local u204= u176 + 8
    local u205= u177 + 1

    local u206= 6
    if u205 < 12 then u206 = math.max(1, math.floor(u205 / 2)) end
    local u207= math.max(1, u206 - 1)

    local u188, u189, u190, u191= u183(255, 140, 0, 255)
    local u208= u168((u191 or 255) * 0.95)

    u201 = math.max(0, math.min(1, u201 or 1))
    local u209= u202 - 1
    local u210= u203 - 1
    local u211= u204 + 2
    local u212= u205 + 2
    local u213= u211 / 2 + (u211 * 0.1)
    local u214= u168(u213 * u201)

    if u214 > 0 then
        local u215= math.min(u206 + 1, u168(u212 / 2), u168(u214 / 2))
        u173(u209, u210, u214, u212, u215, u188, u189, u190, u208)
        u173(u209 + u211 - u214, u210, u214, u212, u215, u188, u189, u190, u208)
    end
    u173(u202, u203, u204, u205, u206, 10, 10, 10, 230)
    u173(u202 + 1, u203 + 1, u204 - 2, u205 - 2, u207, 6, 6, 6, 220)
    if u166.gradient then
        u166.gradient(u202 + 2, u203 + 1, math.max(0, u204 - 4), 2, u188, u189, u190, u168(u208 * 0.14), u188, u189, u190, 0, true)
    end
    u166.text(u174, u175 - 40, 255, 255, 255, 255, '', nil, u200)
end

return u198]]
u743["require/abc/register"] = [[local u169= require("require.abc.login_system")
local u170= "acc_" .. "OIDFGNSOIGNSFGIOSNGOISNGIOS"

local function u171(u172)
    local u173= {}
    for part in u172:gmatch("%S+") do
        table.insert(u173, part)
    end
    return u173
end

client.set_event_callback("console_input", function(u174)
    local u173= u171(u174 or "")
    if #u173 == 0 then return end

    local u175= u173[1]:lower()
    if u175 ~= "register" then
        
        return
    end

    if #u173 < 4 then
        client.log("Usage: register <username> <password> <invite>")
        return
    end

    local u176= u173[2]
    local u177= u173[3]
    local u178= u173[4]

    local u179, u180= u169.is_valid_invite(u178)
    if not u179 then
        client.log("Register failed: invalid or used invite")
        return
    end

    local u181= database.read(u170) or {}
    if u181[u176] then
        client.log("Register failed: username already exists - ", u176)
        return
    end

    local u182, u183= u169.register_with_invite(u178, u176, u177)
    if u182 then
        client.log("Registered user:", u176)
    else
        client.log("Register failed:", u183 or "unknown error")
    end
end)]]
u743["require/abc/screen_logger"] = [[local u172= renderer
local u173= globals
local u174= client
local u175= table.insert
local u176= table.remove
local u177= math.floor




local u178= {}
local u179= 12

local function u180(u181)
    local u182, u183, u184= pcall(u172.measure_text, '', u181)
    if u182 and type(u183) == 'number' then return u183, u184 or 0 end
    u182, u183, h = pcall(u172.measure_text, u181)
    if u182 and type(u183) == 'number' then return u183, u184 or 0 end
    return 0, 0
end

local function u185(u186,u187,u188,u189,u190,u191)
    if not u186 then return end
    u187 = u187 or 4
    if #u178 >= u179 then
        u176(u178, 1)
    end
    u175(u178, {
        text = tostring(u186),
        duration = u187,
        color = { u188 or 255, u189 or 255, u190 or 255, u191 or 255 },
        ts = u173 and u173.curtime and u173.curtime() or os.clock(),
    })
    return true
end

local function u192()
    if not u172 or not u172.text then return end
    local u193= u173 and u173.curtime and u173.curtime() or os.clock()
    local u194, u195= u174 and u174.screen_size and u174.screen_size() or 800, 600

    local u196= 8
    local u197= 6
    local u198= 14
    local u199= 2

    local u200= u197

    for i = #u178, 1, -1 do
        local u201= u178[i]
        if not u201 then goto continue end
        local u202= u193 - (u201.ts or 0)
        local u203= (u201.duration or 4) - u202
        if u203 <= 0 then
            u176(u178, i)
        else
            local u204, u205= u180(u201.text)
            
            local u206= u177(u201.color[4] or 255)
            
            pcall(u172.text, u196, u200, u201.color[1] or 255, u201.color[2] or 255, u201.color[3] or 255, u206, 'b', 0, u201.text)
            u200 = u200 + (u205 > 0 and u205 or u198) + u199
        end
        ::continue::
    end
end

if u174 and u174.set_event_callback then
    u174.set_event_callback('paint', u192)
end

return u185]]
u743["require/brain/dll"] = [=[local ffi = require("ffi")

ffi.cdef([[
struct Vec3 { double x; double y; double z; };
struct AspectState { double original; double last; double last_update; int initialized; };
const char* clipboard_get();
int clipboard_set(const char* text);
int clipboard_empty();
int clantag_anim(double start_time, double now, char* out_buf, int out_buf_len);
void tracer_reset();
void tracer_push_shot(double sx, double sy, double sz, double t);
void tracer_set_impact(double ix, double iy, double iz, double t);
int tracer_collect(double now, double tracer_life, double fade_fraction, double pitch, double yaw, double fallback_dist, double base_alpha, double* out_buf, int max_lines);
 ]])


local function hex(val)
    local ok, num = pcall(ffi.cast, "uintptr_t", val)
    if not ok then return "<na>" end
    return string.format("0x%X", tonumber(num))
end

local function resolve_call_trampoline()
    local tramp = client.find_signature("engine.dll", "\xFF\xE1")
    if tramp == nil then
        return nil
    end
    return ffi.cast("void*", tramp)
end

local function make_import_thunk(sig_pattern, cast_type)
    local addr = client.find_signature("engine.dll", sig_pattern)
    if addr == nil then
        return nil
    end
    local ptr = ffi.cast("void***", ffi.cast("uintptr_t", addr) + 2)[0][0]
    return ptr
end

local call_trampoline = resolve_call_trampoline()
local gm_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B", "void *")
local gpa_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05", "void *")

if gm_thunk and gpa_thunk then
else
    return
end

local function via_trampoline(target, signature, label)
    local fn = ffi.cast(signature, call_trampoline)
    return function(...)
        return fn(target, ...)
    end
end

local function to_wide(str)
    local buf = ffi.new("wchar_t[?]", #str + 1)
    for i = 1, #str do buf[i - 1] = string.byte(str, i) end
    buf[#str] = 0
    return buf
end

local GetModuleHandleA_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const char *)", "GMH A")
local GetModuleHandleW_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const wchar_t *)", "GMH W")
local GetProcAddress_tr   = via_trampoline(gpa_thunk, "void *(__thiscall *)(void *, void *, const char *)", "GPA")

local function call_GetModuleHandle(name)
    local ok1, res1 = pcall(GetModuleHandleA_tr, name)
    if not ok1 then dbg("GetModuleHandleA tramp err", res1) end
    if ok1 and res1 ~= nil and res1 ~= ffi.NULL then
        return res1, "tramp ansi"
    end

    local ok2, res2 = pcall(GetModuleHandleW_tr, to_wide(name))
    if not ok2 then dbg("GetModuleHandleW tramp err", res2) end
    if ok2 and res2 ~= nil and res2 ~= ffi.NULL then
        return res2, "tramp wide"
    end

    return nil, "failed"
end

local function call_GetProcAddress(mod, name)
    local ok, res = pcall(GetProcAddress_tr, mod, name)
    if not ok then dbg("GetProcAddress tramp err", res) end
    if ok and res ~= nil and res ~= ffi.NULL then return res end
    return nil
end

local mod, gm_variant = call_GetModuleHandle("sodiumdll.dll")
if mod == nil then
    return
end

local function bind_export(name, cdecl_sig)
    local addr = call_GetProcAddress(mod, name)
    if addr == nil then
        return nil
    end
    return addr, ffi.cast(cdecl_sig, addr)
end

local add_addr, add_fn = bind_export("add", "int(__cdecl*)(int, int)")
local get_value_addr, get_value_fn = bind_export("get_value", "int(__cdecl*)(void)")
local pin_module_addr, pin_module_fn = bind_export("pin_module", "void(__cdecl*)(void)")
local release_module_addr, release_module_fn = bind_export("release_module", "void(__cdecl*)(void)")
local get_hwid_addr, get_hwid_fn = bind_export("get_hwid", "const char*(__cdecl*)(void)")
local clipboard_get_addr, clipboard_get_fn = bind_export("clipboard_get", "const char*(__cdecl*)(void)")
local clipboard_set_addr, clipboard_set_fn = bind_export("clipboard_set", "int(__cdecl*)(const char*)")
local clipboard_empty_addr, clipboard_empty_fn = bind_export("clipboard_empty", "int(__cdecl*)(void)")
local clantag_anim_addr, clantag_anim_fn = bind_export("clantag_anim", "int(__cdecl*)(double, double, char*, int)")
local tracer_reset_addr, tracer_reset_fn = bind_export("tracer_reset", "void(__cdecl*)(void)")
local tracer_push_shot_addr, tracer_push_shot_fn = bind_export("tracer_push_shot", "void(__cdecl*)(double, double, double, double)")
local tracer_set_impact_addr, tracer_set_impact_fn = bind_export("tracer_set_impact", "void(__cdecl*)(double, double, double, double)")
local tracer_collect_addr, tracer_collect_fn = bind_export("tracer_collect", "int(__cdecl*)(double, double, double, double, double, double, double, double*, int)")

local vec_make_addr, vec_make_fn = bind_export("vec_make", "struct Vec3(__cdecl*)(double, double, double)")
local vec_add_addr, vec_add_fn = bind_export("vec_add", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_sub_addr, vec_sub_fn = bind_export("vec_sub", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_mul_scalar_addr, vec_mul_scalar_fn = bind_export("vec_mul_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_div_scalar_addr, vec_div_scalar_fn = bind_export("vec_div_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_unm_addr, vec_unm_fn = bind_export("vec_unm", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_length_addr, vec_length_fn = bind_export("vec_length", "double(__cdecl*)(struct Vec3)")
local vec_dot_addr, vec_dot_fn = bind_export("vec_dot", "double(__cdecl*)(struct Vec3, struct Vec3)")
local vec_cross_addr, vec_cross_fn = bind_export("vec_cross", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_normalized_addr, vec_normalized_fn = bind_export("vec_normalized", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_distance_addr, vec_distance_fn = bind_export("vec_distance", "double(__cdecl*)(struct Vec3, struct Vec3)")

local m_clamp_addr, m_clamp_fn = bind_export("m_clamp", "double(__cdecl*)(double, double, double)")
local m_clamp01_addr, m_clamp01_fn = bind_export("m_clamp01", "double(__cdecl*)(double)")
local m_abs_addr, m_abs_fn = bind_export("m_abs", "double(__cdecl*)(double)")
local m_lerp_addr, m_lerp_fn = bind_export("m_lerp", "double(__cdecl*)(double, double, double)")
local m_distance2d_addr, m_distance2d_fn = bind_export("m_distance2d", "double(__cdecl*)(double, double, double, double)")
local m_distance3d_addr, m_distance3d_fn = bind_export("m_distance3d", "double(__cdecl*)(double, double, double, double, double, double)")
local m_rad_to_deg_addr, m_rad_to_deg_fn = bind_export("m_rad_to_deg", "double(__cdecl*)(double)")
local m_deg_to_rad_addr, m_deg_to_rad_fn = bind_export("m_deg_to_rad", "double(__cdecl*)(double)")
local m_wrap_degrees_addr, m_wrap_degrees_fn = bind_export("m_wrap_degrees", "double(__cdecl*)(double)")
local m_normalize_angle_addr, m_normalize_angle_fn = bind_export("m_normalize_angle", "double(__cdecl*)(double)")
local m_angle_diff_addr, m_angle_diff_fn = bind_export("m_angle_diff", "double(__cdecl*)(double, double)")
local m_lerp_angle_addr, m_lerp_angle_fn = bind_export("m_lerp_angle", "double(__cdecl*)(double, double, double)")
local m_map_addr, m_map_fn = bind_export("m_map", "double(__cdecl*)(double, double, double, double, double)")
local m_smoothstep_addr, m_smoothstep_fn = bind_export("m_smoothstep", "double(__cdecl*)(double, double, double)")
local aspect_update_addr, aspect_update_fn = bind_export("aspect_update", "void(__cdecl*)(void*, double, double, double, double*, int*)")

if not (add_fn and get_value_fn and pin_module_fn and release_module_fn and get_hwid_fn and
    vec_make_fn and vec_add_fn and vec_sub_fn and vec_mul_scalar_fn and vec_div_scalar_fn and
    vec_unm_fn and vec_length_fn and vec_dot_fn and vec_cross_fn and vec_normalized_fn and vec_distance_fn and
    m_clamp_fn and m_clamp01_fn and m_abs_fn and m_lerp_fn and m_distance2d_fn and m_distance3d_fn and
    m_rad_to_deg_fn and m_deg_to_rad_fn and m_wrap_degrees_fn and m_normalize_angle_fn and m_angle_diff_fn and
    m_lerp_angle_fn and m_map_fn and m_smoothstep_fn and aspect_update_fn and
    clipboard_get_fn and clipboard_set_fn and clipboard_empty_fn and clantag_anim_fn and
    tracer_reset_fn and tracer_push_shot_fn and tracer_set_impact_fn and tracer_collect_fn) then
    return
end

local Call_add = via_trampoline(add_addr, "int(__thiscall *)(void*, int, int)", "add")
local Call_get_value = via_trampoline(get_value_addr, "int(__thiscall *)(void*)", "get_value")
local Call_pin_module = via_trampoline(pin_module_addr, "void(__thiscall *)(void*)", "pin_module")
local Call_release_module = via_trampoline(release_module_addr, "void(__thiscall *)(void*)", "release_module")
local Call_get_hwid = via_trampoline(get_hwid_addr, "const char*(__thiscall *)(void*)", "get_hwid")
local Call_clipboard_get = via_trampoline(clipboard_get_addr, "const char*(__thiscall *)(void*)", "clipboard_get")
local Call_clipboard_set = via_trampoline(clipboard_set_addr, "int(__thiscall *)(void*, const char*)", "clipboard_set")
local Call_clipboard_empty = via_trampoline(clipboard_empty_addr, "int(__thiscall *)(void*)", "clipboard_empty")
local Call_clantag_anim = via_trampoline(clantag_anim_addr, "int(__thiscall *)(void*, double, double, char*, int)", "clantag_anim")
local Call_tracer_reset = via_trampoline(tracer_reset_addr, "void(__thiscall *)(void*)", "tracer_reset")
local Call_tracer_push_shot = via_trampoline(tracer_push_shot_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_push_shot")
local Call_tracer_set_impact = via_trampoline(tracer_set_impact_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_set_impact")
local Call_tracer_collect = via_trampoline(tracer_collect_addr, "int(__thiscall *)(void*, double, double, double, double, double, double, double, double*, int)", "tracer_collect")
local Call_vec_make = via_trampoline(vec_make_addr, "struct Vec3(__thiscall *)(void*, double, double, double)", "vec_make")
local Call_vec_add = via_trampoline(vec_add_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_add")
local Call_vec_sub = via_trampoline(vec_sub_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_sub")
local Call_vec_mul_scalar = via_trampoline(vec_mul_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_mul_scalar")
local Call_vec_div_scalar = via_trampoline(vec_div_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_div_scalar")
local Call_vec_unm = via_trampoline(vec_unm_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_unm")
local Call_vec_length = via_trampoline(vec_length_addr, "double(__thiscall *)(void*, struct Vec3)", "vec_length")
local Call_vec_dot = via_trampoline(vec_dot_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_dot")
local Call_vec_cross = via_trampoline(vec_cross_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_cross")
local Call_vec_normalized = via_trampoline(vec_normalized_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_normalized")
local Call_vec_distance = via_trampoline(vec_distance_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_distance")

local Call_m_clamp = via_trampoline(m_clamp_addr, "double(__thiscall *)(void*, double, double, double)", "m_clamp")
local Call_m_clamp01 = via_trampoline(m_clamp01_addr, "double(__thiscall *)(void*, double)", "m_clamp01")
local Call_m_abs = via_trampoline(m_abs_addr, "double(__thiscall *)(void*, double)", "m_abs")
local Call_m_lerp = via_trampoline(m_lerp_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp")
local Call_m_distance2d = via_trampoline(m_distance2d_addr, "double(__thiscall *)(void*, double, double, double, double)", "m_distance2d")
local Call_m_distance3d = via_trampoline(m_distance3d_addr, "double(__thiscall *)(void*, double, double, double, double, double, double)", "m_distance3d")
local Call_m_rad_to_deg = via_trampoline(m_rad_to_deg_addr, "double(__thiscall *)(void*, double)", "m_rad_to_deg")
local Call_m_deg_to_rad = via_trampoline(m_deg_to_rad_addr, "double(__thiscall *)(void*, double)", "m_deg_to_rad")
local Call_m_wrap_degrees = via_trampoline(m_wrap_degrees_addr, "double(__thiscall *)(void*, double)", "m_wrap_degrees")
local Call_m_normalize_angle = via_trampoline(m_normalize_angle_addr, "double(__thiscall *)(void*, double)", "m_normalize_angle")
local Call_m_angle_diff = via_trampoline(m_angle_diff_addr, "double(__thiscall *)(void*, double, double)", "m_angle_diff")
local Call_m_lerp_angle = via_trampoline(m_lerp_angle_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp_angle")
local Call_m_map = via_trampoline(m_map_addr, "double(__thiscall *)(void*, double, double, double, double, double)", "m_map")
local Call_m_smoothstep = via_trampoline(m_smoothstep_addr, "double(__thiscall *)(void*, double, double, double)", "m_smoothstep")
local Call_aspect_update = via_trampoline(aspect_update_addr, "void(__thiscall *)(void*, void*, double, double, double, double*, int*)", "aspect_update")


return {
    add = function(a, b)
        return Call_add(a, b)
    end,
    get_value = function()
        return Call_get_value()
    end,
    pin_module = function()
        return Call_pin_module()
    end,
    release_module = function()
        return Call_release_module()
    end,
    get_hwid = function()
        return Call_get_hwid()
    end,
    clipboard_get = function()
        return Call_clipboard_get()
    end,
    clipboard_set = function(text)
        return Call_clipboard_set(text)
    end,
    clipboard_empty = function()
        return Call_clipboard_empty()
    end,
    clantag_anim = function(start_time, now, out_buf, out_buf_len)
        return Call_clantag_anim(start_time, now, out_buf, out_buf_len)
    end,
    tracer_reset = function()
        return Call_tracer_reset()
    end,
    tracer_push_shot = function(sx, sy, sz, t)
        return Call_tracer_push_shot(sx, sy, sz, t)
    end,
    tracer_set_impact = function(ix, iy, iz, t)
        return Call_tracer_set_impact(ix, iy, iz, t)
    end,
    tracer_collect = function(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
        return Call_tracer_collect(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
    end,
    vec_make = function(x, y, z)
        return Call_vec_make(x, y, z)
    end,
    vec_add = function(a, b)
        return Call_vec_add(a, b)
    end,
    vec_sub = function(a, b)
        return Call_vec_sub(a, b)
    end,
    vec_mul_scalar = function(v, s)
        return Call_vec_mul_scalar(v, s)
    end,
    vec_div_scalar = function(v, s)
        return Call_vec_div_scalar(v, s)
    end,
    vec_unm = function(v)
        return Call_vec_unm(v)
    end,
    vec_length = function(v)
        return Call_vec_length(v)
    end,
    vec_dot = function(a, b)
        return Call_vec_dot(a, b)
    end,
    vec_cross = function(a, b)
        return Call_vec_cross(a, b)
    end,
    vec_normalized = function(v)
        return Call_vec_normalized(v)
    end,
    vec_distance = function(a, b)
        return Call_vec_distance(a, b)
    end,
    m_clamp = function(val, minVal, maxVal)
        return Call_m_clamp(val, minVal, maxVal)
    end,
    m_clamp01 = function(val)
        return Call_m_clamp01(val)
    end,
    m_abs = function(val)
        return Call_m_abs(val)
    end,
    m_lerp = function(a, b, t)
        return Call_m_lerp(a, b, t)
    end,
    m_distance2d = function(x1, y1, x2, y2)
        return Call_m_distance2d(x1, y1, x2, y2)
    end,
    m_distance3d = function(x1, y1, z1, x2, y2, z2)
        return Call_m_distance3d(x1, y1, z1, x2, y2, z2)
    end,
    m_rad_to_deg = function(rad)
        return Call_m_rad_to_deg(rad)
    end,
    m_deg_to_rad = function(deg)
        return Call_m_deg_to_rad(deg)
    end,
    m_wrap_degrees = function(angle)
        return Call_m_wrap_degrees(angle)
    end,
    m_normalize_angle = function(angle)
        return Call_m_normalize_angle(angle)
    end,
    m_angle_diff = function(a, b)
        return Call_m_angle_diff(a, b)
    end,
    m_lerp_angle = function(a, b, t)
        return Call_m_lerp_angle(a, b, t)
    end,
    m_map = function(val, in_min, in_max, out_min, out_max)
        return Call_m_map(val, in_min, in_max, out_min, out_max)
    end,
    m_smoothstep = function(edge0, edge1, x)
        return Call_m_smoothstep(edge0, edge1, x)
    end,
    aspect_update = function(state, raw_slider, current_aspect, now, out_target, out_dirty)
        return Call_aspect_update(state, raw_slider, current_aspect, now, out_target, out_dirty)
    end,
    module_base = mod,
}]=]
u743["require/brain/test"] = [[local u178= require("require/brain/api/math/math")
local u179= require("require/brain/api/health/health")
local u180= require("require/brain/api/hwid/hwid")
local u181= require("require/brain/dll")


client.set_event_callback("paint_ui", function()
    local u182, u183= pcall(u178.add, 2, math.random(1, 100))
    if u182 then
        
    end

end)

local u184, u185= pcall(u180.get_hwid)
if u184 and u185 and u185 ~= "" then
    
else
    
end]]
u743["require/brain/api/clipboard/clipboard"] = [[]]
u743["require/brain/api/health/health"] = [[local u184= require("require/brain/dll")

if not u184 then
	error("sodiumdll exports unavailable")
end

return {
	pin_module = function()
		return u184.pin_module()
	end,
	release_module = function()
		return u184.release_module()
	end,
	module_base = u184.module_base,
}]]
u743["require/brain/api/hwid/hwid"] = [[local u187= require("ffi")
local u188= require("require/brain/dll")

if not u188 or not u188.get_hwid then
    error("sodiumdll hwid export missing")
end

return {
	get_hwid = function()
		local u189= u188.get_hwid()
		if not u189 or u189 == u187.NULL then
			return ""
		end
		return u187.string(u189)
	end,
}]]
u743["require/brain/api/ip/ip"] = [[
local u190= require("require/brain/dll")

if not u190 or not u190.get_public_ip then
	return error("sodiumdll ip export missing")
end

return {
	get_public_ip = function(u191,u192)
		return u190.get_public_ip(u191, u192)
	end,
}]]
u743["require/brain/api/math/math"] = [[local u193= require("require/brain/dll")

if not u193 or not u193.m_clamp then
	error("sodiumdll math exports missing")
end

return {
	add = function(u194,u195)
		return u193.add(u194, u195)
	end,
	get_value = function()
		return u193.get_value()
	end,
	m_clamp = function(u196,u197,u198)
		return u193.m_clamp(u196, u197, u198)
	end,
	m_clamp01 = function(u196)
		return u193.m_clamp01(u196)
	end,
	m_abs = function(u196)
		return u193.m_abs(u196)
	end,
	m_lerp = function(u194,u195,u199)
		return u193.m_lerp(u194, u195, u199)
	end,
	m_distance2d = function(u200,u201,u202,u203)
		return u193.m_distance2d(u200, u201, u202, u203)
	end,
	m_distance3d = function(u200,u201,u204,u202,u203,u205)
		return u193.m_distance3d(u200, u201, u204, u202, u203, u205)
	end,
	m_rad_to_deg = function(u206)
		return u193.m_rad_to_deg(u206)
	end,
	m_deg_to_rad = function(u207)
		return u193.m_deg_to_rad(u207)
	end,
	m_wrap_degrees = function(u208)
		return u193.m_wrap_degrees(u208)
	end,
	m_normalize_angle = function(u208)
		return u193.m_normalize_angle(u208)
	end,
	m_angle_diff = function(u194,u195)
		return u193.m_angle_diff(u194, u195)
	end,
	m_lerp_angle = function(u194,u195,u199)
		return u193.m_lerp_angle(u194, u195, u199)
	end,
	m_map = function(u196,u209,u210,u211,u212)
		return u193.m_map(u196, u209, u210, u211, u212)
	end,
	m_smoothstep = function(u213,u214,u215)
		return u193.m_smoothstep(u213, u214, u215)
	end,
}]]
u743["require/brain/api/vector/vector"] = [[local u196= require("ffi")
local u197= require("require/brain/dll")

if not u197 or not u197.vec_make or not u197.vec_add or not u197.vec_sub or not u197.vec_mul_scalar or
   not u197.vec_div_scalar or not u197.vec_unm or not u197.vec_length or not u197.vec_dot or
   not u197.vec_cross or not u197.vec_normalized or not u197.vec_distance or not u197.aspect_update then
    error("sodiumdll vector exports missing")
end

local u198= u196.typeof("struct Vec3")

local function u199(u200)
    if u196.istype(u198, u200) then
        return u200
    end
    local u201= (u200 and u200.x) or 0
    local u202= (u200 and u200.y) or 0
    local u203= (u200 and u200.z) or 0
    return u197.vec_make(u201, u202, u203)
end

return {
    Vec3 = u198,
    make = function(u201,u202,u203)
        return u197.vec_make(u201 or 0, u202 or 0, u203 or 0)
    end,
    add = function(u204,u205)
        return u197.vec_add(u199(u204), u199(u205))
    end,
    sub = function(u204,u205)
        return u197.vec_sub(u199(u204), u199(u205))
    end,
    mul_scalar = function(u200,u206)
        return u197.vec_mul_scalar(u199(u200), u206)
    end,
    div_scalar = function(u200,u206)
        return u197.vec_div_scalar(u199(u200), u206)
    end,
    unm = function(u200)
        return u197.vec_unm(u199(u200))
    end,
    length = function(u200)
        return u197.vec_length(u199(u200))
    end,
    dot = function(u204,u205)
        return u197.vec_dot(u199(u204), u199(u205))
    end,
    cross = function(u204,u205)
        return u197.vec_cross(u199(u204), u199(u205))
    end,
    normalized = function(u200)
        return u197.vec_normalized(u199(u200))
    end,
    distance = function(u204,u205)
        return u197.vec_distance(u199(u204), u199(u205))
    end,
    aspect_update = u197.aspect_update,
}]]
u743["require/brain/examples/boxes"] = [[local u199= require("ffi")
local u200= {


}


u200.GetModuleHandlePtr = 
    u199.cast(
        "void***", 
        u199.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B")) + 2
    )[0][0]

u200.GetProcAddressPtr = 
    u199.cast(
        "void***", 
        u199.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05")) + 2
    )[0][0]


u200.reinterpret_cast = function(u201,u202) 
    return function(...) 
        return u199.cast(u202, client.find_signature("engine.dll", "\xFF\xE1"))(u201, ...) 
    end
end


u200.fnGetModuleHandle = u200.reinterpret_cast(
    u200.GetModuleHandlePtr, 
    "void*(__thiscall*)(void*, const char*)"
)

u200.GetModuleHandle = function(u203)
    return u200.fnGetModuleHandle(u203)
end 


u200.fnGetProcAddress = u200.reinterpret_cast(
    u200.GetProcAddressPtr, 
    "void*(__thiscall*)(void*, void*, const char*)"
)

u200.GetProcAddress = function(u203,u204)
    local u201= u200.fnGetProcAddress(u203, u204)
    return u201
end 


u200.lib = {}
u200.lib.user32 = u200.GetModuleHandle("user32.dll")


u200.export = {}
u200.export.user32 = {}

u200.export.user32.MessageBoxPtr = u200.GetProcAddress(u200.lib.user32, "MessageBoxA")
u200.export.user32.MessageBox = u200.reinterpret_cast(
    u200.export.user32.MessageBoxPtr,
    "int(__thiscall*)(void*, void*, const char*, const char*, unsigned int)"
)


local u205= 0x00000000
local u206= 0x00000001
local u207= 0x00000004
local u208= 0x00000010
local u209= 0x00000020
local u210= 0x00000030
local u211= 0x00000040


local u212= 1
local u213= 2
local u214= 6
local u215= 7


local function u216(u217,u218,u219)
    u218 = u218 or "Gamesense"
    u219 = u219 or u205
    
    local u220= u200.export.user32.MessageBox(nil, u217, u218, u219)
    return u220
end


local function u221(u217,u218)
    return u216(u217, u218, u205 + u211)
end

local function u222(u217,u218)
    return u216(u217, u218, u205 + u210)
end

local function u223(u217,u218)
    return u216(u217, u218, u205 + u208)
end

local function u224(u217,u218)
    local u220= u216(u217, u218, u207 + u209)
    return u220 == u214
end
u221("test", "test")]]
u743["require/brain/features/aspectratio"] = [[local u202= require("ffi")
local u203= require("require/brain/dll")

if not u203 or not u203.aspect_update then
    error("sodiumdll aspect_update export missing")
end

return {
    aspect_update = function(u204,u205,u206,u207)
        local u208= u202.new("double[1]")
        local u209= u202.new("int[1]")

        u203.aspect_update(u204 or u202.NULL, u205, u206, u207, u208, u209)

        return u208[0], u209[0]
    end,
}]]
u743["require/features/aa/aa_collect"] = [[
local u205= entity
local u206= require('require/abc/menu_setup')
local u207= require('require/aa/player_condition')

local u208= {}
u208.last_side = 'left'

local function u209()
    local u210, u211= pcall(u207.get)
    if not u210 or not u211 then return nil end
    local u212= 'delay_' .. u211
    if not (u206 and u206.ui) then return nil end
    local u213= u206.ui[u212]
    if not u213 then return nil end
    local u214, u215= pcall(ui.get, u213)
    if not u214 then return nil end
    local u216= tonumber(u215)
    if u216 then return u216 end
    return u215
end

local function u217()
    local u210, u211= pcall(u207.get)
    if not u210 or not u211 then return nil end
    local u212= 'fifty_fifty_' .. u211
    if not (u206 and u206.ui) then return nil end
    local u213= u206.ui[u212]
    if not u213 then return nil end
    local u214, u215= pcall(ui.get, u213)
    if not u214 then return nil end
    local u216= tonumber(u215)
    if u216 then return u216 end
    return u215
end

local function u218()
    local u210, u211= pcall(u207.get)
    if not u210 or not u211 then return nil end
    local u212= 'body_yaw_mode_' .. u211
    if not (u206 and u206.ui) then return nil end
    local u213= u206.ui[u212]
    if not u213 then return nil end
    local u214, u215= pcall(ui.get, u213)
    if not u214 then return nil end
    local u216= tonumber(u215)
    if u216 then return u216 end
    return u215
end

local function u219(u220)
    if not (u205 and u205.get_prop and u220) then return u208.last_side end
    local u221= u205.get_prop(u220, 'm_flPoseParameter', 11)
    if u221 == nil then
        return u208.last_side
    end
    local u222= (u221 > 0.5) and 'right' or 'left'
    u208.last_side = u222
    return u222
end

local function u223()
    local u224= u209() + 1
    local u216= tonumber(u224) or 1
    if u216 < 1 then u216 = 1 end
    if u216 > 17 then u216 = 17 end

    local u225= globals.tickcount()
    if not u225 then return u208.last_side end

    local u226= math.floor(u225 / u216) % 2
    local u222= (u226 == 0) and 'left' or 'right'
    u208.last_side = u222
    return u222
end




local function u227()

    local u228= u217()

    if u228 then
        local u229= math.random(0, 1)
        local u222= (u229 == 0) and 'left' or 'right'
        u208.last_side = u222
        return u222
    end

    local u224= u209()
    local u216= tonumber(u224)

    if u218() ~= 'jitter' then
        return u219(u205.get_local_player())
    end

    if not u216 or u216 == 0 then
        local u220= u205.get_local_player()
        if not u220 or u220 == 0 then return u208.last_side end
        return u219(u220)
    else
        return u223()
    end
end





u208.resolve_side = u219
u208.resolve_local_side = u227
u208.get_delay_for_current_condition = u209

return u208]]
u743["require/features/aa/antiaim"] = [[local u208= require('require/features/aa/builder')
local u209= require('require/features/aa/defensive')

local u210= require('require/abc/callbacks')

local function u211()
    local u212= (globals.maxplayers and globals.maxplayers() or 64)
    local u213, u214, u215= entity.get_classname, entity.is_enemy, entity.is_alive
    if not (u213 and u214 and u215) then return 0 end
    local u216= 0
    for i=1,u212 do
        if u213(i) == 'CCSPlayer' and u214(i) and u215(i) then u216 = u216 + 1 end
    end
    return u216
end

u210.register('setup_command', function(u217)
    if u208 and u208.activate then
        u208.activate(u217)
    end

end, { alive_only = true, require_login = true })]]
u743["require/features/aa/antibrute"] = [[]]
u743["require/features/aa/builder"] = [[local u214= require('require/abc/menu_setup')
local u215= require('require/aa/player_condition')
local u216= require('require/features/aa/aa_collect')
local u217= require('require/help/math')
local u218= require('require/help/vector')
local u219= require('require/help/time')
local u220= require('require/help/string')

local u221= {}
client.set_event_callback('weapon_fire', function(u222)
  if not u222 or not u222.userid then return end
  local u223, u224= pcall(client.userid_to_entindex, u222.userid)
  if not u223 or not u224 or u224 == 0 then return end
  u221[u224] = u219.tickcount()
end)

local function u225(u226)
	if not u226 then return nil end

	local u227= {
		pitch = 'pitch_',
		yaw_base = 'yaw_base_',
		yaw = 'yaw_',
		body_yaw_base = 'body_yaw_base_',
		body_yaw_left = 'body_yaw_left_',
		body_yaw_right = 'body_yaw_right_',
		randomize_yaw = 'randomize_yaw_',
		yaw_jitter = 'yaw_jitter_',
		yaw_jitter_base = 'yaw_jitter_base_',
		body_yaw_mode = 'body_yaw_mode_',
		static_body_yaw = 'static_body_yaw_',
		body_yaw_value = 'body_yaw_value_',
		delay = 'delay_',
		fifty_fifty = 'fifty_fifty_',
		only_flip_on_0_choke = 'only_flip_on_0_choke_',
	}

	local u228= { condition = u226 }
	for name, prefix in pairs(u227) do
		local u229= prefix .. u226
		local u230= u214.ui and u214.ui[u229]
		if u230 then
			local u231, u232= pcall(ui.get, u230)
			if u231 then u228[name] = u232 else u228[name] = nil end
		else
			u228[name] = nil
		end
	end

	return u228
end




local function u233()
  local u231, u226= pcall(u215.get)
  if not u231 or not u226 then
    return nil
  end
  local u234= u225(u226)
  return u234 and u234.pitch or nil
end




local function u235()
  local u231, u226= pcall(u215.get)
  if not u231 or not u226 then
    return nil
  end
  local u234= u225(u226)
  local u236= u234 and u234.yaw_base or nil
  if u236 == nil then return nil end
  local u237= u220.lower(tostring(u236))
  if u237 == 'threat' then
    return 'local view'
  elseif u237 == 'distance' then
    return 'local view'
  elseif u237 == 'target' then
    return 'at targets'
  elseif u237 == 'view' then
    return 'local view'
  elseif u237 == 'smart' then
    return 'local view'
  else
    return tostring(u236)
  end
end




local function u238()
	local u231, u226= pcall(u215.get)
	if not u231 or not u226 then
		return nil
	end
	local u234= u225(u226)
	return u234 and u234.yaw or nil
end




local function u239()
    local u231, u226= pcall(u215.get)
    if not u231 or not u226 then
        return nil
    end
    local u234= u225(u226)
    return u234 and u234.yaw_jitter or nil
end




local function u240()
  local u231, u226= pcall(u215.get)
  if not u231 or not u226 then
    return nil
  end
  local u234= u225(u226)
  return u234 and u234.yaw_jitter_base or nil
end




local function u241()
  local u231, u226= pcall(u215.get)
  if not u231 or not u226 then return nil end
  local u234= u225(u226)
  if not u234 then return nil end
  local u242= u234.randomize_yaw
  if u242 == nil then return nil end
  local u243= tonumber(u242)
  if not u243 then return nil end
  if u243 < 0 then u243 = 0 end
  if u243 > 30 then u243 = 30 end
  return math.floor(u243)
end




local function u244()
    local u231, u226= pcall(u215.get)
    if not u231 or not u226 then
        return nil
    end
  local u234= u225(u226)
  local u245= u234 and u234.body_yaw_mode or nil
  if not u245 then return nil end
  local u246= u220.lower(tostring(u245))
  if u246 == 'jitter' then
    local u247= u216.get_delay_for_current_condition and u216.get_delay_for_current_condition() or nil
    local u243= tonumber(u247) or 0
    if u243 > 0 then
      return 'static'
    else
      return 'jitter'
    end
  end
  return u245
end




local function u248()
  local u231, u226= pcall(u215.get)
  if not u231 or not u226 then
    return nil
  end
  local u234= u225(u226)
  if not u234 then return nil end


  local u245= u234.body_yaw_mode
  if u245 ~= nil then u245 = u220.lower(tostring(u245)) end

  if u245 == 'jitter' then
    local u247= u216.get_delay_for_current_condition and u216.get_delay_for_current_condition() or nil
    local u249= tonumber(u247) or 0
    if u249 > 0 then
      local u250= u216.resolve_local_side and u216.resolve_local_side() or nil
      if u250 == 'right' then
        return -58
      else
        return 58
      end
    end

    local u236= u234.body_yaw_value
    local u243= tonumber(u236) or nil
    if u243 == 1 then
      return -180
    elseif u243 == 2 then
      return 0
    elseif u243 == 3 then
      return 180
    end
    return nil
  elseif u245 == 'static' then
    if u234.static_body_yaw ~= nil then
      local u251= tonumber(u234.static_body_yaw)
      if u251 then return u251 end
    end
    local u236= u234.body_yaw_value
    local u243= tonumber(u236) or nil
    if u243 == 1 then
      return -180
    elseif u243 == 2 then
      return 0
    elseif u243 == 3 then
      return 180
    end
    return nil
  else
    return 0
  end
end




local function u252()
  local u231, u226= pcall(u215.get)
  if not u231 or not u226 then
    return nil
  end
  local u234= u225(u226)
  return u234 and u234.body_yaw_base or nil
end




local function u253()
    local u231, u226= pcall(u215.get)
    if not u231 or not u226 then
        return nil
    end
    local u234= u225(u226)
    return u234 and u234.body_yaw_left or nil
end




local function u254()
    local u231, u226= pcall(u215.get)
    if not u231 or not u226 then
        return nil
    end
    local u234= u225(u226)
    return u234 and u234.body_yaw_right or nil
end




local function u255()
    local u231, u226= pcall(u215.get)
    if not u231 or not u226 then
        return nil
    end
    local u234= u225(u226)
    if not u234 then return nil end
    local u242= u234.only_flip_on_0_choke
    if u242 == nil then return nil end
    return not not u242
end




local function u256()
  local u231, u226= pcall(u215.get)
  if not u231 or not u226 then
    return nil
  end
  local u229= 'delay_' .. u226
  if not (u214 and u214.ui) then return nil end
  local u230= u214.ui[u229]
  if not u230 then return nil end
  local u257, u232= pcall(ui.get, u230)
  if u257 then return u232 end
  return nil
end




local function u258()
  local u231, u226= pcall(u215.get)
  if not u231 or not u226 then return nil end
  local u234= u225(u226)
  if not u234 then return nil end
  local u242= u234.fifty_fifty
  if u242 == nil then return nil end
  return not not u242
end





local function u259(u245)
  local u246= u220.lower(tostring(u245 or 'threat'))

  local u260= nil
  if u246 == 'distance' then
    local u261, u262= pcall(entity.get_players, true)
    if not u261 or not u262 or #u262 == 0 then return nil end
    local u263= entity.get_local_player()
    if not u263 then return nil end
    local u264, u265, u266, u267= pcall(entity.get_origin, u263)
    if not u264 or not u265 then return nil end
    local u268= nil
    local u269= nil
    for _, u224 in ipairs(u262) do
      if u224 and entity.is_alive and entity.is_alive(u224) and entity.is_enemy and entity.is_enemy(u224) then
        local u270, u271, u272, u273= pcall(entity.get_origin, u224)
        if u270 and u271 then
          local u274= u217.distance2d(u265, u266, u271, u272)
          if not u269 or u274 < u269 then
            u269 = u274
            u268 = u224
          end
        end
      end
    end
    u260 = u268
    elseif u246 == 'smart' then
      local u261, u262= pcall(entity.get_players, true)
      if u261 and u262 and #u262 > 0 then
        local u263= entity.get_local_player()
        if u263 then
          local u264, u265, u266, u267= pcall(entity.get_origin, u263)
          if u264 and u265 then
            local u268= nil
            local u269= nil
            for _, u224 in ipairs(u262) do
              if u224 and entity.is_alive and entity.is_alive(u224) and entity.is_enemy and entity.is_enemy(u224) then
                local u270, u271, u272, u273= pcall(entity.get_origin, u224)
                if u270 and u271 then
                  local u275= u221[u224]
                  if u275 and u219.within_ticks_window(u275, 10) then goto continue_smart end
                  local u276, u277= pcall(entity.get_player_weapon, u224)
                  if u276 and u277 and u277 ~= 0 then
                    local u278, u279= pcall(entity.get_classname, u277)
                    local u280= u220.lower(u278 and u279 and tostring(u279) or '')
                    if u280:find('knife') or u280:find('grenade') or u280:find('taser') or u280:find('zeus') then goto continue_smart end
                  end
                  do
                    local u274= u217.distance2d(u265, u266, u271, u272)
                    if not u269 or u274 < u269 then
                      u269 = u274
                      u268 = u224
                    end
                  end
                  ::continue_smart::
                end
              end
            end
            u260 = u268
          end
        end
      end
      if not u260 then
        local u281, u282= pcall(client.current_threat)
        if u281 and u282 then u260 = u282 end
      end
    else
      local u281, u282= pcall(client.current_threat)
      if u281 and u282 then u260 = u282 end
    end

  if not u260 then return nil end
  if not (entity.is_alive and entity.is_enemy and entity.is_alive(u260) and entity.is_enemy(u260)) then
    return nil
  end

  local u263= entity.get_local_player()
  if not u263 then return nil end

  local u283, u265, u266, u267= pcall(entity.get_origin, u263)
  local u284, u271, u272, u273= pcall(entity.get_origin, u260)
  if not u283 or not u284 or not u265 or not u271 then return nil end

  local u285= u271 - u265
  local u286= u272 - u266
  local u287= math.atan2(u286, u285)
  local u288= u217.rad_to_deg(u287)

  local u289, u290, u291= pcall(client.camera_angles)
  local u292= u289 and u291 or 0

  local u293= u217.normalize_angle(u288 - u292)
  return u217 and u217.round and u217.round(u293) or math.floor(u293 + 0.5)

end




local u294= {}
local u295= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local u296= {ui.reference(item[1], item[2], item[3])}
    u294[i] = u296
    for _, ref in ipairs(u296) do
        u295[ref] = true
    end
end





local function u297(u298)
  if weaponn ~= nil and entity.get_classname(weaponn) == "CC4" then
    if u298.in_attack == 1 then
        u298.in_attack = 0 
        u298.in_use = 1
    end
  else
    if u298.chokedcommands == 0 then
        u298.in_use = 0
    end
  end

end





local function u299(u298)

    local u300= u298.chokedcommands
    
    if u255() then
        if u300 > 0 then
            return
        end
    end

    local u250= u216.resolve_local_side()

    
    
    
    ui.set(u294[2][1], tostring(u233()))

    
    
    
    ui.set(u294[3][1], tostring(u235()))

    
    
    
    local u301= u238()
    if u301 == "3way" then
      u301 = '180'
    elseif u301 == "ideal" then
      u301 = '180'
    end
    ui.set(u294[4][1], u301)

    
    
    
    ui.set(u294[5][1], tostring(u239()))

    
    
    
    ui.set(u294[5][2], tostring(u240()))

    
    
    
    ui.set(u294[6][1], tostring(u244()))

    
    
    
    ui.set(u294[6][2], tostring(u248()))

    
    
    
    local u302= tonumber(u252()) or 0
    local u303= 0
    if ui.get(u294[4][1]) == '180' then
      if u250 == 'right' then
        u303 = tonumber(u253()) or 0
      elseif u250 == 'left' then
        u303 = tonumber(u254()) or 0
      end
    end
    local u304= u302 + u303
    local u305= tonumber(u241()) or 0
    if u305 > 0 then
      local u306= math.abs(u304) * (u305 / 100)
      local u307= (u217.random_int(-1000, 1000) / 1000)
      local u308= u307 * u306
      u304 = u304 + u308
    end

    do
      local u309, u226= pcall(u215.get)
      if u309 and u226 then
        local u234= u225(u226)
        if u234 then
          local u310= u220.lower(tostring(u234.yaw_base or ''))
          if u310 == 'threat' or u310 == 'distance' then
            local u311= u259(u310)
            if u311 then
              u304 = u304 + tonumber(u311) or u304
            end
          end
        end
      end
    end

    local u312= u217.normalize_angle(u304)
    ui.set(u294[4][2], u217.round(u312))

    
    
    
    u297(u298)

end


return {
  gather = u225,
  activate = u299,
  print_current = u299,
}]]
u743["require/features/aa/defensive"] = [[local u217= {}
u217.active = nil
u217.activate = nil
local u218= require('require/help/time')
local u219= require('require/abc/menu_setup')
local u220= require('require/features/aa/defensive_presets')
local u221= require('require/aa/player_condition')
local u222= require('require/abc/screen_logger')
local u223, u224= pcall(require, 'require/abc/callbacks')




local u225= {}
local u226= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'RAGE', 'Aimbot', 'Double tap' },
    { 'RAGE', 'Other', 'Duck peek assist' },

}) do
    local u227= {ui.reference(item[1], item[2], item[3])}
    u225[i] = u227
    for _, ref in ipairs(u227) do
        u226[ref] = true
    end
end


local u228= {
    cond = nil,
    idx = nil,
    preset = nil,
    selected_tick = 0,
}
local u229= false
local u230= 0





local u231= {
    last = false,
    pending_until = nil,
}
local function u232()
    local u233, u234= pcall(ui.get, u225[10][2])
    local u235= u233 and not not u234 or false
    local u236= u218.tickcount() or (globals and globals.tickcount and globals.tickcount()) or 0
    if u235 and not u231.last then
        u231.pending_until = u236 + 32
    end
    if not u235 then
        u231.pending_until = nil
    end
    u231.last = u235
    if u231.pending_until then
        return u236 >= u231.pending_until
    end
    return u235
end

local function u237()
    local u227= u225[11]
    if not u227 or not u227[1] then
        return false
    end
    local u233, u234= pcall(ui.get, u227[1])
    return u233 and not not u234 or false
end

local function u238()
  local u239= entity.get_local_player()
  if not u239 or not entity.is_alive(u239) then
    return false
  end
  local u240= entity.get_player_weapon(u239)
  if not u240 then
    return false
  end
  local u241= entity.get_classname(u240)
  return u241 == "CKnife"
end




local function u242()
    if not u219 or type(u219) ~= 'table' or not u219.ui then
        return false
    end
    local u243= u219.ui.fakelag_defensive
    if not u243 then
        return false
    end
    local u233, u234= pcall(ui.get, u243)
    return u233 and not not u234 or false
end

local function u244()
    if not u219 or type(u219) ~= 'table' or not u219.ui then
        return false
    end
    local u243= u219.ui.fakelag_force
    if not u243 then
        return false
    end
    local u233, u234= pcall(ui.get, u243)
    return u233 and not not u234 or false
end

local function u245(u246)

    


    local u236= (globals and globals.tickcount and globals.tickcount()) or u218.tickcount() or 0
    u230 = u236
end




local function u247(u248)

    u248 = u248 or 20
    local u249= entity.get_local_player()
    if not u249 then return false end
    local u250= entity.get_prop(u249, "m_flSimulationTime")
    local u251= 1 / globals.tickinterval()
    if not u250 or u251 == 0 then return false end
    local u252= math.floor(u250 * u251 + 0.5)
    local u253= globals.tickcount()
    nigga = u253 >= u252 and u253 <= u252 + u248

    return u253 >= u252 and u253 <= u252 + u248

end







local function u254(u246)
    
    
    
    local u255= false
    local u256= u242()
    local u257= u232()
    local u258= u237()
    local u259= u238()
    local u260= u247()
    

    u255 = u256 and u257 and not u258 and not u259 
    u217.active = u255


    local u236= (globals and globals.tickcount and globals.tickcount()) or u218.tickcount() or 0
    local u261= false
    if u236 and (u230 == nil or u236 - u230 >= 64) then
        u261 = true
        u245(u246)
    end



    
    
    

    
    
    
    if u255 then
        local u262= u221.get() or 'global'
        if (not u229) or (u228.cond ~= u262) or (not u228.preset) then
            local u263, u264= u220.get_random_for_condition(u262)
            if u263 and u264 then
                u228.cond = u262
                u228.idx = u263
                u228.preset = u264
                u228.selected_tick = globals.tickcount()
            else
                u228.cond = u262
                u228.idx = nil
                u228.preset = nil
                u228.selected_tick = 0
            end
        end

        if not u261 then
            if u228.preset and type(u228.preset.apply) == 'function' then
                u228.preset.apply(u228, u246)
            end
        end
    else
        if u229 then
            u228.cond = nil
            u228.idx = nil
            u228.preset = nil
            u228.selected_tick = 0
        end
    end

    u229 = u255

end


u217.activate = u254
u217.reset = u245


u224.register('setup_command', function(u246)
    u254(u246)
end, { alive_only = true, require_login = true })


return u217]]
u743["require/features/aa/defensive_presets"] = [[local u220= require('require/aa/player_condition')
local u221= require('require/help/time')
local u222= require('require/abc/screen_logger')



local u223= {}
local u224= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },

}) do
    local u225= {ui.reference(item[1], item[2], item[3])}
    u223[i] = u225
    for _, ref in ipairs(u225) do
        u224[ref] = true
    end
end


local u226= {}

local function u227(u228,u229,u230) if u228 < u229 then return u229 end if u228 > u230 then return u230 end return u228 end

local function u231(u232,u233,u234)
    local u225= u223[u232]
    if not u225 or not u225[u233] then return false end
    pcall(ui.set, u225[u233], u234)
    return true
end



local u235, u236= pcall(require, "require/abc/menu_setup")



local function u237(u238)

    local u239, u236= pcall(require, "require/abc/menu_setup")
    if not u239 or not u236 or not u236.ui then return end
    local u240, u241= pcall(ui.get, u236.ui.fakelag_fakedef)

    
    if u241 then 
        u238.force_defensive = false
    else
        u238.force_defensive = true
    end

end

do
    local u242, u243= pcall(require, "require/abc/callbacks")

    ticks = ticks or {}
    ticks.tickbase_max = ticks.tickbase_max or nil
    ticks.tickbase_diff = ticks.tickbase_diff or nil
    ticks.current_cmd = ticks.current_cmd or nil

    ticks.runc = function(u238)
        if not u238 then return end
        ticks.current_cmd = u238.command_number
    end

    ticks.tickcalc = function(u238)
        if not u238 then return end
        if u238.command_number == ticks.current_cmd then
            ticks.current_cmd = nil
            local u244= entity.get_local_player()
            if not u244 then return end
            local u245= entity.get_prop(u244, "m_nTickBase")
            if u245 then
                if ticks.tickbase_max ~= nil then
                    ticks.tickbase_diff = u245 - ticks.tickbase_max
                end
                ticks.tickbase_max = math.max(u245, ticks.tickbase_max or 0)
            end
        end
    end

    if u242 and u243 and u243.callback then
        u243.callback('run_command', ticks.runc, { alive_only = true, require_login = true })
        u243.callback('predict_command', ticks.tickcalc, { alive_only = true, require_login = true })
    end
end

client.set_event_callback("level_init", function()
    ticks.tickbase_max = nil
    ticks.tickbase_diff = nil
end)


local function u246(u247)
    local u244= entity.get_local_player()
    if not u244 then return false end

    local u248= entity.get_prop(u244, 'm_nTickBase')
    if not u248 then return false end

    local u249= ticks and ticks.tickbase_max or 0

    if math.abs(u248 - u249) > 64 then
        u249 = 0
    end

    local u250= 0

    if u248 > u249 then
        u249 = u248
    elseif u249 > u248 then
        u250 = math.min(14, math.max(0, u249 - u248 - 1))
    end

    u247 = u247 or 7

    return u250 > u247
end




local u251= {



    stand = {

        [1] = {
            name = "jitter -90/90",
            apply = function(u252,u238)

                local u253= globals.tickcount()
                local u254= math.floor(u253 / 2) % 2

                local function u255()
                    local u253= globals.tickcount()

                    if not u252._next_change_at then
                        u252._next_change_at = u253 + math.random(24, 64)
                        u252._mode = math.random(1, 3)
                        u252._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        u252._spin_speed = math.random(45, 55)
                        u252._spin_angle = (u254 == 0) and -90 or 90
                    end

                    if u253 >= (u252._next_change_at or 0) then
                        u252._next_change_at = u253 + math.random(24, 64)
                        u252._mode = math.random(1, 3)
                        u252._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        u252._spin_speed = math.random(45, 55)
                        u252._spin_angle = (u254 == 0) and -90 or 90

                        if u252._mode == 2 then
                            u252._spin_until = u253 + math.random(12, 24)
                        elseif u252._mode == 3 then
                            local u256= math.ceil(360 / u252._spin_speed)
                            u252._spin_until = u253 + u256
                            u252._rest_until = u253 + u256 + math.random(24, 64)
                            u252._spin_done = false
                        else
                            u252._spin_until = nil
                            u252._rest_until = nil
                        end
                    end

                    if u252._mode == 1 then
                        local u257= (u254 == 0) and -120 or 120
                        local u258= 0
                        return u257, u258

                    elseif u252._mode == 2 then
                        if u252._spin_until and u253 <= u252._spin_until then
                            u252._spin_angle = (u252._spin_angle or ((u254 == 0) and -90 or 90)) + (u252._spin_dir * (u252._spin_speed or 50))
                            if u252._spin_angle > 180 then u252._spin_angle = u252._spin_angle - 360 end
                            if u252._spin_angle < -180 then u252._spin_angle = u252._spin_angle + 360 end
                            return u252._spin_angle, 0
                        end
                        local u257= (u254 == 0) and -90 or 90
                        return u257, 0
                    else
                        if u252._spin_until and u253 <= u252._spin_until then
                            u252._spin_angle = (u252._spin_angle or ((u254 == 0) and -90 or 90)) + (u252._spin_dir * (u252._spin_speed or 50))
                            if u252._spin_angle > 180 then u252._spin_angle = u252._spin_angle - 360 end
                            if u252._spin_angle < -180 then u252._spin_angle = u252._spin_angle + 360 end
                            return u252._spin_angle, -89
                        end

                        if u252._rest_until and u253 <= u252._rest_until then
                            return nil, nil
                        end

                        local u257= (u254 == 0) and -90 or 90
                        return u257, 0
                    end
                end

                local u257, u258= u255()

                if u257 ~= nil and u238.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (u246(6))) then
                    u237(u238)
                    u231(4, 2, u257)
                    u231(2, 1, 'Custom')
                    u231(2, 2, u258)
                    u231(5, 1, 'off')
                    u231(6, 1, 'off')
                end

            end
        }
    },

    move = {

        [1] = {
            name = "jitter -90/90",
            apply = function(u252,u238)


                local u253= globals.tickcount()
                local u254= math.floor(u253 / 2) % 2
                local u257= (u254 == 0) and -135 or 135
                u252._side = u257
                u252._pitch = -55


                if u238.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (u246(3))) then
                    u237(u238)
                    u231(4, 2, u252._side)
                    u231(2, 1, 'Custom')
                    u231(2, 2, u252._pitch)
                    u231(5, 1, 'off')
                    u231(6, 1, 'off')
                    u231(3, 1, 'at targets')
                end
            end
        }
    },

    walk = {

        [1] = {
            name = "jitter -90/90",
            apply = function(u252,u238)

                local u253= globals.tickcount()
                local u254= math.floor(u253 / 2) % 2
                local u259= (u254 == 0) and -130 or 130

                
                local u257, u258
                if (u253 % 8) == 0 then
                    u257 = 0
                    u258 = 89
                else
                    u257 = u259
                    u258 = -65
                end

                u252._side = u257
                u252._pitch = u258





                if u238.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (u246(3))) then
                    u237(u238)
                    u231(4, 2, u252._side)
                    u231(2, 1, 'Custom')
                    u231(2, 2, u252._pitch)
                    u231(5, 1, 'off')
                    u231(6, 1, 'off')
                    u231(3, 1, 'at targets')
                end
            end
        },
    },

    duck = {
        
        [1] = {
            name = "jitter -90/90",
            apply = function(u252,u238)

                local u253= globals.tickcount()
                local u254= math.floor(u253 / 2) % 2

                local function u255()
                    local u253= globals.tickcount()

                    
                    if not u252._next_change_at then
                        u252._next_change_at = u253 + math.random(24, 64)
                        u252._mode = 1 
                    end

                    if u253 >= (u252._next_change_at or 0) then
                        u252._next_change_at = u253 + math.random(24, 64)
                        u252._mode = math.random(1, 5)
                        
                        u252._spin_dir = nil
                        u252._spin_speed = nil
                        u252._spin_angle = nil
                        u252._jitter_yaw = nil
                        u252._jitter_pitch = nil
                        u252._rand_yaw = nil
                        u252._rand_pitch = nil
                        u252._rand_until = nil
                        u252._phase_tick = u253
                    end

                    
                    
                    
                    
                    
                    

                    if u252._mode == 1 then
                        if not u252._spin_dir then
                            u252._spin_dir = (math.random(0,1) == 0) and -1 or 1
                            u252._spin_speed = 35
                            u252._spin_angle = (u254 == 0) and -90 or 90
                        end

                        if u253 % 10 == 0 then
                            return nil, nil
                        end

                        u252._spin_angle = (u252._spin_angle or ((u254 == 0) and -90 or 90)) + (u252._spin_dir * (u252._spin_speed or 45))
                        if u252._spin_angle > 180 then u252._spin_angle = u252._spin_angle - 360 end
                        if u252._spin_angle < -180 then u252._spin_angle = u252._spin_angle + 360 end
                        return u252._spin_angle, 0

                    elseif u252._mode == 2 then
                        local u260= math.random(-100, 100)
                        return u260, -50

                    elseif u252._mode == 3 then
                        local u260= math.random(-180, 180)
                        local u258= math.random(-89, 89)
                        return u260, u258

                    elseif u252._mode == 4 then
                        if not u252._rand_until then
                            u252._rand_yaw = math.random(-180, 180)
                            u252._rand_pitch = math.random(-89, 89)
                            u252._rand_until = u253 + 2
                            u252._rand_rest = u253 + 3
                        end
                        if u253 <= u252._rand_until then
                            return u252._rand_yaw, u252._rand_pitch
                        elseif u253 <= u252._rand_rest then
                            return nil, nil
                        else
                            u252._rand_until = nil
                            u252._rand_rest = nil
                            return nil, nil
                        end

                    else
                        
                        if not u252._ramp then
                            u252._ramp = {}
                            u252._ramp.yaw = math.random(-180, 180)
                            u252._ramp.pitch = 89
                            u252._ramp.dir = -1 
                        end

                        
                        if not u252._ramp.step then u252._ramp.step = 30 end
                        if u252._ramp.pitch == 89 then
                            
                            u252._ramp.pitch = u252._ramp.pitch + (u252._ramp.dir * u252._ramp.step)
                            if u252._ramp.pitch < -89 then u252._ramp.pitch = -89 end
                            return u252._ramp.yaw, 89
                        else
                            
                            local u261= u252._ramp.pitch
                            u252._ramp.pitch = u252._ramp.pitch + (u252._ramp.dir * u252._ramp.step)
                            if u252._ramp.pitch <= -89 then
                                
                                u252._ramp = nil
                            end
                            return u252._ramp and u252._ramp.yaw or math.random(-180,180), u261
                        end
                    end
                end

                local u257, u258= u255()

                if u257 ~= nil and u238.chokedcommands == 1 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (u246(8))) then
                    u237(u238)
                    u231(4, 2, u257)
                    u231(2, 1, 'Custom')
                    u231(2, 2, u258)
                    u231(5, 1, 'off')
                    u231(6, 1, 'off')
                    u231(3, 1, 'at targets')
                end
            end
        }
    },

    ["duck+"] = {
        
        [1] = {

            name = "jitter -90/90",
            apply = function(u252,u238)


                local u253= globals.tickcount()
                local u254= math.floor(u253 / 2) % 2
                local u257= (u254 == 0) and -90 or 90
                u252._side = 180
                u252._pitch = -76


                if u238.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (u246(1))) then
                    u237(u238)
                    u231(4, 2, u252._side)
                    u231(2, 1, 'Custom')
                    u231(2, 2, u252._pitch)
                    u231(5, 1, 'off')
                    u231(6, 1, 'off')
                    u231(3, 1, 'at targets')
                end

            end
        }
    },

    ['jump'] = {
        [1] = {
            name = "jitter -90/90",
            apply = function(u252,u238)

                local u253= globals.tickcount()
                
                if not u252._spin_choice_at then
                    u252._spin_choice_at = u253 + 64
                    u252._spin_dir = (math.random(0,1) == 0) and -1 or 1
                    u252._spin_angle = 0
                end

                if u253 >= (u252._spin_choice_at or 0) then
                    u252._spin_choice_at = u253 + 64
                    u252._spin_dir = (math.random(0,1) == 0) and -1 or 1
                end

                
                if (u253 % 10) == 0 then
                    return
                end

                
                u252._spin_angle = (u252._spin_angle or 0) + (u252._spin_dir * 35)
                if u252._spin_angle > 180 then u252._spin_angle = u252._spin_angle - 360 end
                if u252._spin_angle < -180 then u252._spin_angle = u252._spin_angle + 360 end

                local u257= u252._spin_angle
                u252._side = u257
                u252._pitch = 0

                if u238.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (u246(8))) then
                    u237(u238)
                    u231(4, 2, u252._side)
                    u231(2, 1, 'Custom')
                    u231(2, 2, u252._pitch)
                    u231(5, 1, 'off')
                    u231(6, 1, 'off')
                    u231(3, 1, 'at targets')
                end
            end
        },

    },

    ['jump+'] = {
        [0] = {
            name = "jitter -90/90",
            apply = function(u252,u238)

                local u253= globals.tickcount()
                local u254= math.floor(u253 / 2) % 2
                local u257= (u254 == 0) and -90 or 90
                u252._side = u257
                u252._pitch = 0

                if u238.chokedcommands > 0 and (not (u246(6))) then
                    u237(u238)
                    u231(4, 2, u252._side)
                    u231(2, 1, 'Custom')
                    u231(2, 2, u252._pitch)
                    u231(5, 1, 'off')
                    u231(6, 1, 'off')
                    u231(3, 1, 'at targets')
                end
            end
        },
    },

    
    global = {
        [0] = {
            name = "back",
            apply = function(u252,u238)

            end
        }
    }


}





local function u262(u263)
    local u264= {}
    for k, _ in pairs(u263) do
        if type(k) == 'number' then table.insert(u264, k) end
    end
    table.sort(u264)
    return u264
end

function M.get_presets_for_condition(u265)
    u265 = u265 or u220.get() or 'global'
    return u251[u265] or u251['global'] or {}
end

function M.get_preset_by_index(u265,u266)
    local u267= u226.get_presets_for_condition(u265)
    return u267[u266]
end

function M.get_random_for_condition(u265)
    local u267= u226.get_presets_for_condition(u265)
    local u264= u262(u267)
    if #u264 == 0 then return nil, nil end
    local u268= u264[math.random(1, #u264)]
    return u268, u267[u268]
end

function M.get_random_for_current_condition()
    return u226.get_random_for_condition(u220.get())
end


function M.get_next_for_condition(u265,u269)
    local u267= u226.get_presets_for_condition(u265)
    local u264= u262(u267)
    if #u264 == 0 then return nil, nil end
    
    local u270= 1
    for i, k in ipairs(u264) do
        if k == u269 then u270 = i; break end
    end
    local u271= (u270 % #u264) + 1
    local u272= u264[u271]
    return u272, u267[u272]
end


function M.available_conditions()
    local u273= {}
    for k, _ in pairs(u251) do table.insert(u273, k) end
    table.sort(u273)
    return u273
end

u226._presets = u251

return u226]]
u743["require/features/misc/analyze"] = [[local function u223(u224)
	while u224 > 180 do u224 = u224 - 360 end
	while u224 < -180 do u224 = u224 + 360 end
	return u224
end

local u225= _G.player_labels or {}
_G.player_labels = u225

local u226= function(ent)
	return (_G.player_history and _G.player_history[ent]) or nil
end

local u227, u228= pcall(require, "require/features/misc/resolver_dispatcher")
local u229= require('require/abc/callbacks')

local function u230(u231)
	
	local u232= u226(u231)
	if not u232 or #u232 < 2 then
		u225[u231] = nil
		return
	end

	
	
	local u233, u234= pcall(function() return (globals and globals.curtime and globals.curtime()) or nil end)
	if u232[1] and u232[1].last_shot_time and u233 and u234 then
		local u235= u234 - u232[1].last_shot_time
		if u235 >= 0 and u235 <= 0.25 then
			u225[u231] = "ON SHOT"
			return
		end
	end

	
	local u236= {}
	for i = 1, #u232 - 1 do
		local u237= u232[i] and u232[i].yaw
		local u238= u232[i+1] and u232[i+1].yaw
		if u237 ~= nil and u238 ~= nil then
			u236[#u236 + 1] = u223(u237 - u238)
		end
	end

	if #u236 == 0 then
		u225[u231] = nil
		return
	end

	
	local u239, u240= 0, 0
	local u241, u242= -1e9, 1e9
	for _, v in ipairs(u236) do
		u239 = u239 + v
		u240 = u240 + math.abs(v)
		if v > u241 then u241 = v end
		if v < u242 then u242 = v end
	end
	local u243= u239 / #u236
	local u244= u240 / #u236

	local u245= 0
	for _, v in ipairs(u236) do
		u245 = u245 + (v - u243) ^ 2
	end
	local u246= math.sqrt(u245 / #u236)

	local u247= 0
	for i = 2, #u236 do
		if (u236[i] > 0 and u236[i-1] < 0) or (u236[i] < 0 and u236[i-1] > 0) then
			u247 = u247 + 1
		end
	end

	
	local u248= u236[1]
	local u249= u241 - u242

	
	local u250= {}
	for i, v in ipairs(u236) do u250[i] = v end
	table.sort(u250)
	local u251= u250[math.ceil(#u250 / 2)]

	
	local u252= {
		deltas = u236,
		mean = u243,
		meanabs = u244,
		std = u246,
		sign_changes = u247,
		max_delta = u241,
		min_delta = u242,
		total_range = u249,
		median = u251,
		last_delta = u248,
		samples = #u236,
		last_yaw = u232[1] and u232[1].yaw,
		oldest_yaw = u232[#u232] and u232[#u232].yaw,
		hist = u232
	}

	
	do
		local u253, u254= 0, 0
		local u255, u256, u257
		for i=1,math.min(#u232, 20) do
			local u258= u232[i]
			if u258 then
				if u258.moveSpeedAnim then u253 = u253 + (u258.moveSpeedAnim or 0); u254 = u254 + 1 end
				if u258.speed2d then u253 = u253 + (u258.speed2d or 0); u254 = u254 + 1 end
				if not u255 and u258.feetYaw then u255 = u258.feetYaw end
				if not u256 and u258.goalFeetYaw then u256 = u258.goalFeetYaw end
				if not u257 and u258.moveSpeedAnim then u257 = u258.moveSpeedAnim end
			end
		end
		local u259= (u254 > 0) and (u253 / u254) or 0
		u252.movement = u259 >= 1.2
		u252.avg_speed = u259
		u252.feet_yaw = u255
		u252.goal_feet_yaw = u256
		u252.move_anim = u257
	end

	local u260= nil
	if detect_static and detect_static(u252, u231) then u260 = "STATIC" end
	if detect_spin and detect_spin(u252, u231) then u260 = "SPIN" end
	if detect_jitter_minus and detect_jitter_minus(u252, u231) then u260 = "JITTER-" end
	if detect_jitter and detect_jitter(u252, u231) then u260 = "JITTER" end
	if detect_jitter_plus and detect_jitter_plus(u252, u231) then u260 = "JITTER+" end
	if detect_sway and detect_sway(u252, u231) then u260 = "SWAY" end
	if detect_skitter and detect_skitter(u252, u231) then u260 = "SKITTER" end
	if detect_defensive and detect_defensive(u252, u231) then u260 = "DEFENSIVE" end
	if detect_random and detect_random(u252, u231) then u260 = "RANDOM" end
	if detect_delayed and detect_delayed(u252, u231) then u260 = "DELAYED" end

	if not u260 then u260 = "?" end
	pcall(function()
		local u261= nil
		pcall(function() u261 = entity.get_player_name(u231) end)
		local u262= "nil"
		if u232 and u232[1] and u232[1].last_shot_time then
			u262 = string.format("%.3f", u232[1].last_shot_time)
		end
		local u263= u252.feet_yaw and string.format("%.2f", u252.feet_yaw) or "nil"
		local u264= u252.goal_feet_yaw and string.format("%.2f", u252.goal_feet_yaw) or "nil"

	end)

	u225[u231] = u260

	
	if u227 and u228 and type(u228.process_entity) == "function" then
		pcall(function() u228.process_entity(u231, u260, u252) end)
	end
end



function u265(u252,u231)
	local u244= u252.meanabs or 0
	local u246= u252.std or 0
	local u266= u252.samples or 0
	local u236= u252.deltas or {}
	local u267= 1.0
	local u268= 1.5
	local u269= 2.5

	if u244 <= u267 and u246 <= u268 then
		return true
	end

	local u270= 0
	local u271= nil
	for i, d in ipairs(u236) do
		if math.abs(d) >= u269 then
			u270 = u270 + 1
			if not u271 then
				u271 = i
			end
		end
	end

	if u270 == 0 then
		return true
	end

	if u270 == 1 and u271 and u271 > 20 then
		return true
	end

	return false
end

function u272(u252,u231)
	local u244= u252.meanabs or 0
	local u246= u252.std or 0
	local u266= u252.samples or 0
	local u247= u252.sign_changes or 0
	local u273= math.max(math.abs(u252.max_delta or 0), math.abs(u252.min_delta or 0))

	local u274= false

	if u266 >= 4 then
		local u275= 5.0
		local u276= 12.0
		local u277= 22.0
		local u278= 40.0

		if u244 >= u275 and u244 < u276 and u246 <= u277 and u273 <= u278 then
			u274 = true
		end
	end

	return u274
end

function u279(u252,u231)
	local u244= u252.meanabs or 0
	local u246= u252.std or 0
	local u266= u252.samples or 0
	local u247= u252.sign_changes or 0
	local u273= math.max(math.abs(u252.max_delta or 0), math.abs(u252.min_delta or 0))

	local u274= false

	if u266 >= 4 then
		local u275= (u252.movement and 8.0) or 6.0
		local u276= 24.0
		local u280= 34.0
		local u281= 28.0
		local u282= 100.0

		if u244 >= u275 and u244 < u276 and u246 <= u280 then
			if u247 >= 2 or u273 <= u282 or (u244 < 12.0 and u246 <= u281) then
				u274 = true
			end
		end
	end

	return u274
end

function u283(u252,u231)
	local u244= u252.meanabs or 0
	local u246= u252.std or 0
	local u266= u252.samples or 0
	local u247= u252.sign_changes or 0
	local u273= math.max(math.abs(u252.max_delta or 0), math.abs(u252.min_delta or 0))

	local u274= false

	if u266 >= 4 then
		local u275= 18.0
		local u284= 22.0
		local u285= 26.0
		local u286= 70.0

		if u244 >= u275 and (u246 >= u285 or u273 >= u286) then
			if u244 >= u284 or u273 >= u286 or u246 >= (u285 + 8) then
				u274 = true
			end
		end
	end
	
	return u274
end

function u287(u252,u231)
	local u244= u252.meanabs or 0
	local u246= u252.std or 0
	local u266= u252.samples or 0
	local u247= u252.sign_changes or 0
	local u249= u252.total_range or 0
	local u273= math.max(math.abs(u252.max_delta or 0), math.abs(u252.min_delta or 0))

	local u274= false

	if u266 >= 6 then
		local u275= 2.5
		local u276= 15.0
		local u288= 0.08
		local u289= 30.0
		local u290= 180.0

		if u244 >= u275 and u244 < u276 and u246 <= 40.0 and u249 >= u289 and u249 <= u290 then
			if (u247 / math.max(1, u266)) >= u288 then
				u274 = true
			end
		end
	end

	return u274
end

function u291(u252,u231)
	local u244= u252.meanabs or 0
	local u246= u252.std or 0
	local u266= u252.samples or 0
	local u247= u252.sign_changes or 0
	local u249= u252.total_range or 0
	local u248= u252.last_delta or 0
	local u273= math.max(math.abs(u252.max_delta or 0), math.abs(u252.min_delta or 0))

	local u236= u252.deltas or {}

	local u292, u293, u294= 0, 0, 0
	for _, v in ipairs(u236) do
		if v > 0.5 then u292 = u292 + 1
		elseif v < -0.5 then u293 = u293 + 1
		else u294 = u294 + 1 end
	end

	local u295= math.max(u292, u293) / math.max(1, u266)
	local u296= math.abs(u292 - u293) / math.max(1, (u292 + u293))

	local u297, u298, u299= 0, 0, 0
	for _, v in ipairs(u236) do
		local u258= 0
		if v > 0.5 then u258 = 1 elseif v < -0.5 then u258 = -1 end
		if u258 ~= 0 and u258 == u299 then
			u298 = u298 + 1
		else
			u298 = (u258 ~= 0) and 1 or 0
			u299 = u258
		end
		if u298 > u297 then u297 = u298 end
	end

	local u300= u297 / math.max(1, u266)

	local u274= false

	if u266 >= 6 then
		if u249 >= 300 and (u295 >= 0.60 or u296 >= 0.60) then
			u274 = true
		end

		if not u274 and u249 >= 140 and u244 >= 9 and (u295 >= 0.75 or u296 >= 0.70 or u247 <= 1) then
			u274 = true
		end

		if not u274 and u300 >= 0.50 and u244 >= 8 and u249 >= 120 then
			u274 = true
		end

		if not u274 and u273 >= 120 and (u295 >= 0.60 or u296 >= 0.60) then
			u274 = true
		end
	end
	local u301= nil
	if not u274 and u266 > 0 then
		local u302= math.min(u249, 360) / 360.0
		local u303= math.min(u244, 60) / 60.0
		local u304= (u247 or 0) / math.max(1, u266)
		u301 = u302 * 0.45 + u303 * 0.35 + u296 * 0.15 + u295 * 0.05 - u304 * 0.20
		if u301 >= 0.42 and u249 >= 200 and u244 >= 6 then
			u274 = true
		end
		u252.spin_score = u301
	end

	return u274
end

function u305(u252,u231)
	
	return false
end

function u306(u252,u231)
	
	return false
end

function u307(u252,u231)
	local u244= u252.meanabs or 0
	local u246= u252.std or 0
	local u266= u252.samples or 0
	local u247= u252.sign_changes or 0
	local u249= u252.total_range or 0
	local u273= math.max(math.abs(u252.max_delta or 0), math.abs(u252.min_delta or 0))
	local u236= u252.deltas or {}

	if u266 < 6 then return false end

	local u308= u247 / math.max(1, u266)
	local u309= u252.movement
	if u308 >= 0.45 and u246 >= (u309 and 12.0 or 18.0) and u244 >= (u309 and 4.0 or 6.0) then
		return true
	end

	if u273 >= 120 and u308 >= 0.30 and u246 >= 12.0 then
		return true
	end

	if u249 >= 60 and u249 <= 300 and u308 >= 0.40 and u246 >= 14.0 and u244 >= 4.0 then
		return true
	end

	if u246 >= 30.0 and u308 >= 0.25 and u244 >= 5.0 then
		return true
	end

	return false
end

function u310(u252,u231)
	local u244= u252.meanabs or 0
	local u246= u252.std or 0
	local u266= u252.samples or 0
	local u247= u252.sign_changes or 0
	local u249= u252.total_range or 0
	local u273= math.max(math.abs(u252.max_delta or 0), math.abs(u252.min_delta or 0))

	if u266 >= 6 then
		local u275= 2.5
		local u276= 24.0
		local u311= 9.0
		local u312= 40.0
		local u289= 10.0

		if u244 >= u275 and u244 < u276 and u246 >= u311 and u246 <= u312 and u249 >= u289 then
			local u313= (u247 or 0) / math.max(1, u266)
			if u247 <= 3 or u313 <= 0.12 or u273 >= 40 then
				return true
			end
		end
	end

	return false
end

local function u314()
	local u315, u316= pcall(entity.get_players, true)
	if not u315 or type(u316) ~= "table" then return end
	for _, u231 in ipairs(u316) do
		if entity.is_alive(u231) and not entity.is_dormant(u231) then
			pcall(u230, u231)
		else
			u225[u231] = nil
		end
	end
end

local function u317(u231)
	if not entity.is_alive(entity.get_local_player()) then return end
	if not u231 or u231 == 0 then return end

	local u318= u225[u231]


	if u318 then
		return true, u318
	end

	local u232= u226(u231)
	if u232 and u232[1] and u232[1].yaw ~= nil then
		return true, tostring(u232[1].yaw)
	end
end

client.register_esp_flag("Resolver", 255, 255, 255, u317)

u229.register('net_update_end', function()
	local u319, u320= pcall(require, "require/abc/menu_setup")
	if u319 and u320 and u320.ui and u320.ui.misc_resolver then
		local u321, u322= pcall(ui.get, u320.ui.misc_resolver)
		if u321 and u322 then
			pcall(u314)
		end
	end
end, { alive_only = true, require_login = true })
]]
u743["require/features/misc/backstab_assist"] = [[local u226= require("require/abc/menu_setup")
local u227= require('require/abc/callbacks')
local u228= require('require/help/enemies')

local u229= ui.reference("AA", "Anti-aimbot angles", "Pitch")
local u230= ui.reference("AA", "Anti-aimbot angles", "Yaw base")
local u231, u232= ui.reference("AA", "Anti-aimbot angles", "Yaw")
local u233= nil

local function u234()
	if u233 then return end
	u233 = {}
	if u229 then u233.pitch = ui.get(u229) end
	if u230 then u233.yaw_base = ui.get(u230) end
	if u231 then u233.yaw = ui.get(u231) end
	if u232 then u233.yaw_slider = ui.get(u232) end
end

local function u235()
	if not u233 then return end
	if u229 and u233.pitch ~= nil then pcall(ui.set, u229, u233.pitch) end
	if u230 and u233.yaw_base ~= nil then pcall(ui.set, u230, u233.yaw_base) end
	if u231 and u233.yaw ~= nil then pcall(ui.set, u231, u233.yaw) end
	if u232 and u233.yaw_slider ~= nil then pcall(ui.set, u232, u233.yaw_slider) end
	u233 = nil
end

local function u236()
	u234()
	if u229 then pcall(ui.set, u229, "Off") end
	if u230 then pcall(ui.set, u230, "At targets") end
	if u231 then pcall(ui.set, u231, "180") end
	if u232 then pcall(ui.set, u232, 180) end
end

local function u237(u238)
	local u239= entity.get_local_player()
	if not u239 or not entity.is_alive(u239) then return false end
	local u240= u228.list() or {}
	for _, enemy in ipairs(u240) do
		if u228.is_alive(enemy) and not u228.is_dormant(enemy) and u228.has_knife(enemy) then
			local u241= u228.distance(enemy)
			if u241 and u241 <= u238 then
				return true
			end
		end
	end
	return false
end

local function u242(u243)
	if not (u226 and u226.ui and u226.ui.misc_backstab) then u235() return end
	local u244, u245= pcall(ui.get, u226.ui.misc_backstab)
	if not u244 or not u245 then u235() return end
	local u238= 200
	if u237(u238) then
		u236()
	else
		u235()
	end
end

if u226 and u226.ui and u226.ui.misc_backstab then
	ui.set_callback(u226.ui.misc_backstab, function()
		local u244, u246= pcall(ui.get, u226.ui.misc_backstab)
		if not u244 or not u246 then u235() end
	end)
end

u227.register("setup_command", u242, { alive_only = true, require_login = true })
u227.register("shutdown", u235, { alive_only = true, require_login = true })]]
u743["require/features/misc/collect"] = [=[
local M = {}


do
    local ok, ffi = pcall(require, "ffi")
    if ok and ffi and client and client.create_interface then
        local status, entity_list_ptr = pcall(function()
            return client.create_interface("client.dll", "VClientEntityList003")
        end)

        if status and entity_list_ptr then
            local pointer_type = ffi.typeof("void***")
            local entity_list = ffi.cast(pointer_type, entity_list_ptr)
            local ok_cast, get_client_entity = pcall(function()
                return ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
            end)

            if ok_cast and get_client_entity then
                
                local animstate_offset = 0x9960

                
                
                
                ffi.cdef[[
                struct animation_layer_t {
                    char  pad_0000[20];
                    uint32_t m_nOrder;
                    uint32_t m_nSequence;
                    float m_flPrevCycle;
                    float m_flWeight;
                    float m_flWeightDeltaRate;
                    float m_flPlaybackRate;
                    float m_flCycle;
                    void *m_pOwner;
                    char  pad_0038[4];
                };
                ]]

                
                
                

                ffi.cdef[[
                struct c_animstate_min {
                    char pad0[3];
                    char m_bForceWeaponUpdate;
                    char pad1[91];
                    void* m_pBaseEntity;
                    void* m_pActiveWeapon;
                    void* m_pLastActiveWeapon;
                    float m_flLastClientSideAnimationUpdateTime;
                    int m_iLastClientSideAnimationUpdateFramecount;
                    float m_flAnimUpdateDelta;
                    float m_flEyeYaw;
                    float m_flPitch;
                    float m_flGoalFeetYaw;
                    float m_flCurrentFeetYaw;
                    float m_flCurrentTorsoYaw;
                    float m_flUnknownVelocityLean;
                    float m_flLeanAmount;
                    char pad2[4];
                    float m_flFeetCycle;
                    float m_flFeetYawRate;
                    char pad3[4];
                    float m_fDuckAmount;
                    float m_fLandingDuckAdditiveSomething;
                    char pad4[4];
                    float m_vOriginX;
                    float m_vOriginY;
                    float m_vOriginZ;
                    float m_vLastOriginX;
                    float m_vLastOriginY;
                    float m_vLastOriginZ;
                    float m_vVelocityX;
                    float m_vVelocityY;
                    char pad5[4];
                    float m_flUnknownFloat1;
                    char pad6[8];
                    float m_flUnknownFloat2;
                    float m_flUnknownFloat3;
                    float m_flUnknown;
                    float m_flSpeed2D;
                    float m_flUpVelocity;
                    float m_flSpeedNormalized;
                    float m_flFeetSpeedForwardsOrSideWays;
                    float m_flFeetSpeedUnknownForwardOrSideways;
                    float m_flTimeSinceStartedMoving;
                    float m_flTimeSinceStoppedMoving;
                    bool m_bOnGround;
                    bool m_bInHitGroundAnimation;
                    char pad7[2];
                    float m_flTimeSinceInAir;
                    float m_flLastOriginZ;
                    float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
                    float m_flStopToFullRunningFraction;
                    float m_flMagicFraction;
                    char pad8[60];
                    float m_flWorldForce;
                    char pad9[462];
                    float m_flMaxYaw;
                };
                ]]

                
                M._get_animstate = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    
                    
                    local base = ffi.cast("char*", ent_ptr)
                    local anim_ptr_ptr = ffi.cast("struct c_animstate_min**", base + animstate_offset)
                    if anim_ptr_ptr == nil or anim_ptr_ptr == ffi.NULL then return nil end
                    local anim_ptr = anim_ptr_ptr[0]
                    if anim_ptr == nil or anim_ptr == ffi.NULL then return nil end
                    return anim_ptr
                end
                
                M._get_entity_ptr = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    return ent_ptr
                end
            end
        end
    end
end



function M.get_sim_time(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flSimulationTime") end)
    if ok then return val end
    return nil
end


function M.get_enemies_simtimes()
    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        out[ent] = M.get_sim_time(ent)
    end
    return out
end


function M.get_velocity_3d(ent)
    local ok, vals = pcall(function() return { entity.get_prop(ent, "m_vecVelocity") } end)
    if not ok or type(vals) ~= "table" then return nil end
    if #vals >= 3 then
        return { vals[1], vals[2], vals[3] }
    end
    return nil
end


function M.get_speed_2d(ent)
    local v = M.get_velocity_3d(ent)
    if not v then return nil end
    local x, y = v[1] or 0, v[2] or 0
    return math.sqrt(x * x + y * y)
end




function M.get_origin(ent)
    local ok, x, y, z = pcall(function() return entity.get_prop(ent, "m_vecOrigin") end)
    if ok and x then
        
        if type(x) == "table" then
            return x[1], x[2], x[3]
        elseif y and z then
            return x, y, z
        end
    end
    return nil
end


function M.get_view_offset(ent)
    local tries = { "m_vecViewOffset[0]", "m_vecViewOffset" }
    for _, prop in ipairs(tries) do
        local ok, v1, v2, v3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and v1 then
            if type(v1) == "table" then
                return v1[1], v1[2], v1[3]
            elseif v2 and v3 then
                return v1, v2, v3
            end
        end
    end
    return nil
end


function M.get_eye_pos(ent)
    local ox, oy, oz = M.get_origin(ent)
    local vx, vy, vz = M.get_view_offset(ent)
    if ox and vx then
        return ox + vx, oy + vy, oz + vz
    end
    return nil
end


function M.get_eye_angles(ent)
    local tries = { "m_angEyeAngles[0]", "m_angEyeAngles", "m_angRotation", "m_angNetworkAngles" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return nil
end


function M.get_abs_angles(ent)
    local tries = { "m_angAbsRotation", "m_angAbsAngles", "m_angAbsOrigin" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return M.get_eye_angles(ent)
end


function M.get_lower_body_yaw(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flLowerBodyYawTarget") end)
    if ok and val then return val end
    return nil
end


function M.get_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flCurrentFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    
    return M.get_lower_body_yaw(ent)
end

function M.get_goal_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flGoalFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    return M.get_feet_yaw(ent)
end


function M.get_speed(ent)
    
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flVelocityModifier") end)
    if ok and val then return val end
    
    local v = M.get_velocity_3d(ent)
    if v then
        return math.sqrt((v[1] or 0) * (v[1] or 0) + (v[2] or 0) * (v[2] or 0) + (v[3] or 0) * (v[3] or 0))
    end
    return nil
end

function M.get_move_speed_anim(ent)
    
    
    
    
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local try_fields = { "m_flFeetSpeedForwardsOrSideWays", "m_flSpeed2D", "m_flSpeedNormalized", "m_flFeetSpeedUnknownForwardOrSideways" }
            for _, f in ipairs(try_fields) do
                local okf, val = pcall(function() return tonumber(anim[f]) end)
                if okf and val and val ~= 0 then
                    return val
                end
            end
        end
    end

    
    local ok_nv, nv = pcall(function() return entity.get_prop(ent, "m_flMaxspeed") end)
    if ok_nv and nv then return nv end

    
    return M.get_speed_2d(ent)
end


function M.get_flags(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_fFlags") end)
    if ok and val then return val end
    ok, val = pcall(function() return entity.get_prop(ent, "m_iFlags") end)
    if ok and val then return val end
    return nil
end



function M.read_animstate(ent)
    if not M._get_animstate then return nil end
    local ok, anim = pcall(function() return M._get_animstate(ent) end)
    if not ok or not anim then return nil end
    local out = {}
    pcall(function()
        out.m_flEyeYaw = tonumber(anim.m_flEyeYaw)
        out.m_flPitch = tonumber(anim.m_flPitch)
        out.m_flGoalFeetYaw = tonumber(anim.m_flGoalFeetYaw)
        out.m_flCurrentFeetYaw = tonumber(anim.m_flCurrentFeetYaw)
        out.m_flCurrentTorsoYaw = tonumber(anim.m_flCurrentTorsoYaw)
        out.m_flUnknownVelocityLean = tonumber(anim.m_flUnknownVelocityLean)
        out.m_flLeanAmount = tonumber(anim.m_flLeanAmount)
        out.m_flFeetCycle = tonumber(anim.m_flFeetCycle)
        out.m_flFeetYawRate = tonumber(anim.m_flFeetYawRate)
        out.m_fDuckAmount = tonumber(anim.m_fDuckAmount)
        out.m_fLandingDuckAdditiveSomething = tonumber(anim.m_fLandingDuckAdditiveSomething)
        out.m_vOrigin = { tonumber(anim.m_vOriginX), tonumber(anim.m_vOriginY), tonumber(anim.m_vOriginZ) }
        out.m_vLastOrigin = { tonumber(anim.m_vLastOriginX), tonumber(anim.m_vLastOriginY), tonumber(anim.m_vLastOriginZ) }
        out.m_vVelocity = { tonumber(anim.m_vVelocityX), tonumber(anim.m_vVelocityY) }
        out.m_flUnknownFloat1 = tonumber(anim.m_flUnknownFloat1)
        out.m_flUnknownFloat2 = tonumber(anim.m_flUnknownFloat2)
        out.m_flUnknownFloat3 = tonumber(anim.m_flUnknownFloat3)
        out.m_flUnknown = tonumber(anim.m_flUnknown)
        out.m_flSpeed2D = tonumber(anim.m_flSpeed2D)
        out.m_flUpVelocity = tonumber(anim.m_flUpVelocity)
        out.m_flSpeedNormalized = tonumber(anim.m_flSpeedNormalized)
        out.m_flFeetSpeedForwardsOrSideWays = tonumber(anim.m_flFeetSpeedForwardsOrSideWays)
        out.m_flFeetSpeedUnknownForwardOrSideways = tonumber(anim.m_flFeetSpeedUnknownForwardOrSideways)
        out.m_flTimeSinceStartedMoving = tonumber(anim.m_flTimeSinceStartedMoving)
        out.m_flTimeSinceStoppedMoving = tonumber(anim.m_flTimeSinceStoppedMoving)
        out.m_bOnGround = (anim.m_bOnGround ~= 0)
        out.m_bInHitGroundAnimation = (anim.m_bInHitGroundAnimation ~= 0)
        out.m_flTimeSinceInAir = tonumber(anim.m_flTimeSinceInAir)
        out.m_flLastOriginZ = tonumber(anim.m_flLastOriginZ)
        out.m_flHeadHeightOrOffsetFromHittingGroundAnimation = tonumber(anim.m_flHeadHeightOrOffsetFromHittingGroundAnimation)
        out.m_flStopToFullRunningFraction = tonumber(anim.m_flStopToFullRunningFraction)
        out.m_flMagicFraction = tonumber(anim.m_flMagicFraction)
        out.m_flWorldForce = tonumber(anim.m_flWorldForce)
        out.m_flMaxYaw = tonumber(anim.m_flMaxYaw)
    end)
    return out
end



function M.read_anim_layers(ent)
    if not M._get_entity_ptr then return nil end
    local ok_ent, ent_ptr = pcall(function() return M._get_entity_ptr(ent) end)
    if not ok_ent or not ent_ptr then return nil end
    local ok, res = pcall(function()
        local ffi = require("ffi")
        local base = ffi.cast("char*", ent_ptr)
        local layers_ptr = ffi.cast("struct animation_layer_t**", base + 0x2990)
        if layers_ptr == nil or layers_ptr == ffi.NULL then return nil end
        local owner = layers_ptr[0]
        if owner == nil or owner == ffi.NULL then return nil end
        local out = {}
        for i = 0, 15 do
            local layer = owner[i]
            if layer == nil or layer == ffi.NULL then break end
            local t = {}
            t.m_nOrder = tonumber(layer.m_nOrder)
            t.m_nSequence = tonumber(layer.m_nSequence)
            t.m_flPrevCycle = tonumber(layer.m_flPrevCycle)
            t.m_flWeight = tonumber(layer.m_flWeight)
            t.m_flWeightDeltaRate = tonumber(layer.m_flWeightDeltaRate)
            t.m_flPlaybackRate = tonumber(layer.m_flPlaybackRate)
            t.m_flCycle = tonumber(layer.m_flCycle)
            t.m_pOwner = tostring(layer.m_pOwner)
            table.insert(out, t)
        end
        return out
    end)
    if not ok then return nil end
    return res
end


function M.get_tick_from_simtime(simtime)
    if not simtime or not globals or not globals.tickinterval then return nil end
    local ti = globals.tickinterval()
    if not ti or ti == 0 then return nil end
    return math.floor(simtime / ti + 0.5)
end

function M.get_tick(ent)
    local sim = M.get_sim_time(ent)
    if sim then return M.get_tick_from_simtime(sim) end
    return nil
end








function M.get_enemies_snapshot(opts)
    opts = opts or {}
    local heavy = true 

    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        local snap = {}

        
        snap.is_alive = (pcall(function() return entity.is_alive(ent) end) and entity.is_alive(ent)) or false
        snap.is_dormant = (pcall(function() return entity.is_dormant(ent) end) and entity.is_dormant(ent)) or false

        
        local ok_name, name = pcall(function() return entity.get_player_name(ent) end)
        snap.name = ok_name and name or nil

        
        snap.simtime = M.get_sim_time(ent)
        do
            local base_tick = snap.simtime and M.get_tick_from_simtime(snap.simtime) or nil
            
            local ok_flags, esp_flags = pcall(function()
                local d = entity.get_esp_data and entity.get_esp_data(ent)
                return (d and d.flags) or 0
            end)

            local adjusted_tick = base_tick
            if ok_flags and esp_flags and base_tick then
                
                local ok_bit, is_backtrack = pcall(function()
                    return bit and bit.band(esp_flags, bit.lshift(1, 17)) ~= 0
                end)
                if ok_bit and is_backtrack then
                    adjusted_tick = base_tick - 14
                end
            end
            snap.simTicks = adjusted_tick
        end

        
        do
            local ok, ox, oy, oz = pcall(function() return M.get_origin(ent) end)
            if ok and ox then snap.origin = { ox, oy, oz } end
        end
        do
            local ok, vx, vy, vz = pcall(function() return M.get_view_offset(ent) end)
            if ok and vx then snap.viewOffset = { vx, vy, vz } end
        end
        do
            local ok, ex, ey, ez = pcall(function() return M.get_eye_pos(ent) end)
            if ok and ex then snap.eyePos = { ex, ey, ez } end
        end

        
        do
            local ok, a1, a2, a3 = pcall(function() return M.get_eye_angles(ent) end)
            if ok and a1 then snap.eyeAngles = { a1, a2, a3 } end
        end
        do
            local ok, aa1, aa2, aa3 = pcall(function() return M.get_abs_angles(ent) end)
            if ok and aa1 then snap.absAngles = { aa1, aa2, aa3 } end
        end

        
        snap.lowerBodyYaw = (pcall(function() return M.get_lower_body_yaw(ent) end) and M.get_lower_body_yaw(ent)) or nil
        snap.feetYaw = (pcall(function() return M.get_feet_yaw(ent) end) and M.get_feet_yaw(ent)) or snap.lowerBodyYaw
        snap.goalFeetYaw = (pcall(function() return M.get_goal_feet_yaw(ent) end) and M.get_goal_feet_yaw(ent)) or snap.feetYaw

        
        snap.velocity3d = (pcall(function() return M.get_velocity_3d(ent) end) and M.get_velocity_3d(ent)) or nil
        if snap.velocity3d then
            snap.speed2d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0))
            snap.speed3d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0) + (snap.velocity3d[3] or 0) * (snap.velocity3d[3] or 0))
        else
            snap.speed2d = M.get_speed_2d(ent)
            snap.speed3d = M.get_speed(ent)
        end

        
        do
            local ok_ms, ms = pcall(function() return M.get_move_speed_anim(ent) end)
            if ok_ms and ms then
                snap.moveSpeedAnim = ms
            else
                snap.moveSpeedAnim = nil
            end
        end

        
        snap.flags = (pcall(function() return M.get_flags(ent) end) and M.get_flags(ent)) or nil

        
        local ok_head, hx, hy, hz = pcall(function() return entity.hitbox_position(ent, "head") end)
        if ok_head and hx then snap.headPos = { hx, hy, hz } end

        
        local ok_w, w = pcall(function() return entity.get_player_weapon(ent) end)
        snap.weapon = ok_w and w or nil

        

        
        local ok_b, bones = pcall(function() return entity.get_bone_matrices and entity.get_bone_matrices(ent) end)
        if ok_b and bones then snap.bones = bones end

        local ok_as, as = pcall(function() return M.read_animstate(ent) end)
        if ok_as and as then snap.animstate_full = as end
        local ok_layers, layers = pcall(function() return M.read_anim_layers(ent) end)
        if ok_layers and layers then snap.animLayers = layers end

        out[ent] = snap
    end
    return out
end

return M
]=]
u743["require/features/misc/dormant_aimbot"] = [[local u232, u233, u234, u235= client.visible, client.eye_position, client.log, client.trace_bullet
local u236, u237, u238, u239, u240, u241, u242, u243, u244, u245= entity.get_bounding_box, entity.get_local_player, entity.get_origin, entity.get_player_name, entity.get_player_resource, entity.get_player_weapon, entity.get_prop, entity.is_dormant, entity.is_enemy, entity.is_alive
local u246, u247, u248= globals.curtime, globals.maxplayers, globals.tickcount
local u249, u250, u251= math.max, math.min, math.sqrt
local u252, u253, u254= renderer.indicator, string.format, table.unpack or unpack
local u255, u256, u257, u258, u259, u260, u261, u262, u263, u264= ui.get, ui.new_checkbox, ui.new_color_picker, ui.new_hotkey, ui.new_multiselect, ui.new_slider, ui.reference, ui.set, ui.set_callback, ui.set_visible
local u265, u266= plist.get, entity.hitbox_position
local u267= require("ffi")
local u268= require("vector")
local u269= require("gamesense/csgo_weapons")
local u270= vtable_bind("client_panorama.dll", "VClientEntityList003", 3, "void*(__thiscall*)(void*, int)")
local u271= vtable_thunk(166, "bool(__thiscall*)(void*)")
local u272= vtable_thunk(483, "float(__thiscall*)(void*)")
local u273= {
	mindamage = u261("RAGE", "Aimbot", "Minimum damage"),
	dormant_esp = u261("VISUALS", "Player ESP", "Dormant"),
	override_mindamage = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}
local u274= require("require/abc/menu_setup")
local u275= require('require/abc/callbacks')

local u276= {}
local function u277(u278)
	if type(u274) ~= 'table' then return false end
	if u276[u278] == nil then u276[u278] = u274.ui and u274.ui[u278] end
	local u279= u276[u278]
	if not u279 then return false end
	local u280, u281= pcall(u255, u279)
	if not u280 then
		u276[u278] = u274.ui and u274.ui[u278]
		u279 = u276[u278]
		if not u279 then return false end
		u280, val = pcall(u255, u279)
		if not u280 then return false end
	end
	return u281
end

local u282= { "Head", "Chest", "Stomach" }
local u283= {
	"generic",
	"head",
	"chest",
	"stomach",
	"left arm",
	"right arm",
	"left leg",
	"right leg",
	"neck",
	"?",
	"gear"
}

local u284= {
	"",
	"Head",
	"Chest",
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs",
	"Head",
	"",
	""
}

local u285= {
	{ scale = 5, hitbox = "Stomach", vec = u268(0, 0, 40) },
	{ scale = 6, hitbox = "Chest", vec = u268(0, 0, 50) },
	{ scale = 3, hitbox = "Head", vec = u268(0, 0, 58) },
	{ scale = 4, hitbox = "Legs", vec = u268(0, 0, 20) }
}

local u286= {
	[0] = "Head",
	nil,
	"Stomach",
	nil,
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs"
}

local u287= 0
local u288= {}
local u289= {}
local u290= 1
local u291= false
local u292
local u293
local u294
local u295
local u296= false
local u297= {}

local u298= {
	0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18
}

local function u299(u300,u301,u302)
	local u303, u304= u300:to(u301):angles()
	local u305= math.rad(u304 + 90)
	local u306= u268(math.cos(u305), math.sin(u305), 0) * u302

	return {
		{ text = "Middle", vec = u301 },
		{ text = "Left", vec = u301 + u306 },
		{ text = "Right", vec = u301 - u306 }
	}
end

local function u307(u308,u309)
	for i = 1, #u308 do if u308[i] == u309 then return true end end
	return false
end
local function u310(u308,u309)
	for i = 1, #u308 do local u311= u308[i] if type(u311) == 'table' and u311[1] == u309 then return i end end
end
local function u312(u308,u313) return u310(u308, u313) ~= nil end
local function u314(u308,u313) local u315= u310(u308, u313) if u315 then table.remove(u308, u315) end end

local function u316(u317,u318)
	local u319= u251(u317.forwardmove*u317.forwardmove + u317.sidemove*u317.sidemove)
	if u318<=0 or u319<=0 then return end
	if u317.in_duck==1 then u318 = u318*2.94117647 end
	if u319<=u318 then return end
	local u320= u318/u319; u317.forwardmove = u317.forwardmove*u320; u317.sidemove = u317.sidemove*u320
end

local function u321()
	local u322, u323= {}, u240()
	for i=1,u247() do if u242(u323, "m_bConnected", i)==1 and i~=u237() and u244(i) then u322[#u322+1]=i end end
	return u322
end
local function u324()
	local u322, u323= {}, u240()
	for i=1,u247() do if u242(u323, "m_bConnected", i)==1 and not u265(i, "Add to whitelist") and u243(i) and u244(i) then u322[#u322+1]=i end end
	return u322
end

local function u325()
	for u303,enemy in ipairs(u321()) do
		local u303,u303,u303,u303,u326= u236(enemy)
		if u326<1 then if not u312(u289,enemy) then u289[#u289+1]={enemy,u248()} end else u314(u289,enemy) end
	end
end

local function u327(u328)
	local u329= u255(u273.override_mindamage[1]) and u255(u273.override_mindamage[2])
	local u330= u329 and u255(u273.override_mindamage[3]) or u255(u273.mindamage)
	local u331= entity.get_esp_data(u328).health
	if u330>100 then u330 = u330 - 100 + u331 end
	return u330
end

local function u332(u333,u320) return (u333.type=="sniperrifle" and u320) and u333.max_player_speed_alt or u333.max_player_speed end

local function u334(u328,u335,u336)
	local u337= {}
	local u338= u242(u328, "m_flDuckAmount") or 0
	for u303,p in ipairs(u285) do
		if #u336==0 or u307(u336,p.hitbox) then
			local u339= p.vec
			if p.hitbox=="Head" then u339 = u339 - u268(0,0,u338*10) elseif p.hitbox=="Chest" then u339 = u339 - u268(0,0,u338*4) end
			u337[#u337+1]={vec=u335+u339,scale=p.scale,hitbox=p.hitbox}
		end
	end
	for i=1,7 do
		local u340= u286[i-1]
		if u340 and (#u336==0 or u307(u336,u340)) then
			local u341= u266(u328,i-1)
			if u341 then u337[#u337+1]={vec=u268(u341),scale=3,hitbox=u340} end
		end
	end
	return u337
end

local function u342(u343,u344,u345,u346,u347)
	for u303,p in ipairs(u346) do
		for u303,u339 in ipairs(u299(u345,p.vec,3)) do
			local u303,u348= u235(u343, u345.x,u345.y,u345.z, u339.vec.x,u339.vec.y,u339.vec.z, true)
			if p.hitbox=="Head" then u348=u348*4 end
			if u348>u347 then return u339.vec,u348,p.hitbox,u339.text end
		end
	end
end

local function u349(u317)
	u325()

	if not u277('misc_dormantaimbot') and u277('misc_dormantaimbot_key') then
		return
	end

	local u350= u237()
	if not u350 or not u245(u350) then
		return
	end

	local u351= u241(u350)
	if not u351 then
		return
	end

	local u352= u270(u351)
	if not u352 or not u271(u352) then
		return
	end

	local u353= u272(u352)
	if not u353 then
		return
	end

	local u354= u268(u233())
	local u355= u242(u350, "m_flSimulationTime")
	local u356= u248()
	local u357= u269(u351)
	local u358= u242(u350, "m_bIsScoped") == 1
	local u359= bit.band(u242(u350, "m_fFlags"), bit.lshift(1, 0))

	local u360= u324()
	if #u360 == 0 then
		u288 = {}
		return
	end

	if u356 % #u360 ~= 0 then
		u290 = u290 + 1
	else
		u290 = 1
	end

	local u328= u360[u290]
	if not u328 then
		u288 = {}
		return
	end

	if u356 < u287 then
		u288 = {}
		return
	end

	if u357.type == "grenade" or u357.type == "knife" then
		u288 = {}
		return
	end

	if u317.in_jump == 1 and u359 == 0 then
		u288 = {}
		return
	end

	local u361= u282
	local u362= u268(u238(u328))
	local u303, u303, u303, u303, u363= u236(u328)

	u288[u328] = nil

	if u363 < 1 then
		if not u312(u297, u328) then
			u297[#u297 + 1] = { u328, u356 }
		end
	else
		u314(u297, u328)
	end

	local u364= u334(u328, u362, u361)
	local u365= u327(u328)

	local u366
	if u357.is_revolver then
		u366 = u355 > u242(u351, "m_flNextPrimaryAttack")
	else
		u366 = u355 > u249(
			u242(u350, "m_flNextAttack"),
			u242(u351, "m_flNextPrimaryAttack"),
			u242(u351, "m_flNextSecondaryAttack")
		)
	end

	if not u366 then
		return
	end

	local u367, u368, u369, u370= u342(
		u350,
		u357,
		u354,
		u364,
		u365
	)

	if not u367 then
		return
	end

	if u232(u367.x, u367.y, u367.z) then
		return
	end

	u316(u317, u332(u357, u358) * 0.33)

	local u371, u304= u354:to(u367):angles()

	if not u358 and u357.type == "sniperrifle" and u317.in_jump == 0 and u359 == 1 then
		u317.in_attack2 = 1
	end

	u288[u328] = true

	if u353 < 0.01 then
		u317.pitch = u371
		u317.yaw = u304
		u317.in_attack = 1
		u291 = true
		u292 = u369
		u293 = u370
		u294 = u328
		u295 = (u255(u274.ui.misc_dormantaimbot_value) or 0)
	end
end

local function u372(u373)
	client.delay_call(0.03, function()
		local u350= u237()
		if client.userid_to_entindex(u373.userid) ~= u350 then
			return
		end

		if u291 and not u296 then
			client.fire_event("dormant_miss", {
				userid = u294,
				aim_hitbox = u292,
				aim_point = u293,
				accuracy = u295
			})
		end

		u296 = false
		u291 = false
		u292 = nil
		u293 = nil
		u294 = nil
		u295 = nil
	end)
end

local function u374(u373)
	local u375= client.userid_to_entindex(u373.userid)
	local u376= client.userid_to_entindex(u373.attacker)

	if u376 == u237() and u375 ~= nil and u291 then
		u296 = true

		client.fire_event("dormant_hit", {
			userid = u375,
			attacker = u376,
			health = u373.health,
			armor = u373.armor,
			weapon = u373.weapon,
			dmg_health = u373.dmg_health,
			dmg_armor = u373.dmg_armor,
			hitgroup = u373.hitgroup,
			accuracy = u295 or 0,
			aim_hitbox = u292
		})
	end
end

local function u377()
	local u378= (cvar.mp_freezetime:get_float() + 1) / globals.tickinterval()
	u287 = u248() + u378
end

u275.register("setup_command", u349, { alive_only = true, require_login = true })
u275.register("round_prestart", u377, { alive_only = true, require_login = true })
u275.register("player_hurt", u374, { alive_only = true, require_login = true })
u275.register("weapon_fire", u372, { alive_only = true, require_login = true })

client.register_esp_flag("DA", 255, 255, 255, function(u313)
	if u277('misc_dormantaimbot') and u277('misc_dormantaimbot_key') and u245(u237()) then
		return u288[u313]
	end
end)


u275.register("paint", function()
	if not u245(u237()) then return end
	if u277('misc_dormantaimbot') and u277('misc_dormantaimbot_key') then
		local u379= {255,255,255,200}
		for u303,u311 in pairs(u288) do if u311 then u379={143,194,21,255}; break end end
		if #u324()==0 then u379={255,0,50,255} end
		u252(u379[1],u379[2],u379[3],u379[4],"DA")
	end
end, { alive_only = true, require_login = true })]]
u743["require/features/misc/enhance_osaa"] = [[local u235, u236= pcall(require, "require/abc/menu_setup")

local u237= require('require/abc/callbacks')

local u238= {}
local u239= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local u240= {ui.reference(item[1], item[2], item[3])}
    u238[i] = u240
    for _, ref in ipairs(u240) do
        u239[ref] = true
    end
end

local u241= {}
local u242= {}

u237.register("weapon_fire", function(u243)
    local u244= entity.get_local_player()
    if u244 and client.userid_to_entindex(u243.userid) == u244 then
        u241[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

u237.register("player_hurt", function(u243)
    local u244= entity.get_local_player()
    if u244 and client.userid_to_entindex(u243.userid) == u244 then
        u242[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

local function u245()
    local u246= globals.tickcount()
    local u247= nil
    for t = u246-20, u246 do
        if u241[t] then
            u247 = t
            break
        end
    end
    if u247 then
        if u246 - u247 <= 4 then
            return true
        end
        return true
    end
    return false
end



local function u248(u249)

    local u245= has_fired()

    local function u250(u251,u252)
        if type(u251) ~= 'table' then return false end
        for _, v in ipairs(u251) do if tostring(v) == tostring(u252) then return true end end
        return false
    end

    local u253= ui.get(u236.ui.fakelag_settings_enhance_onshot) or {}

    if u236 and u236.ui and u245 then
            if u250(u253, 'defensive') then
                u249.force_defensive = true
            end

            if u250(u253, 'roll') then
                ui.set(u238[3][1], math.random(-45, 45))
            end

            local u254= globals.tickcount() % 4 < 2
            if u250(u253, 'jitter') then
                ui.set(u238[2][1], '180')
                ui.set(u238[2][2], u254 and 55 or -48)
            end
    end
end

u237.register('setup_command', function(u249)

    u248(u249)

end, { alive_only = true, require_login = true })]]
u743["require/features/misc/events"] = [[local u238= {}
local u239= globals

u238.last_hit = {}
u238.last_miss = {}

u238.shots_queue = {}
u238.shots_by_id = {}

function events.record_weapon_fire(u240)
  if not u240 or not u240.t then return end
  u238.shots_queue[#u238.shots_queue+1] = u240
end

function events.record_aim_fire(u241,u240)
  if not u241 or not u240 then return end
  u238.shots_by_id[u241] = u240
end

function events.record_aim_miss(u241,u242,u243)
  if not u242 then return end
  local u244= u239.curtime()
  local u245= u243 or {}
  u245.time = u244
  u238.last_miss[u242] = u245
  if u241 then u238.shots_by_id[u241] = nil end
end

function events.record_player_hurt(u241,u242,u243)
  if not u242 then return end
  local u244= u239.curtime()
  local u245= u243 or {}
  u245.time = u244
  u238.last_hit[u242] = u245
  if u241 then u238.shots_by_id[u241] = nil end
end

function events.link_recent_shot_to_victim(u242,u246)
  u246 = u246 or 0.35
  local u244= u239.curtime()
  for i=#u238.shots_queue,1,-1 do
    local u247= u238.shots_queue[i]
    if u247 and u247.target == u242 and (u244 - (u247.t or u244)) <= u246 and not u247.linked then
      u238.shots_queue[i].linked = true
      return u238.shots_queue[i]
    end
  end
  return nil
end

return u238
]]
u743["require/features/misc/exploit_fakelag"] = [[local u241, u242= pcall(require, "require/abc/menu_setup")

local u243= require('require/abc/callbacks')

local u244= {}
local u245= {}
for i, item in ipairs({
    { 'rage', 'aimbot', 'double tap' },
    { 'aa', 'other', 'on shot anti-aim' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },

}) do
    local u246= {ui.reference(item[1], item[2], item[3])}
    u244[i] = u246
    for _, ref in ipairs(u246) do
        u245[ref] = true
    end
end


local function u247(u248)

    local u249= ui.get(u242.ui.misc_exploit_fakelag)

    local u250= (ui.get(u244[1][1]) and ui.get(u244[1][2]))
    local u251= (ui.get(u244[2][1]) and ui.get(u244[2][2]))

    local u252= u249 and (u250 or u251)

    if u252 then
        ui.set(u244[3][1], false)
    end

end

u243.register('setup_command', function(u248)

    u247(u248)

end, { alive_only = true, require_login = true })]]
u743["require/features/misc/fakelag"] = [[local u244= {}
local u245= {}
for i, item in ipairs({
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
}) do
    local u246= {ui.reference(item[1], item[2], item[3])}
    u244[i] = u246
    for _, ref in ipairs(u246) do
        u245[ref] = true
    end
end

local u247, u248= pcall(require, "require/abc/menu_setup")

local u249= require('require/abc/callbacks')

u249.register("setup_command", function()
    if not (u247 and u248 and u248.ui) then return end

    local u250, u251= pcall(ui.get, u248.ui.fakelag_fakelag)
    if not u250 or not u251 then return end

    local u252, u253= pcall(ui.get, u248.ui.fakelag_fakelag_type)
    if not u252 then return end

    if tostring(u253) == "gamesense" then
        ui.set(u244[1][1], true)
        local u254, u255= pcall(ui.get, u248.ui.fakelag_fakelag_amount)
        local u256, u257= pcall(ui.get, u248.ui.fakelag_fakelag_variance)
        local u258, u259= pcall(ui.get, u248.ui.fakelag_fakelag_limit)

        if u254 and u255 and u244[2] and u244[2][1] then
            pcall(ui.set, u244[2][1], u255)
        end
        if u256 and u257 and u244[3] and u244[3][1] then
            pcall(ui.set, u244[3][1], u257)
        end
        if u258 and u259 and u244[4] and u244[4][1] then
            pcall(ui.set, u244[4][1], u259)
        end

        return
    end

    if tostring(u253) == "sodium" then
        ui.set(u244[1][1], true)
        local u260, u261= pcall(ui.get, u248.ui.fakelag_fakelag_type2)
        if not u260 then return end

        if tostring(u261) == "jitter" then
            if u244[2] and u244[2][1] then
                pcall(ui.set, u244[2][1], "dynamic")
            end
            local u262= globals.tickcount() or 0
            local u263= math.max(u262 % 101, 100)
            local u264= math.min(math.random(7) + (u262 % 15), 11)
            if u244[3] and u244[3][1] then pcall(ui.set, u244[3][1], u263) end
            if u244[4] and u244[4][1] then pcall(ui.set, u244[4][1], 15) end

            return
        end

        if tostring(u261) == "max" then
            if u244[2] and u244[2][1] then
                pcall(ui.set, u244[2][1], "dynamic")
            end
            if u244[3] and u244[3][1] then
                pcall(ui.set, u244[3][1], 0)
            end
            local u259= 14 + ((globals.tickcount() or 0) % 2)
            if u244[4] and u244[4][1] then pcall(ui.set, u244[4][1], u259) end

            return
        end
    end
end, { alive_only = true, require_login = true })]]
u743["require/features/misc/freestand_helper"] = [[local u247= {}
local u248= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
}) do
    local u249= {ui.reference(item[1], item[2], item[3])}
    u247[i] = u249
    for _, ref in ipairs(u249) do
        u248[ref] = true
    end
end

local u250, u251= pcall(require, "require/abc/menu_setup")

local u252= require('require/abc/callbacks')

local function u253(u254)
    if not (u251 and u251.ui and u251.ui.aa_gskey_freestand) then return end
    if not ui.get(u251.ui.aa_gskey_freestand) then return end

    local function u255(u256,u257)
        if type(u256) ~= 'table' then return false end
        for _, v in ipairs(u256) do if tostring(v) == tostring(u257) then return true end end
        return false
    end

    local u258= ui.get(u251.ui.fakelag_settings_freestanding) or {}


    localplayer = entity.get_local_player()
    local u259, u260, u261= entity.get_prop(localplayer, 'm_vecVelocity')
    if u259 and u260 and u261 then
        velvel =  math.sqrt(u259 * u259 + u260 * u260 + u261 * u261)
    end
    


    if u255(u258, 'static') then
        ui.set(u247[1][1], true)
        ui.set(u247[5][1], '180')
        ui.set(u247[5][2], 6)
        ui.set(u247[6][1], 'off')
        ui.set(u247[7][1], 'off')
    end

    if u255(u258, 'zero pitch') and velvel > 5 then
        ui.set(u247[3][1], 'Off')
    end

    if u255(u258, 'defensive') then
        u254.force_defensive = true
    end

    local u262= globals.tickcount() % 4 < 2
    if u255(u258, 'side flip') and velvel > 5 then
        ui.set(u247[5][1], '180')
        ui.set(u247[5][2], u262 and -90 or 90)
    end

    local u262= globals.tickcount() % 6 < 2
    if u255(u258, 'pitch flip') and velvel > 5 then
        ui.set(u247[3][1], 'custom')
        ui.set(u247[3][2], u262 and -89 or 89)
    end

end

u252.register('setup_command', function(u254)
    u253(u254)
end, { alive_only = true, require_login = true })]]
u743["require/features/misc/history"] = [[
local u250= {}

local u251= 20
local u252= {}

local function u253(u254)
  if not u252[u254] then u252[u254] = { buf = {} } end
  return u252[u254]
end

function history.push(u254,u255)
  if not u254 or not u255 then return end
  local u256= u253(u254)
  u256.buf[#u256.buf+1] = u255
  if #u256.buf > u251 then table.remove(u256.buf, 1) end
end

function history.get_last_n(u254,u257)
  u257 = u257 or u251
  local u256= u252[u254]
  if not u256 or #u256.buf == 0 then return {} end
  local u258= {}
  local u259= #u256.buf
  local u260= math.max(1, u259 - u257 + 1)
  for i = u260, u259 do u258[#u258+1] = u256.buf[i] end
  return u258
end

function history.clear(u254)
  if not u254 then u252 = {} return end
  u252[u254] = nil
end

return u250
]]
u743["require/features/misc/hotkeys"] = [[local u253= {}
local u254= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local u255= {ui.reference(item[1], item[2], item[3])}
    u253[i] = u255
    for _, ref in ipairs(u255) do
        u254[ref] = true
    end
end

local u256, u257= pcall(require, "require/abc/menu_setup")

local u258= require('require/abc/callbacks')

local function u259()

    if ui.get(u257.ui.aa_gskey_freestand) then
        ui.set(u253[3][1], true)
        ui.set(u253[3][2], 'Always on')
    else
        ui.set(u253[3][1], false)
        ui.set(u253[3][2], 'On hotkey')
    end

    if ui.get(u257.ui.aa_gskey_slowmotion) then
        ui.set(u253[4][1], true)
    else
        ui.set(u253[4][1], false)
    end

    if u257 and u257.ui and ui.get(u257.ui.aa_gskey_edgeyaw) then
        ui.set(u253[2][1], true)
    else
        ui.set(u253[2][1], false)
    end

    if u257 and u257.ui and ui.get(u257.ui.aa_gskey_onshot) then
        ui.set(u253[6][2], 'Always on')
    else
        ui.set(u253[6][2], 'On hotkey')
    end

end

u258.register('setup_command', function()

    u259()

end, { alive_only = true, require_login = true })]]
u743["require/features/misc/localdebug"] = [=[local callbacks_ok, callbacks = pcall(require, "require/abc/callbacks")
local M = {}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")

local state = {
    last_yaw = nil,
    last_pitch = nil,
    last_defensive = false,
    skel_list = {},
    last_choked = 0,
    shot_ticks = {},
    shot_ticks_aim = {},
    skel_history = {},
}

local function normalize_angle(a)
    if not a then return a end
    local ang = tonumber(a) or 0
    while ang > 180 do ang = ang - 360 end
    while ang <= -180 do ang = ang + 360 end
    return ang
end

local function on_weapon_fire(ev)
    if not ev then return end
    local attacker_ent = client.userid_to_entindex(ev.userid)
    local lp = entity.get_local_player()
    if attacker_ent ~= lp then return end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks, t)
    while #state.shot_ticks > 200 do table.remove(state.shot_ticks, 1) end
end

local function on_aim_fire(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    if ev.attacker then
        local attacker_ent = client.userid_to_entindex(ev.attacker)
        if attacker_ent ~= lp then return end
    end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks_aim, t)
    while #state.shot_ticks_aim > 200 do table.remove(state.shot_ticks_aim, 1) end
end

local function had_recent_shot(ticks_back)
    ticks_back = ticks_back or 30
    local now = globals.tickcount and globals.tickcount() or 0
    for i = #state.shot_ticks_aim, 1, -1 do
        local s = state.shot_ticks_aim[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    for i = #state.shot_ticks, 1, -1 do
        local s = state.shot_ticks[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    return false
end

local function safe_tonumber(v)
    local n = tonumber(v)
    if n then return n end
    return 0
end


local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {
    head={names={'head','Head','HEAD'},idx={0}},
    neck={names={'neck','Neck'},idx={1}},
    chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},
    stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},
    pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},
    l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},
    l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},
    l_hand={names={'left hand','Left Hand'},idx={14}},
    r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},
    r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},
    r_hand={names={'right hand','Right Hand'},idx={13}},
    l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},
    l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},
    l_foot={names={'left foot','Left Foot'},idx={12}},
    r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},
    r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},
    r_foot={names={'right foot','Right Foot'},idx={11}},
}

local function find_bone(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x,y,z = entity.hitbox_position(ent, def.names[i])
        if x then return x,y,z end
    end
    for i = 1, #(def.idx or {}) do
        local x,y,z = entity.hitbox_position(ent, def.idx[i])
        if x then return x,y,z end
    end
end

local function snap_ent(ent)
    if not ent then return end
    local pts = {}
    for key, def in pairs(boxes) do
        local x,y,z = find_bone(ent, def)
        if x then pts[key] = {x=x,y=y,z=z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local function paint_handler()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lag_record then
        local ok_enabled, enabled = pcall(ui.get, menu_setup.ui.paint_lag_record)
        if not ok_enabled or not enabled then return end
    end
    if not renderer or not renderer.world_to_screen or not renderer.line then return end
    local now = globals.realtime and globals.realtime() or os.time()
    local i = 1
    while i <= #state.skel_list do
        local it = state.skel_list[i]
        if not it or not it.t or (now - it.t) > 10 then
            table.remove(state.skel_list, i)
        else
            local SKEL_SCALE = 1.15
            
            local trail = it.trail or {}
            if trail and #trail > 0 then
                for ti = 1, #trail do
                    local entry = trail[ti]
                    local trail_pts = entry.pts or {}
                    
                    local ratio = ti / #trail
                    local r, g, b, alpha
                    if ti == #trail then
                        
                        r = 0
                        g = 140
                        b = 255
                        alpha = 200
                    else
                        
                        r = 255
                        g = math.floor(255 * (1 - ratio))
                        b = math.floor(255 * (1 - ratio))
                        alpha = math.floor(40 + ratio * (160 - 40))
                    end
                    
                    local center = trail_pts.pelvis or trail_pts.chest
                    if not center then
                        local sx, sy, sz, ccount = 0,0,0,0
                        for k, v in pairs(trail_pts) do
                            if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                        end
                        if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
                    end
                    for c = 1, #chains do
                        local chain = chains[c]
                        local from, to = trail_pts[chain[1]], trail_pts[chain[2]]
                        if from and to then
                            local fxw, fyw, fzw = from.x, from.y, from.z
                            local txw, tyw, tzw = to.x, to.y, to.z
                            if center and center.x then
                                fxw = center.x + (from.x - center.x) * SKEL_SCALE
                                fyw = center.y + (from.y - center.y) * SKEL_SCALE
                                fzw = center.z + (from.z - center.z) * SKEL_SCALE
                                txw = center.x + (to.x - center.x) * SKEL_SCALE
                                tyw = center.y + (to.y - center.y) * SKEL_SCALE
                                tzw = center.z + (to.z - center.z) * SKEL_SCALE
                            end
                            local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                            local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                            if fx and tx then renderer.line(fx,fy,tx,ty,r,g,b,alpha) end
                        end
                    end
                end
            end
            
            local pts = it.pts or {}
            local center = pts.pelvis or pts.chest
            if not center then
                local sx, sy, sz, ccount = 0,0,0,0
                for k, v in pairs(pts) do
                    if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                end
                if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
            end
            for c = 1, #chains do
                local chain = chains[c]
                local from, to = pts[chain[1]], pts[chain[2]]
                if from and to then
                    local fxw, fyw, fzw = from.x, from.y, from.z
                    local txw, tyw, tzw = to.x, to.y, to.z
                    if center and center.x then
                        fxw = center.x + (from.x - center.x) * SKEL_SCALE
                        fyw = center.y + (from.y - center.y) * SKEL_SCALE
                        fzw = center.z + (from.z - center.z) * SKEL_SCALE
                        txw = center.x + (to.x - center.x) * SKEL_SCALE
                        tyw = center.y + (to.y - center.y) * SKEL_SCALE
                        tzw = center.z + (to.z - center.z) * SKEL_SCALE
                    end
                    local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                    local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                    if fx and tx then renderer.line(fx,fy,tx,ty,255,0,0,220) end
                end
            end
            i = i + 1
        end
    end
end


local function on_setup_command(cmd)
    if not cmd then return end
    local aa_funcs = nil
    local ok_req, req_lib = pcall(require, 'gamesense/antiaim_funcs')
    if ok_req and req_lib then aa_funcs = req_lib end
    if not aa_funcs then
        local ok_libs, libs = pcall(require, 'require/help/libs')
        if ok_libs and libs and libs.get then
            aa_funcs = libs.get('antiaim_funcs')
        end
    end

    local pitch, yaw = nil, nil
    if aa_funcs then
        local okp, pval = pcall(function() return aa_funcs.get_pitch and aa_funcs.get_pitch() end)
        if okp and pval ~= nil then pitch = pval end
        local oky, yval = pcall(function() return aa_funcs.get_yaw_base and aa_funcs.get_yaw_base() end)
        if oky and yval ~= nil then yaw = yval end
        if yaw == nil then
            local okb, bval = pcall(function() return aa_funcs.get_body_yaw and aa_funcs.get_body_yaw() end)
            if okb and bval ~= nil then yaw = bval end
        end
    end

    if (pitch == nil or yaw == nil) then
        local lp = entity.get_local_player()
        if lp then
            local ax, ay = entity.get_prop(lp, "m_angEyeAngles")
            if ax and ay then
                if pitch == nil then pitch = ax end
                if yaw == nil then yaw = ay end
            end
        end
    end

    if pitch ~= nil then state.last_pitch = pitch end
    if yaw ~= nil then state.last_yaw = normalize_angle(yaw) end

    do
        local ok_def, def_mod = pcall(require, 'require/features/aa/defensive')
        if ok_def and def_mod and def_mod.active ~= nil then
            state.last_defensive = not not def_mod.active
        else
            if cmd and cmd.force_defensive ~= nil then
                state.last_defensive = not not cmd.force_defensive
            end
        end
    end
    if cmd and cmd.chokedcommands ~= nil then
        state.last_choked = tonumber(cmd.chokedcommands) or 0
    end
    local lp = entity.get_local_player()
    if lp then
        local tick = globals.tickcount and globals.tickcount() or 0
        local hist_pts = snap_ent(lp)
        if hist_pts then
            state.skel_history[#state.skel_history + 1] = { tick = tick, pts = hist_pts }
            if #state.skel_history > 128 then table.remove(state.skel_history, 1) end
        end
    end
end

local function on_player_death(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    local victim_ent = client.userid_to_entindex(ev.userid)
    local attacker_ent = nil
    if ev.attacker then attacker_ent = client.userid_to_entindex(ev.attacker) end

    if victim_ent == lp then
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then
                attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker)
            else
                attacker_name = tostring(ev.attacker)
            end
        end
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] DIED — last_yaw=%.2f last_pitch=%.2f attacker=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
        return
    end
    if attacker_ent == lp and victim_ent and victim_ent ~= 0 and victim_ent ~= lp then
        local victim_name = entity.get_player_name(victim_ent) or tostring(ev.userid)
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] KILLED — last_yaw=%.2f last_pitch=%.2f victim=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, victim_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end
end

if callbacks_ok and callbacks and callbacks.callback then
    callbacks.callback('setup_command', on_setup_command, { alive_only = false, require_login = false })
    callbacks.callback('player_death', on_player_death, { alive_only = false, require_login = false })
    callbacks.callback('paint', paint_handler, { alive_only = false, require_login = false })
    callbacks.callback('weapon_fire', on_weapon_fire, { alive_only = false, require_login = false })
    callbacks.callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end, { alive_only = false, require_login = false })
else
    client.set_event_callback('setup_command', on_setup_command)
    client.set_event_callback('player_death', on_player_death)
    client.set_event_callback('paint', paint_handler)
    client.set_event_callback('weapon_fire', on_weapon_fire)
    client.set_event_callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end)
end
]=]
u743["require/features/misc/resolver"] = [[














local u259, u260= pcall(require, "require/features/misc/collect")
local u261, u262= pcall(require, "require/features/misc/history")
local u263, u264= pcall(require, "require/features/misc/state")
local u265, u266= pcall(require, "require/features/misc/events")
local u267, u268= pcall(require, "require/help/vector")
local u269= u267 and u268 or nil
local u270= require('require/abc/callbacks')







if not M then M = {} end
M.players = M.players or {}


local function u271()
	pcall(function()
		if not u259 or type(u260) ~= "table" or not u260.get_enemies_snapshot then return end

		local u272, u273= pcall(function() return u260.get_enemies_snapshot() end)
		if not u272 or type(u273) ~= "table" then return end

		M.players = M.players or {}

		for ent, snap in pairs(u273) do
			M.players[ent] = M.players[ent] or {}
			M.players[ent].snapshot = snap

            
            
            
			M.players[ent].simtime = snap.simtime
			M.players[ent].simTicks = snap.simTicks
			M.players[ent].lowerBodyYaw = snap.lowerBodyYaw
			M.players[ent].speed2d = snap.speed2d
			M.players[ent].velocity3d = snap.velocity3d
			M.players[ent].is_alive = snap.is_alive
			M.players[ent].is_dormant = snap.is_dormant
			M.players[ent].feetYaw = snap.feetYaw
			M.players[ent].goalFeetYaw = snap.goalFeetYaw
			M.players[ent].moveSpeedAnim = snap.moveSpeedAnim
		end

		for ent, snap in pairs(u273) do
			local u274= snap.name or "?"
			local u275= snap.simtime or 0
			local u276= snap.speed2d or 0
			local u277= snap.lowerBodyYaw or "nil"
			local u278= snap.moveSpeedAnim or 0
			local u279= snap.feetYaw or "nil"
			local u280= snap.goalFeetYaw or "nil"
			local u281= snap.animstate_full.m_fDuckAmount

		end
	end)
end



local function u282(u283)
    while u283 > 180 do
        u283 = u283 - 360
    end
    while u283 < -180 do
        u283 = u283 + 360
    end
    return u283
end


local function u284(u285,u286)
    local u287= u286 - u285
    local u283= math.atan(u287.y / u287.x)
    u283 = u282(u283 * 180 / math.pi)

    if u287.x >= 0 then
        u283 = u282(u283 + 180)
    end

    return u283
end



local u288= 100
local u289= {}
_G.player_history = u289

local function u290(u291)
    return math.floor(0.5 + u291 / globals.tickinterval())
end

local function u292(u293)
    local u294= entity.get_players(true)

	if #u294 == 0 then
		
		u289 = {}
		_G.player_history = u289
		return nil
	end


	for i, player in ipairs(u294) do
		if entity.is_alive(player) and not entity.is_dormant(player) then

			local u295= 0
			local u296= entity.get_esp_data(player).flags or 0

			if bit.band(u296, bit.lshift(1, 17)) ~= 0 then
				u295 = u290(entity.get_prop(player, "m_flSimulationTime")) - 14
			else
				u295 = u290(entity.get_prop(player, "m_flSimulationTime"))
			end

			
			local u297= u289[player] or {}
			local u298= u297[1]

			if u298 == nil or (u295 - (u298.simtime or -999)) >= 1 then

				local u299= u269(entity.get_prop(u293, "m_vecOrigin"))
				local u300= u269(entity.get_prop(player, "m_angEyeAngles"))
				local u301= u269(entity.get_prop(player, "m_vecOrigin"))
				local u302= math.floor(u282(u300.y - u284(u299, u301)))
				

				local u303= {
					id = player or nil,
					origin = u269(entity.get_origin(player)) or u269(nil,nil,nil),
					pitch = u300.x or nil,
					yaw = u302 or nil,
					yaw_backwards = backwards_angle or nil,
					simtime = u295 or nil,
					stance = stance or nil,
					esp_flags = entity.get_esp_data(player).flags or 0,
					last_shot_time = last_shot_time or nil
				}

				table.insert(u297, 1, u303)
				while #u297 > u288 do
					table.remove(u297)
				end

				u289[player] = u297
			end
		end
	end
end















client.set_event_callback('net_update_end', function()
    pcall(function()

        
        

        local u293= entity.get_local_player()
        if not entity.is_alive(u293) then
            return
        end
        u292(u293)


        local u304= (globals and globals.tickcount and globals.tickcount()) or (globals and globals.realtime and globals.realtime()) or os.time()
        

    end)
end, { alive_only = true, require_login = true })

u270.register('weapon_fire', function(u305)
    pcall(function()







        local u306= (u305 and u305.userid) and (client.userid_to_entindex and client.userid_to_entindex(u305.userid)) or (u305 and (u305.attacker or u305.userid)) or "?"
        local u307= (u305 and (u305.weapon or u305.weapon_name or u305.weaponid)) or "?"
        
    end)
    if EVENTS and EVENTS.record_weapon_fire then pcall(EVENTS.record_weapon_fire, u305) end
end, { alive_only = true, require_login = true })

u270.register('aim_fire', function(u305)
    pcall(function()








        local u308= u305 and u305.id or "?"
        local u309= u305 and u305.target or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_fire then pcall(EVENTS.record_aim_fire, u305) end
end, { alive_only = true, require_login = true })

u270.register('aim_hit', function(u305)
    pcall(function()








        local u308= u305 and u305.id or "?"
        local u309= u305 and u305.target or "?"
        local u310= u305 and u305.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_hit then pcall(EVENTS.record_aim_hit, u305) end
end, { alive_only = true, require_login = true })

u270.register('aim_miss', function(u305)
    pcall(function()






        local u308= u305 and u305.id or "?"
        local u311= u305 and u305.reason or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_miss then pcall(EVENTS.record_aim_miss, u305) end
end, { alive_only = true, require_login = true })

u270.register('player_hurt', function(u305)
    pcall(function()






        local u312= (u305 and u305.attacker) or (u305 and u305.userid) or "?"
        local u313= (u305 and u305.userid) or (u305 and u305.userid) or "?"
        local u310= u305 and u305.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_player_hurt then pcall(EVENTS.record_player_hurt, u305) end
end, { alive_only = true, require_login = true })

u270.register('bullet_impact', function(u305)
    pcall(function()




        local u306= (u305 and u305.userid) and (client.userid_to_entindex and client.userid_to_entindex(u305.userid)) or "?"
        local u314,u315,u316= u305 and u305.x or "?", u305 and u305.y or "?", u305 and u305.z or "?"
        
    end)
    if EVENTS and EVENTS.on_bullet_impact then pcall(EVENTS.on_bullet_impact, u305) end
    if EVENTS and EVENTS.record_bullet_impact then pcall(EVENTS.record_bullet_impact, u305) end
end, { alive_only = true, require_login = true })

u270.register('paint', function()
    pcall(function()

        

    end)
    if EVENTS and EVENTS.on_paint then pcall(EVENTS.on_paint) end
end, { alive_only = true, require_login = true })

u270.register("round_start", function(u305)
    pcall(function() print("[resolver] round_start") end)



    M.players = {}
    if EVENTS and EVENTS.on_round_start then pcall(EVENTS.on_round_start, u305) end
end, { alive_only = true, require_login = true })

u270.register("shutdown", function()
    if client and client.unset_event_callback then



    end
end, { alive_only = true, require_login = true })
]]
u743["require/features/misc/resolver_dispatcher"] = [[local u262= {}


local u263= {}


_G.player_resolver_state = _G.player_resolver_state or {}

local function u264(u265)
    if not u265 or type(u265) ~= "string" then return nil end
    
    local u266= u265:lower()
    u266 = u266:gsub("%+", "plus")
    u266 = u266:gsub("%-% ", "minus_") 
    u266 = u266:gsub("%-%", "minus")
    u266 = u266:gsub("%s+", "_")
    u266 = u266:gsub("[^%w_]", "")
    return u266
end

local function u267(u265)
    local u268
    
    if u265 == "?" then
        u268 = "default"
    else
        u268 = u264(u265)
    end
    if not u268 or u268 == "" then return nil end
    if u263[u268] ~= nil then return u263[u268] end
    local u269= "require/features/misc/res_" .. u268
    local u270, u271= pcall(require, u269)
    if u270 and type(u271) == "table" then
        u263[u268] = u271
        return u271
    end
    u263[u268] = false
    return nil
end



function M.process_entity(u272,u265,u273)
    local u270, u274= pcall(function()
        if not u272 or u272 == 0 then return end
        if not u265 or u265 == "?" then return end

        local u271= u267(u265)
        if not u271 then return end

        
        local u275= _G.player_resolver_state[u272]
        if not u275 then
            u275 = {}
            _G.player_resolver_state[u272] = u275
        end

        if type(u271.run) == "function" then
            
            pcall(function() u271.run(u272, u273 or {}, u275, u265) end)
        elseif type(u271.process) == "function" then
            pcall(function() u271.process(u272, u273 or {}, u275, u265) end)
        end
    end)
    return u270
end


u262._modules = u263
u262._sanitize_label = u264

return u262
]]
u743["require/features/misc/res_default"] = [[local u265= {}

local function u266(u267)
    pcall(function()
        if plist and type(plist.set) == "function" then
            
            plist.set(u267, "Force body yaw", false)
            plist.set(u267, "Force body yaw value", 0)
            plist.set(u267, "Force pitch", false)
            plist.set(u267, "Force pitch value", 0)
        end
    end)
end

function M.run(u267,u268,u269,u270)
    
    if u270 ~= "?" and u270 ~= "DEFAULT" and u270 ~= "default" then return end

    u269.clears = (u269.clears or 0) + 1
    u269.last_seen = (globals and globals.curtime and globals.curtime()) or os.time()

    
    u266(u267)

    pcall(function()
        print(string.format("[res_default] ent=%d cleared_forces label=%s count=%d", u267, tostring(u270), u269.clears))
    end)
end

return u265
]]
u743["require/features/misc/res_static"] = [=[local M = {}
local ok_ffi, ffi = pcall(require, "ffi")
local ok_bit, bit = pcall(require, "bit")


local get_entity_ptr
local function init_ffi_helpers()
    if not ok_ffi or not client or not client.create_interface then return end
    local status, res = pcall(function()
        local pointer_type = ffi.typeof("void***")
        local entity_list_ptr = client.create_interface("client.dll", "VClientEntityList003")
        if not entity_list_ptr then return nil end
        local entity_list = ffi.cast(pointer_type, entity_list_ptr)
        local get_client_entity = ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
        return function(entindex)
            if not entindex or entindex == 0 then return nil end
            local ptr = get_client_entity(entity_list, entindex)
            if ptr == nil then return nil end
            return ptr
        end
    end)
    if status and type(res) == "function" then
        get_entity_ptr = res
    else
        get_entity_ptr = nil
    end
end
init_ffi_helpers()

local function get_speed2d(ent)
    
    local ok, vx, vy = pcall(function()
        local x,y,z = entity.get_prop(ent, "m_vecVelocity")
        return x or 0, y or 0
    end)
    if ok and vx and vy then
        return math.sqrt((vx or 0)*(vx or 0) + (vy or 0)*(vy or 0))
    end
    return 0
end

local function estimate_max_desync_ent(ent)
    
    if not ok_ffi or not get_entity_ptr then return nil end
    local ok_read, result = pcall(function()
        ffi.cdef[[
        struct c_animstate {
            char pad0[3];
            char m_bForceWeaponUpdate;
            char pad1[91];
            void* m_pBaseEntity;
            void* m_pActiveWeapon;
            void* m_pLastActiveWeapon;
            float m_flLastClientSideAnimationUpdateTime;
            int m_iLastClientSideAnimationUpdateFramecount;
            float m_flAnimUpdateDelta;
            float m_flEyeYaw;
            float m_flPitch;
            float m_flGoalFeetYaw;
            float m_flCurrentFeetYaw;
            float m_flCurrentTorsoYaw;
            float m_flUnknownVelocityLean;
            float m_flLeanAmount;
            char pad2[4];
            float m_flFeetCycle;
            float m_flFeetYawRate;
            char pad3[4];
            float m_fDuckAmount;
            float m_fLandingDuckAdditiveSomething;
            char pad4[4];
            float m_vOriginX;
            float m_vOriginY;
            float m_vOriginZ;
            float m_vLastOriginX;
            float m_vLastOriginY;
            float m_vLastOriginZ;
            float m_vVelocityX;
            float m_vVelocityY;
            char pad5[4];
            float m_flUnknownFloat1;
            char pad6[8];
            float m_flUnknownFloat2;
            float m_flUnknownFloat3;
            float m_flUnknown;
            float m_flSpeed2D;
            float m_flUpVelocity;
            float m_flSpeedNormalized;
            float m_flFeetSpeedForwardsOrSideWays;
            float m_flFeetSpeedUnknownForwardOrSideways;
            float m_flTimeSinceStartedMoving;
            float m_flTimeSinceStoppedMoving;
            bool m_bOnGround;
            bool m_bInHitGroundAnimation;
            char pad7[2];
            float m_flTimeSinceInAir;
            float m_flLastOriginZ;
            float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
            float m_flStopToFullRunningFraction;
            float m_flMagicFraction;
            char pad8[60];
            float m_flWorldForce;
            char pad9[462];
            float m_flMaxYaw;
        };
        ]]
        local ent_ptr = get_entity_ptr(ent)
        if not ent_ptr then return nil end
        local animstate_ptr = ffi.cast("struct c_animstate**", ffi.cast("uintptr_t", ent_ptr) + 0x9960)
        if animstate_ptr == nil or animstate_ptr == ffi.NULL then return nil end
        local anim = animstate_ptr[0]
        if anim == nil or anim == ffi.NULL then return nil end

        local duck_amount = tonumber(anim.m_fDuckAmount) or 0
        local speed2d_norm = tonumber(anim.m_flFeetSpeedForwardsOrSideWays) or 0
        local stop_to_full = tonumber(anim.m_flStopToFullRunningFraction) or 0
        local max_yaw = tonumber(anim.m_flMaxYaw) or 0

        local yaw_modifier = ((-0.3 * stop_to_full) - 0.2) * math.max(0, math.min(speed2d_norm, 1)) + 1.0
        if duck_amount > 0 then
            yaw_modifier = yaw_modifier + (duck_amount * 0.5) * (0.5 - yaw_modifier)
        end

        local raw_delta = max_yaw * yaw_modifier
        local velocity = get_speed2d(ent) or 0
        local velocity_clamped = math.min(math.max(velocity, 0), 260)
        local move_scale = 1.0 - (velocity_clamped / 260)
        move_scale = 0.35 + (move_scale * 0.65)
        local delta = raw_delta * move_scale
        if velocity >= 250 then
            delta = math.min(delta, 28)
        end
        local flags = nil
        if ok_bit and entity and entity.get_prop then
            flags = entity.get_prop(ent, "m_fFlags") or 0
        end
        local on_ground = true
        if flags then on_ground = bit.band(flags, 1) == 1 end
        if not on_ground then delta = delta * 0.55 end
        if duck_amount > 0.9 then delta = delta * 0.9 end
        delta = math.max(0, math.min(delta, 60))
        return delta
    end)
    if ok_read then return result end
    return nil
end

local function safe_unset(ent)
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", false)
            plist.set(ent, "Force body yaw value", 0)
        end
    end)
end

local function now_time()
    local ok, t = pcall(function() return (globals and globals.curtime and globals.curtime()) or os.time() end)
    return ok and t or os.time()
end

local function normalize_angle(angle)
    if not angle or type(angle) ~= "number" then return 0 end
    while angle > 180 do angle = angle - 360 end
    while angle < -180 do angle = angle + 360 end
    return angle
end

local function round(n)
    return math.floor((n or 0) + 0.5)
end

function M.run(ent, features, state, label)
    
    state.count = (state.count or 0) + 1
    state.last_seen = now_time()
    if state.last_label and state.last_label ~= label then state.count = 1 end
    state.last_label = label

    
    if not label or label ~= "STATIC" then return end

    
    local required_count = 3
    if state.count < required_count then return end

    
    if features and features.shot_age and tonumber(features.shot_age) and features.shot_age <= 0.25 then
        return
    end

    
    local avg_speed = tonumber((features and features.avg_speed) or 0) or 0
    if features and features.movement and features.movement == true then return end
    if avg_speed >= 1.2 then return end

    
    local max_mag_low = 58
    local max_mag_high = 28
    local speed_cap = 250
    local t = math.min(math.max(avg_speed / speed_cap, 0), 1)
    local max_mag = max_mag_low + (max_mag_high - max_mag_low) * t

    
    local ok_est, est = pcall(function() return estimate_max_desync_ent(ent) end)
    if ok_est and est and type(est) == "number" then
        max_mag = math.min(max_mag, est)
    end

    
    local on_ground = true
    pcall(function()
        if ok_bit and entity and entity.get_prop then
            local flags = entity.get_prop(ent, "m_fFlags") or 0
            on_ground = bit.band(flags, 1) == 1
        end
    end)
    if not on_ground then max_mag = max_mag * 0.55 end

    
    local forced_val = 0

    
    local last_yaw = (features and features.last_yaw)
    local ref_yaw = features and (features.goal_feet_yaw or features.feet_yaw)
    local desync = nil
    if last_yaw and ref_yaw then
        desync = normalize_angle(last_yaw - ref_yaw)
    end

    
    if not desync then
        forced_val = 0
    else
        local absd = math.abs(desync)
        
        if absd <= 10 then
            forced_val = 0
        else
            
            if ok_est and est and type(est) == "number" and est >= 8 then
                local mag = math.min(math.floor(max_mag + 0.5), math.floor(est + 0.5))
                local desired = math.min(absd, mag)
                
                if desired >= 8 then
                    forced_val = (desync >= 0) and desired or -desired
                else
                    forced_val = 0
                end
            else
                
                forced_val = 0
            end
        end
    end

    
    forced_val = round(forced_val)
    if forced_val > 60 then forced_val = 60 end
    if forced_val < -60 then forced_val = -60 end

    
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", true)
            plist.set(ent, "Force body yaw value", forced_val)
            state.forced = true
            state.forced_value = forced_val
            state.cooldown = now_time() + 0.5

            if client and type(client.delay_call) == "function" then
                client.delay_call(0.6, function()
                    pcall(function()
                        local t = now_time()
                        if not state.cooldown or t > state.cooldown then
                            safe_unset(ent)
                            state.forced = nil
                            state.forced_value = nil
                        end
                    end)
                end)
            end
        end
    end)
end

return M
]=]
u743["require/features/misc/roll"] = [[local u271, u272= pcall(require, "require/abc/menu_setup")

local u273= {}
local u274= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local u275= {ui.reference(item[1], item[2], item[3])}
    u273[i] = u275
    for _, ref in ipairs(u275) do
        u274[ref] = true
    end
end

local function u276(u277)

    local u278= 0
    if u272 and u272.ui and u272.ui.fakelag_settings_roll then
        u278 = ui.get(u272.ui.fakelag_settings_roll) or 0
    end
    local u279= ui.get(u272.ui.fakelag_settings_side) or 1
    local u280= entity.get_local_player()
    local u281= u280 and entity.get_prop(u280, 'm_vecVelocity') or 0

    if u281 > 3 then
        ui.set(u273[1][1], 0)
        return
    end

    if u279 == 3 then
        ui.set(u273[1][1], -u278)
    elseif u279 == 2 then
        local u282= (globals.tickcount() % 20) < 10
        ui.set(u273[1][1], u282 and u278 or -u278)
    elseif u279 == 1 then
        ui.set(u273[1][1], u278)
    end

end

client.set_event_callback('setup_command', function(u277)

    u276(u277)

end)]]
u743["require/features/misc/spin_on_dead_enemies"] = [[local u274= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local u275= {ui.reference(item[1], item[2], item[3])}
    u274[i] = u275
end

local u276, u277, u278, u279= entity, globals, ui, client
local u280= require("require/abc/menu_setup")
local u281= (u279.random_int(1, 2) == 1) and 1 or -1

local function u282()
    local u283= {
        {2, 'Off'}, {3, 'Local view'}, {4, {'Spin', 45}}, {5, {'Off', 0}}, {6, {'Off', 0}},
    }
    local u281= (u279.random_int(1, 2) == 1) and 1 or -1
    for _, v in ipairs(u283) do
        local u284, u285= v[1], v[2]
        local u275= u274[u284]
        if not u275 then goto continue end
        if type(u285) ~= 'table' then
            pcall(u278.set, u275[1], u285)
        else
            if u275[1] then pcall(u278.set, u275[1], u285[1]) end
            if u275[2] then
                if type(u285[2]) == 'number' and u285[1] == 'Spin' then
                    pcall(u278.set, u275[2], u285[2] * u281)
                else
                    pcall(u278.set, u275[2], u285[2])
                end
            end
        end
        ::continue::
    end
end

local function u286()
    local u287= (u277.maxplayers and u277.maxplayers() or 64)
    local u288, u289, u290= u276.get_classname, u276.is_enemy, u276.is_alive
    if not (u288 and u289 and u290) then return 0 end
    local u291= 0
    for i=1,u287 do
        if u288(i) == 'CCSPlayer' and u289(i) and u290(i) then u291 = u291 + 1 end
    end
    return u291
end

local function u292()
    if not u278.get(u280.ui.misc_spindead) then return end
    if u286() == 0 then u282() end
end

local u293, u294= pcall(require, "require/abc/callbacks")
if u293 and u294 then
    u294.callback('run_command', u292, { alive_only = true, require_login = true })
end
]]
u743["require/features/misc/walkbot"] = [[local u277= require("require/abc/callbacks")
local u278= require("require/abc/menu_setup")

local u279= nil
local u280= 1
local u281= 0
local u282= 40
local u283= 30
local u284= 450
local u285= 200
local u286= 8
local u287= {150, 300}
local u288= nil
local u289= nil
local u290= nil
local u291= 0
local u292= 700
local u293= 3

local u294= {}
local u295= 3
local u296= 4
local u297= 0
local u298= nil
local u299= 0
local u300= 500
local u301= 1500
local u302= 30
local u303= {}
local u304= false

local u305= 500 
local u306= 0

local u307= {
    { name = "A", x = -445.0, y = -1997.7, z = -180.0 },
    { name = "B", x = -2032.4, y = 259.8, z = -160.0 },
    { name = "Mid", x = -350.3, y = -617.1, z = -269.2 },
}

local function u308(u309)
    if not u309 then return false end
    local u310, u311= pcall(ui.get, u309)
    if not u310 then return false end
    return u311
end

local function u312(u313)
    while u313 > 180 do u313 = u313 - 360 end
    while u313 < -180 do u313 = u313 + 360 end
    return u313
end

local function u314(u315,u316,u317,u318,u319,u320)
    local u321, u322, u323= u315-u318, u316-u319, u317-u320
    return math.sqrt(u321*u321 + u322*u322 + u323*u323)
end

local function u324(u325,u326,u327,u328,u329,u330,u331)
    local u310, u332, u333= pcall(function()
        return client.trace_line(u325, u326, u327, u328, u329, u330, u331)
    end)
    if not u310 then return nil end
    return u332, u333
end

local function u334(u325,u335,u336,u337)
    local u338= u337 + 1000
    local u339= u337 - 1000
    local u332= u324(u325, u335, u336, u338, u335, u336, u339)
    if not u332 then return u337 end
    if type(u332) ~= 'number' then return u337 end
    local u340= u338 + (u339 - u338) * u332
    return u340
end

local function u341(u325,u326,u327,u328,u329,u330,u331)
    local u332= u324(u325, u326, u327, u328, u329, u330, u331)
    if not u332 then return false end
    if u332 >= 1 then return true end
    return false
end

local function u342(u335,u336)
    return tostring(math.floor(u335/50))..":"..tostring(math.floor(u336/50))
end

local function u343(u335,u336)
    local u344= u342(u335, u336)
    u294[u344] = (u294[u344] or 0) + 1
    if u294[u344] >= u295 then
        u303[u344] = true
    end
    return u294[u344]
end

local function u345(u335,u336)
    local u344= u342(u335, u336)
    u294[u344] = nil
end

local function u346(u325)
    local u347, u348, u349= entity.get_origin(u325)
    if not u347 then return nil end
    for i=1,u283 do
        local u350= math.random()*math.pi*2
        local u351= 200 + math.random()*800
        local u329= u347 + math.cos(u350)*u351
        local u330= u348 + math.sin(u350)*u351
        local u331= u349
            local u332= u324(u325, u347, u348, u349 + 16, u329, u330, u331 + 16)
        if u332 and u332 >= 1 then
            local u352= u334(u325, u329, u330, u331)
            return { x = u329, y = u330, z = u352 }
        end
        if u332 and u332 < 1 then
            local u353= u347 + (u329-u347)*u332
            local u354= u348 + (u330-u348)*u332
            local u355= u349 + (u331-u349)*u332
            for _, r in ipairs(u287) do
                for s=0,u286-1 do
                    local u313= (s/u286) * math.pi * 2
                    local u356= u353 + math.cos(u313)*r
                    local u357= u354 + math.sin(u313)*r
                    local u358= u334(u325, u356, u357, u355)
                    local u359= u324(u325, u347, u348, u349+16, u356, u357, u358+16)
                    local u360= u324(u325, u356, u357, u358+16, u329, u330, u331+16)
                    if u359 and u359>=1 and u360 and u360>=1 then
                        local u352= u334(u325, u329, u330, u331)
                        return { x = u329, y = u330, z = u352 }
                    end
                end
            end
        end
    end
    return nil
end

local function u361(u362)
    local u363= {}
    while u362 do
        u363[#u363+1] = { x = u362.x, y = u362.y, z = u362.z }
        u362 = u362.parent
    end
    local u364= {}
    for i=#u363,1,-1 do u364[#u364+1] = u363[i] end
    return u364
end

local function u365(u325,u366)
    local u347, u348, u349= entity.get_origin(u325)
    if not u347 then return nil end
    local u367= { x = u347, y = u348, z = u349 }
    u367.z = u334(u325, u367.x, u367.y, u367.z)
    local u368= { { x = u367.x, y = u367.y, z = u367.z, parent = nil } }
    local u369= {}
    local function u370(u371)
        local u372= tostring(math.floor(u371.x/50))..":"..tostring(math.floor(u371.y/50))
        u369[u372] = true
    end
    local function u373(u371)
        local u372= tostring(math.floor(u371.x/50))..":"..tostring(math.floor(u371.y/50))
        if u303[u372] then return true end
        return u369[u372]
    end
    u370(u367)
    local u374= 0
    while #u368 > 0 and u374 < u285 do
        local u375= table.remove(u368, 1)
        u374 = u374 + 1
        local u332= u324(u325, u375.x, u375.y, u375.z+16, u366.x, u366.y, u366.z+16)
        if u332 and u332 >= 1 then
            local u376= u361(u375)
            u376[#u376+1] = { x = u366.x, y = u366.y, z = u366.z }
            return u376
        end
        if u332 and u332 < 1 then
            local u353= u375.x + (u366.x-u375.x)*u332
            local u354= u375.y + (u366.y-u375.y)*u332
            local u355= u375.z + (u366.z-u375.z)*u332
            for _, r in ipairs(u287) do
                for s=0,u286-1 do
                    local u313= (s/u286) * math.pi * 2
                    local u356= u353 + math.cos(u313)*r
                    local u357= u354 + math.sin(u313)*r
                    local u358= u334(u325, u356, u357, u355)
                    if not u373({x=u356,y=u357}) then
                        local u359= u324(u325, u375.x, u375.y, u375.z+16, u356, u357, u358+16)
                        if u359 and u359 >= 1 then
                            u370({x=u356,y=u357})
                            table.insert(u368, { x = u356, y = u357, z = u358, parent = u375 })
                        end
                    end
                end
            end
        end
    end
    return nil
end

local function u377(u378,u325,u329,u330,u331)
    local u347, u348, u349= entity.get_origin(u325)
    if not u347 then return end
    
    local u321, u322= u329 - u347, u330 - u348
    local u379= math.sqrt(u321*u321 + u322*u322)
    if u379 <= 0 then return end
    local u380, u381= u321 / u379, u322 / u379
    local u382= 64
    local u326= u347 + u380 * u382
    local u327= u348 + u381 * u382
    local u328= u349

    
    local u383, u384= client.camera_angles()
    local u350= math.deg(math.atan2(u322, u321))
    local u385= u312(u350 - u384)
    local u386= math.rad(u385)
    local u387= math.cos(u386) * u284
    local u388= -math.sin(u386) * u284

    
    local u389, u390, u391= client.eye_position()
    if not u389 then u389, u390, ez = u347, u348, u349 end
    if type(u389) == 'table' then u389, u390, ez = u389[1], u389[2], u389[3] end
    local u392= u347 + u380 * 24
    local u393= u348 + u381 * 24
    local u394= u349 + 16
    local u395= u324(u325, u389, u390, u391, u392, u393, u394)
    if u395 and u395 < 1 then
        
        if u304 then pcall(client.log, "move_towards: short forward blocked, sidestep") end
        pcall(function() u378.forwardmove = 0; u378.sidemove = -u284 end)
        local u396= u347 - u381 * u382
        local u397= u348 + u380 * u382
        local u398= u324(u325, u347, u348, u349 + 16, u396, u397, u328 + 16)
        if u398 and u398 >= 1 then return end
        pcall(function() u378.forwardmove = 0; u378.sidemove = u284 end)
        local u399= u347 + u381 * u382
        local u400= u348 - u380 * u382
        local u401= u324(u325, u347, u348, u349 + 16, u399, u400, u328 + 16)
        if u401 and u401 >= 1 then return end
        
        pcall(function() u343(u329, u330); u281 = client.timestamp() + 250 end)
        u279 = nil
        return
    end

    
    pcall(function()
        u378.forwardmove = u387
        u378.sidemove = u388
    end)

    if u304 then pcall(client.log, string.format("move_towards: fwd=%.1f side=%.1f yaw_diff=%.1f", u387, u388, u385)) end

    local u332= u324(u325, u347, u348, u349 + 16, u326, u327, u328 + 16)
    if u332 and u332 < 1 then
        
        if u304 then pcall(client.log, "move_towards: forward blocked, attempting sidestep") end
        
        pcall(function() u378.forwardmove = 0; u378.sidemove = -u284 end)
        local u396= u347 - u381 * u382
        local u397= u348 + u380 * u382
        local u398= u324(u325, u347, u348, u349 + 16, u396, u397, u328 + 16)
        if u398 and u398 >= 1 then return end
        
        pcall(function() u378.forwardmove = 0; u378.sidemove = u284 end)
        local u399= u347 + u381 * u382
        local u400= u348 - u380 * u382
        local u401= u324(u325, u347, u348, u349 + 16, u399, u400, u328 + 16)
        if u401 and u401 >= 1 then return end
        
        pcall(function()
            u343(u329, u330)
            u281 = client.timestamp() + 250
        end)
        u279 = nil
        return
    end
end

u277.register("setup_command", function(u378)
    local u310, u402= pcall(function()
        if not u308(u278.ui.misc_walkbot) then return end
        local u325= entity.get_local_player()
        if not u325 or not entity.is_alive(u325) then return end
        local u403= client.timestamp()
        if u403 < u281 then return end

        
        do
            local u404= client.timestamp()
            if u404 - u306 >= u305 then
                local u405, u406, u407= entity.get_origin(u325)
                if u405 then
                    pcall(function()
                        client.log(string.format("walkbot_coord: %.1f %.1f %.1f", u405, u406, u407))
                    end)
                    u306 = u404
                end
            end
        end
        if client.key_state(87) or client.key_state(65) or client.key_state(83) or client.key_state(68) or client.key_state(32) or client.key_state(16) or client.key_state(17) then
            u281 = u403 + 500
            return
        end
        
        do
            local u408= entity.get_players(true) or {}
            for i=1,#u408 do
                local u409= u408[i]
                local u405, u406, u407= entity.get_origin(u409)
                if u405 then
                    local u410= pcall(function() return client.visible(u405, u406, u407) end)
                    if u410 and client.visible(u405, u406, u407) then
                        pcall(function()
                            local u411= u378.buttons or 0
                            u378.buttons = bit.bor(u411, 4) 
                        end)
                        break
                    end
                end
            end
        end
        
        local u347, u348, u349= entity.get_origin(u325)
        if u347 then
            local u408= entity.get_players(true) or {}
            if #u408 > 0 then
                if not u288 or not entity.is_alive(u288) or entity.is_dormant(u288) then
                    
                    local u412= {}
                    for i=1,#u408 do
                        local u409= u408[i]
                        local u405, u406, u407= entity.get_origin(u409)
                        if u405 then
                            local u413= u314(u347, u348, u349, u405, u406, u407)
                            u412[#u412+1] = { ent = u409, dist = u413 }
                        end
                    end
                    table.sort(u412, function(u313,u411) return u313.dist < u411.dist end)
                    if #u412 > 0 then
                                u288 = u412[1].ent  
                        u279 = nil
                        u280 = 1
                    end
                end
            else
                u288 = nil
            end
        end

        
        if u288 and entity.is_alive(u288) and not entity.is_dormant(u288) then
            local u329, u330, u331= entity.get_origin(u288)
            if u329 then
                local u352= u334(u325, u329, u330, u331)
                u289 = { x = u329, y = u330, z = u352 }
            else
                u288 = nil
                u289 = nil
            end
        else
            u288 = nil
            u289 = nil
        end

        
        do
            local u403= client.timestamp()
            if u347 then
                if not u298 then
                    u298 = { x = u347, y = u348, z = u349 }
                    u299 = u403
                else
                    if u403 - u299 >= u300 then
                        local u414= u314(u298.x, u298.y, u298.z, u347, u348, u349)
                        if u414 >= u302 then
                            
                            u297 = 0
                            u298 = { x = u347, y = u348, z = u349 }
                            u299 = u403
                        else
                            
                            if u403 - u299 >= u301 then
                                u297 = u297 + 1
                                u279 = nil
                                u281 = u403 + 300
                                u298 = { x = u347, y = u348, z = u349 }
                                u299 = u403
                                if u297 >= u296 then
                                    
                                    u288 = nil
                                    u289 = nil
                                    u297 = 0
                                end
                            end
                        end
                    end
                end
            end
        end

        if u289 then
            local u403= client.timestamp()
            local u415= (not u279) or (u403 > u291)
            if not u290 then u415 = true end
            if u290 and u289 and u314(u290.x, u290.y, u290.z, u289.x, u289.y, u289.z) > 100 then
                u415 = true
            end
            if u415 then
                local u409= u365(u325, u289)
                if u409 then
                    u279 = u409
                    u280 = 1
                    u291 = client.timestamp() + u292
                    u290 = { x = u289.x, y = u289.y, z = u289.z }
                else
                    
                    u288 = nil
                    u289 = nil
                    u279 = nil
                end
            end
        else
            if not u279 then
                local u416= u346(u325)
                
                if not u416 and #u307 > 0 then
                    local u417= u307[ math.random(1, #u307) ]
                    if u417 then u416 = { x = u417.x, y = u417.y, z = u417.z } end
                end
                if u416 then
                    local u409= u365(u325, u416)
                    if u409 then
                        u279 = u409
                        u280 = 1
                    else
                        
                        u279 = nil
                    end
                end
            end
        end
        if not u279 then return end
        local u347, u348, u349= entity.get_origin(u325)
        if not u347 then return end
        local u418= u279[u280+1] or u279[#u279]
        if not u418 then u279 = nil return end
        local u413= u314(u347, u348, u349, u418.x, u418.y, u418.z)
        if u413 <= u282 then
            u280 = u280 + 1
            
            u345(u418.x, u418.y)
            if u280 >= #u279 then u279 = nil return end
            return
        end
        do
            local u419= false
            if u288 and u289 then
                local u329, u330, u331= u289.x, u289.y, u289.z
                local u351= u314(u347, u348, u349, u329, u330, u331)
                if u351 > 1000 then
                    
                end
            end
            if not u419 then
                u377(u378, u325, u418.x, u418.y, u418.z)
            end
        end
    end)
    if not u310 then pcall(client.error_log, "walkbot error: "..tostring(u402)) end
end)

u277.register("paint", function()
    if not u308(u278.ui.misc_walkbot) then return end
    if not u279 or #u279 == 0 then return end
    local u325= entity.get_local_player()
    if not u325 then return end
    local u347, u348, u349= entity.get_origin(u325)
    if not u347 then return end
    local u420, u421, u422= u347, u348, u349
    u422 = u334(u325, u420, u421, u422)
    local u405, u406= renderer.world_to_screen(u420, u421, u422)
    for i=u280, #u279 do
        local u364= u279[i]
        if not u364 then break end
        local u423= u334(u325, u364.x, u364.y, u364.z)
        local u326, u327= renderer.world_to_screen(u364.x, u364.y, u423)
        if u326 and u327 and u405 and u406 then
            renderer.line(u405, u406, u326, u327, 255, 180, 0, 200)
            renderer.rectangle(u326-3, u327-3, 6, 6, 255, 80, 0, 200)
        end
        u405, py = u326, u327
    end
end)

return true
]]
u743["require/features/paint/aimbot_logs"] = [[local u280= require("require/abc/menu_setup")
local u281= require("require/abc/screen_logger")


local u282= nil
pcall(function() u282 = require('require/abc/callbacks') end)
if not u282 then error("callbacks manager required: require/abc/callbacks") end
local u283= {}
local u284= {}

local function u285()
	local u286= u280.ui.paint_aimbot_logs
	if not u286 then return false end
	local u287= ui.get(u286)
	if type(u287) == "string" then
		return u287 ~= "off"
	end
	return false
end

local function u288()
	local u286= u280.ui.paint_aimbot_logs
	if not u286 then return "gamesense" end
	local u287= ui.get(u286)
	if type(u287) == "table" then
		for _, v in ipairs(u287) do
			if v == "gamesense beta" then return "gamesense beta" end
			if v == "sodium" then return "sodium" end
			if v == "gamesense" then return "gamesense" end
		end
	elseif type(u287) == "string" then
		return u287
	end
	return "gamesense"
end

local u289= require("require/help/enemies")
local u290= require("require/abc/push_logger")
local u291= require("require/help/safe")

local u292, u293= pcall(require, "require/features/misc/collect")


local function u294(u295)
	if not u295 or u295 == 0 then return 0 end
	
	if u292 and u293 then
		local u296, u297= pcall(function()
			return u293.get_goal_feet_yaw(u295) or u293.get_feet_yaw(u295) or u293.get_lower_body_yaw(u295)
		end)
		if u296 and u297 and u297 ~= 0 then return u297 end
	end
	
	local u298, u299, u300, u301= pcall(function() return entity.get_prop(u295, "m_angAbsRotation") end)
	if u298 and u299 then
		if type(u299) == "table" then
			return u299[2] or 0
		else
			return u300 or 0
		end
	end
	
	local u302, u303= pcall(function() return entity.get_prop(u295, "m_flLowerBodyYawTarget") end)
	if u302 and u303 then return u303 end
	return 0
end


local function u304(u295)
	local u296, u305= pcall(function() return _G.player_labels end)
	if not u296 or type(u305) ~= "table" then return nil end
	local u306, u307= pcall(function() return u305[u295] end)
	if not u306 then return nil end
	return u307
end


local function u308()
	local u296, u309, u310, u311= pcall(function() return client.camera_angles() end)
	if not u296 then return nil, nil, nil end
	return u309 or 0, u310 or 0, u311 or 0
end


local function u312(u295)
	if not u295 or u295 == 0 then return nil, nil, nil end
	local u296, u313, u314, u315= pcall(function() return entity.get_prop(u295, "m_angAbsRotation") end)
	if not u296 then return nil, nil, nil end
	
	if type(u313) == "table" then
		return u313[1] or 0, u313[2] or 0, u313[3] or 0
	else
		return u313 or 0, u314 or 0, u315 or 0
	end
end

local function u316(u317)
	local u286= u280.ui.paint_logger
	if not u286 then return false end
	local u287= u291.safe_get(u286)
	if type(u287) == 'table' then
		for _, v in ipairs(u287) do
			if v == u317 then return true end
		end
		return false
	elseif type(u287) == 'string' then
		return u287 == u317
	end
	return false
end

local function u318(u319,u320,u310,u309) return string.format("\a%02x%02x%02x%02x", u319 or 255, u320 or 255, u310 or 255, u309 or 255) end
local function u321(u322,u319,u320,u310,u309)
	if not u322 or u322 == "" then return u322 end
	local u323= u318(u319,u320,u310,u309)
	local u324= u318(255,255,255,255)
	local u325= "([-+]?%d+%.?%d*%%?)"
	local u296, u326= pcall(function()
		return (u322:gsub(u325, function(u327)
			return u323 .. u327 .. u324
		end))
	end)
	if u296 and u326 then return u326 end
	return u322
end

local function u328(u322)
	if not u322 then return "" end
	return u322:gsub("([%^%$%(%)%%.%[%]%*%+%-%?])", "%%%1")
end

local function u329(u330,u331,u319,u320,u310,u309)
	if not u330 or u330 == "" then return u330 end
	if not u331 or u331 == "" then
		return u321(u330, u319,u320,u310,u309)
	end
	
	local u332, u333= u330:find(u331, 1, true)
	if not u332 then
		
		return u321(u330, u319,u320,u310,u309)
	end
	local u334= u330:sub(1, u332 - 1)
	local u335= u330:sub(u332, u333)
	local u336= u330:sub(u333 + 1)
	local u337= u321(u334, u319,u320,u310,u309)
	local u338= u321(u336, u319,u320,u310,u309)
	local u323= u318(u319,u320,u310,u309)
	local u324= u318(255,255,255,255)
	local u339= u323 .. u335 .. u324
	return (u337 or "") .. u339 .. (u338 or "")
end
local function u340(u341,u342,u343,u344)
	local u345= u341.target_name or "?"
	local u346= u341.hitgroup_name or "?"
	local u347= (u344 and u344.damage) or u341.damage or 0
	local u348= u341.damage or u347
	local u349= u347 - u348
	local u350
	if u347 == u348 then
		u350 = string.format("%d dmg", u347)
	elseif u349 < 0 then
		u350 = string.format("%d(-%d) dmg", u347, math.abs(u349))
	else
		u350 = string.format("%d(+%d) dmg", u347, u349)
	end
	local u351= (u342 == "gamesense" and u344 and u344.health) or u341.health or 0
	local u331= u344 and u344.reason or ""

	local u352= u341.backtrack_ticks or (u344 and u344.backtrack_ticks) or 0
	if u352 == 0 then
		local u353, u354= pcall(function() return globals.tickcount() end)
		if u353 and u341.tick then
			u352 = math.max(0, u354 - (u341.tick or u354))
		end
	end
	local u355= u341.backtrack or (u344 and u344.backtrack) or 0
	if u355 == 0 and u352 and u352 > 0 then
		local u356, u357= pcall(function() return globals.tickinterval() end)
		local u358= (u356 and u357) or 0
		u355 = math.floor(u352 * u358 * 1000)
	end
	if u355 == 0 and u341.time then
		local u359, u360= pcall(function() return globals.realtime() end)
		if u359 and u360 and u341.time then
			u355 = math.floor((u360 - u341.time) * 1000)
		end
	end
	local u361= u344 and u344.hitchance or u341.hitchance or "hehe"
	local u362= u341.safepoint or false
	local u363= u341.tick or 0
	local u364= u341.time or globals.realtime()
	local u365= u341.move or 0
	local u366= u341.t or 0
	local u367= (u344 and u344.boneyaw) or u294(u341.target) or 0
	local u368= (u344 and u344.resolver) or u304(u341.target) or "?"
	u368 = tostring(u368):lower()
	local u369, u370= u308()
	local u371, u372= u312(u341.target)
	local u373= u341.id or 0
	if u342 == "gamesense beta" then
		if u343 == "hit" then
			return string.format("[+] Hit %s's %s for %s (%d%%) bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				u345, u346, u350, u361, u355, u352,
				u370 or 0, u369 or 0, u372 or 0, u371 or 0, u365, u366, u367)
		else
			return string.format("[-] Missed %s's %s for %s (%d%%) due to %s bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				u345, u346, u350, u361, u331, u355, u352,
				u370 or 0, u369 or 0, u372 or 0, u371 or 0, u365, u366, u367)
		end
	elseif u342 == "gamesense" then
		if u343 == "hit" then
			return string.format("[gamesense] Hit %s's %s for %s (%d%%) (%dhp remaining)",
				u345, u346, u350, u361, u351)
		else
			return string.format("[gamesense] Missed %s's %s for %s (%d%%) reason=%s",
				u345, u346, u350, u361, u331)
		end
	elseif u342 == "sodium" then
		if u343 == "hit" then
			return string.format("hit %s's %s for %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				u345, u346, u350, u361, u355, u368, u367)
		else
			return string.format("missed %s's %s due to %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				u345, u346, u331, u361, u355, u368, u367)
		end
	else
		if u343 == "hit" then
			return string.format("a",
				u345, u346, dmg, u361, u365, u366, u367)
		else
			return string.format("b",
				u345, u346, dmg, u361, u331, u365, u366, u367)
		end
	end
end

u282.register('aim_fire', function(u374)

	if not u285() then return end
	
	u284[u374.id] = {
		id = u374.id,
		target = u374.target,
		target_name = entity.get_player_name(u374.target or 0),
		hitgroup = u374.hitgroup,
		hitgroup_name = u374.hitgroup and ({"head","chest","stomach","left arm","right arm","left leg","right leg"})[u374.hitgroup] or "?",
		damage = u374.damage,
		health = u374.health,
		backtrack = (u374.backtrack or 0) * globals.tickinterval() * 1000,
		backtrack_ticks = u374.backtrack or 0,
		hitchance = u374.hit_chance or 0,
		safepoint = u374.safepoint,
		tick = globals.tickcount(),
		time = globals.realtime(),
		move = u374.move or 0,
		t = u374.t or 0,
		boneyaw = u374.boneyaw or u294(u374.target) or 0,
	}
end, { require_login = true, alive_only = true })

u282.register('aim_hit', function(u374)

	if not u285() then return end
	local u375= u284[u374.id]
	if not u375 then return end
	local u342= u288()
	local u376= entity.get_prop(u374.target, "m_iHealth") or 0
	local u367= u375.boneyaw or u294(u375.target)
	local u377= u304(u375.target)
	local u378= u340(u375, u342, "hit", {
		damage=u374.damage,
		health=u376,
		backtrack=u375.backtrack,
		backtrack_ticks=u375.backtrack_ticks,
		boneyaw=u367,
		resolver=u377
	})
	if u342 == "gamesense beta" then
		
		client.color_log(165, 202, 42, u378)
		u281(u378, 4, 165, 202, 42, 255)
	elseif u342 == "sodium" then
		local u379= u375.damage or 0
		local u380= u374.damage or u379
		local u381= u380 - u379
		if u381 == 0 then
			client.color_log(165, 202, 42, u378)
			local u382= u321(u378, 165, 202, 42, 255)
			u281(u382, 4)
		else
			client.color_log(255, 204, 51, u378)

			local u383= string.format("(%+d)", u381)
			local u384= u328(u383)
			local u334, u335, u336= u378:match("^(.-)(" .. u384 .. ")(.*)$")
			if not u334 then
				local u382= u321(u378, 165, 202, 42, 255)
				u281(u382, 4)
			else
				local u385= u321(u334, 165, 202, 42, 255)
				local u386= u321(u336, 165, 202, 42, 255)
				local u387, u388, u389
				if u381 > 0 then
					u387, u388, db = 255, 204, 51
				else
					u387, u388, db = 217, 100, 100 
				end
				local u323= u318(u387, u388, u389, 255)
				local u324= u318(255, 255, 255, 255)
				local u390= u335:sub(2, -2) or u335
				local u391= "(" .. u323 .. u390 .. u324 .. ")"
				local u382= (u385 or "") .. u391 .. (u386 or "")
				u281(u382, 4)
			end
		end
	else
		client.log(u378)
		u281(u378, 4, 255, 255, 255, 255)
	end

	
	if u316('aimbot') then
		local u345= u375.target_name or "?"
		local u392= u375.hitgroup_name or "?"
		local u393= u374.damage or 0
		local u394= u375.hitchance or 0
		local u395= string.format("Hit %s's %s for %d(%d%%)", u345, u392, u393, u394)
		u290(u395, 4, 255, 255, 255, 255)
	end

	u284[u374.id] = nil
end, { require_login = true, alive_only = true })

u282.register('aim_miss', function(u374)

	if not u285() then return end
	local u375= u284[u374.id]
	if not u375 then return end
	local u342= u288()
	local u367= u375.boneyaw or u294(u375.target)
	local u377= u304(u375.target)
	local u378= u340(u375, u342, "miss", {reason=u374.reason or "?", boneyaw=u367, resolver=u377})
		if u342 == "gamesense beta" then
			client.color_log(217, 100, 100, u378)
			u281(u378, 4, 217, 100, 100, 255)
		elseif u342 == "sodium" then
			
			local u396= u374.reason or "?"
			local u382= u329(u378, u396, 217, 100, 100, 255)
			u281(u382, 4)
			client.color_log(217, 100, 100, u378)
		else
			u281(u378, 4, 255, 255, 255, 255)
			client.log(u378)
		end

	if u316('aimbot') then
		local u345= u375.target_name or "?"
		local u392= u375.hitgroup_name or "?"
		local u393= u375.damage or 0
		local u394= u375.hitchance or 0
		local u331= u374.reason or "?"
		local u395= string.format("Missed %s's %s for %d(%d%%) due to %s", u345, u392, u393, u394, u331)
		u290(u395, 4, 255, 255, 255, 255)
	end

	u284[u374.id] = nil
end, { require_login = true, alive_only = true })]]
u743["require/features/paint/animations"] = [[


local u283= nil
pcall(function() u283 = require('require/help/safe') end)
local u284= nil
pcall(function() u284 = require('require/abc/menu_setup') end)

local u285= nil
pcall(function() u285 = require('require/abc/callbacks') end)
if not u285 then error("callbacks manager required: require/abc/callbacks") end
local u286= require("gamesense/entity") or error("You're missing a required module: gamesense/entity")


local function u287()
    local u288= entity.get_local_player()
    if not u288 then return nil, nil end
    local u289, u290= pcall(function() return u286.new(u288) end)
    if not u289 then return u288, nil end
    return u288, u290
end




local u291= {
    STRAFE_YAW = 0,
    STAND = 1,
    LEAN_YAW = 2,
    SPEED = 3,
    LADDER_YAW = 4,
    LADDER_SPEED = 5,
    JUMP_FALL = 6,
    MOVE_YAW = 7,
    MOVE_BLEND_CROUCH = 8,
    MOVE_BLEND_WALK = 9,
    MOVE_BLEND_RUN = 10,
    BODY_YAW = 11,
    BODY_PITCH = 12,
    AIM_BLEND_STAND_IDLE = 13,
    AIM_BLEND_STAND_WALK = 14,
    AIM_BLEND_STAND_RUN = 14,
    AIM_BLEND_CROUCH_IDLE = 16,
    AIM_BLEND_CROUCH_WALK = 17,
    DEATH_YAW = 18
}

local function u292(u293)
    if not u293 then return 0 end
    local u294, u295, u296= entity.get_prop(u293, 'm_vecVelocity')
    if not u294 or not u295 then
        local u297= u294
        if type(u297) == 'table' then
            u294 = u297.x or u297[1] or 0
            u295 = u297.y or u297[2] or 0
        else
            return 0
        end
    end
    return math.sqrt((u294 or 0) * (u294 or 0) + (u295 or 0) * (u295 or 0))
end

local u298= {}
local u299= {}
for i, item in ipairs({
    { 'AA', 'Other', 'Leg movement' },

}) do
    local u300= {ui.reference(item[1], item[2], item[3])}
    u298[i] = u300
    for _, ref in ipairs(u300) do
        u299[ref] = true
    end
end






local u301= require("gamesense/antiaim_funcs")


local function u302()
    local u288= entity.get_local_player()
    if not u288 then return end
    entity.set_prop(u288, "m_flPoseParameter", 1, u291.JUMP_FALL)
end

local function u303()

    if u301.get_tickbase_shifting() > 0 then
        return
    end
    
    value = 0.5
    local u288= entity.get_local_player()
    if not u288 then return end
    local u304= globals.tickcount()
    local u305= math.floor(u304 / 2) % 2
    local u306= (u305 == 0) and -0.1 or 0.9
    entity.set_prop(u288, "m_flPoseParameter", math.random(0, 10) / value, u291.SPEED)
    entity.set_prop(u288, "m_flPoseParameter", math.random(0, 10) / 10, u291.MOVE_YAW)
    entity.set_prop(u288, "m_flPoseParameter", math.random(0, 10) / 10, u291.JUMP_FALL)
end



local function u307()
    local u288, u308= u287()
    if not u288 or not u308 then return end
    local u309= u308:get_anim_state()
    local u310= u308:get_anim_overlay(12)
    entity.set_prop(u288, "m_flPoseParameter", client.random_float(0, 1), 0)
    u310.weight = client.random_float(0, 1)
    ui.set(u298[1][1], "Always slide")
end

local function u311()
    local u288, u308= u287()
    if not u288 or not u308 then return end
    local u310= u308:get_anim_overlay(12)
    u310.weight = math.random(0,10) / 10
end


local function u312()
    local u288, u308= u287()
    if not u288 or not u308 then return end
    local u309= u308:get_anim_state()
    local u310= u308:get_anim_overlay(12)
    if u310 then u310.weight = 0.999 end
end

local function u313()
    local u288, u308= u287()
    if not u288 or not u308 then return end
    local u309= u308:get_anim_state()
    if u309 and u309.hit_in_ground_animation then
        entity.set_prop(u288, "m_flPoseParameter", 0.5, u291.BODY_PITCH)
    end
end

local function u314()
    local u288, u308= u287()
    if not u288 or not u308 then return end
    local u315= u308:get_anim_overlay(6)
    entity.set_prop(u288, "m_flPoseParameter", 0, u291.MOVE_YAW)
    if u315 then u315.weight = 1 end
end

local function u316()
    local u288, u308= u287()
    if not u288 or not u308 then return end
    local u317= u308:get_anim_overlay(12)
    local u318= u308:get_anim_overlay(6)
    if u317 then u317.weight = 0 end
    if u318 then u318.weight = 1 end
end

local function u319()
    local u288= entity.get_local_player()
    if not u288 then return end
    ui.set(u298[1][1], math.random(1,2) == 1 and "Always slide" or "Never slide")
    entity.set_prop(u288, "m_flPoseParameter", 8, 0)
end


local function u320()
    local u288, u308= u287()
    if not u288 or not u308 then return end
    local u321= u308:get_anim_overlay(9)
    if u321 then
        u321.weight = 1
        u321.sequence = 224
    end
end

local function u322()
    local u288, u308= u287()
    if not u288 or not u308 then return end
    local u323= u308:get_anim_overlay(0)
    if u323 then u323.sequence = 11 end
end

local function u324()

    local u288= u287()
    if not u288 then return end
    entity.set_prop(u288, 'm_flPoseParameter', 0, u291.BODY_PITCH)
    entity.set_prop(u288, 'm_flPoseParameter', math.random(-1, 1), u291.BODY_YAW)

end




u285.register('pre_render', function()
    local u288= entity.get_local_player()
    if not u288 then return end
    local u325= u292(u288)


    local u326= nil
    if u284 and u284.ui and u284.ui.paint_animations then
        if u283 and u283.safe_get then
            u326 = u283.safe_get(u284.ui.paint_animations)
        else
            local u289, u327= pcall(function() return ui.get(u284.ui.paint_animations) end)
            if u289 then u326 = u327 end
        end
    end

    local u328= {}
    if type(u326) == 'table' then
        for _, v in ipairs(u326) do u328[v] = true end
    end

    if u328['kingaru'] and u325 > 3 then u303() end
    if u328['body lean'] and u325 > 3 then u312() end
    if u328['static legs'] and u325 > 3 then u302() end
    if u328['moonwalk'] and u325 > 3 then u314() end
    if u328['allah'] and u325 > 3 then u316() end
    if u328['no pitch on land'] and u325 > 3 then u313() end
    if u328['reversed legs'] and u325 > 3 then u319() end
    if u328['earthquake'] then u311() end
    if u328['t-pose'] then u322() end
    if u328['blind'] then u320() end
    if u328['pitch up'] then u324() end
    if u328['gamesense legs'] then u307() end
end, { require_login = true, alive_only = true })

u285.register('setup_command', function(u329)

    local u288= entity.get_local_player()
    if not u288 then return end
    local u325= u292(u288)
    if u325 < 3 then return end

    local u326= nil
    if u284 and u284.ui and u284.ui.paint_animations then
        if u283 and u283.safe_get then
            u326 = u283.safe_get(u284.ui.paint_animations)
        else
            local u289, u327= pcall(function() return ui.get(u284.ui.paint_animations) end)
            if u289 then u326 = u327 end
        end
    end

    local u328= {}
    if type(u326) == 'table' then
        for _, v in ipairs(u326) do u328[v] = true end
    end

    

end, { require_login = true, alive_only = true })]]
u743["require/features/paint/aspect_ratio"] = [[
local u286= require("require/abc/menu_setup")
local u287= require("require/help/time")
local u288= require("require/help/safe")
local u289= require("ffi")
local u290= require("require/brain/dll")
local u291= nil
pcall(function() u291 = require('require/abc/callbacks') end)

if not (u290 and u290.aspect_update) then
    error("sodiumdll aspect_update export missing")
end

local u292= u289.new("struct AspectState[1]")
local u293= u289.new("double[1]")
local u294= u289.new("int[1]")
local u295= u290.aspect_update

local function u296()
    if cvar.r_aspectratio and cvar.r_aspectratio.get_float then
        return cvar.r_aspectratio:get_float()
    end
    return nil
end

local function u297(u298)
    if cvar.r_aspectratio and cvar.r_aspectratio.set_float then
        cvar.r_aspectratio:set_float(u298)
        return true
    elseif client and client.exec then
        client.exec("r_aspectratio " .. tostring(u298))
        return true
    end
    return false
end

u291.register('paint', function()
    if not ui.is_menu_open() then return end
    local u299= u286.ui.paint_aspect_ratio
    if not u299 then return end
    local u300= u288.safe_get(u299)
    if type(u300) ~= 'number' then return end
    u295(u292, u300, u296() or 0, u287.realtime(), u293, u294)
    if u294[0] ~= 0 then
        u297(u293[0])
    end
end, { require_login = true })

client.set_event_callback('shutdown', function()
    u292[0].initialized = 0
    u292[0].original = 0
    u292[0].last = 0
    u292[0].last_update = 0
end)]]
u743["require/features/paint/bomb_esp"] = [[local u289= nil
local u290= {}
local u291= nil
local u292= 500
local u293= 1000

local u294= 1.0
local u295= true
local u296= 0.25 
local u297= 0
local u298= 2

local u299= nil
pcall(function() u299 = require('require/abc/callbacks') end)
if not u299 then error("callbacks manager required: require/abc/callbacks") end

local function u300()
    u289 = nil
end

local function u301(u302)
    if not u302 then return 650, 2275 end
    local u303= tostring(u302):lower()
    if u303:find('de_dust2') then return 500, 1750 end
    if u303:find('de_ancient') then return 650, 2275 end
    if u303:find('de_anubis') then return 450, 1575 end
    if u303:find('de_inferno') then return 620, 2170 end
    if u303:find('de_mirage') then return 650, 2275 end
    if u303:find('de_nuke') then return 650, 2275 end
    if u303:find('de_overpass') then return 650, 2275 end
    if u303:find('de_vertigo') then return 500, 1750 end
    return 650, 2275
end

local function u304(u305,u306)
    u306 = tonumber(u306) or 0
    if u306 > 0 then
        local u307= 0.5
        local u308= 0.5
        local u309= u305 * u307
        local u310= (u305 - u309) * u308
        if u310 > tonumber(u306) then
            u310 = tonumber(u306) * (1.0 / u308)
            u309 = u305 - u310
        end
        u305 = u309
    end
    return u305
end

local function u311(u312,u313,u314,u315,u316,u317,u306,u318)
    if not u312 or not u313 or not u314 or not u315 or not u316 or not u317 then return 0 end
    local u319, u320= u301(u318)
    local u321= u320 / 3.0
    local u322= u312 - u315
    local u323= u313 - u316
    local u324= u314 - u317
    local u325= math.sqrt(u322*u322 + u323*u323 + u324*u324)
    local u326= math.exp( - (u325 * u325) / (2 * u321 * u321) )
    local u305= u319 * u326
    local u327= u304(u305, u306)
    return math.floor(u327 + 0.0)
end

local function u328(u329)
    if not u329 then return "?" end
    if u329 == 454 then return "A" end
    if u329 == 455 then return "B" end
    if u329 == 0 then return "A" end
    if u329 == 1 then return "B" end
    if type(u329) == "string" then
        local u330= u329:upper()
        if u330 == "A" or u330 == "B" then return u330 end
    end
    return tostring(u329)
end

u299.register('bomb_planted', function(u331)
    local u332= u331 and u331.site

    local u333= entity.get_all("CPlantedC4") or {}
    local u334= nil
    local u335= nil

    for i = 1, #u333 do
        local u329= u333[i]
        local u336= entity.get_prop(u329, "m_flC4Blow")
        if u336 and u336 > 0 then
            u334 = u336
            u335 = u329
            break
        end
    end

    if not u334 then
        local u337= 40
        if cvar and cvar.mp_c4timer then
            local u338, u339= pcall(function()
                if type(cvar.mp_c4timer.get_float) == "function" then
                    return cvar.mp_c4timer:get_float()
                elseif type(cvar.mp_c4timer.get_int) == "function" then
                    return cvar.mp_c4timer:get_int()
                else
                    return tonumber(cvar.mp_c4timer:get_string())
                end
            end)
            if u338 and u339 and tonumber(u339) then
                u337 = tonumber(u339)
            end
        end
        u334 = globals.curtime() + (u337 or 40)
    end

    u289 = {
        site = u332,
        blow_time = u334,
        entindex = u335,
        planted_at = globals.curtime()
    }
end, { require_login = true, alive_only = true })

u299.register('bomb_defused', u300, { require_login = true, alive_only = true })
u299.register('bomb_exploded', function(u331)
    
    local u340= u289 ~= nil
    local u341= globals.curtime()
    
    local u342= nil
    local u343= entity.get_local_player()
    if u340 and u343 then
        local function u344()
            
            local u345= nil
            if u289 and u289.entindex then
                local u338, u346, u347, u321= pcall(function() return entity.get_prop(u289.entindex, "m_vecOrigin") end)
                if u338 then
                    if type(u346) == "table" then
                        u345 = u346
                    elseif u346 ~= nil and u347 ~= nil and u321 ~= nil then
                        u345 = { u346, u347, u321 }
                    end
                end
            end
            if not u345 then
                local u333= entity.get_all("CPlantedC4") or {}
                for i = 1, #u333 do
                    local u329= u333[i]
                    local u338, u346, u347, u321= pcall(function() return entity.get_prop(u329, "m_vecOrigin") end)
                    if u338 then
                        if type(u346) == "table" then
                            u345 = u346
                            break
                        elseif u346 ~= nil and u347 ~= nil and u321 ~= nil then
                            u345 = { u346, u347, u321 }
                            break
                        end
                    end
                end
            end
            if not u345 then return nil end
            local u338, u348, u349, u350= pcall(function() return client.eye_position() end)
            local u312, u313, u314
            
            local u351, u352, u353, u354= pcall(function() return entity.get_origin(u343) end)
            if u351 then
                if type(u352) == "table" then
                    if #u352 >= 3 then u312, u313, pz = u352[1], u352[2], u352[3] end
                elseif u352 ~= nil and u353 ~= nil and u354 ~= nil then
                    u312, u313, pz = u352, u353, u354
                end
            end
            
            if (not u312 or not u313 or not u314) and u338 and u348 ~= nil and u349 ~= nil and u350 ~= nil then
                u312, u313, pz = u348, u349, u350
            end
            if not u312 or not u345 or #u345 < 3 then return nil end
            local u315, u316, u317= u345[1], u345[2], u345[3]
            
            local u355, u306= pcall(function() return entity.get_prop(u343, "m_ArmorValue") end)
            u306 = tonumber(u306) or 0
            local u318= nil
            local u356, u357= pcall(function()
                if type(client.mapname) == 'function' then return client.mapname() end
                if cvar and cvar.mapname then return cvar.mapname:get_string() end
                if cvar and cvar.map then return cvar.map:get_string() end
                return nil
            end)
            if u356 then u318 = u357 end
            local u358= u311(u312, u313, u314, u315, u316, u317, u306, u318)
            local u359= math.floor((u358 * (u294 or 1.0)) + 0.5)
            return u358, u359, math.sqrt((u312-u315)^2 + (u313-u316)^2 + (u314-u317)^2)
        end
        local u360, u361, u362= u344()
        u342 = u361
    end

    
    u300()

    
    if u295 and u342 and u342 > 0 then
        local u363= 0.15
        client.delay_call(u363, function()
            local u364= globals.curtime()
            if u364 - u297 < u298 then return end
            local u365= entity.get_local_player()
            if not u365 then return end
            local u338, u366= pcall(function() return entity.get_prop(u365, "m_iHealth") end)
            u366 = tonumber(u366)
            local u367= u291
            if not u367 or not u366 then return end
            local u310= u367 - u366
            if u310 <= 0 then return end

            
            local u368= (u342 and u342 > 0) and u342 or 1
            local u369= u310 / u368
            if u369 <= 0 then return end

            
            local u370= (u294 or 1.0) * (1 + (u369 - 1) * u296)
            if u370 < 0.05 then u370 = 0.05 end
            if u370 > 10 then u370 = 10 end
            local u371= u294
            u294 = u370
            u297 = globals.curtime()
            
            pcall(function()
                client.log("[bomb_esp] auto-tuned scale %.3f -> %.3f (ratio=%.3f, predicted=%d, actual=%d)", u371, u294, u369, u342 or 0, u310)
            end)
        end)
    end
end, { require_login = true, alive_only = true })
u299.register('round_start', u300, { require_login = true, alive_only = true })
u299.register('round_start', function()
    u291 = nil
end, { require_login = true, alive_only = true })
u299.register('player_spawned', function()
    u291 = nil
end, { require_login = true, alive_only = true })


u299.register('player_hurt', function(u331)
    if not u331 then return end
    local u343= entity.get_local_player()
    if not u343 then return end
    local u372= client.userid_to_entindex(u331.userid)
    if u372 ~= u343 then return end

    
    local u373= u331.dmg_health or u331.damage or u331.hp or 0
    u373 = tonumber(u373) or 0
    if u373 <= 0 then return end

    
    local u374= string.format("-%d HP", u373)
    
    table.insert(u290, { t = globals.curtime(), text = u374 })
end, { require_login = true, alive_only = true })


u299.register('paint', function()
    local u375, u376= pcall(require, "require/abc/menu_setup")
    if not u375 or not u376 or not u376.ui then return end
    local u377, u378= pcall(ui.get, u376.ui.paint_bombwarning)
    if not u377 or not u378 then return end

    local u364= globals.curtime()

    
    local u343= entity.get_local_player()
    if u343 then
        local u338, u379= pcall(function() return entity.get_prop(u343, "m_iHealth") end)
        u379 = tonumber(u379)
        if u379 then
            if u291 == nil then
                u291 = u379
            else
                if u379 < u291 then
                    local u373= u291 - u379
                    table.insert(u290, { t = u364, text = string.format("-%d HP", u373) })
                end
                u291 = u379
            end
        end
    else
        u291 = nil
    end

    
    for i = #u290, 1, -1 do
        local u380= u290[i]
        local u381= u364 - u380.t
        local u382= 1.4
        if u381 >= u382 then
            table.remove(u290, i)
        else
            local u383= math.floor(255 * (1 - (u381 / u382)))
            if u383 < 0 then u383 = 0 end
            
            renderer.indicator(255, 210, 0, u383, u380.text)
        end
    end

    
    if u289 then
        local u343= entity.get_local_player()
        local u345= nil
        if u289.entindex then
            local u338, u346, u347, u321= pcall(function() return entity.get_prop(u289.entindex, "m_vecOrigin") end)
            if u338 then
                if type(u346) == "table" then
                    u345 = u346
                elseif u346 ~= nil and u347 ~= nil and u321 ~= nil then
                    u345 = { u346, u347, u321 }
                end
            end
        end
        
        if not u345 then
            local u333= entity.get_all("CPlantedC4") or {}
            for i = 1, #u333 do
                local u329= u333[i]
                local u338, u346, u347, u321= pcall(function() return entity.get_prop(u329, "m_vecOrigin") end)
                if u338 then
                    if type(u346) == "table" then
                        u345 = u346
                        break
                    elseif u346 ~= nil and u347 ~= nil and u321 ~= nil then
                        u345 = { u346, u347, u321 }
                        break
                    end
                end
            end
        end

        if u345 and u343 then
            local u312, u313, u314= nil, nil, nil
            local u338, u348, u349, u350= pcall(function() return client.eye_position() end)
            if u338 and u348 ~= nil and u349 ~= nil and u350 ~= nil then
                u312, u313, pz = u348, u349, u350
            else
                local u351, u352, u353, u354= pcall(function() return entity.get_origin(u343) end)
                if u351 then
                    if type(u352) == "table" then
                        if #u352 >= 3 then u312, u313, pz = u352[1], u352[2], u352[3] end
                    elseif u352 ~= nil and u353 ~= nil and u354 ~= nil then
                        u312, u313, pz = u352, u353, u354
                    end
                end
            end

            if u312 and u345 and #u345 >= 3 then
                local u315, u316, u317= u345[1], u345[2], u345[3]
                
                local u355, u306= pcall(function() return entity.get_prop(u343, "m_ArmorValue") end)
                u306 = tonumber(u306) or 0
                local u356, u357= pcall(function()
                    if type(client.mapname) == 'function' then return client.mapname() end
                    if cvar and cvar.mapname then return cvar.mapname:get_string() end
                    if cvar and cvar.map then return cvar.map:get_string() end
                    return nil
                end)
                local u318= u356 and u357 or nil
                local u360= u311(u312, u313, u314, u315, u316, u317, u306, u318)
                local u384= math.floor((u360 * (u294 or 1.0)) + 0.5)

                
                renderer.indicator(255, 210, 0, 255, string.format("-%d HP", u384))
            end
        end
    end

    
    if u289 then
        
        if u289.entindex then
            local u336= entity.get_prop(u289.entindex, "m_flC4Blow")
            if u336 and u336 > 0 then
                u289.blow_time = u336
            end
        end

        local u385= (u289.blow_time or 0) - u364
        if u385 <= 0 then
            u289 = nil
            return
        end

        local u386= u328(u289.site)
        local u374= string.format("%s - %.1fs", u386, u385)
        renderer.indicator(255, 255, 255, 255, u374)
    end
end, { require_login = true, alive_only = true })]]
u743["require/features/paint/bullet_tracer"] = [[local u292= require("ffi")
local u293= require('require/help/time')
local u294= nil
local u295= require('require/help/self')
pcall(function() u294 = require('require/help/safe') end)
pcall(function() DLL = require('require/brain/dll') end)
pcall(function() menu_setup = require('require/abc/menu_setup') end)
pcall(function() cb = require('require/abc/callbacks') end)

local u296= 10
local u297= 7.0
local u298= {255,255,255,255}
local u299= 0.05
local u300= 8192

if not (DLL and DLL.tracer_reset and DLL.tracer_push_shot and DLL.tracer_set_impact and DLL.tracer_collect) then return end
DLL.tracer_reset()

local u301= 7
local u302= u292.new("double[?]", u296 * u301)

local u303= u293.realtime

cb.register('weapon_fire', function(u304)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if u295.index() ~= client.userid_to_entindex(u304.userid) then return end
    local u305= u295.weapon()
    if u305 then
        local u306= entity.get_classname(u305) or ""
        local u307= u306:lower()
        if u307:find("knife") or u307:find("grenade") or u307:find("decoy") or u307:find("molotov") or u307:find("flash") or u307:find("smoke") or u307:find("taser") or u307:find("zeus") then
            return
        end
    end

    local u308,u309,u310= client.eye_position()
    if not u308 then u308,u309,sz = entity.get_origin(u295.index()) end
    u308,u309,sz = tonumber(u308) or 0, tonumber(u309) or 0, tonumber(u310) or 0
    DLL.tracer_push_shot(u308, u309, u310, u303())
end, { require_login = true, alive_only = true })
 
cb.register('bullet_impact', function(u304)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if u295.index() ~= client.userid_to_entindex(u304.userid) then return end
    local u311,u312,u313= tonumber(u304.x) or 0, tonumber(u304.y) or 0, tonumber(u304.z) or 0
    DLL.tracer_set_impact(u311, u312, u313, u303())
end, { require_login = true, alive_only = true })

if not cb then error("callbacks manager required: require/abc/callbacks") end

cb.register('paint', function()
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    local u314= u303()
    local u315= { client.camera_angles() }
    local u316= DLL.tracer_collect(u314, u297, u299, u315[1] or 0, u315[2] or 0, u300, u298[4] or 255, u302, u296)
    for i=0, (u316 or 0)-1 do
        local u317= i * u301
        local u308, u309, u310= u302[u317], u302[u317 + 1], u302[u317 + 2]
        local u318, u319, u320= u302[u317 + 3], u302[u317 + 4], u302[u317 + 5]
        local u321= u302[u317 + 6]
        local u322,u323= renderer.world_to_screen(u308, u309, u310)
        local u324,u325= renderer.world_to_screen(u318, u319, u320)
        if u322 and u324 then
            renderer.line(u322, u323, u324, u325, u298[1], u298[2], u298[3], u321)
        end
    end
end, { require_login = true, alive_only = true })]]
u743["require/features/paint/clantag"] = [[local u295=require("require/abc/menu_setup")
local u296=require("require/help/safe")
local u297=require("require/help/string")
local u298=require("require/help/time")
local u299=require("require/brain/dll")
local u300=require("ffi")
local u301=pcall
local u302=ui.reference
local u303=ui.set
local u304=client.set_clan_tag
local u305, u306= pcall(require, "require/abc/callbacks")
if not u305 or not u306 then error("require/abc/callbacks is required by clantag.lua") end
if not u299 or type(u299) ~= "table" or not u299.clantag_anim then return end

local u307=64
local u308=u300.new("char[?]",u307)
local u309,u310,u311=nil,0,nil
local function u312(u313)
    local u314={{"MISC","Misc","Clantag spammer"},{"MISC","Miscellaneous","Clantag spammer"},{"MISC","Misc","Clan tag spammer"},{"MISC","Miscellaneous","Clan tag spammer"},{"MISC","Misc","Clantag spamer"},{"MISC","Miscellaneous","Clantag spamer"}}
    for _,v in ipairs(u314) do
        local u315,u316=u301(u302,v[1],v[2],v[3])
        if u315 and u316 and u301(u303,u316,u313) then return true end
    end
    return false
end
local u317=function() return u312(true) end
local u318=function() return u312(false) end
u306.register('paint', function()
    local u316=u295.ui.paint_clantag if not u316 then return end
    local u319=u296.safe_get(u316) if type(u319)~='string' then return end
    local u320=u297.lower(u319) if u320==u309 and u320~='sodium' and u310==0 then return end
    if u320=='off' then u318(); u310=3; u301(u304," ")
    elseif u320=='gamesense' then if not u317() then u301(u304,"gamesense") end
    elseif u320 == 'sodium' then
        u318()

        if not u311 or type(u311) ~= 'table' or not u311.start then
            u311 = { start = u298.realtime() }
        end

        local u321= u298.realtime() or 0
        u300.fill(u308, u307, 0)
        local u322= u299.clantag_anim(u311.start or 0, u321, u308, u307)
        if u322 and u322 ~= 0 then
            u301(u304, u300.string(u308))
        else
            u301(u304, "")
        end
    end
    if u310>0 then u301(u304,"") u310=u310-1 end
    u309=u320
end, { require_login = true })]]
u743["require/features/paint/custom_scope"] = [[]]
u743["require/features/paint/damage"] = [[local u301= require("require/abc/menu_setup")
local u302= require("require/brain/api/vector/vector")
local u303= { shots = {}, last = 0 }


local u304= 5
local u305= 3
local u306= 10

local function u307()
	local u308= 0
	for i = 1, #u303.shots do
		local u309= u303.shots[i]
		if u309 and u309.impacts then u308 = u308 + #u309.impacts end
	end
	return u308
end

local function u310()
	while u307() > u306 do
		
		if #u303.shots == 0 then break end
		local u311= false
		for si = 1, #u303.shots do
			local u309= u303.shots[si]
			if u309 and u309.impacts and #u309.impacts > 0 then
				table.remove(u309.impacts, 1)
				u311 = true
				
				if #u309.impacts == 0 then
					table.remove(u303.shots, si)
				end
				break
			else
				
				table.remove(u303.shots, si)
				u311 = true
				break
			end
		end
		if not u311 then break end
	end
end

local function u312()
	local u313= u301.ui.paint_hitmarker
	if not u313 then return false end
	local u314= ui.get(u313)
	if type(u314) == "table" then
		for _, v in ipairs(u314) do
			if v == "damage" then return true end
		end
	end
	return false
end

local u315, u316= pcall(require, "require/abc/callbacks")
local function u317(u318)
	if not u312() then u303 = { shots = {}, last = 0 } return end
	if not u312() then return end
	local u319= entity.get_local_player()
	if not u319 then return end
	local u320= u318.target or u318.target_index
	if type(u320) ~= 'number' or u320 == 0 or not entity.is_enemy(u320) then return end
	local u321= u318.damage or 0
	local u322= u318.hitgroup == 1
	local u323= u318.health == 0
	local u324, u325, u326= entity.hitbox_position(u320, u318.hitgroup or 'head')
	if not u324 then u324, u325, z = entity.get_origin(u320) end
	if not u324 then return end
	local u327= u302.make(u324, u325, u326)
	local u328= globals.realtime()
	local u329= {255, 255, 255}
	if u323 then u329 = {217, 100, 100} elseif u322 then u329 = {165, 202, 42} end

	local u330
	if u303.last and u328 - u303.last < 0.05 then
		u330 = u303.shots[#u303.shots]
	else
		u303.last = u328
		u330 = { impacts = {}, finished = false, t = u328 }
		u303.shots[#u303.shots + 1] = u330
		if #u303.shots > 12 then table.remove(u303.shots, 1) end
	end

	if u330 then
		u330.impacts[#u330.impacts + 1] = { dmg = u321, x = u324, y = u325, z = u326, pos = u327, t = u328, color = u329 }
		if #u330.impacts > u305 then table.remove(u330.impacts, 1) end
		
		u310()
	end
end

local function u331(u318)
	if u312() then
		local u328= globals.realtime()
		local u332= 1.4
		local u333= 32
		local u334= 1
		while u334 <= #u303.shots do
			if u328 - (u303.shots[u334].t or 0) > (u332 + 0.5) then
				table.remove(u303.shots, u334)
			else
				u334 = u334 + 1
			end
		end
		local u335= {}
		local u336= 12
		for si = #u303.shots, 1, -1 do
			local u330= u303.shots[si]
			for ii = #u330.impacts, 1, -1 do
				table.insert(u335, u330.impacts[ii])
				if #u335 >= u336 then break end
			end
			if #u335 >= u336 then break end
		end

		local u337= math.min(4, #u335)
		for j = 1, u337 do
			local u338= u335[j]
			local u339, u340= renderer.world_to_screen(u338.pos.x, u338.pos.y, u338.pos.z)
			if u339 and u340 then
				local u341= u328 - (u338.t or 0)
				local u342= math.min(1, u341 / u332)
				local u343= u333 * (1 - math.exp(-3 * u342))
				local u344= math.floor(math.max(0, (1 - u342) * 255))
				if u344 > 0 then
					renderer.text(u339, u340 - u343, u338.color[1], u338.color[2], u338.color[3], u344, "crdb-", 0, tostring(u338.dmg))
				end
			end
		end
	else
		u303 = { shots = {}, last = 0 }
	end
end

u316.callback('aim_hit', u317, { alive_only = true, require_login = true })
u316.callback('paint', u331, { alive_only = true, require_login = true })]]
u743["require/features/paint/damage_penetration"] = [[
local function u304(u305,u306)
	if u306 and rawget(_G, u306) ~= nil then
		return rawget(_G, u306)
	end
	local u307, u308= pcall(require, u305)
	if u307 then return u308 end
	return nil
end

local u309= u304('ui', 'ui')
local u310= u304('client', 'client')
local u311= u304('entity', 'entity')
local u312= u304('renderer', 'renderer')

if not u309 or not u310 or not u311 or not u312 then
	return
end

local u313= u309.new_checkbox
local u314= u309.get
local u315= u309.reference

local u316= u310.screen_size
local u317= u310.set_event_callback
local u318= u310.unset_event_callback
local u319= u310.eye_position
local u320= u310.camera_angles
local u321= u310.trace_line
local u322= u310.trace_bullet

local u323= u311.get_local_player
local u324= u311.is_alive or function() return false end
local u325= u311.get_player_weapon or function() return nil end
local u326= u311.get_classname or function() return nil end

local u327= u312.text

local u328= math.floor
local u329= math.cos
local u330= math.sin
local u331= math.rad

sodium_SUPPRESS = sodium_SUPPRESS or false
sodium_REFS = sodium_REFS or {}
sodium_FN = sodium_FN or {}

local function u332(u333)
	if not u333 then return false end
	local u307, u334= pcall(u314, u333)
	return u307 and u334 == true
end


if type(sodium_FN.min_dmg_active) ~= 'function' then
	sodium_FN.min_dmg_active = function()
		ensure_min_damage_refs()
		local u335= sodium_REFS.min_dmg_hotkey
		if u335 then
			local u307, u334= pcall(u314, u335)
			if u307 then return u334 == true end
		end
		return false
	end
end

if type(sodium_FN.min_dmg_value) ~= 'function' then
	sodium_FN.min_dmg_value = function()
		ensure_min_damage_refs()
		local u336= sodium_REFS.min_dmg_slider
		if not u336 then return nil end
		local u307, u334= pcall(u314, u336)
		if u307 and type(u334) == 'number' then
			return u334
		end
		return nil
	end
end

local function u337(u338,u339)
	if sodium and sodium.ui and sodium.ui[u338] then
		return sodium.ui[u338]
	end
	local u340= 'ui_' .. u338
	if sodium_REFS[u340] then
		return sodium_REFS[u340]
	end
	if not u339 then return nil end
	local u333= u339()
	if u333 then
		sodium_REFS[u340] = u333
	end
	return u333
end


local u341= nil
pcall(function() u341 = require('require/abc/menu_setup') end)


local function u342(u343)
    if not u309.get(u341.ui.paint_show_damage_penetration) then return end
	if not u325 or not u326 then return false end
	local u344= u325(u343)
	if not u344 then return false end
	local u345= u326(u344)
	if not u345 then return false end
	if u345:sub(1, 7) ~= 'CWeapon' then return false end
	if u345:find('Grenade', 1, true) or u345:find('Taser', 1, true) or u345:find('C4', 1, true) then return false end
	return true
end

local function u346()
    if not u309.get(u341.ui.paint_show_damage_penetration) then return end
	if not u323 then return nil end
	local u347= u323()
	if not u347 then return nil end
	if u324 and not u324(u347) then return nil end
	return u347
end




local function u348()
    if not u309.get(u341.ui.paint_show_damage_penetration) then return end
	local u347= u346()
	if not u347 or not u342(u347) then return end
	local u349, u350, u351= u319()
	if not u349 or not u350 or not u351 then return end
	local u352, u353= u320()
	if not u352 or not u353 then return end
	local u354, u355= u329(u331(u352)), u330(u331(u352))
	local u356, u357= u329(u331(u353)), u330(u331(u353))
	local u358, u359, u360= u354 * u356, u354 * u357, -u355
	local u361= 8192
	local u362, u363, u364= u349 + u358 * u361, u350 + u359 * u361, u351 + u360 * u361
	local u365= select(1, u321(u347, u349, u350, u351, u362, u363, u364)) or 1
	if u365 < 0 then u365 = 0 end
	if u365 > 1 then u365 = 1 end

	local u366
	if u365 >= 0.999 then
		u366 = { 256, 512, 1024, 2048, 4096 }
	else
		local u367= u361 * u365
		u366 = { u367 + 4, u367 + 16, u367 + 32, u367 + 64, u367 + 128, u367 + 256 }
	end

	local u368= 0
	for i = 1, #u366 do
		local u369= u366[i]
		if u369 > u361 then u369 = u361 end
		local u370, u371, u372= u349 + u358 * u369, u350 + u359 * u369, u351 + u360 * u369
		local u373, u374= u322(u347, u349, u350, u351, u370, u371, u372, true)
		if u374 and u374 > u368 then u368 = u374 end
		if u369 == u361 then break end
	end

	local u375= u328((u368 or 0) + 0.5)
	if u375 <= 0 then return end

	local u376, u377= u316()
	if not u376 or not u377 then return end
	local u378= u376 / 2
	local u379= u377 / 2 + 8
	local u380= tostring(u375)
	local u381= false
	if sodium_FN.draw_surface_text_centered and _G.sodium_FONTS and _G.sodium_FONTS.pen then
		u381 = sodium_FN.draw_surface_text_centered(_G.sodium_FONTS.pen, u378, u379, u380, 177, 194, 89, 255) and true or false
	end
	if not u381 then
		u327(u378, u377 / 2 + 12, 177, 194, 89, 255, 'cb', 0, u380)
	end
end

local function u382()
    if not u309.get(u341.ui.paint_show_damage_penetration) then return end
	if sodium_SUPPRESS then return end
	u348()
end

local u383, u384= pcall(require, "require/abc/callbacks")
if u383 and u384 then
	if _G.sodium_B_MD_DP and type(_G.sodium_B_MD_DP) == 'number' then
		pcall(u384.unregister, _G.sodium_B_MD_DP)
	end

	local function u385()
		if sodium_SUPPRESS then return end
        if not u309.get(u341.ui.paint_show_damage_penetration) then return end
		u348()
	end

	_G.sodium_B_MD_DP = u384.register('paint', u385, { require_login = true, alive_only = true })
else
	if u318 and _G.sodium_B_MD_DP then
		u318('paint', _G.sodium_B_MD_DP)
	end

	_G.sodium_B_MD_DP = u382
	u317('paint', u382)
end]]
u743["require/features/paint/entidx"] = [[local u307= require("require/abc/menu_setup")
local u308= require("require/help/enemies")

local function u309()
	if not ui.get(u307.ui.paint_entidx) then return end

	local u310= u308.get_current_threat and u308.get_current_threat() or client.current_threat and client.current_threat() or nil
	if u310 and u310 ~= 0 then
		local u311= entity.get_player_name(u310)

		renderer.text(70, 120, 255, 0, 0, 255, "b", 0, string.format("entidx%d: %s", u310, u311))
	end
end

local u312, u313= pcall(require, "require/abc/callbacks")
if u312 and u313 and u313.callback then
	u313.callback("paint", u309, { alive_only = true, require_login = true })
else
	client.set_event_callback("paint", u309)
end]]
u743["require/features/paint/filter_console"] = [[


local u310= pcall(require, 'require/abc/menu_setup') and require('require/abc/menu_setup') or nil
local u311= u310 and u310.ui and u310.ui.paint_filter_console or nil

local u312= cvar.con_filter_enable
local u313= cvar.con_filter_text

local u314= { enable = nil, text = nil }

local function u315()
    if u314.enable == nil then
        
        local u316, u317= pcall(function() return u312:get_int() end)
        u314.enable = (u316 and u317) and u317 or nil
    end

    if u314.text == nil then
        local u316, u318= pcall(function() return u313:get_string() end)
        u314.text = (u316 and u318) and u318 or nil
    end
end

local function u319()
    if u314.enable ~= nil then
        pcall(function() u312:set_raw_int(u314.enable) end)
    end

    if u314.text ~= nil then
        pcall(function() u313:set_string(u314.text) end)
    else
        pcall(function() u313:set_string('') end)
    end

    u314.enable = nil
    u314.text = nil
end

local function u320()
    u315()
    pcall(function() u312:set_raw_int(1) end)
    pcall(function() u313:set_string('[gamesense]') end)
end




local function u321()
    if not u311 then
        return false
    end

    
    if type(u311) == 'table' and u311.get then
        local u316, u317= pcall(function() return u311:get() end)
        return u316 and u317 or false
    end

    
    local u316, u317= pcall(function() return ui.get(u311) end)
    return u316 and u317 or false
end

local function u322()
    if not u321() then
        u319()
        return
    end

    u320()
    client.delay_call(1, u322)
end


client.delay_call(0.1, u322)


client.set_event_callback('shutdown', u319)

return {
    
    get_ui_state = u321,
    restore_values = u319,
    apply_filter = u320,
}
]]
u743["require/features/paint/hit_miss_indicator"] = [[local u313=require("require/help/math")
local u314=require("require/help/self")
local u315=require("require/help/safe")
local u316=require("require/abc/menu_setup")

local u317,u318=0,0
local u319=function() return u316 and u316.ui and u315.safe_get(u316.ui.paint_hitmiss_indicator) end
local u320=function() u317,shots=0,0 end

client.set_event_callback("aim_fire", function(u321)
    if not u319() or not u314.is_alive() then return end
    local u322= nil
    if u321.userid then u322 = client.userid_to_entindex(u321.userid) end
    if (not u322 or u322 == 0) and u321.player then u322 = u321.player end
    if u322 == u314.index() then u318 = u318 + 1 end
end)

client.set_event_callback("aim_hit", function(u321)
    if not u319() or not u314.is_alive() then return end
    local u322= nil
    if u321.userid then u322 = client.userid_to_entindex(u321.userid) end
    if (not u322 or u322 == 0) and u321.attacker then u322 = client.userid_to_entindex(u321.attacker) end
    if (not u322 or u322 == 0) and u321.player then u322 = u321.player end
    if u322 == u314.index() then u317 = u317 + 1 end
end)


client.set_event_callback("paint",function()
    if not u319() then return end
    local u323=u318>0 and u313.round(u317/u318*100,1) or 0
    renderer.indicator(255,255,255,255,string.format("%d / %d (%.1f)",u317,u318,u323))
end)
defer(u320)]]
u743["require/features/paint/indicators_bold"] = [[local u316= { 0, 0, 0 }
local u317= { 3, 3, 3 }
local u318= { 6, 6, 6 }

local function u319(u320,u321,u322)
  return u320 + (u321 - u320) * u322
end

local u323, u324= pcall(require, "require/abc/menu_setup")
local u325, u326= pcall(require, "require/help/string")
local function u327(u328)
  if u328 == nil then return "" end
  if u325 and u326 and u326.lower then
    return u326.lower(tostring(u328))
  end
  return tostring(u328)
end
local u329, u330= pcall(require, "require/help/color")
local u331, u332= pcall(require, "require/help/math")
local u333= u329 and u330.rgba_to_hex or function(u334,u335,u321,u320) return string.format("\a%02x%02x%02x%02x", u334 or 0, u335 or 0, u321 or 0, u320 or 255) end

local function u336(u337,u338,u334,u335,u321,u320,u339)
  local u322= globals.realtime() or globals.curtime()
  if not u339 or #u339 == 0 then return "" end
  local u340= {}

  if u337 == 0 then
    local u341= u333(u334,u335,u321,u320)
    for i=1,#u339 do u340[#u340+1] = u341 .. u339:sub(i,i) end
    return table.concat(u340)
  end

  if u337 == 2 then
    local u342= (math.sin(u322 * u338) + 1) * 0.5
    local u343= math.floor(u320 * (0.45 + 0.55 * u342))
    local u341= u333(u334,u335,u321,u343)
    for i=1,#u339 do u340[#u340+1] = u341 .. u339:sub(i,i) end
    return table.concat(u340)
  end

  if u337 == 3 then
    for i=1,#u339 do
      local u344= math.sin(u322 * u338 - i * 0.6)
      local u345= math.max(0, u344)
      local u342= u345 * u345
      local u343= math.floor(u320 * (0.35 + 0.65 * u342))
      u340[#u340+1] = u333(u334,u335,u321,u343) .. u339:sub(i,i)
    end
    return table.concat(u340)
  end

  for i=1,#u339 do
    local u342= (math.sin(u322 * u338 - i * 0.35) + 1) * 0.5
    local u343= math.floor(u320 * (0.4 + 0.6 * u342))
    u340[#u340+1] = u333(u334,u335,u321,u343) .. u339:sub(i,i)
  end
  return table.concat(u340)
end
local function u346()
  if u323 and u324 and u324.ui and u324.ui.paint_indicators then
    local u347, u348= pcall(ui.get, u324.ui.paint_indicators)
    if u347 and u348 == "bold" then return true end
    return false
  end

  return true
end

local u349, u350= pcall(require, "require/abc/callbacks")
local function u351(u352)
  if not u346() then return end

  local u353, u354= client.screen_size()
  local u355, u356= u353 / 2, u354 / 2

  local u357, u358, u359= 200, 200, 255
  local u360, u361, u362= 255, 255, 255
  local u363= 18

  local u364= { 12, 12 }

  local u365= u356 + 18

  local u366= entity.get_local_player()
  local u367= false
  if u366 then
    local u368= entity.get_prop(u366, "m_bIsScoped")
    u367 = u368 == 1
  end

  local u369= "sodium"
  local u370= "beta"
  local u371= "DT"

  local u372= false
  do
    local u347, u373= pcall(require, "require/help/libs")
    if u347 and u373 and u373.get then
      local u374= u373.get("antiaim_funcs")
      if u374 and u374.get_double_tap then
        local u375, u376= pcall(u374.get_double_tap)
        if u375 and u376 then u372 = true end
      end
    end
  end

  local u377= 1
  if u323 and u324 and u324.ui and u324.ui.paint_indicators_animation then
    local u378, u379= pcall(ui.get, u324.ui.paint_indicators_animation)
    if u378 and type(u379) == 'number' then u377 = u379 end
  end
  local u380= u369 .. " " .. u370
  u380 = u327(u380)
  u369 = u327(u369)
  u370 = u327(u370)
  local u381= renderer.measure_text("b", u380) or 0
  local u382= renderer.measure_text("b", u369) or 0
  local u383= renderer.measure_text("b", u370) or 0
  local u384= renderer.measure_text("b", u371) or 0

  local u385= ""
  do
    local u347, u386= pcall(require, "require/aa/player_condition")
    if u347 and u386 and u386.get then
      local u375, u387= pcall(u386.get)
      if u375 and u387 then
        local u388= {
          legit = "Legit",
          fakelag = "Fakelag",
          walk = "Walk",
          move = "Move",
          stand = "Stand",
          ["duck"] = "Duck",
          ["duck+"] = "Duck+",
          jump = "Jump",
          ["jump+"] = "Jump+"
        }
        u385 = u388[u387] or tostring(u387)
        u385 = u327(u385)
      end
    end
  end

  u371 = u327(u371)
  local u389= renderer.measure_text("b", u385) or 0

  local u390, u391, u392, u393= 200, 200, 255, 255
  do
    local u394= false
    if u323 and u324 and u324.ui and u324.ui.paint_indicator_color then
      local u395, u320, u321, u396, u397= pcall(ui.get, u324.ui.paint_indicator_color)
      if u395 then
        u394 = true
        if type(u320) == 'number' then
          if u329 and u330 and u330.clamp then
            u390 = u330.clamp(u320 or u390)
            u391 = u330.clamp(u321 or u391)
            u392 = u330.clamp(u396 or u392)
            u393 = u330.clamp(u397 or u393)
          else
            u390 = math.floor(u320 or u390)
            u391 = math.floor(u321 or u391)
            u392 = math.floor(u396 or u392)
            u393 = math.floor(u397 or u393)
          end
        elseif type(u320) == 'string' and #u320 == 12 then
          local u347
          u347, mr = pcall(function() return tonumber(u320:sub(1,3)) end)
          u347, mg = pcall(function() return tonumber(u320:sub(4,6)) end)
          u347, mb = pcall(function() return tonumber(u320:sub(7,9)) end)
          u347, ma = pcall(function() return tonumber(u320:sub(10,12)) end)
          if u329 and u330 and u330.clamp then
            u390 = u330.clamp(u390 or 200)
            u391 = u330.clamp(u391 or 200)
            u392 = u330.clamp(u392 or 255)
            u393 = u330.clamp(u393 or 255)
          else
            u390 = u390 or 200; u391 = u391 or 200; u392 = u392 or 255; u393 = u393 or 255
          end
        end
      end
    end

    if not u394 then
      local u398, u399= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if u398 and u399 then
        local u395, u320, u321, u396, u397= pcall(ui.get, u399)
        if u395 then
          if type(u320) == 'number' then
            if u329 and u330 and u330.clamp then
              u390 = u330.clamp(u320 or u390)
              u391 = u330.clamp(u321 or u391)
              u392 = u330.clamp(u396 or u392)
              u393 = u330.clamp(u397 or u393)
            else
              u390 = math.floor(u320 or u390)
              u391 = math.floor(u321 or u391)
              u392 = math.floor(u396 or u392)
              u393 = math.floor(u397 or u393)
            end
          elseif type(u320) == 'string' and #u320 == 12 then
            local u347
            u347, mr = pcall(function() return tonumber(u320:sub(1,3)) end)
            u347, mg = pcall(function() return tonumber(u320:sub(4,6)) end)
            u347, mb = pcall(function() return tonumber(u320:sub(7,9)) end)
            u347, ma = pcall(function() return tonumber(u320:sub(10,12)) end)
            if u329 and u330 and u330.clamp then
              u390 = u330.clamp(u390 or 200)
              u391 = u330.clamp(u391 or 200)
              u392 = u330.clamp(u392 or 255)
              u393 = u330.clamp(u393 or 255)
            else
              u390 = u390 or 200; u391 = u391 or 200; u392 = u392 or 255; u393 = u393 or 255
            end
          end
        end
      end
    end
  end

  for i = 1, 3 do
    local u400= (i == 1) and u381 or ((i == 2) and u384 or u389)
    local u401= u317[i] or 0
    local u402= u367 and (u401 + (u400 / 2)) or 0
    local u338= u318[i] or 10
    local u403= globals.frametime()
    local u322= 1 - math.exp(-u338 * u403)
    u316[i] = u319(u316[i], u402, u322)
  end

  local u404= u355 - (u381 / 2)
  local u405= u404 + (u316[1] or 0)
  renderer.text(u405, u365, 255, 255, 255, 255, "b", 0, u369)
  local u406= renderer.measure_text("b", " ") or 0
  local u407= u405 + (u382 or 0) + u406
  
  local u408= u336(u377, 3.5, u390, u391, u392, u393, u370)
  renderer.text(u407, u365, u390, u391, u392, u393, "b", 0, u408)
  u365 = u365 + (u364[1] or u363)

  local u409= u355 - (u384 / 2)
  local u410= u409 + (u316[2] or 0)
  local u411, u412, u413= 255, 80, 80
  if u372 then u411, u412, dt_b = 155, 255, 155 end
  renderer.text(u410, u365, u411, u412, u413, 255, "b", 0, u371)
  u365 = u365 + (u364[2] or u363)

  local u414= u355 - (u389 / 2)
  local u415= u414 + (u316[3] or 0)
  renderer.text(u415, u365, u360, u361, u362, 255, "b", 0, u385)
end

if u349 and u350 and u350.callback then
  u350.callback("paint", u351, { alive_only = true, require_login = true })
end]]
u743["require/features/paint/indicators_small"] = [[local u319= { 0, 0 }
local u320= { 4, 0.8 }
local u321= { 5, 5 }
local u322= 0
local u323= 8

local function u324(u325,u326,u327)
  return u325 + (u326 - u325) * u327
end

local u328, u329= pcall(require, "require/abc/menu_setup")
local u330, u331= pcall(require, "require/help/string")
local u332= require('require/abc/callbacks')
local function u333(u334)
  if u334 == nil then return "" end
  if u330 and u331 and u331.upper then
    return u331.upper(tostring(u334))
  end
  return tostring(u334)
end

local u335, u336= pcall(require, "require/help/color")
local u337, u338= pcall(require, "require/help/math")
local u339= u335 and u336.rgba_to_hex or function(u340,u341,u326,u325) return string.format("\a%02x%02x%02x%02x", u340 or 0, u341 or 0, u326 or 0, u325 or 255) end

local function u342(u343,u344,u340,u341,u326,u325,u345)
  local u327= globals.realtime() or globals.curtime()
  if not u345 or #u345 == 0 then return "" end
  local u346= {}

  if u343 == 0 then
    local u347= u339(u340,u341,u326,u325)
    for i=1,#u345 do u346[#u346+1] = u347 .. u345:sub(i,i) end
    return table.concat(u346)
  end

  if u343 == 2 then
    local u348= (math.sin(u327 * u344) + 1) * 0.5
    local u349= math.floor(u325 * (0.45 + 0.55 * u348))
    local u347= u339(u340,u341,u326,u349)
    for i=1,#u345 do u346[#u346+1] = u347 .. u345:sub(i,i) end
    return table.concat(u346)
  end

  if u343 == 3 then
    for i=1,#u345 do
      local u350= math.sin(u327 * u344 - i * 0.6)
      local u351= math.max(0, u350)
      local u348= u351 * u351
      local u349= math.floor(u325 * (0.35 + 0.65 * u348))
      u346[#u346+1] = u339(u340,u341,u326,u349) .. u345:sub(i,i)
    end
    return table.concat(u346)
  end

  for i=1,#u345 do
    local u348= (math.sin(u327 * u344 - i * 0.35) + 1) * 0.5
    local u349= math.floor(u325 * (0.4 + 0.6 * u348))
    u346[#u346+1] = u339(u340,u341,u326,u349) .. u345:sub(i,i)
  end
  return table.concat(u346)
end
local function u352()
  if u328 and u329 and u329.ui and u329.ui.paint_indicators then
    local u353, u354= pcall(ui.get, u329.ui.paint_indicators)
    if u353 and u354 == "small" then return true end
    return false
  end

  return true
end



local function u355()
  if not (u328 and u329 and u329.ui) then return true end
  local u356= u329.ui.paint_indicators_bar
  if not u356 then return true end
  local u353, u354= pcall(ui.get, u356)
  if not u353 then return true end
  return not (u354 == false or u354 == nil) 
end

u332.register("paint", function()
  if not entity.is_alive(entity.get_local_player()) then return end
  if not u352() then return end

  local u357, u358= client.screen_size()
  local u359, u360= u357 / 2, u358 / 2

  local u361, u362, u363= 200, 200, 255
  local u364, u365, u366= 255, 255, 255
  local u367= 18

  local u368= { 12, 13 }

  local u369= u360 + 18

  
  local u370= entity.get_local_player()
  local u371= false
  if u370 then
    local u372= entity.get_prop(u370, "m_bIsScoped")
    u371 = u372 == 1
  end

  local u373= "sodium"
  local u374= "beta"
  local u375= "DT"

  local u376= false
  do
    local u353, u377= pcall(require, "require/help/libs")
    if u353 and u377 and u377.get then
      local u378= u377.get("antiaim_funcs")
      if u378 and u378.get_double_tap then
        local u379, u380= pcall(u378.get_double_tap)
        if u379 and u380 then u376 = true end
      end
    end
  end

  local u381= u333(u373)
  local u382= u333(u374)
  u381 = tostring(u381)
  u382 = tostring(u382)
  local u383= renderer.measure_text("b", u381) or 0
  local u384= renderer.measure_text("b", u382) or 0

  u375 = u333(u375)
  local u385= renderer.measure_text("b", u375) or 0

  for i = 1, 2 do
    local u386= (i == 1) and u383 or u385
    local u387= u320[i] or 0
    local u388= u371 and (u387 + (u386 / 2)) or 0
    local u344= u321[i] or 10
    local u389= globals.frametime()
    local u327= 1 - math.exp(-u344 * u389)
    u319[i] = u324(u319[i], u388, u327)
  end

  local u390= 4.5
  local u391= u359 - ((u383 + u390 + (u384 or 0)) / 2)
  local u392= u391 + (u319[1] or 0)
  local u393= 22
  local u394= u393 - u390
  local u395= math.floor((u394 + 1) / 2)
  local u396= u394 - u395
  local u397= u395 
  local u398= -u396 

  local u399, u400, u401, u402= u361, u362, u363, 255
  do
    local u403= false
    
    if u328 and u329 and u329.ui and u329.ui.paint_indicator_color then
      local u404, u325, u326, u405, u406= pcall(ui.get, u329.ui.paint_indicator_color)
      if u404 then
        u403 = true
        if type(u325) == 'number' then
          if u335 and u336 and u336.clamp then
            u399 = u336.clamp(u325 or u399)
            u400 = u336.clamp(u326 or u400)
            u401 = u336.clamp(u405 or u401)
            u402 = u336.clamp(u406 or u402)
          else
            u399 = math.floor(u325 or u399)
            u400 = math.floor(u326 or u400)
            u401 = math.floor(u405 or u401)
            u402 = math.floor(u406 or u402)
          end
        elseif type(u325) == 'string' and #u325 == 12 then
          local u353
          u353, mr = pcall(function() return tonumber(u325:sub(1,3)) end)
          u353, mg = pcall(function() return tonumber(u325:sub(4,6)) end)
          u353, mb = pcall(function() return tonumber(u325:sub(7,9)) end)
          u353, ma = pcall(function() return tonumber(u325:sub(10,12)) end)
          if u335 and u336 and u336.clamp then
            u399 = u336.clamp(u399 or u361)
            u400 = u336.clamp(u400 or u362)
            u401 = u336.clamp(u401 or u363)
            u402 = u336.clamp(u402 or 255)
          else
            u399 = u399 or u361; u400 = u400 or u362; u401 = u401 or u363; u402 = u402 or 255
          end
        end
      end
    end

    
    if not u403 then
      local u407, u356= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if u407 and u356 then
        local u404, u325, u326, u405, u406= pcall(ui.get, u356)
        if u404 then
          if type(u325) == 'number' then
            if u335 and u336 and u336.clamp then
              u399 = u336.clamp(u325 or u399)
              u400 = u336.clamp(u326 or u400)
              u401 = u336.clamp(u405 or u401)
              u402 = u336.clamp(u406 or u402)
            else
              u399 = math.floor(u325 or u399)
              u400 = math.floor(u326 or u400)
              u401 = math.floor(u405 or u401)
              u402 = math.floor(u406 or u402)
            end
          elseif type(u325) == 'string' and #u325 == 12 then
            local u353
            u353, mr = pcall(function() return tonumber(u325:sub(1,3)) end)
            u353, mg = pcall(function() return tonumber(u325:sub(4,6)) end)
            u353, mb = pcall(function() return tonumber(u325:sub(7,9)) end)
            u353, ma = pcall(function() return tonumber(u325:sub(10,12)) end)
            if u335 and u336 and u336.clamp then
              u399 = u336.clamp(u399 or u361)
              u400 = u336.clamp(u400 or u362)
              u401 = u336.clamp(u401 or u363)
              u402 = u336.clamp(u402 or 255)
            else
              u399 = u399 or u361; u400 = u400 or u362; u401 = u401 or u363; u402 = u402 or 255
            end
          end
        end
      end
    end
  end

  local u408= 1
  if u328 and u329 and u329.ui and u329.ui.paint_indicators_animation then
    local u409, u410= pcall(ui.get, u329.ui.paint_indicators_animation)
    if u409 and type(u410) == 'number' then u408 = u410 end
  end

  local u411= (function()
    local u347= u339(255,255,255,255)
    local u346= {}
    for i=1,#u381 do u346[#u346+1] = u347 .. u381:sub(i,i) end
    return table.concat(u346)
  end)()

  local u412= u342(u408, 3.5, u399, u400, u401, u402, u382)
  local u413= u392 + (u397 or 0)
  local u414= u371 and 3 or 0
  u413 = u413 + u414
  renderer.text(u413, u369, 255,255,255,255, "-", 0, u411)
  local u415= u392 + (u383 or 0) + u390
  local u416= u415 + (u398 or 0) + u414
  renderer.text(u416, u369, u399, u400, u401, u402, "-", 0, u412)

  local u417= false
  if u355() then
    u417 = true
    do
      local u418= (u383 or 0) + u390 + (u384 or 0)
      local u419= 16
      local u420= math.max(8, u418 - u419)
      local u421= u371 and math.floor((u319[1] or 0) * 0.35) or 0
      local u422= u392 + math.floor((u418 - u420) / 2) - 2 + u421
      local u423= 2
      local u424= u369 + math.max(2, (u368[1] or u367) - (u423 + 4)) + 5
      local u425= math.floor((u402 or 255) * 0.7)
      renderer.rectangle(u422 - 1, u424 - 1, u420 + 2, u423 + 2, u399, u400, u401, u425)
      renderer.rectangle(u422, u424, u420, u423, 0, 0, 0, 255)
      local u426= u376 and u420 or 0
      local u427= globals.frametime()
      local u428= 1 - math.exp(-u323 * u427)
      u322 = u324(u322, u426, u428)
      local u429= math.floor(math.max(0, math.min(u322, u420)))
      if u429 > 0 then
        renderer.rectangle(u422, u424, u429, u423, u399, u400, u401, u402)
      end
    end
  end

  
  local u430= (u368[1] or u367)
  local u431= u430
  if not u417 then
    
    u431 = math.max(0, u430 - 7)
  end
  u369 = u369 + u431

  local u432= u359 - (u385 / 2)
  local u433= u432 + (u319[2] or 0)
  local u434, u435, u436= 255, 80, 80
  if u376 then u434, u435, dt_b = 155, 255, 155 end
  renderer.text(u433, u369 + 2, u434, u435, u436, 255, "-", 0, u375)
  u369 = u369 + (u368[2] or u367)

end, { alive_only = true, require_login = true })]]
u743["require/features/paint/insults"] = [[local u322= client
local u323= entity
local u324= ui

local u325= require("require/abc/menu_setup")
local u326, u327= pcall(require, "require/help/string")
local u328, u329= pcall(require, "require/help/math")
local u330, u331= pcall(require, "require/help/time")

local u332= {
    "buy sodium",
    "sodium is the bestest lua",
    "SODIUMMMM >__<",
    "you just got sodiumed",
    "sodium beta > all other lues",
    "₴ØĐłɄ₥ ₮₳₴₮ɆĐ Vł₵₮ØⱤɎ, ł₮ ₩₳₴ ₴ØɄⱤ",
    "₴ØĐłɄ₥ ₳ⱤⱤ₳₦₲ɆĐ ₮ⱧɆ ₴₮₳Ɽ₴ ₣ØⱤ ₮Ⱨ₳₮ ⱧɆ₳Đ₴ⱧØ₮",
    "₴ØĐłɄ₥ ₴Ⱡł₱₱ɆĐ ł₦ ₳ ฿₳₦₳₦₳ ₱ɆɆⱠ Ø₣ ₣₳₮Ɇ",
    "₴ØĐłɄ₥ ₩Ⱨł₴₱ɆⱤɆĐ ₴Ɇ₵ⱤɆ₮₴ ł₦₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ₥₳₭Ɇ₴ ₣ⱤłɆ₦Đ₴ ₩ł₮Ⱨ Ⱡ₳₲, ₮ⱧɆ₦ ฿Ɇ₮Ɽ₳Ɏ₴ ł₮",
    "₴ØĐłɄ₥ ₣ØⱠĐɆĐ ɎØɄⱤ ₵ØɄⱤ₳₲Ɇ ł₦₮Ø ₳ ₱₳₱ɆⱤ ₱Ⱡ₳₦Ɇ",
    "₴ØĐłɄ₥ ₱₳ł₦₮₴ ł₦ ⱤɆĐ ₩ⱧɆ₦ ł₮ ł₴ ⱧɄ₦₲ⱤɎ",
    "₴ØĐłɄ₥ ł₴ ₴₵ⱧłⱫØ₱ⱧⱤɆ₦ł₵ ฿Ʉ₮ ₵Ⱨ₳Ɽ₥ł₦₲",
    "₴ØĐłɄ₥ ₳₮Ɇ ₥Ɏ ₴₳₦Đ₩ł₵Ⱨ ฿Ʉ₮ ⱠɆ₣₮ ₳ ₮ⱤØ₱ⱧɎ",
    "₴ØĐłɄ₥ ⱧɄ₥₴ ⱠɄⱠⱠ₳฿łɆ₴ ₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ĐØɆ₴ ₮ⱧɆ ₵Ⱨ₳-₵Ⱨ₳ ₩ł₮Ⱨ ɎØɄⱤ ₳ł₥",
    "₴ØĐłɄ₥ ₣ØⱤ₲Ø₮ ₮Ø ฿Ɇ ₱ØⱠł₮Ɇ, ₴ØⱤⱤɎ ₦Ø₮ ₴ØⱤⱤɎ",
    "₴ØĐłɄ₥ ₳₦Đ ł ₴Ⱨ₳ⱤɆ ₮ØØ₮Ⱨ฿ⱤɄ₴ⱧɆ₴ (₥Ɇ₮₳₱ⱧØⱤ)",
    "₴ØĐłɄ₥ ₮Ɏ₱ɆĐ 'ɎØɄ' ł₦ ⱠØ₩ɆⱤ₵₳₴Ɇ ₳₦Đ ₥Ɇ₳₦₮ ł₮",
    "₴ØĐłɄ₥ ₵ØⱠⱠɆ₵₮₴ ₴₥₳ⱠⱠ ₮ⱤØ₱ⱧłɆ₴ (ɎØɄ ł₦₵ⱠɄĐɆĐ)",
    "₴ØĐłɄ₥ ₭ɆɆ₱₴ ⱤɆ₵Ɇł₱₮₴ ₣ØⱤ ɎØɄⱤ ₥ł₴₮₳₭Ɇ₴",
    "₴ØĐłɄ₥ ł₴ ₳ ₲ØØĐ ⱠɄ₳ ₳₦Đ ₳Ⱡ₴Ø ₳ Ⱡł₮₮ⱠɆ ₥₳Đ",
    "₴ØĐłɄ₥, ₮Ⱨ₳₦₭ ₣ØⱤ ₳ⱠⱠ₳Ⱨ ₲ØĐ, Đ₳Đ :)",
    "₴ØĐłɄ₥ ₴Ɇ₦ĐɆⱤ ₲ⱤɆɆ₮ł₦₲ ₣ⱤØ₥ ₭Ʉ฿₳₦",
    "₥łⱠⱠłØ₦₳łⱤɆ ฿ɄɎ₴ ₲ⱧØ₴₮ ツ Ⱨ₳₳₳Ⱨ₳Ⱨ₳",
    "₴ Ø Đ ł Ʉ ₥ ⱠɄ₳ Ⱨ₳₴ ₮ⱧɆ ฿Ɇ₴₮ ⱧɆ₳Đ₴ⱧØ₮₮₮",
    "₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ <3",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ",
    "ł₣ ₣ⱠɎł₦₲ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐØ₦₮ ₭₦Ø₩ł₦₲ ӾĐĐ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₥Ɏ ₳ł₥ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ɆⱤVɆⱤ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ, ฿Ɇ₲ ₮Ø ₱ⱤØ₵Ⱡ₳ł₥",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄ ₵₳₦ ₥₳₮₵Ⱨ Ⱡ₥Ⱨ ł ⱤɆ₵ØĐɆĐ",
    "ł ₱Ⱡ₳₵Ɇ ɎØɄ Ø₦ ₦Ɇ₩ ⱠɆ₣Ɇ₦Đ ⱠɆ₵₮ɆĐ ₥₳₱ ₩ł₮Ⱨ ØĐł₣ł₵ ⱤɆ₵ØĐɆ",
    "♡ ₴ØĐłɄ₥ ł₴ ₥Ɏ ₵Ø₵₭ Ø₣ ⱠɄ₳ ♡",
    "ł ⱤØ₳₴₮ɆĐ ɎØɄ ₴Ø ₣Ʉ₵₭ł₦₲ Ⱨ₳ⱤĐ ɆVɆⱤ ₴ɆⱤɆĐ",
    "ɎØɄ ₮ⱤłɆĐ ₮Ø ₱ⱤɆ₮Ɇ₦Đ, ฿Ʉ₮ ₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ₭łⱠⱠɆĐ ₮Ⱨ₳₮",
    "ɎØɄ ⱠØ₴Ɇ ₮Ø ₥Ɇ ₣ØⱤ ₦ł₵Ɇ ₣ØⱠ₭",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱ØɆ₥",
    "ł ₣Ⱡł₲Ⱨ₮ ɎØɄ Ø₣₣ ₮ⱧɆ ₥₳₱ ₩ł₮Ⱨ ₥Ɏ ₴ɆⱤVɆⱤ ₩ł₣Ɇ",
    "₴ɆⱤł₳Ⱡ ฿ɄⱠⱠɎ Ø₣ ⱠɄ₳ ₳ⱠⱠ Đ₳Ɏ",
    "₥Ɏ ₴ØĐłɄ₥ ฿ⱤɆ₳₭₴ ₥ØⱤɆ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ₴ØĐłɄ₥ ❤",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ, ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₣ⱠɎ ₳ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ, ₮ⱧɆ₦ ₴₮łⱠⱠ ฿Ɇ₳₮ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐłĐ₦’₮ ₭₦Ø₩ł₦₲ ӾĐĐĐ, ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳ ₣₮₩",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ₴Ɇ₦Đ ₲ⱤɆɆ₮ł₦₲₴ ₱₳Ɽ₳ ₳ ₵Ø₦₳ Đ₳ ₮Ʉ₳ ₥₳₮Ɇ",
    "₳ĐĐɆĐ ₮Ⱨł₴ ₮Ø ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₳₦Đ ł₮ ₥₳ĐɆ ł₮ ₴Ø ₥Ʉ₵Ⱨ ฿Ɇ₮₮ɆⱤ",
    "ł ₴₥Ø₭ɆĐ ɎØɄ ɎɆ₴₮ɆⱤĐ₳Ɏ ₩ł₮Ⱨ ₴ØĐłɄ₥, ₮ØĐ₳Ɏ ł ₣ⱠɆӾ ₳₲₳ł₦",
    "₴ØĐłɄ₥ ⱠɄ₳ JɄ₴₮ Ø₩₦ɆĐ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄⱤ ₴₵Ɽł₱₮ ₵₳₦ ₥₳₮₵Ⱨ ₴ØĐłɄ₥? ⱠØⱠ ₦Ø₱Ɇ",
    "ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ ₥ØĐɆ ₳₵₮łV₳₮ɆĐ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ = 100% ₩ł₦ ₲Ʉ₳Ɽ₳₦₮ɆɆĐ",
    "ł ฿ⱤɆ₳₭ ɎØɄⱤ ⱠɄ₳, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₥ł₦Đ, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₴ɆⱤVɆⱤ — ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "(‿ˠ‿)",
    "₣ØⱤ ₲₳₦₲₴₮ɆⱤ ₩Ɇ Ⱨ₳VɆ ₩Ø₦, ₮Ⱨł₴ ₥₳₮₵Ⱨ",
    "https://discord.gg/8nMMVgqdHk",
    "BUY SODIUM NOW!!! ₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ BUY SODIUM NOW!!! AT DISCORD ;;;",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥ ⱠɄ₳ ",
}


local u333= {
    ""
}

pcall(function()
    local u334= nil
    if u330 and u331 and u331.unix_time then
        u334 = math.floor((u331.unix_time() or 0) % (2^31))
    else
        local u335= nil
        pcall(function() u335 = u322.timestamp() end)
        if not u335 or u335 == 0 then
            u335 = globals.tickcount() or 0
        end
        u334 = math.floor((u335 or 0) % (2^31))
    end
    math.randomseed(u334)
end)
local u336= 1
local u337= {}
local u338= false

local function u339(u340)
    if u322 and u322.exec then
        pcall(u322.exec, u340)
    end
end

local function u341()
    if #u337 == 0 then
        u338 = false
        return
    end

    local u342= table.remove(u337, 1)
    if not u342 or u342 == "" then
        if #u337 > 0 then
            if u322 and u322.delay_call then
                pcall(function() u322.delay_call(u336, u341) end)
            else
                u341()
            end
        else
            u338 = false
        end
        return
    end

    local u340= string.format('say "%s"', u342)
    if u322 and u322.delay_call then
        pcall(function()
            u322.delay_call(0, function()
                u339(u340)
            end)
        end)
    else
        u339(u340)
    end

    if #u337 > 0 then
        if u322 and u322.delay_call then
            pcall(function() u322.delay_call(u336, u341) end)
        else
            u341()
        end
    else
        u338 = false
    end
end

local function u343(u344)
    if not u344 or u344 == "" then return end
    local u345= tostring(u344)
    local u346
    if u326 and u327 and u327.replace then
        u346 = u327.replace(u345, '"', '')
        if u327.trim then u346 = u327.trim(u346) end
    else
        u346 = u345:gsub('"','')
    end

    table.insert(u337, u346)
    if not u338 then
        u338 = true
        if u322 and u322.delay_call then
            pcall(function() u322.delay_call(u336, u341) end)
        else
            u341()
        end
    end
end

local function u347(u348)
	if not u325 or not u325.ui or not u325.ui.paint_insults then
		return
	end
	local u349, u350= pcall(u324.get, u325.ui.paint_insults)
	if not u349 or not u350 then return end

	if not u348 then return end
	local u351= u348.userid
	local u352= u348.attacker
	if not u351 or not u352 then return end

	local u353= u323.get_local_player and u323.get_local_player()
	if not u353 or u353 == 0 then return end

	local u354= u322.userid_to_entindex and u322.userid_to_entindex(u351) or nil
	local u355= u322.userid_to_entindex and u322.userid_to_entindex(u352) or nil
	if u352 == u351 then return end
	if u355 == u353 and u354 ~= u353 then
        if #u332 > 0 then
            local u356= 1
            if u328 and u329 and u329.random_int then
                u356 = u329.random_int(1, #u332)
            else
                u356 = math.random(1, #u332)
            end
            local u342= u332[u356]
            u343(u342)
        end
		return
	end
	if u354 == u353 and u355 ~= u353 then
        if #u333 > 0 then
            local u356= 1
            if u328 and u329 and u329.random_int then
                u356 = u329.random_int(1, #u333)
            else
                u356 = math.random(1, #u333)
            end
            local u342= u333[u356]
            u343(u342)
        end
		return
	end
end

local u357, u358= pcall(require, "require/abc/callbacks")
if u357 and u358 and u358.callback then
    u358.callback('player_death', u347, { alive_only = true, require_login = true })
end]]
u743["require/features/paint/lagcomp_box"] = [=[


local g_net_data = {}
local g_sim_ticks = {}
local g_esp_data = {}


local menu_setup = require('require/abc/menu_setup')
local DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A = 47, 117, 221, 255


local floor = math.floor

local function length_sqr(x, y, z)
    return (x or 0) * (x or 0) + (y or 0) * (y or 0) + (z or 0) * (z or 0)
end

local function time_to_ticks(seconds)
    local ti = globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return floor((seconds or 0) / ti + 0.5)
end

local function extrapolate(ent, ticks)
    local ti = globals.tickinterval()
    if not ti then return nil end

    local g = (cvar.sv_gravity and cvar.sv_gravity:get_float() or 800) * ti
    local jump = (cvar.sv_jump_impulse and cvar.sv_jump_impulse:get_float() or 301) * ti

    local ox, oy, oz = entity.get_origin(ent)
    if not ox then return nil end

    local vx, vy, vz = entity.get_prop(ent, "m_vecVelocity")
    vx, vy, vz = vx or 0, vy or 0, vz or 0

    local gravity = (vz > 0) and -g or jump

    for i = 1, (ticks or 0) do
        local px, py, pz = ox, oy, oz

        ox = ox + (vx * ti)
        oy = oy + (vy * ti)
        oz = oz + (vz + gravity) * ti

        local frac = select(1, client.trace_line(ent or 0, px, py, pz, ox, oy, oz))
        if frac and frac <= 0.99 then
            return px, py, pz
        end
    end

    return ox, oy, oz
end


local edges = {
    {0, 1}, {1, 2}, {2, 3}, {3, 0}, {5, 6}, {6, 7}, {1, 4}, {4, 8},
    {0, 4}, {1, 5}, {2, 6}, {3, 7}, {5, 8}, {7, 8}, {3, 4}
}


local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
    local me = entity.get_local_player()
    if not me or not entity.is_alive(me) then return end

    
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box then
        local ok, enabled = pcall(ui.get, menu_setup.ui.paint_lagcomp_box)
        if ok and enabled == false then
            return
        end
    end

    
    local players = entity.get_players(true)
    for i = 1, #players do
        local ent = players[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local prev = g_sim_ticks[ent]
            local sim_time = entity.get_prop(ent, 'm_flSimulationTime')
            local ox, oy, oz = entity.get_origin(ent)

            if sim_time and ox then
                local sim_ticks = time_to_ticks(sim_time)

                if prev ~= nil then
                    local delta = sim_ticks - prev.tick
                    if delta < 0 or (delta > 0 and delta <= 64) then
                        local dx, dy, dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
                        local teleport_distance = length_sqr(dx, dy, dz)

                        local ex_ticks = math.max(delta - 1, 0)
                        local ex_x, ex_y, ex_z = extrapolate(ent, ex_ticks)
                        if delta < 0 then
                            g_esp_data[ent] = 1
                        end

                        g_net_data[ent] = {
                            tick = ex_ticks,
                            player = ent,
                            delta = delta,
                            origin = { x = ox, y = oy, z = oz },
                            extrapolated = (ex_x and { x = ex_x, y = ex_y, z = ex_z } or { x = ox, y = oy, z = oz }),
                            lagcomp = teleport_distance > 4096,
                            tickbase = delta < 3
                        }
                    end
                end

                if g_esp_data[ent] == nil then g_esp_data[ent] = 0 end
                g_sim_ticks[ent] = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
            else
                g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
            end
        else
            g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
        end
    end

    
    local r, g, b, a = DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box_color then
        local ok, rr, gg, bb, aa = pcall(ui.get, menu_setup.ui.paint_lagcomp_box_color)
        if ok and rr then
            r, g, b, a = rr, gg, bb, aa
        end
    end
    for ent, data in pairs(g_net_data) do
        if data and data.player and entity.is_alive(data.player) and not entity.is_dormant(data.player) and data.lagcomp then
            local minsx, minsy, minsz = entity.get_prop(data.player, 'm_vecMins')
            local maxsx, maxsy, maxsz = entity.get_prop(data.player, 'm_vecMaxs')
            if not minsx or not maxsx then goto continue_box end

            local ex = data.extrapolated.x
            local ey = data.extrapolated.y
            local ez = data.extrapolated.z

            local min = { x = (minsx or 0) + ex, y = (minsy or 0) + ey, z = (minsz or 0) + ez }
            local max = { x = (maxsx or 0) + ex, y = (maxsy or 0) + ey, z = (maxsz or 0) + ez }

            local points = {
                min,
                { x = min.x, y = max.y, z = min.z },
                { x = max.x, y = max.y, z = min.z },
                { x = max.x, y = min.y, z = min.z },
                { x = min.x, y = min.y, z = max.z },
                { x = min.x, y = max.y, z = max.z },
                max,
                { x = max.x, y = min.y, z = max.z }
            }

            for k, v in pairs(edges) do
                
                if k == 1 then
                    local ox, oy = renderer.world_to_screen(data.origin.x, data.origin.y, data.origin.z)
                    local mx, my = renderer.world_to_screen(min.x, min.y, min.z)
                    if ox and mx then
                        renderer.line(ox, oy, mx, my, r, g, b, 255)
                    end
                end
                local p1 = points[v[1]]
                local p2 = points[v[2]]
                if p1 and p2 then
                    local x1, y1 = renderer.world_to_screen(p1.x, p1.y, p1.z)
                    local x2, y2 = renderer.world_to_screen(p2.x, p2.y, p2.z)
                    if x1 and x2 then
                        renderer.line(x1, y1, x2, y2, r, g, b, 255)
                    end
                end
            end
            ::continue_box::
        end
    end

    
    for i = 1, #players do
        local ent = players[i]
        if not entity.is_alive(ent) or entity.is_dormant(ent) then goto continue_label end

        local x1, y1, x2, y2, alpha = entity.get_bounding_box(ent)
        if alpha == 0 then goto continue_label end

        local palpha = 0
        if g_esp_data[ent] ~= nil and g_esp_data[ent] > 0 then
            g_esp_data[ent] = g_esp_data[ent] - globals.frametime() * 2
            if g_esp_data[ent] < 0 then g_esp_data[ent] = 0 end
            palpha = g_esp_data[ent]
        end

        local tag = ''
        local data = g_net_data[ent]
        if data then
            local tb = data.tickbase
            local lc = data.lagcomp
            if (not tb) or lc then
                palpha = alpha
            end
            tag = tb and 'SHIFTING TICKBASE' or (lc and 'LAG COMP BREAKER' or '')
        end

        
            local name = entity.get_player_name(ent)
            local y_add = (name == '  ' or name == ' ' or name == '' or name == '   ') and 8 or 0
            local mid_x = x1 + (x2 - x1) / 2
            renderer.text(mid_x, y1 - 18 + y_add, 255, 45, 45, floor((palpha or 0) * 255), 'cb', 0, tag)
        

        ::continue_label::
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end

local function round_start_handler(ev)
    g_net_data = {}
    g_sim_ticks = {}
    g_esp_data = {}
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('round_start', round_start_handler, { alive_only = true, require_login = true })
end]=]
u743["require/features/paint/minimum_damage"] = [[local u328= require("require/abc/menu_setup")
local u329= require("require/help/drag")

local u330= {
    minimum_damage = ui.reference("RAGE", "Aimbot", "Minimum damage"),
    minimum_damage_override = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}

local u331= { client.screen_size() }

local u332= nil
do
    local u333, u334= client.screen_size()
    local u335= math.floor((u331[1] or u333 or 0) / 2 + 2)
    local u336= math.floor((u331[2] or u334 or 0) / 2 - 14)
    local u337= 30
    local u338, u339= 10, 18
    u332 = u329.new("minimum_damage_indicator", {
        x = u335 - math.floor(u338 / 2),
        y = u336 - math.floor(u339 / 2),
        w = u338,
        h = u339,
        snap = true,
        snap_threshold = 24,
        require_menu_open = true,
        constraint_center = { cx = u335, cy = u336, radius = u337 },
        default_center = { x = u335, y = u336 },
    })
end

local u340, u341= pcall(require, "require/abc/callbacks")
local function u342(u343)

    if not ui.get(u328.ui.paint_minimum_damage) then return end
    
    local u344= entity.get_local_player()
    if u344 == nil or not entity.is_alive(u344) then return end
    if u332 then
        pcall(function()
            u332:handle()
            u332:draw()
        end)
    end

    

    if ui.get(u330.minimum_damage_override[2]) then
        local u345, u346= u331[1] / 2 + 2, u331[2] / 2 - 14
        if u332 then
            pcall(function()
                u345 = u332.x + math.floor(u332.w / 2)
                u346 = u332.y + math.floor(u332.h / 2)
            end)
        end
        renderer.text(u345, u346, 255, 255, 255, 225, "d", 0, ui.get(u330.minimum_damage_override[3]) .. "")
    end

end

if u340 and u341 and u341.callback then
    u341.callback('paint', u342, { alive_only = true, require_login = true })
end]]
u743["require/features/paint/molotov_particles"] = [[local u331= ui
local u332= client
local u333= entity
local u334= renderer
local u335= globals
local u336= require("require/abc/menu_setup")
local u337= require('require/brain/api/vector/vector')
local u338= require('require/abc/callbacks')


local u339= {}


local u340= u337.make(0, 0, 0)
local u341= u337.make(0, 0, 0)

local u342= 128
local u343= 158
local u344= 48


local function u345()
    local u346= {}
    local u347= u333.get_all('inferno') or {}
    for _, v in ipairs(u347) do table.insert(u346, v) end
    local u348= u333.get_all('CInferno') or {}
    for _, v in ipairs(u348) do table.insert(u346, v) end
    return u346
end


local function u349(u350,u351,u352)
    offsets_templates = offsets_templates or {}
    local u353= tostring(u351) .. ':' .. tostring(u352)
    if offsets_templates[u353] then return offsets_templates[u353] end

    local u354= {}
    local u355= math.pi * (3 - math.sqrt(5))
    for i = 1, u351 do
        local u356= u352 * math.sqrt(i / u351)
        local u357= i * u355
        local u358= math.cos(u357) * u356
        local u359= math.sin(u357) * u356
        local u360= ((i % 24) - 12) 
        u354[i] = {u358, u359, u360}
    end
    offsets_templates[u353] = u354
    return u354
end

u338.register('paint', function()

    local u361= u333.get_local_player()
    if not u361 then return end
    if u336 and u336.ui and u336.ui.paint_molotov then
        local u362, u363= pcall(u331.get, u336.ui.paint_molotov)
        if u362 and not u363 then return end
    end

    local u351= math.max(1, math.floor(u342 or 24))
    local u352= math.max(1, math.floor(u343 or 100))
    local u364= math.max(1, math.floor(u344 or 6))

    
    local u365, u366, u367= u332.camera_position()
    u340.x = u365 or 0
    u340.y = u366 or 0
    u340.z = u367 or 0

    local u368= u345()
    if #u368 == 0 then return end

    for _, u350 in ipairs(u368) do
        local u369, u370, u371= u333.get_origin(u350)
        if u369 then
            local u353= tostring(u350) .. ":" .. tostring(u351) .. ":" .. tostring(u352)
            local u372= u339[u353]

            
            if not u372 or not u372.origin or
               math.abs(u372.origin[1] - u369) > 0.01 or
               math.abs(u372.origin[2] - u370) > 0.01 or
               math.abs(u372.origin[3] - u371) > 0.01 then
                local u354= u349(u350, u351, u352)
                local u373= {}
                for _, off in ipairs(u354) do
                    local u374= u369 + (off[1] or 0)
                    local u375= u370 + (off[2] or 0)
                    local u376= u371 + (off[3] or 0)
                    table.insert(u373, {u374, u375, u376})
                end
                u372 = { origin = {u369, u370, u371}, pts = u373 }
                u339[u353] = u372
            end

            for _, p in ipairs(u372.pts) do
                local u374, u375, u376= p[1], p[2], p[3]
                local u377, u378= u334.world_to_screen(u374, u375, u376)
                if u377 and u378 then
                    
                    u341.x = u374 - u340.x
                    u341.y = u375 - u340.y
                    u341.z = u376 - u340.z

                    local u379= u341.x
                    local u380= u341.y
                    local u381= u341.z
                    local u382= math.sqrt(u379*u379 + u380*u380 + u381*u381)

                    local u383= math.max(1, math.floor((200 / (u382 + 1)) * (u364 / 6)))
                    local u384= math.max(1, math.floor(u383 / 2))
                    u334.rectangle(u377 - u384, u378 - u384, u383, u383, 255, 24, 24, 255)
                end
            end
        end
    end
end, { alive_only = true, require_login = true })]]
u743["require/features/paint/onshot_skeleton"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")


local function find(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x, y, z = entity.hitbox_position(ent, def.names[i])
        if x then return x, y, z end
    end
    for i = 1, #(def.idx or {}) do
        local x, y, z = entity.hitbox_position(ent, def.idx[i])
        if x then return x, y, z end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local sk = {list = {}}

local function is_skeleton_enabled()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_hitmarker then
        local ok, sel = pcall(ui.get, menu_setup.ui.paint_hitmarker)
        if not ok then return false end
        if type(sel) == "table" then
            for _, v in ipairs(sel) do
                if v == "skeleton" then return true end
            end
        end
        return false
    end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function aim_fire_handler(ev)
    if not is_skeleton_enabled() then sk.list = {} return end
    if not is_skeleton_enabled() then return end
    local target = ev and (ev.target or ev.target_index)
    if type(target) ~= 'number' or target == 0 then return end
    local pts = snap(target)
    if not pts then return end
    local now = globals.realtime and globals.realtime() or 0
    sk.list[#sk.list + 1] = {pts = pts, t = now}
    if #sk.list > 5 then table.remove(sk.list, 1) end
end

local function paint_handler(ev)
    if is_skeleton_enabled() then
        local now = globals.realtime and globals.realtime() or 0
        local hold = 2.2 * 0.8 * 3
        local fade = 2.2 * 0.8
        local total = hold + fade
        local i = 1
        while i <= #sk.list do
            if now - (sk.list[i].t or 0) > total then
                table.remove(sk.list, i)
            else
                i = i + 1
            end
        end
        table.sort(sk.list, function(a, b) return (a.t or 0) < (b.t or 0) end)
        local start = math.max(1, #sk.list - 2)
        for j = start, #sk.list do
            local it = sk.list[j]
            local age = now - (it.t or 0)
            local alpha = age <= hold and 220 or math.floor(math.max(0, (1 - math.max(0, age - hold) / fade) * 220))
            if alpha > 0 then
                local pts = it.pts or {}
                for c = 1, #chains do
                    local chain = chains[c]
                    local from, to = pts[chain[1]], pts[chain[2]]
                    if from and to then
                        local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                        local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                        if fx and tx then renderer.line(fx, fy, tx, ty, 255, 255, 255, alpha) end
                    end
                end
            end
        end
    else
        sk.list = {}
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('aim_fire', aim_fire_handler, { alive_only = true, require_login = true })
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
else
    client.set_event_callback('aim_fire', aim_fire_handler)
    client.set_event_callback('paint', paint_handler)
end]=]
u743["require/features/paint/performance_mode"] = [[



local u337, u338= pcall(require, "require/abc/menu_setup")


local u339= nil
pcall(function() u339 = require('require/abc/callbacks') end)
if not u339 then error("callbacks manager required: require/abc/callbacks") end


local u340= {
    captured = false
}

local u341= {
    blood = nil,
    ragdolls = nil,
    particles = nil,
    lensflare = nil,
    animations = nil,
    features = nil,
}

local function u342()
    if u340.captured then return end
    local function u343(u344,u345)
        local u337, u346= pcall(client.get_cvar, u344)
        if u337 and u346 then return u346 end
        return u345
    end

    u340.violence_hblood = u343('violence_hblood', '1')
    u340.cl_ragdoll_physics_enable = u343('cl_ragdoll_physics_enable', '1')
    u340.r_drawparticles = u343('r_drawparticles', '1')
    u340.mat_disable_bloom = u343('mat_disable_bloom', '0')
    u340.captured = true
end

local function u347(u344,u348)
    
    pcall(client.exec, string.format('%s %s', u344, tostring(u348)))
end

local function u349(u350,u351)
    if u350 == 'blood' then
        if u351 then u347('violence_hblood', 0) else u347('violence_hblood', u340.violence_hblood or 1) end
    elseif u350 == 'ragdolls' then
        if u351 then u347('cl_ragdoll_physics_enable', 0) else u347('cl_ragdoll_physics_enable', u340.cl_ragdoll_physics_enable or 1) end
    elseif u350 == 'particles' then
        if u351 then u347('r_drawparticles', 0) else u347('r_drawparticles', u340.r_drawparticles or 1) end
    elseif u350 == 'lensflare' then
        if u351 then u347('mat_disable_bloom', 1) else u347('mat_disable_bloom', u340.mat_disable_bloom or 0) end
    end
end

local function u352(u353)
    
    
    if u353['animations'] then
        _G.PERFORMANCE_ANIMATIONS = false
    else
        
        _G.PERFORMANCE_ANIMATIONS = true
    end

    if u353['feature updates'] then
        _G.PERFORMANCE_FEATURE_UPDATES = false
    else
        _G.PERFORMANCE_FEATURE_UPDATES = true
    end
end

local function u354(u355)
    local u356= {}
    if type(u355) == 'table' then
        for _, u346 in ipairs(u355) do u356[u346] = true end
    end
    return u356
end


u339.register('paint', function()
    if not u337 or not u338 or not u338.ui or not u338.ui.paint_performance_mode then return end
    u342()

    local u357= ui.get(u338.ui.paint_performance_mode)
    local u353= u354(u357)

    
    local u358= u353['blood'] or false
    if u358 ~= u341.blood then
        u349('blood', u358)
        u341.blood = u358
    end

    
    u358 = u353['ragdolls'] or false
    if u358 ~= u341.ragdolls then
        u349('ragdolls', u358)
        u341.ragdolls = u358
    end

    
    u358 = u353['particles'] or false
    if u358 ~= u341.particles then
        u349('particles', u358)
        u341.particles = u358
    end

    
    u358 = u353['lens flare'] or false
    if u358 ~= u341.lensflare then
        u349('lensflare', u358)
        u341.lensflare = u358
    end

    
    u358 = u353['animations'] or false
    if u358 ~= u341.animations then
        
        u352(u353)
        u341.animations = u358
        u341.features = u353['feature updates'] or false
    end

    
    local u359= u353['feature updates'] or false
    if u359 ~= u341.features then
        u352(u353)
        u341.features = u359
    end
end, { require_login = true, alive_only = true })


u339.register('shutdown', function()
    if u340.captured then
        pcall(u347, 'violence_hblood', u340.violence_hblood)
        pcall(u347, 'cl_ragdoll_physics_enable', u340.cl_ragdoll_physics_enable)
        pcall(u347, 'r_drawparticles', u340.r_drawparticles)
        pcall(u347, 'mat_disable_bloom', u340.mat_disable_bloom)
    end
    
    _G.PERFORMANCE_ANIMATIONS = true
    _G.PERFORMANCE_FEATURE_UPDATES = true
end, { require_login = true, alive_only = true })


if _G.PERFORMANCE_ANIMATIONS == nil then _G.PERFORMANCE_ANIMATIONS = true end
if _G.PERFORMANCE_FEATURE_UPDATES == nil then _G.PERFORMANCE_FEATURE_UPDATES = true end

return {
    _internal = {
        orig = u340,
        last_state = u341,
    }
}
]]
u743["require/features/paint/presmoke_warning"] = [[local u340= { start = nil, limit = nil }

client.set_event_callback("round_start", function(u341)
	u340.start = globals.curtime()
	u340.limit = tonumber(u341.timelimit) or tonumber(u341.round_time) or 115
end)

local function u342()
	local u343= entity.get_game_rules()
	if not u343 then return nil end
	local u344= {
		"m_flGameTimeRemaining",
		"m_flRoundTimeRemaining",
		"m_fRoundStartTime",
		"m_flRoundStartTime",
		"m_iRoundTime",
		"m_iRoundTimeLimit",
	}
	for _, name in ipairs(u344) do
		local u345, u346= pcall(entity.get_prop, u343, name)
		if u345 and u346 and type(u346) == "number" then
			if name:lower():find("remain") then
				return math.max(0, u346)
			end
		end
	end
	local u347= nil
	for _, name in ipairs({"m_fRoundStartTime", "m_flRoundStartTime"}) do
		local u345, u346= pcall(entity.get_prop, u343, name)
		if u345 and u346 and type(u346) == "number" then
			u347 = u346
			break
		end
	end
	if u347 then
		local u348= nil
		local u345, u349= pcall(entity.get_prop, u343, "m_iRoundTime")
		if u345 and u349 and type(u349) == "number" then u348 = u349 end
		if not u348 then
			u348 = tonumber(client.get_cvar("mp_roundtime")) or tonumber(client.get_cvar("mp_roundtime_defuse"))
		end
		if u348 and type(u348) == "number" then
			local u350= u348 - (globals.curtime() - u347)
			return math.max(0, u350)
		end
	end
	return nil
end

local function u351()
	if u340.start and u340.limit then
		local u352= globals.curtime() - u340.start
		local u350= u340.limit - u352
		if u350 < 0 then u350 = 0 end
		return u350
	end
	return u342()
end

client.set_event_callback("paint", function()
	local u353, u354= pcall(require, "require/abc/menu_setup")
	if not u353 or not u354 or not u354.ui then return end
	local u355, u356= pcall(ui.get, u354.ui.paint_presmoke)
	if not u355 or not u356 then return end

	local u350= u351()
	if not u350 then return end
	if u350 <= 18 then
		local u357, u358= client.screen_size()
		local u359= u357 * 0.5
		local u360= math.floor(u358 * 0.3)
		local u361= string.format("%.2f", u350)
		local u362= string.format("PRESMOKE NOW PRESMOKE NOW %s", u361)
		renderer.text(u359, u360, 255, 30, 30, 255, "cb+", 0, u362)
	end
end)

client.set_event_callback("round_end", function()
	u340.start = nil
	u340.limit = nil
end)

client.set_event_callback("cs_game_disconnected", function()
	u340.start = nil
	u340.limit = nil
end)

]]
u743["require/features/paint/self_boxes"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end


local ui_extrap_check, ui_extrap_ticks, ui_extrap_color
local ui_pred3d_check
local ui_pred3d_scale
if not (menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation) then
  
  ui_extrap_check = ui.new_checkbox('LUA', 'B', 'Self: Extrapolation Line')
  ui_extrap_ticks = ui.new_slider('LUA', 'B', 'Extrapolation ticks', 1, 64, 6)
  ui_extrap_color = ui.new_color_picker('LUA', 'B', 'Extrapolation color', 255, 200, 0, 220)
  ui_pred3d_check = ui.new_checkbox('LUA', 'B', 'Self: Predicted 3D Box')
  ui_pred3d_scale = ui.new_slider('LUA', 'B', 'Predicted 3D Box Scale %', 0, 200, 20)
end

local function is_self_extrapolation_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation)
    if ok then return val end
  elseif ui_extrap_check then
    local ok, val = pcall(ui.get, ui_extrap_check)
    if ok then return val end
  end
  return false
end

local function get_extrap_ticks()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_ticks then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_ticks)
    if ok then return val end
  elseif ui_extrap_ticks then
    local ok, val = pcall(ui.get, ui_extrap_ticks)
    if ok then return val end
  end
  return 6
end

local function get_extrap_color()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_color then
    local ok, r,g,b,a = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_color)
    if ok then return r,g,b,a end
  elseif ui_extrap_color then
    local ok, r,g,b,a = pcall(ui.get, ui_extrap_color)
    if ok then return r,g,b,a end
  end
  return 255,200,0,220
end

local function is_predicted_3d_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d)
    if ok then return val end
  elseif ui_pred3d_check then
    local ok, val = pcall(ui.get, ui_pred3d_check)
    if ok then return val end
  end
  return false
end

local function get_pred3d_scale()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d_scale then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d_scale)
    if ok then return val end
  elseif ui_pred3d_scale then
    local ok, val = pcall(ui.get, ui_pred3d_scale)
    if ok then return val end
  end
  return 20
end

client.set_event_callback('paint',function()
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  
  local _lp_state = client.globals and client.globals.__self_lc_state or nil
  if not _lp_state then
    _lp_state = {}
    client.globals = client.globals or {}
    client.globals.__self_lc_state = _lp_state
  end
  local function length_sqr(x,y,z)
    x = x or 0; y = y or 0; z = z or 0
    return x*x + y*y + z*z
  end
  local function time_to_ticks(seconds)
    local ti = globals.tickinterval and globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return math.floor((seconds or 0) / ti + 0.5)
  end
  local function is_local_breaking_lagcomp()
    local sim_time = entity.get_prop(lp, 'm_flSimulationTime')
    local ox,oy,oz = entity.get_origin(lp)
    if not sim_time or not ox then return false end
    local sim_ticks = time_to_ticks(sim_time)
    local prev = _lp_state.prev
    local breaking = false
    if prev then
      local delta = sim_ticks - prev.tick
      if delta > 0 and delta <= 64 then
        local dx,dy,dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
        local teleport_distance = length_sqr(dx,dy,dz)
        if teleport_distance > 4096 then breaking = true end
      end
    end
    _lp_state.prev = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
    return breaking
  end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end

  
  if is_self_extrapolation_enabled() then
    local ox,oy,oz = entity.get_origin(lp)
    if ox and oy and oz then
      local vx,vy,vz = entity.get_prop(lp, "m_vecVelocity")
      if vx and vy and vz then
        local ticks = get_extrap_ticks() or 6
        local tickint = (globals.tickinterval and globals.tickinterval()) or 0.015625
        local dt = tickint * ticks
        local px,py,pz = ox + vx * dt, oy + vy * dt, oz + vz * dt
        local sx1,sy1 = renderer.world_to_screen(ox,oy,oz)
        local sx2,sy2 = renderer.world_to_screen(px,py,pz)
        if sx1 and sx2 then
          local r,g,b,a = get_extrap_color()
          renderer.line(sx1,sy1,sx2,sy2, r, g, b, a)
          renderer.circle(sx2,sy2, r, g, b, a, 6, 0, 1.0)
          renderer.text(sx2, sy2 - 10, r, g, b, a, 'c+', 0, tostring(ticks) .. 't')
          
          local bx1,by1,bx2,by2,alpha_mult = entity.get_bounding_box(lp)
          if bx1 and alpha_mult and alpha_mult ~= 0 then
            local sx_orig, sy_orig = sx1, sy1
            if sx_orig and sy_orig then
              local dx, dy = sx2 - sx_orig, sy2 - sy_orig
              local bw, bh = (bx2 - bx1), (by2 - by1)
              local pbx, pby = bx1 + dx, by1 + dy
              
              renderer.rectangle(pbx, pby, bw, bh, 255,255,255,40)
              renderer.rectangle(pbx-1, pby-1, bw+2, bh+2, 255,255,255,200)
            end
          end

          
          if is_predicted_3d_enabled() and is_local_breaking_lagcomp() then
            
            local o = {x = ox, y = oy, z = oz}
            local offs = {}
            local keys = {'head','pelvis','l_shoulder','r_shoulder','l_hip','r_hip'}
            for i=1,#keys do
              local def = boxes[keys[i]]
              if def then
                local ok, hx, hy, hz = pcall(function() return find(lp, def) end)
                if ok and hx then
                  table.insert(offs, {x = hx - o.x, y = hy - o.y, z = hz - o.z})
                end
              end
            end
            if #offs > 0 then
              local minx,miny,minz = offs[1].x,offs[1].y,offs[1].z
              local maxx,maxy,maxz = offs[1].x,offs[1].y,offs[1].z
              for i=2,#offs do
                local v = offs[i]
                if v.x < minx then minx = v.x end
                if v.y < miny then miny = v.y end
                if v.z < minz then minz = v.z end
                if v.x > maxx then maxx = v.x end
                if v.y > maxy then maxy = v.y end
                if v.z > maxz then maxz = v.z end
              end
              
              local scale_pct = 105
              local cx = (minx + maxx) * 0.5
              local cy = (miny + maxy) * 0.5
              local cz = (minz + maxz) * 0.5
              local ex = (maxx - minx) * 0.5 * (1 + scale_pct / 100)
              local ey = (maxy - miny) * 0.5 * (1 + scale_pct / 100)
              local ez = (maxz - minz) * 0.5 * (1 + scale_pct / 100)
              minx = cx - ex; maxx = cx + ex
              miny = cy - ey; maxy = cy + ey
              minz = cz - ez; maxz = cz + ez

              
              local corners = {
                {x = px + minx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + maxy, z = pz + maxz},
                {x = px + minx, y = py + maxy, z = pz + maxz},
              }
              
              local sc = {}
              local all_on_screen = true
              for i=1,8 do
                local sx, sy = renderer.world_to_screen(corners[i].x, corners[i].y, corners[i].z)
                if not sx then all_on_screen = false break end
                sc[i] = {x = sx, y = sy}
              end
              if all_on_screen then
                
                local rr,gg,bb,aa = 255,255,255,200
                
                renderer.line(sc[1].x,sc[1].y,sc[2].x,sc[2].y, rr,gg,bb,aa)
                renderer.line(sc[2].x,sc[2].y,sc[3].x,sc[3].y, rr,gg,bb,aa)
                renderer.line(sc[3].x,sc[3].y,sc[4].x,sc[4].y, rr,gg,bb,aa)
                renderer.line(sc[4].x,sc[4].y,sc[1].x,sc[1].y, rr,gg,bb,aa)
                
                renderer.line(sc[5].x,sc[5].y,sc[6].x,sc[6].y, rr,gg,bb,aa)
                renderer.line(sc[6].x,sc[6].y,sc[7].x,sc[7].y, rr,gg,bb,aa)
                renderer.line(sc[7].x,sc[7].y,sc[8].x,sc[8].y, rr,gg,bb,aa)
                renderer.line(sc[8].x,sc[8].y,sc[5].x,sc[5].y, rr,gg,bb,aa)
                
                for i=1,4 do renderer.line(sc[i].x,sc[i].y,sc[i+4].x,sc[i+4].y, rr,gg,bb,aa) end
              end
            end
          end
        end
      end
    end
  end
end)]=]
u743["require/features/paint/self_skeleton"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end
end

if cb_ok and callbacks and callbacks.callback then
  callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end]=]
u743["require/features/paint/skeletons"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}


local time = require("require/help/time")
local enemies = require("require/help/enemies")
local color = require("require/help/color")
local math_help = require("require/help/math")




local function find(ent, def)
    if not ent or not def then return end
    local names = def.names
    if names then
        for i = 1, #names do
            local x, y, z = entity.hitbox_position(ent, names[i])
            if x then return x, y, z end
        end
    end
    local idx = def.idx
    if idx then
        for i = 1, #idx do
            local x, y, z = entity.hitbox_position(ent, idx[i])
            if x then return x, y, z end
        end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    return pts
end


client.set_event_callback("paint", function()
    local enemy_list = entity.get_players(true)
    for i = 1, #enemy_list do
        local ent = enemy_list[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local pts = snap(ent)
            for _, chain in ipairs(chains) do
                local from = pts[chain[1]]
                local to = pts[chain[2]]
                if from and to then
                    local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                    local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                    if fx and fy and tx and ty then
                        renderer.line(fx, fy, tx, ty, 255, 0, 0, 255)
                    end
                end
            end
        end
    end
end)

]=]
u743["require/features/paint/target_info"] = [[local u352= require("require/abc/menu_setup")
local u353= renderer
local u354= client


local u355= nil
local function u356()
	if u355 then return u355 end
	if u353.load_rgba then
		local u357, u358= pcall(u353.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if u357 and u358 then u355 = u358 end
	end
	return u355
end




local u359= state or {
	fl_val = math.random(0, 14),
	fl_target = math.random(0, 14),
	by_val = math.random(-58, 58),
	by_target = math.random(-58, 58),
	last_update = u354.system_time()
}


local function u360()
	u359.fl_val = math.random(0, 14)
	u359.by_val = math.random(-58, 58)
end



local function u361()
	local u362= u354.system_time()
	if u362 - u359.last_update > 1 then
		u359.fl_target = math.random(0, 14)
		u359.by_target = math.random(-58, 58)
		u359.last_update = u362
	end
end

local function u363()
	u359.fl_val = u359.fl_val + (u359.fl_target - u359.fl_val) * 0.08
	u359.by_val = u359.by_val + (u359.by_target - u359.by_val) * 0.08
end

local function u364()
	if not ui.get(u352.ui.paint_target_info) then return end

	u361()
	u363()
	u360() 

	
	local u365, u366= u354.screen_size()
	local u367= 170
	local u368= 80
	local u369= 30
	local u370= math.floor(u366 / 2 - u368 / 2)

	
	u353.rectangle(u369 - 7, u370 - 5, u367 + 14, u368 + 10, 0, 0, 0, 200)
	u353.rectangle(u369 - 6, u370 - 4, u367 + 12, u368 + 8, 60, 60, 60, 255)
	u353.rectangle(u369 - 5, u370 - 3, u367 + 10, u368 + 6, 40, 40, 40, 255)
	u353.rectangle(u369 - 3, u370 - 1, u367 + 6, u368 + 2, 60, 60, 60, 255)
	u353.rectangle(u369 - 2, u370, u367 + 4, u368, 12, 12, 12, 255)
	u353.rectangle(u369 - 2, u370, u367 + 4, u368, 32, 32, 32, 255)

	
	local u371= u356()
	if u371 and u353.texture then
		u353.texture(u371, u369 - 2, u370, u367 + 4, u368, 255,255,255,60, 'r')
	end

	
	local u372= u370
	local u373= 1
	local u374= math.floor((u367 + 4) / 2)
	local u375= math.ceil((u367 + 4) / 2)
	
	u353.rectangle(u369 - 2, u372 - 1, u367 + 4, u373 + 2, 0, 0, 0, 255)
	if u353.gradient then
		u353.gradient(u369 - 2, u372, u374, u373, 59,175,222,255, 202,70,205,255, true)
		u353.gradient(u369 - 2 + u374, u372, u375, u373, 202,70,205,255, 204,227,53,255, true)
	end

	
	local u376= u369 + 12
	local u377= u370 + 13  
	local u378= 18
	local u379= u367 - 60 
	local u380= 7 

	
	local u381= math.floor(u359.fl_val + 0.5)
	
	local u382= u380 / 2 - 7
	u353.text(u376 - 8, u377 + u382, 255,255,255,255, '', 0, "Fake lag")
	local u383= u376 + 42 
	local u384= u377 + 6  
	local u385= 14
	local u386= math.floor(u379 * (u359.fl_val / u385))
	
	local u387= u379 + 2
	local u388= u380 + 2
	local u389= u383 + 1
	local u390= u384 + 1
	local u391= u379 - 2
	local u392= u380 - 2
	u353.rectangle(u383 - 1, u384 - 1, u387, u388, 0, 0, 0, 255)
	u353.rectangle(u383, u384, u379, u380, 60, 60, 60, 255)
	u353.rectangle(u389, u390, math.max(0, math.floor(u391 * (u359.fl_val / u385))), u392, 180, 220, 80, 255)
	local u393= u383 + u386 - 4
	local u394= u384 + u380 / 2
	u353.circle(u393, u394, 5, 180,220,80,255, 16)
	
	local u395= tostring(u381)
	local u396= u383 + u386 + 8 
	local u397= u384 + u380 + 0 
	u353.text(u396 + 1, u397 + 1, 0,0,0,255, '-', 0, u395)
	u353.text(u396, u397, 255,255,255,255, '-', 0, u395)

	
	local u398= math.floor(u359.by_val + 0.5)
	u353.text(u376 - 8, u377 + u378 + u382, 255,255,255,255, '', 0, "Body yaw")
	local u399= u376 + 42 
	local u400= u377 + u378 + 6  
	local u401= -58
	local u402= 58
	local u403= u402 - u401
	
	local u404= math.floor(u379 * ((u359.by_val - u401) / u403))
	
	local u405= u379 + 2
	local u406= u380 + 2
	local u407= u399 + 1
	local u408= u400 + 1
	local u409= u379 - 2
	local u410= u380 - 2
	u353.rectangle(u399 - 1, u400 - 1, u405, u406, 0, 0, 0, 255)
	u353.rectangle(u399, u400, u379, u380, 60, 60, 60, 255)
	
	local u411= u399 + u379 / 2
	local u412= u399 + u404
	if u359.by_val < 0 then
		u353.rectangle(u412 + 1, u408, u411 - u412, u410, 180, 220, 80, 255)
	else
		u353.rectangle(u411 + 1, u408, u412 - u411, u410, 180, 220, 80, 255)
	end
	local u413= u412 - 4
	local u414= u400 + u380 / 2
	u353.circle(u413, u414, 5, 180,220,80,255, 16)
	
	local u415= tostring(u398)
	local u416= u399 + u404
	local u417= u416 + 8 
	local u418= u400 + u380 + 0 
	u353.text(u417 + 1, u418 + 1, 0,0,0,255, '-', 0, u415)
	u353.text(u417, u418, 255,255,255,255, '-', 0, u415)

	
	local u419= 22
	local u420= 14

	
	local u421= math.random() > 0.5 and "[Offensive]" or "[Defensive]"
	local u422= u421 == "[Offensive]" and {204,227,53,255} or {202,70,205,255}
	u353.text(u376 - 8, u377 + u378 * 2 + u382, 255,255,255,255, '', 0, "Double tap")
	local u423= u376 + u379 + 32
	local u424= u377 + u378 * 2 - 2
	u353.text(u423 + 4, u424 + 2, table.unpack(u422), '', 0, u421)

	
	local u425= math.random() > 0.5 and "[On]" or "[Off]"
	local u426= u425 == "[On]" and {80,255,80,255} or {255,255,80,255}
	u353.text(u376 - 8, u377 + u378 * 3 + u382, 255,255,255,255, '', 0, "Freestanding")
	local u427= u376 + u379 + 32
	local u428= u377 + u378 * 3 - 2
	u353.text(u427 + 4, u428 + 2, table.unpack(u426), '', 0, u425)
end

local u429= require("require/abc/callbacks")
u429.callback('paint', u364, { alive_only = true, require_login = true })
]]
u743["require/features/paint/text_watermark"] = [[local u355= require("require/help/string")
local u356= require("require/help/time")
local u357= require("require/help/color")
local u358= u357.rgba_to_hex
local u359= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local u360= nil

local function u361(u362,u363,u364,u365,u366,u367,u368)
    local u369= u356.realtime() or globals.curtime()
    if not u368 or #u368 == 0 then return "" end
    local u370= {}

    if u362 == 0 then
        local u371= u358(u364,u365,u366,u367)
        for i=1,#u368 do u370[#u370+1] = u371 .. u368:sub(i,i) end
        return table.concat(u370)
    end

    if u362 == 2 then
        local u372= (math.sin(u369 * u363) + 1) * 0.5
        local u373= u357.clamp(math.floor(u367 * (0.45 + 0.55 * u372)))
        local u371= u358(u364,u365,u366,u373)
        for i=1,#u368 do u370[#u370+1] = u371 .. u368:sub(i,i) end
        return table.concat(u370)
    end

    if u362 == 3 then
        for i=1,#u368 do
            local u374= math.sin(u369 * u363 - i * 0.6)
            local u375= math.max(0, u374)
            local u372= u375 * u375
            local u373= u357.clamp(math.floor(u367 * (0.35 + 0.65 * u372)))
            u370[#u370+1] = u358(u364,u365,u366,u373) .. u368:sub(i,i)
        end
        return table.concat(u370)
    end

    for i=1,#u368 do
        local u372= (math.sin(u369*u363 - i*0.35) + 1) * 0.5
        local u373= u357.clamp(math.floor(u367 * (0.4 + 0.6 * u372)))
        u370[#u370+1] = u358(u364,u365,u366,u373) .. u368:sub(i,i)
    end
    return table.concat(u370)
end

local u376= {}
local u377= {}
for i, item in ipairs({
    { 'misc', 'settings', 'menu color' },
}) do
    local u378= {ui.reference(item[1], item[2], item[3])}
    u376[i] = u378
    for _, ref in ipairs(u378) do
        u377[ref] = true
    end
end

local u379, u380= pcall(require, "require/abc/callbacks")
local function u381(u382)
    local u383, u384= client.screen_size()
    if not u383 or not u384 then return end
    local u385, u386, u387, u388= 255, 255, 255, 255
    
    local u389= false
    local u390, u391= pcall(require, "require/abc/menu_setup")
    if u390 and u391 and u391.ui and u391.ui.paint_advertisement_color then
        local u392, u367, u366, u393, u394= pcall(ui.get, u391.ui.paint_advertisement_color)
        if u392 then
            u389 = true
            if type(u367) == 'number' then
                u385 = u357.clamp(u367 or u385)
                u386 = u357.clamp(u366 or u386)
                u387 = u357.clamp(u393 or u387)
                u388 = u357.clamp(u394 or u388)
            elseif type(u367) == 'string' and #u367 == 12 then
                local u395
                u395, mr = pcall(function() return tonumber(u367:sub(1,3)) end)
                u395, mg = pcall(function() return tonumber(u367:sub(4,6)) end)
                u395, mb = pcall(function() return tonumber(u367:sub(7,9)) end)
                u395, ma = pcall(function() return tonumber(u367:sub(10,12)) end)
                u385 = u357.clamp(u385 or 255); u386 = u357.clamp(u386 or 255); u387 = u357.clamp(u387 or 255); u388 = u357.clamp(u388 or 255)
            end
        end
    end

    if not u389 then
        local u392, u367, u366, u393, u394= pcall(ui.get, u376[1][1])
        if u392 then
            if type(u367) == 'number' then
                u385 = u357.clamp(u367 or u385)
                u386 = u357.clamp(u366 or u386)
                u387 = u357.clamp(u393 or u387)
                u388 = u357.clamp(u394 or u388)
            elseif type(u367) == 'string' and #u367 == 12 then
                local u395
                u395, mr = pcall(function() return tonumber(u367:sub(1,3)) end)
                u395, mg = pcall(function() return tonumber(u367:sub(4,6)) end)
                u395, mb = pcall(function() return tonumber(u367:sub(7,9)) end)
                u395, ma = pcall(function() return tonumber(u367:sub(10,12)) end)
                u385 = u357.clamp(u385 or 255); u386 = u357.clamp(u386 or 255); u387 = u357.clamp(u387 or 255); u388 = u357.clamp(u388 or 255)
            end
        end
    end

    local u390, u391= pcall(require, "require/abc/menu_setup")
    if not u390 or not u391 or not u391.ui then return end
    if not ui.get(u391.ui.paint_advertisement) then return end
    local u369= u356.realtime() or globals.curtime()
    local u396= 0
    local u397= math.floor(200 + 55 * (math.sin(u369*2)+1)/2)
    local u398, u399, u400= "sodium", "[BETA]", 3

    local u401, u402= renderer.measure_text("", u398)
    u401 = u401 or 0; u402 = u402 or 16
    local u403= (renderer.measure_text("", u399) or 0)

    if u359 and not u360 then
        local u404= math.floor(u383/2 - (u401 + u400 + u403)/2)
        local u405= math.floor(u384 - 15)
        u360 = u359.new('sodium_watermark', {
            x = u404,
            y = u405,
            w = u401 + u400 + u403,
            h = u402,
                default_pos = { x = u404, y = u405 },
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
        })
    end

    if u360 then
        u360:handle()
    end

    local u406, u407
    if u360 then
        u406 = u360.x
        u407 = u360.y + u396
    else
        u406 = math.floor(u383/2 - (u401 + u400 + u403)/2)
        u407 = u384 - 15 + u396
    end

    local u408= math.floor(math.max(0, u397 - 140) * 0.6)
    local u409= { {-1,0},{1,0},{0,-1},{0,1} }

    if u360 then u360:draw() end

    for _,o in ipairs(u409) do renderer.text(u406+o[1], u407+o[2], 0,0,0, u408, "", 0, u398) end
    renderer.text(u406, u407, 255,255,255, u397, "", 0, u398)

    local u410= 1
    local u411, u412= pcall(require, "require/abc/menu_setup")
    if u411 and u412 and u412.ui and u412.ui.paint_advertisement_animation then
        local u413, u414= pcall(ui.get, u412.ui.paint_advertisement_animation)
        if u413 and type(u414) == 'number' then u410 = u414 end
    end

    local u415= u406 + u401 + u400
    local u416= u361(u410, 3.5, u385, u386, u387, u388, u399)
    renderer.text(u415, u407, u385, u386, u387, u388, "", 0, u416)
end

if u379 and u380 and u380.callback then
    u380.callback('paint', u381, { alive_only = true, require_login = true })
end]]
u743["require/features/paint/third_person_distance"] = [[local u358= require("require/abc/menu_setup")
local u359= require("require/help/time")
local u360= require("require/help/math")
local u361= require("require/help/safe")
local u362= { original = nil, last = nil, last_update = nil }

local function u363()
    if cvar.cam_idealdist and cvar.cam_idealdist.get_float then
        return cvar.cam_idealdist:get_float()
    end
    return nil
end

local function u364(u365)
    if cvar.cam_idealdist and cvar.cam_idealdist.set_float then
        cvar.cam_idealdist:set_float(u365)
        return true
    elseif client and client.exec then
        client.exec("cam_idealdist " .. tostring(u365))
        return true
    end
    return false
end

local u366= require("require/abc/callbacks")
u366.callback('paint', function()
    local u367= u358.ui and u358.ui.paint_third_person_distance
    if not u367 then
        client.log('third_person_distance: menu ref missing')
        return
    end
    local u368= u361.safe_get(u367)
    if type(u368) ~= 'number' then
        client.log('third_person_distance: invalid slider value', tostring(u368))
        return
    end
    local u369= u360.clamp(u368, 29, 180)
    u369 = u360.round(u369, 2)
    if u362.original == nil then
        u362.original = u363()
        if u362.original == nil then
            client.log('third_person_distance: cam_idealdist cvar not available')
        end
    end
    if u362.last == nil then
        u362.last = u363() or u369
    end
    local u370= u359.realtime()
    local u371= u362.last_update or u370
    local u372= u370 - u371
    u362.last_update = u370
    local u373= 300
    local u374= u373 * u372
    if math.abs(u362.last - u369) > 0.01 then
        local u375= u360.clamp(u374 / math.max(math.abs(u369 - u362.last), 0.01), 0, 1)
        u362.last = u360.lerp(u362.last, u369, u375)
        u362.last = u360.round(u362.last, 2)
        u364(u362.last)
    end
end, { require_login = true })]]
u743["require/features/paint/warnings"] = [[local u361, u362= client.screen_size()
local u363, u364= pcall(require, "require/abc/menu_setup")


local function u365()
    
    if not u363 or not u364 or not u364.ui or not u364.ui.paint_warnings then return end
    local u366= ui.get(u364.ui.paint_warnings)
    local u367= false
    if type(u366) == "table" then
        for _, v in ipairs(u366) do
            if v == "lethal" then u367 = true break end
        end
    end
    if not u367 then return end

    if entity.get_prop(entity.get_local_player(), 'm_iHealth') and entity.get_prop(entity.get_local_player(), 'm_iHealth') > 0 and entity.get_prop(entity.get_local_player(), 'm_iHealth') < 93 then
        renderer.text(u361 / 2, u362 * 0.3, 255, 0, 0, 255, "c, -", 0, "YOU'RE LETHAL:   " .. entity.get_prop(entity.get_local_player(), 'm_iHealth') .. " HP REMAINING")
    end
    
end

local u368, u369= pcall(require, "require/abc/callbacks")
if u368 and u369 then
    u369.callback('paint', u365, { alive_only = true, require_login = true })
end]]
u743["require/features/paint/watermark_gamesense"] = [[local u364= renderer
local u365= client
local u366= globals
local u367= require('require/help/color')

local u368= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local u369= nil

local function u370()
	local u371= u366 and u366.frametime and u366.frametime() or 0.016
	if u371 > 0 then
		return math.floor(1 / u371 + 0.5)
	end
	return 0
end

local u372= nil
local function u373()
	if u372 then return u372 end
	if u364.load_rgba then
		local u374, u375= pcall(u364.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if u374 and u375 then u372 = u375 end
	end
	return u372
end

local u376= u367.hex_to_rgba

local u377= {
	green  = "a5ca2aFF",
	red    = "d96464FF",
	yellow = "ccb854FF",
	blue   = "5462ccFF",
	purple = "7054ccFF",
	white  = "ffffffFF",
	grey   = "757575FF",
	black  = "000000FF",
	pink   = "c8a2deFF",
}


local u378= require("require/abc/login_system")
local u379= require("require/abc/menu_setup")
local u380= require("require/help/self")

local u381= require("require/help/time")
local u382= 0
local u383= u381.new(0.25)

local function u384()
	if not u379 or not u379.ui then return end
	
	local u385, u386= pcall(ui.get, u379.ui.paint_watermark)
	if not u385 or not u386 then return end
	
	local u387, u388= pcall(ui.get, u379.ui.paint_watermark_type)
	if not u387 or u388 ~= 0 then return end
	local u389, u390= u365 and u365.screen_size and u365.screen_size() or 800, 600

	local u391
	if u378.logged_in then
		local u392= database.read and database.read('cached_credentials')
		if u392 and u392.username then
			u391 = u392.username
		end
	else
		local u393= u378.load_credentials and u378.load_credentials()
		if u393 and u393.username then
			u391 = u393.username
		end
	end
	if not u391 or u391 == "" then
		u391 = u380.player_name and u380.player_name() or "unknown"
	end
	if u381.expired(u383) then
		u382 = u370()
		u381.reset(u383)
	end
	local u394= u382

	local u395= 0
	if u380 and u380.ping then
		local u396= u380.ping()
		if type(u396) == 'number' then u395 = u396 end
	elseif u365 and u365.latency then
		local u396= u365.latency()
		if type(u396) == 'number' then u395 = u396 end
	end
	local u397= math.floor((u395 or 0) * 1000 + 0.5)

	local u398= ''
	local u399= {
		{text = "game", style = u398, color = u377.white},
		{text = "sense", style = u398, color = u377.green},
		{text = " ", style = u398, color = u377.white},
		{text = "[beta]", style = u398, color = u377.white},
		{text = " | ", style = u398, color = u377.white},
		{text = u391, style = u398, color = u377.white},
		{text = " | ", style = u398, color = u377.white},
		{text = tostring(u397) .. " ms", style = u398, color = u377.white},
		{text = " | ", style = u398, color = u377.white},
		{text = tostring(u394) .. " fps", style = u398, color = u377.white},
	}

	local u400, u401= 0, 0
	for _, seg in ipairs(u399) do
		local u402, u403= u364.measure_text and u364.measure_text(seg.style, seg.text) or 0, 13
		u400 = u400 + u402
		if u403 > u401 then u401 = u403 end
	end
	local u404, u405= 5, 2
	local u406= u400 + u404 * 2
	local u407= u401 + u405 * 2
	local u408= u389 - u406 - 16
	local u409= 16

	if u368 and not u369 then
		local u410= u408
		local u411= u409
		u369 = u368.new('gamesense_watermark', {
			x = u410,
			y = u411,
			w = u406,
			h = u407,
			snap = true,
			snap_threshold = 24,
			require_menu_open = true,
			box_color = {255,255,255,100},
			default_pos = { x = u410, y = u411 },
		})
	end

	if u369 then u369:handle() end

	if u369 then
		u408 = u369.x
		u409 = u369.y
	end

	u364.rectangle(u408 - 7, u409 - 5, u406 + 14, u407 + 10, 0, 0, 0, 200)
	u364.rectangle(u408 - 6, u409 - 4, u406 + 12, u407 + 8, 60, 60, 60, 255)
	u364.rectangle(u408 - 5, u409 - 3, u406 + 10, u407 + 6, 40, 40, 40, 255)
	u364.rectangle(u408 - 3, u409 - 1, u406 + 6, u407 + 2, 60, 60, 60, 255)
	u364.rectangle(u408 - 2, u409, u406 + 4, u407, 12, 12, 12, 255)
	u364.rectangle(u408 - 2, u409, u406 + 4, u407, 32, 32, 32, 255)

	local u412= u373()
	if u412 and u364.texture then
		u364.texture(u412, u408 - 2, u409, u406 + 4, u407, 255,255,255,60, 'r')
	end

	if u364.gradient then
		u364.gradient(u408 - 2, u409, u406 / 2 + 1, 1, 59,175,222,255, 202,70,205,255, true)
		u364.gradient(u408 - 2 + u406 / 2, u409, u406 / 2 + 4.5, 1, 202,70,205,255, 204,227,53,255, true)
	end

	local u413= u408 + u404
	local u414= u409 + u405
    if u369 then u369:draw() end
	for _, seg in ipairs(u399) do
		local u402, u403= u364.measure_text and u364.measure_text(seg.style, seg.text) or 0, 13
			local u415,u416,u417,u418= u376(seg.color)
			u415,u416,u417,a = u367.normalize(u415,u416,u417,u418)
			u364.text(u413, u414, u415,u416,u417,u418, seg.style, nil, seg.text)
		u413 = u413 + u402
	end
end

local u419, u420= pcall(require, "require/abc/callbacks")
if u419 and u420 and u420.callback then
	u420.callback('paint', u384, { alive_only = true, require_login = true })
end
]]
u743["require/features/paint/watermark_solus"] = [[local u367= renderer
local u368= client
local u369= require('require/help/color')
local u370, u371= pcall(require, "require/abc/callbacks")
local u372, u373= pcall(require, "require/abc/menu_setup")
local u374, u375= pcall(ui.reference, 'misc', 'settings', 'menu color')
local u376= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local u377= nil
local function u378(u379,u380,u381,u382,u383,u384,u385,u386,u387)
    u367.rectangle(u379+u383, u380, u381-(u383*2), u382, u384,u385,u386,u387)
    u367.rectangle(u379, u380+u383, u381, u382-(u383*2), u384,u385,u386,u387)
    u367.circle(u379+u383, u380+u383, u384,u385,u386,u387, u383, 0, 1)
    u367.circle(u379+u381-u383, u380+u383, u384,u385,u386,u387, u383, 0, 1)
    u367.circle(u379+u383, u380+u382-u383, u384,u385,u386,u387, u383, 0, 1)
    u367.circle(u379+u381-u383, u380+u382-u383, u384,u385,u386,u387, u383, 0, 1)
end

local u388= globals
local u389= 0
local u390= 0
local u391= 0.1

local function u392(u393)
    local u394, u395= pcall(require, u393)
    if u394 then return u395 end
    return nil
end

local function u396()
    if not u372 or not u373 or not u373.ui then return end
    local u397, u398= pcall(ui.get, u373.ui.paint_watermark)
    if not u397 or not u398 then return end
    local u399, u400= pcall(ui.get, u373.ui.paint_watermark_type)
    if not u399 or u400 ~= 1 then return end

    local u401, u402= u368.screen_size()
    if not u401 or not u402 then return end

    local u403= "unknown"
    local u404= u392('require/abc/login_system')
    local u405= (pcall(require, 'require/help/self') and require('require/help/self')) or nil
    if u404 then
        if u404.logged_in then
            local u406= database and database.read and database.read('cached_credentials')
            if u406 and u406.username then u403 = u406.username end
        else
            if u404.load_credentials then
                local u407= u404.load_credentials()
                if u407 and u407.username then u403 = u407.username end
            end
        end
    end
    if (not u403 or u403 == "") and u405 and u405.player_name then
        u403 = u405.player_name()
    end

    local u408= u389 or 0
    pcall(function()
        local u409= u388 and u388.realtime and u388.realtime() or os.clock()
        if (u409 - (u390 or 0)) >= u391 then
            local u410= u388 and u388.frametime and u388.frametime() or 0.016
            if u410 and u410 > 0 then
                u389 = math.floor(1 / u410 + 0.5)
            end
            u390 = u409
        end
        u408 = u389 or u408
    end)

    local u411= 0
    if u405 and u405.ping then
        local u412= u405.ping()
        if type(u412) == 'number' then u411 = math.floor(u412 * 1000 + 0.5) end
    elseif u368 and u368.latency then
        local u412= u368.latency()
        if type(u412) == 'number' then u411 = math.floor(u412 * 1000 + 0.5) end
    end

    local u413= {
        { text = "gamesense ", bold = true },
        { text = " | ", bold = false },
        { text = u403 or "unknown", bold = false },
        { text = " | ", bold = false },
        { text = tostring(u411) .. " ms", bold = false },
        { text = " | ", bold = false },
        { text = tostring(u408) .. " fps", bold = false },
    }

    local u414, u415= 0, 0
    for _, seg in ipairs(u413) do
        local u381, u382= 0, 13
        if u367.measure_text then
            local u394, u416, u417= pcall(u367.measure_text, '', seg.text)
            if u394 and u416 then u381, h = u416, u417 or u382 end
        end
        u414 = u414 + (u381 or 0)
        if u382 and u382 > u415 then u415 = u382 end
    end

    local u418, u419= 12, 6
    local u420= u414 + u418 * 2
    local u421= u415 + u419 * 2
    local u422= 18
    local u379= u401 - u420 - u422
    local u380= u422
    local u383= 8
    if u376 and not u377 then
        local u423= u379
        local u424= u380
        u377 = u376.new('solus_watermark', {
            x = u423,
            y = u424,
            w = u420,
            h = u421,
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
            default_pos = { x = u423, y = u424 },
        })
    end

    if u377 then u377:handle() end

    if u377 then
        u379 = u377.x
        u380 = u377.y
    end
    local u425, u426, u427, u428= 255, 140, 0, 255
    do
        
        if u372 and u373 and u373.ui and u373.ui.paint_watermark_color then
            local u429, u430, u431, u432, u433= pcall(ui.get, u373.ui.paint_watermark_color)
            if u429 then
                if type(u430) == 'number' then
                    u425 = u369.clamp(u430 or u425)
                    u426 = u369.clamp(u431 or u426)
                    u427 = u369.clamp(u432 or u427)
                    u428 = u369.clamp(u433 or u428)
                elseif type(u430) == 'string' and #u430 == 12 then
                    local u394
                    u394, mr = pcall(function() return tonumber(u430:sub(1,3)) end)
                    u394, mg = pcall(function() return tonumber(u430:sub(4,6)) end)
                    u394, mb = pcall(function() return tonumber(u430:sub(7,9)) end)
                    u394, ma = pcall(function() return tonumber(u430:sub(10,12)) end)
                    u425 = u369.clamp(u425 or 255); u426 = u369.clamp(u426 or 140); u427 = u369.clamp(u427 or 0); u428 = u369.clamp(u428 or 255)
                end
                
            else
                
                if u374 and u375 then
                    local u434, u435, u436, u437, u438= pcall(ui.get, u375)
                    if u434 then
                        if type(u435) == 'number' then
                            u425 = u369.clamp(u435 or u425)
                            u426 = u369.clamp(u436 or u426)
                            u427 = u369.clamp(u437 or u427)
                            u428 = u369.clamp(u438 or u428)
                        elseif type(u435) == 'string' and #u435 == 12 then
                            local u394
                            u394, mr = pcall(function() return tonumber(u435:sub(1,3)) end)
                            u394, mg = pcall(function() return tonumber(u435:sub(4,6)) end)
                            u394, mb = pcall(function() return tonumber(u435:sub(7,9)) end)
                            u394, ma = pcall(function() return tonumber(u435:sub(10,12)) end)
                            u425 = u369.clamp(u425 or 255); u426 = u369.clamp(u426 or 140); u427 = u369.clamp(u427 or 0); u428 = u369.clamp(u428 or 255)
                        end
                    end
                end
            end
        else
            
            if u374 and u375 then
                local u429, u430, u431, u432, u433= pcall(ui.get, u375)
                if u429 then
                    if type(u430) == 'number' then
                        u425 = u369.clamp(u430 or u425)
                        u426 = u369.clamp(u431 or u426)
                        u427 = u369.clamp(u432 or u427)
                        u428 = u369.clamp(u433 or u428)
                    elseif type(u430) == 'string' and #u430 == 12 then
                        local u394
                        u394, mr = pcall(function() return tonumber(u430:sub(1,3)) end)
                        u394, mg = pcall(function() return tonumber(u430:sub(4,6)) end)
                        u394, mb = pcall(function() return tonumber(u430:sub(7,9)) end)
                        u394, ma = pcall(function() return tonumber(u430:sub(10,12)) end)
                        u425 = u369.clamp(u425 or 255); u426 = u369.clamp(u426 or 140); u427 = u369.clamp(u427 or 0); u428 = u369.clamp(u428 or 255)
                    end
                end
            end
        end
    end

    local function u439(u440,u441,u442,u384,u443,u444,u445)
        local u446= math.rad(u443)
        local u447= math.rad(u444)
        for i=0,u445 do
            local u448= i / u445
            local u387= u446 + (u447 - u446) * u448
            u440[#u440+1] = { u441 + math.cos(u387) * u384, u442 + math.sin(u387) * u384 }
        end
    end

    local function u449(u379,u380,u381,u382,u450,u451)
        local u452= {}
        u451 = u451 or 6
        local u453= u379
        local u454= u379 + u381
        local u455= u380
        local u456= u380 + u382
        local u457= u453 + u450
        local u458= u454 - u450
        local function u459(u460,u461)
            local u462= #u452
            if u462 == 0 then u452[#u452+1] = { u460, u461 }; return end
            local u463= u452[u462]
            if not (math.abs(u463[1] - u460) < 0.001 and math.abs(u463[2] - u461) < 0.001) then
                u452[#u452+1] = { u460, u461 }
            end
        end

        if u458 > u457 then
            for xx = u457, u458, u451 do u459(xx, u455) end
            
            u459(u458, u455)
        end

        u439(u452, u454 - u450, u455 + u450, u450, -90, 0, 6)

        local u464= u455 + u450
        local u465= u456 - u450
        if u465 > u464 then
            for yy = u464, u465, u451 do u459(u454, yy) end
            u459(u454, u465)
        end

        u439(u452, u454 - u450, u456 - u450, u450, 0, 90, 6)

        if u458 > u457 then
            for xx = u458, u457, -u451 do u459(xx, u456) end
            u459(u457, u456)
        end

        u439(u452, u453 + u450, u456 - u450, u450, 90, 180, 6)

        if u465 > u464 then
            for yy = u465, u464, -u451 do u459(u453, yy) end
            u459(u453, u464)
        end

        u439(u452, u453 + u450, u455 + u450, u450, 180, 270, 6)

        return u452
    end

    local u466= 3
    local u452= u449(u379-1, u380-1, u420+2, u421+2, u383+1, u466)
    local u462= #u452

    if u377 then u377:draw() end

    u378(u379-1, u380-1, u420+2, u421+2, u383+1, 0, 0, 0, 255)
    u378(u379, u380, u420, u421, u383, 0, 0, 0, 200)

    
    if u462 > 2 then
        local u448= (u388 and u388.realtime and u388.realtime() or 0)
        local u467= 7
        u467 = u467 * 4
        local u468= u467 / 60
        local u469= math.max(0.5, u468 * u462)
        local u470= math.floor((u448 * u469) % u462)

        local u471= math.max(6, math.floor(u462 * 0.25))

        local u472= u369.clamp(math.floor((u428 or 255) * 1.15))
        for j = u471 - 1, 0, -1 do
            local u473= ((u470 + j) % u462) + 1
            local u474= ((u470 + j + 1) % u462) + 1
            local u475= u452[u473]
            local u476= u452[u474]
            if u475 and u476 then
                local u477= 1 - (j / u471)
                local u387= u369.clamp(math.floor(u472 * u477))
                u367.line(u475[1], u475[2], u476[1], u476[2], u425, u426, u427, u387)
            end
        end
    end

    local u478= u379 + u418
    local u479= u380 + math.floor((u421 - u415) / 2)
    for i, seg in ipairs(u413) do
        local u381= 0
        if u367.measure_text then
            local u394, u416= pcall(u367.measure_text, '', seg.text)
            if u394 and u416 then u381 = u416 end
        end
        local u480= seg.bold and 'b' or ''
        u367.text(u478, u479, 255,255,255,255, u480, 0, seg.text)
        u478 = u478 + u381
    end
end

if u370 and u371 and u371.callback then
    u371.callback('paint', u396, { alive_only = true, require_login = true })
end

return true]]
u743["require/features/paint/world_hitmarker_plus"] = [[
local u370= require("require/abc/menu_setup")
local u371= {shots = {}, last = 0}
local u372, u373= pcall(require, "require/brain/api/vector/vector")

local function u374()
	local u375= ui.get(u370.ui.paint_hitmarker)
	if type(u375) == "table" then
		for _, v in ipairs(u375) do
			if v == "world +" then return true end
		end
	end
	return false
end

local u376, u377= pcall(require, "require/abc/callbacks")
local function u378(u379)
	if not u374() then u371.shots = {} return end
	if not u374() then return end
	local u380= globals.realtime()
	
	if u371.last and u380 - u371.last < 0.05 then return end
	u371.last = u380
	u371.shots[#u371.shots + 1] = {impacts = {}, finished = false, t = u380}
	if #u371.shots > 12 then table.remove(u371.shots, 1) end
end

local function u381(u379)
	if not u374() then u371 = {shots = {}, last = 0} return end
	local u382= entity.get_local_player()
	if not u382 then return end
	local u383= client.userid_to_entindex(u379.userid or 0)
	if u383 ~= u382 then return end
	local u380= globals.realtime()
	local u384
	for i = #u371.shots, 1, -1 do
		if not u371.shots[i].finished and u380 - (u371.shots[i].t or 0) < 1.2 then
			u384 = u371.shots[i]
			break
		end
	end
	if not u384 then return end
	local u385, u386, u387= u379.x, u379.y, u379.z
	local u388, u389, u390, u391= pcall(client.eye_position)
	local u392, u393, u394= 0, 0, 0
	if u388 and u389 and u390 and u391 then
		if u372 and u373 and u373.make and u373.normalized and u373.sub then
			local u395= u373.make(u385, u386, u387)
			local u396= u373.make(u389, u390, u391)
			local u397= u373.normalized(u373.sub(u395, u396))
			u392, u393, dirz = u397.x, u397.y, u397.z
		else
			u392 = u385 - u389; u393 = u386 - u390; u394 = u387 - u391
			local u398= math.sqrt(u392*u392 + u393*u393 + u394*u394)
			if u398 > 0 then u392, u393, dirz = u392/u398, u393/u398, u394/u398 end
		end
	end
	local u399= false
	local u400, u401, u402= pcall(client.trace_line, u382, u385 - (u392 or 0) * 1, u386 - (u393 or 0) * 1, u387 - (u394 or 0) * 1, u385 + (u392 or 0) * 1, u386 + (u393 or 0) * 1, u387 + (u394 or 0) * 1)
	if u400 and u402 and u402 > 0 and u402 ~= u382 then
		if entity.is_enemy(u402) then u399 = true end
	end
	local u403, u404, u405, u406
	local u407, u408, u409, u410, u411= pcall(ui.get, u370.ui.paint_hitmarker_color)
	if u407 and u408 then
		u403, u404, u405, ca = u408 or 0, u409 or 235, u410 or 235, u411 or 255
	else
		u403, u404, u405, ca = 0, 235, 235, 255
	end
	u384.impacts[#u384.impacts + 1] = {x = u385, y = u386, z = u387, t = u380, r = u403, g = u404, b = u405, a = u406, dir = {u392, u393, u394}, hit = u399}
	
	if #u384.impacts > 5 then table.remove(u384.impacts, 1) end
	if u399 then
		u384.finished = true
	end
end

local function u412(u379)
	if u374() then
		local u380= globals.realtime()
		local u413= 5.5 * 3 * 0.8
		local u414= 0.25 * 0.8
		local u415= u413 + u414
		local u416= 1
		while u416 <= #u371.shots do
			if u380 - (u371.shots[u416].t or 0) > u415 then
				table.remove(u371.shots, u416)
			else
				u416 = u416 + 1
			end
		end
		
		local u417= {}
		local u418= 12
		for si = #u371.shots, 1, -1 do
			local u384= u371.shots[si]
			for ii = #u384.impacts, 1, -1 do
				table.insert(u417, u384.impacts[ii]) 
				if #u417 >= u418 then break end
			end
			if #u417 >= u418 then break end
		end
		local u419= math.min(4, #u417)
		for j = 1, u419 do
			local u420= u417[j]
			local u421, u422, u423= u420.x, u420.y, u420.z
			if not u420.hit and u420.dir then
				local u389= u420.x + (u420.dir[1] or 0) * 24
				local u390= u420.y + (u420.dir[2] or 0) * 24
				local u391= u420.z + (u420.dir[3] or 0) * 24
				u421, u422, draw_z = u389, u390, u391
			end
			local u424, u425= renderer.world_to_screen(u421, u422, u423)
			if u424 and u425 then
				local u426= u380 - (u420.t or 0)
				local u427= u426 <= u413 and 255 or math.floor(math.max(0, (1 - math.max(0, u426 - u413) / u414) * 255))
				if u427 > 0 then
					local u398= 4
					local u428= u420.r or 200
					local u429= u420.g or 200
					local u430= u420.b or 200
					renderer.line(u424 - u398, u425, u424 + u398, u425, u428, u429, u430, u427)
					renderer.line(u424, u425 - u398, u424, u425 + u398, u428, u429, u430, u427)
				end
			end
		end
	else
		u371 = {shots = {}, last = 0}
	end
end

if u376 and u377 and u377.callback then
	u377.callback('aim_fire', u378, { alive_only = true, require_login = true })
	u377.callback('bullet_impact', u381, { alive_only = true, require_login = true })
	u377.callback('paint', u412, { alive_only = true, require_login = true })
end
]]
u743["require/help/bit"] = [[local u373= {}

local u374= 0xFFFFFFFF
local u375= 4294967296

local function u376(u377)
	u377 = tonumber(u377) or 0
	u377 = math.floor(u377) % u375
	if u377 < 0 then u377 = u377 + u375 end
	return u377
end

function bit.tobit(u377)
	local u378= u376(u377)
	if u378 >= 2147483648 then
		return u378 - u375
	end
	return u378
end

function bit.tohex(u377,u379)
	local u378= u376(u377)
	local u380= 8
	local u381= false
	if u379 then
		if u379 < 0 then
			u381 = true
			u380 = -u379
		else
			u380 = u379
		end
	end
	if u380 < 1 then u380 = 1 end
	if u380 > 8 then u380 = 8 end
	u378 = u378 % (2^(4 * u380))
	if u381 then
		return string.format(string.format("%%0%uX", u380), u378)
	else
		return string.format(string.format("%%0%ux", u380), u378)
	end
end

local function u382(u378,u383)
	return math.floor(u378 / 2^u383) % 2
end

function bit.band(u384,...)
	local u385= {u384, ...}
	if #u385 == 0 then return 0 end
	local u386= 0
	for u383 = 0, 31 do
		local u387= 1
		for j = 1, #u385 do
			if u382(u376(u385[j]), u383) == 0 then
				u387 = 0
				break
			end
		end
		if u387 == 1 then u386 = u386 + 2^u383 end
	end
	return u373.tobit(u386)
end

function bit.bor(u384,...)
	local u385= {u384, ...}
	if #u385 == 0 then return 0 end
	local u386= 0
	for u383 = 0, 31 do
		for j = 1, #u385 do
			if u382(u376(u385[j]), u383) == 1 then
				u386 = u386 + 2^u383
				break
			end
		end
	end
	return u373.tobit(u386)
end

function bit.bxor(u384,...)
	local u385= {u384, ...}
	if #u385 == 0 then return 0 end
	local u386= 0
	for u383 = 0, 31 do
		local u388= 0
		for j = 1, #u385 do
			if u382(u376(u385[j]), u383) == 1 then u388 = u388 + 1 end
		end
		if (u388 % 2) == 1 then u386 = u386 + 2^u383 end
	end
	return u373.tobit(u386)
end

function bit.bnot(u377)
	local u378= u376(u377)
	local u386= u374 - u378
	return u373.tobit(u386)
end

function bit.lshift(u377,u379)
	u379 = tonumber(u379) or 0
	u379 = u379 % 32
	local u378= u376(u377)
	local u386= (u378 * 2^u379) % u375
	return u373.tobit(u386)
end

function bit.rshift(u377,u379)
	u379 = tonumber(u379) or 0
	u379 = u379 % 32
	local u378= u376(u377)
	local u386= math.floor(u378 / 2^u379) % u375
	return u373.tobit(u386)
end

function bit.arshift(u377,u379)
	u379 = tonumber(u379) or 0
	u379 = u379 % 32
	local u389= u373.tobit(u377)
	local u386= math.floor(u389 / 2^u379)
	return u373.tobit(u386)
end

function bit.rol(u377,u379)
	u379 = tonumber(u379) or 0
	u379 = u379 % 32
	if u379 == 0 then return u373.tobit(u377) end
	local u378= u376(u377)
	local u390= (u378 * 2^u379) % u375
	local u391= math.floor(u378 / 2^(32 - u379))
	local u386= (u390 + u391) % u375
	return u373.tobit(u386)
end

function bit.ror(u377,u379)
	u379 = tonumber(u379) or 0
	u379 = u379 % 32
	if u379 == 0 then return u373.tobit(u377) end
	local u378= u376(u377)
	local u391= math.floor(u378 / 2^u379)
	local u390= (u378 * 2^(32 - u379)) % u375
	local u386= (u390 + u391) % u375
	return u373.tobit(u386)
end

function bit.bswap(u377)
	local u378= u376(u377)
	local u392= u378 % 256
	local u393= math.floor(u378 / 256) % 256
	local u394= math.floor(u378 / 65536) % 256
	local u395= math.floor(u378 / 16777216) % 256
	local u386= u392 * 16777216 + u393 * 65536 + u394 * 256 + u395
	return u373.tobit(u386)
end

return u373]]
u743["require/help/client"] = [[local u376= {}

function M.camera_angles(u377,u378)
  if u377 == nil and u378 == nil then
    return client.camera_angles()
  end
  return client.camera_angles(u377, u378)
end

function M.camera_position()
  return client.camera_position()
end

function M.color_log(u379,u380,u381,...)
  return client.color_log(u379, u380, u381, ...)
end

function M.create_interface(u382,u383)
  return client.create_interface(u382, u383)
end

function M.current_threat()
  return client.current_threat()
end

function M.delay_call(u384,u385,...)
  return client.delay_call(u384, u385, ...)
end

function M.draw_debug_text(u386,u387,u388,u389,u390,u379,u380,u381,u391,...)
  return client.draw_debug_text(u386, u387, u388, u389, u390, u379, u380, u381, u391, ...)
end

function M.draw_hitboxes(u392,u390,u393,u379,u380,u381,u391,u394)
  return client.draw_hitboxes(u392, u390, u393, u379, u380, u381, u391, u394)
end

function M.error_log(u395)
  return client.error_log(u395)
end

function M.exec(...)
  return client.exec(...)
end

function M.eye_position()
  return client.eye_position()
end

function M.find_signature(u382,u396)
  return client.find_signature(u382, u396)
end

function M.fire_event(u397,...)
  return client.fire_event(u397, ...)
end

function M.get_cvar(u398)
  return client.get_cvar(u398)
end

function M.get_model_name(u399)
  return client.get_model_name(u399)
end

function M.key_state(u400)
  return client.key_state(u400)
end

function M.latency()
  return client.latency()
end

function M.log(...)
  return client.log(...)
end

function M.random_float(u401,u402)
  return client.random_float(u401, u402)
end

function M.random_int(u401,u402)
  return client.random_int(u401, u402)
end

function M.real_latency()
  return client.real_latency()
end

function M.register_esp_flag(u403,u379,u380,u381,u385)
  return client.register_esp_flag(u403, u379, u380, u381, u385)
end

function M.reload_active_scripts()
  return client.reload_active_scripts()
end

function M.request_full_update()
  return client.request_full_update()
end

function M.scale_damage(u392,u404,u405)
  return client.scale_damage(u392, u404, u405)
end

function M.screen_size()
  return client.screen_size()
end

function M.set_clan_tag(...)
  return client.set_clan_tag(...)
end

function M.set_event_callback(u397,u385)
  return client.set_event_callback(u397, u385)
end

function M.system_time()
  return client.system_time()
end

function M.timestamp()
  return client.timestamp()
end

function M.trace_bullet(u406,u407,u408,u409,u410,u411,u412,u413)
  return client.trace_bullet(u406, u407, u408, u409, u410, u411, u412, u413)
end

function M.trace_line(u414,u407,u408,u409,u410,u411,u412)
  return client.trace_line(u414, u407, u408, u409, u410, u411, u412)
end

function M.unix_time()
  return client.unix_time()
end

function M.unset_event_callback(u397,u385)
  return client.unset_event_callback(u397, u385)
end

function M.update_player_list()
  return client.update_player_list()
end

function M.userid_to_entindex(u415)
  return client.userid_to_entindex(u415)
end

function M.visible(u386,u387,u388)
  return client.visible(u386, u387, u388)
end

return u376]]
u743["require/help/color"] = [[local function u379(u380)
    u380 = tostring(u380 or "")
    local u381= u380:match("([0-9A-Fa-f]+)$")
    if not u381 or #u381 ~= 8 then
        return 255,255,255,255
    end
    local u382= tonumber(u381:sub(1,2), 16)
    local u383= tonumber(u381:sub(3,4), 16)
    local u384= tonumber(u381:sub(5,6), 16)
    local u385= tonumber(u381:sub(7,8), 16)
    return u382,u383,u384,u385
end

local function u386(u382,u383,u384,u385)
    return string.format("\a%02x%02x%02x%02x", tonumber(u382) or 0, tonumber(u383) or 0, tonumber(u384) or 0, tonumber(u385) or 255)
end

local function u387(u388)
    local u389= tonumber(u388) or 0
    if u389 < 0 then return 0 end
    if u389 > 255 then return 255 end
    return math.floor(u389 + 0.5)
end

local function u390(u382,u383,u384,u385,u391)
    u391 = tonumber(u391) or 32
    return u387((u382 or 0) + u391), u387((u383 or 0) + u391), u387((u384 or 0) + u391), u387(u385 or 255)
end

local function u392(u382,u383,u384,u385,u391)
    u391 = tonumber(u391) or 32
    return u387((u382 or 0) - u391), u387((u383 or 0) - u391), u387((u384 or 0) - u391), u387(u385 or 255)
end

local u393= {
    default = "d6d6d6FF", 
    green  = "a5ca2aFF", 
    red    = "d96464FF", 
    reddark = "b22222FF", 
    orange = "dca53aFF", 
    yellow = "ccb854FF", 
    blue   = "5462ccFF", 
    cyan   = "54ccccFF", 
    purple = "7054ccFF", 
    white  = "ffffffFF", 
    grey   = "757575FF", 
    black  = "000000FF", 
    pink   = "c8a2deFF", 
    discord = "7289daFF", 
    youtube = "FF0000FF", 
    sellhub = "FFC107FF", 

}


local u394= {}
for name, u380 in pairs(u393) do
    local u382,u383,u384,u385= u379(u380)
    u394[name] = {
        base = u380,
        lighter = u386(u390(u382,u383,u384,u385,32)),
        darker  = u386(u392(u382,u383,u384,u385,32)),
        light2  = u386(u390(u382,u383,u384,u385,64)),
        dark2   = u386(u392(u382,u383,u384,u385,64)),
        rgb = {u382,u383,u384,u385},
        log = {u382,u383,u384},
        ui = u380,
    }
end

function COLORS.get(u395,u396)
    u396 = u396 or "base"
    local u397= u394[u395]
    if not u397 then return nil end
    if u396 == "log" and u397.log then
        return unpack(u397.log)
    elseif u396 == "ui" and u397.ui then
        return "\a"..entry.ui
    elseif u397[u396] then
        return u397[u396]
    end
    return nil
end

function COLORS.blend(u398,u399,u400)
    local u401,u402,u403,u404= unpack(u394[u398].rgb)
    local u405,u406,u407,u408= unpack(u394[u399].rgb)
    u400 = u400 or 0.5
    local u382= u387(u401 + (u405-u401)*u400)
    local u383= u387(u402 + (u406-u402)*u400)
    local u384= u387(u403 + (u407-u403)*u400)
    local u385= u387(u404 + (u408-u404)*u400)
    return u386(u382,u383,u384,u385)
end

function COLORS.hex_to_rgba(u380)
    return u379(u380)
end

function COLORS.rgba_to_hex(u382,u383,u384,u385)
    return u386(u382,u383,u384,u385)
end

function COLORS.clamp(u382,u383,u384,u385)
    return u387(u382), u387(u383), u387(u384), u387(u385)
end

function COLORS.normalize(u382,u383,u384,u385)
    return u387(u382), u387(u383), u387(u384), u387(u385 or 255)
end

function COLORS.modulate(u382,u383,u384,u385,u409,u410,u411,u412)
    u409 = tonumber(u409) or 1
    u410 = tonumber(u410) or u409
    u411 = tonumber(u411) or u409
    u412 = tonumber(u412) or 1
    local u413= u387((tonumber(u382) or 0) * u409)
    local u414= u387((tonumber(u383) or 0) * u410)
    local u415= u387((tonumber(u384) or 0) * u411)
    local u416= u387((tonumber(u385) or 255) * u412)
    return u413, u414, u415, u416
end

function COLORS.alpha_modulate(u385,u417)
    u417 = tonumber(u417) or 1
    return u387((tonumber(u385) or 255) * u417)
end

return u394]]
u743["require/help/drag"] = [[local u382= {}
local u383= {}
local u384= false

local u385= {
	['top-left'] = function(u386,u387,u388,u389) return 0, 0 end,
	['top-center'] = function(u386,u387,u388,u389) return math.floor(u386/2 - u388/2), 0 end,
	['top-right'] = function(u386,u387,u388,u389) return math.floor(u386 - u388), 0 end,
	['center-left'] = function(u386,u387,u388,u389) return 0, math.floor(u387/2 - u389/2) end,
	['center'] = function(u386,u387,u388,u389) return math.floor(u386/2 - u388/2), math.floor(u387/2 - u389/2) end,
	['center-right'] = function(u386,u387,u388,u389) return math.floor(u386 - u388), math.floor(u387/2 - u389/2) end,
	['bottom-left'] = function(u386,u387,u388,u389) return 0, math.floor(u387 - u389) end,
	['bottom-center'] = function(u386,u387,u388,u389) return math.floor(u386/2 - u388/2), math.floor(u387 - u389) end,
	['bottom-right'] = function(u386,u387,u388,u389) return math.floor(u386 - u388), math.floor(u387 - u389) end,
}

local function u390(u391,u392,u388,u389,u393,u394)
	if not u393 or not u394 then return false end
	return u393 >= u391 and u393 <= u391 + u388 and u394 >= u392 and u394 <= u392 + u389
end

local function u395(u396,u397,u398)
	if not u396 then return u397 end
	if u396 < u397 then return u397 end
	if u396 > u398 then return u398 end
	return u396
end

function M.new(u399,u400)
	if not u399 then error('drag.new requires id') end
	u400 = u400 or {}
	local u401= {}
	u401.id = u399
	u401.x = u400.x or 0
	u401.y = u400.y or 0
	u401.w = u400.w or 100
	u401.h = u400.h or 20
	u401.snap = u400.snap == nil and true or u400.snap
	u401.snap_threshold = u400.snap_threshold or 24
	u401.snap_positions = u400.snap_positions or nil
	u401.require_menu_open = u400.require_menu_open == nil and true or u400.require_menu_open
	u401.locked = u400.lock or false
	u401.box_color = u400.box_color or {255,255,255,100}
	u401.show_alignment = u400.show_alignment == nil and true or u400.show_alignment
	u401.align_color = u400.align_color or {255,255,255,100}
	u401.align_cross_size = u400.align_cross_size or 6
	u401.show_screen_guides = u400.show_screen_guides == nil and true or u400.show_screen_guides
	u401.line_snap_threshold = u400.line_snap_threshold or 6
	u401.bounds = u400.bounds or nil
	u401.constraint_center = u400.constraint_center or nil
	u401.constraint_box = u400.constraint_box or nil
	u401.default_pos = u400.default_pos or nil
	u401.default_center = u400.default_center or nil

	local u402= {
		obj = u401,
		dragging = false,
		drag_offset_x = 0,
		drag_offset_y = 0,
		last_left = false,
		last_right = false,
		locked_to = nil,
		snap_progress = 0,
		snap_target = 0,
		line_snap_progress_x = 0,
		line_snap_progress_y = 0,
		line_snap_target_x = 0,
		line_snap_target_y = 0,
		drag_button = nil,
		disable_snap = false,
	}
	u383[u399] = u402

	local u403, u404= pcall(database.read, 'drag_positions')
	if u403 and type(u404) == 'table' and u404[u399] then
		local u405= u404[u399]
		if type(u405.x) == 'number' and type(u405.y) == 'number' then
			u401.x = u405.x
			u401.y = u405.y
		end
	end

	if not u384 then
		client.set_event_callback('setup_command', function(u406)
			for _, st in pairs(u383) do
				if st.dragging then
					pcall(function()
						u406.in_attack = false
						u406.in_attack2 = false
					end)
					break
				end
			end
		end)
		u384 = true
	end

	function obj:set_pos(u391,u392)
		self.x = u391
		self.y = u392
	end
	function obj:set_size(u388,u389)
		self.w = u388; self.h = u389
	end
	function obj:set_bounds(u391,u392,u388,u389)
		self.bounds = { x = u391, y = u392, w = u388, h = u389 }
	end
	function obj:clear_bounds()
		self.bounds = nil
	end
	function obj:get_pos()
		return self.x, self.y
	end
	function obj:is_dragging()
		return not not u402.dragging
	end
	function obj:get_bounds()
		return self.bounds
	end
	function obj:set_locked(u407)
		self.locked = not not u407
	end
	function obj:set_snap(u407)
		self.snap = not not u407
	end
	function obj:toggle_snap()
		self.snap = not self.snap
	end
	function obj:reset_to_anchor(u408)
		local u386, u387= client.screen_size()
		if not u386 or not u387 then return end
		local u409= u385[u408]
		if type(u409) == 'function' then
			local u410, u411= u409(u386,u387,self.w,self.h)
			self.x = u410; self.y = u411
			u402.locked_to = u408
		end
	end

	function obj:handle()
		if self.locked then return end
		local u386, u387= client.screen_size()
		if not u386 or not u387 then return end
		if self.require_menu_open and not ui.is_menu_open() then u402.last_left = false; return end

		local u393, u394= ui.mouse_position()
		local u412= client.key_state(1)
		local u413= client.key_state(2)

		if u412 and u413 and (u390(self.x, self.y, self.w, self.h, u393, u394) or u402.dragging) then
			if self.default_pos then
				self.x = self.default_pos.x
				self.y = self.default_pos.y
				return
			elseif self.default_center then
				self.x = (self.default_center.x or 0) - math.floor(self.w/2)
				self.y = (self.default_center.y or 0) - math.floor(self.h/2)
				return
			end
		end
		if u412 and not u402.last_left and u390(self.x, self.y, self.w, self.h, u393, u394) then
			u402.dragging = true
			u402.drag_button = 1
			u402.disable_snap = false
			u402.drag_offset_x = u393 - self.x
			u402.drag_offset_y = u394 - self.y
			u402.locked_to = nil
		elseif u413 and not u402.last_right and u390(self.x, self.y, self.w, self.h, u393, u394) then
			u402.dragging = true
			u402.drag_button = 2
			u402.disable_snap = true
			u402.drag_offset_x = u393 - self.x
			u402.drag_offset_y = u394 - self.y
			u402.locked_to = nil
			u402.snap_target = 0
			u402.line_snap_target_x = 0
			u402.line_snap_target_y = 0
		end

		if (u412 and u402.dragging and u402.drag_button == 1) or (u413 and u402.dragging and u402.drag_button == 2) then
			local u410= u393 - u402.drag_offset_x
			local u411= u394 - u402.drag_offset_y
			local u414, u415= 0, math.max(0, u386 - self.w)
			local u416, u417= 0, math.max(0, u387 - self.h)
			if self.constraint_center then
				local u418= self.constraint_center
				local u419= u418.cx or math.floor(u386/2)
				local u420= u418.cy or math.floor(u387/2)
				local u421= u418.radius or 0
				u414 = (u419 - u421) - math.floor(self.w/2)
				u415 = (u419 + u421) - math.floor(self.w/2)
				u416 = (u420 - u421) - math.floor(self.h/2)
				u417 = (u420 + u421) - math.floor(self.h/2)
			elseif self.bounds or self.constraint_box then
				local u422= self.bounds or self.constraint_box
				local u423= u422.x or u422[1] or 0
				local u424= u422.y or u422[2] or 0
				local u425= u422.w or u422[3] or (u386 - u423)
				local u426= u422.h or u422[4] or (u387 - u424)
				u414 = u423
				u415 = math.max(u423, u423 + u425 - self.w)
				u416 = u424
				u417 = math.max(u424, u424 + u426 - self.h)
			end
			u410 = u395(u410, u414, u415)
			u411 = u395(u411, u416, u417)
			self.x = u410; self.y = u411
			if self.snap and not u402.disable_snap then
				local u427= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and u385[p] then
							local u409= u385[p]
							local u428, u429= u409(u386,u387,self.w,self.h)
							table.insert(u427, {x=u428,y=u429})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(u427, {x=p[1], y=p[2]})
						end
					end
				else
					for k,u409 in pairs(u385) do
						local u428, u429= u409(u386,u387,self.w,self.h)
						table.insert(u427, {x=u428,y=u429})
					end
				end
				local u430= math.huge
				for _,u418 in ipairs(u427) do
					local u431= (u418.x - self.x)
					local u432= (u418.y - self.y)
					local u433= math.sqrt(u431*u431 + u432*u432)
					if u433 < u430 then u430 = u433 end
				end
				if u430 <= self.snap_threshold then u402.snap_target = 1 else u402.snap_target = 0 end
				local u434= math.floor(u386/2)
				local u435= math.floor(u387/2)
				local u419= math.floor(self.x + self.w/2)
				local u420= math.floor(self.y + self.h/2)
				if math.abs(u419 - u434) <= (self.line_snap_threshold or 6) then u402.line_snap_target_x = 1 else u402.line_snap_target_x = 0 end
				if math.abs(u420 - u435) <= (self.line_snap_threshold or 6) then u402.line_snap_target_y = 1 else u402.line_snap_target_y = 0 end
			end
		end

		local u436= false
		if u402.dragging then
			if u402.drag_button == 1 and not u412 and u402.last_left then u436 = true end
			if u402.drag_button == 2 and not u413 and u402.last_right then u436 = true end
		end
		if u436 then
			if not u402.disable_snap then
				local u434, u435= math.floor(u386/2), math.floor(u387/2)
				local u419= math.floor(self.x + self.w/2)
				local u420= math.floor(self.y + self.h/2)
				if self.show_screen_guides then
					if math.abs(u419 - u434) <= (self.line_snap_threshold or 6) then
						self.x = u434 - math.floor(self.w/2)
					end
					if math.abs(u420 - u435) <= (self.line_snap_threshold or 6) then
						self.y = u435 - math.floor(self.h/2)
					end
				end
			end
			u402.dragging = false
			local u437, u438= pcall(database.read, 'drag_positions')
			local u439= (u437 and type(u438) == 'table') and u438 or {}
			u439[self.id] = { x = self.x, y = self.y }
			pcall(function() database.write('drag_positions', u439) end)
			if self.snap and not u402.disable_snap then
				local u427= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and u385[p] then
							local u409= u385[p]
							local u428, u429= u409(u386,u387,self.w,self.h)
							table.insert(u427, {x=u428,y=u429, key=p})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(u427, {x=p[1], y=p[2], key=nil})
						end
					end
				else
					for k,u409 in pairs(u385) do
						local u428, u429= u409(u386,u387,self.w,self.h)
						table.insert(u427, {x=u428,y=u429, key=k})
					end
				end
				local u440, u430= nil, math.huge
				for _,u418 in ipairs(u427) do
					local u431= (u418.x - self.x)
					local u432= (u418.y - self.y)
					local u433= math.sqrt(u431*u431 + u432*u432)
					if u433 < u430 then u430 = u433; u440 = u418 end
				end
				if u440 and u430 <= self.snap_threshold then
					self.x = u440.x; self.y = u440.y
					u402.locked_to = u440.key
				end
			end
		end

		u402.last_left = u412
		u402.last_right = u413
	end

	function obj:draw()
		local u402= u383[self.id]
		if not u402 then return end
		if u402.dragging then
			local u421,u441,u422,u442= unpack(self.box_color)
			local u443,u444,u445,u446= unpack(self.align_color)
			local u447= globals.frametime() or 0.016
			local u448= math.min(1, 12 * u447)
			u402.snap_progress = u402.snap_progress + (u402.snap_target - u402.snap_progress) * u448
			u402.line_snap_progress_x = u402.line_snap_progress_x + (u402.line_snap_target_x - u402.line_snap_progress_x) * u448
			u402.line_snap_progress_y = u402.line_snap_progress_y + (u402.line_snap_target_y - u402.line_snap_progress_y) * u448
			local u449= math.floor(u421 + (0 - u421) * u402.snap_progress)
			local u450= math.floor(u441 + (0 - u441) * u402.snap_progress)
			local u451= math.floor(u422 + (0 - u422) * u402.snap_progress)
			local u452= math.floor(u442 + (200 - u442) * u402.snap_progress)
			renderer.rectangle(self.x, self.y, self.w, self.h, u449, u450, u451, u452)
			renderer.line(self.x, self.y, self.x + self.w, self.y, 200,200,200,150)
			renderer.line(self.x + self.w, self.y, self.x + self.w, self.y + self.h, 200,200,200,150)
			renderer.line(self.x + self.w, self.y + self.h, self.x, self.y + self.h, 200,200,200,150)
			renderer.line(self.x, self.y + self.h, self.x, self.y, 200,200,200,150)
			if self.show_alignment then
				local u386, u387= client.screen_size()
				if u386 and u387 then
					if self.show_screen_guides then
						local u434= math.floor(u386/2)
						local u435= math.floor(u387/2)
						local u419= math.floor(self.x + self.w/2)
						local u420= math.floor(self.y + self.h/2)
						local u453= math.abs(u419 - u434) <= (self.line_snap_threshold or 6)
						local u454= math.abs(u420 - u435) <= (self.line_snap_threshold or 6)
						local u455= math.floor(u446 * 0.35)
						renderer.line(u434, u435, 0, u435, u443,u444,u445, u455)
						renderer.line(u434, u435, u434, 0, u443,u444,u445, u455)
						renderer.line(u434, u435, u386, u435, u443,u444,u445, u455)
						renderer.line(u434, u435, u434, u387, u443,u444,u445, u455)
						local u456= math.floor(u446 * u402.line_snap_progress_x)
						local u457= math.floor(u446 * u402.line_snap_progress_y)
						if u456 > 0 then renderer.line(u434, 0, u434, u387, u443,u444,u445, u456) end
						if u457 > 0 then renderer.line(0, u435, u386, u435, u443,u444,u445, u457) end
					end
				end
			end
			if self.constraint_center then
				local u418= self.constraint_center
				local u419= u418.cx or math.floor((client.screen_size()) / 2)
				local u420= u418.cy or math.floor((client.screen_size()) / 2)
				local u421= u418.radius or 0
				local u423= u419 - u421
				local u424= u420 - u421
				local u425= u421 * 2
				local u426= u421 * 2
				renderer.rectangle(u423, u424, u425, u426, 255, 255, 255, 60)
				renderer.line(u423, u424, u423 + u425, u424, 255, 255, 255, 160)
				renderer.line(u423 + u425, u424, u423 + u425, u424 + u426, 255, 255, 255, 160)
				renderer.line(u423 + u425, u424 + u426, u423, u424 + u426, 255, 255, 255, 160)
				renderer.line(u423, u424 + u426, u423, u424, 255, 255, 255, 160)
			end
		end
	end

	return u401
end

function M.get(u399)
	local u402= u383[u399]
	if not u402 then return nil end
	return u402.obj
end

function M.ids()
	local u458= {}
	for k,_ in pairs(u383) do table.insert(u458, k) end
	return u458
end

return u382]]
u743["require/help/emojis"] = [[local u385= {

    chat = { "" },
    rewind = { "" },
    thumbsup = { "" },
    mail = { "U+E135" },
    square = { "" },
    square2 = { "" },
    square_hollow = { "" },
    play = { "" },
    pause = { "" },
    sun = { "" },
    pc = { "" },
    pc2 = { "" },
    phone = { "U+E1C9" },
    trash = { "" },
    reject = { "" },
    accept = { "" },
    config = { "" },
    config_write = { "U+E28F" },
    gear = { "" },
    arrow_right = { "" },
    arrow_left = { "" },
    arrow_up = { "" },
    arrow_down = { "" },
    star = { "U+E0B4" },
    minus = { "" },
    plus = { "" },
    plus_in_brackets = { "U+E0C5" },
    pen = { "" },
    recycle = { "" },
    camera = { "" },
    download = { "" },
    upload = { "" },
    question = { "" },
    search = { "" },
    globe = { "" },
    globe2 = { "" },
    id = { "" },
    phone = { "" },
    user = { "" },
    user2 = { "U+E2AF" },
    user3 = { "U+E13D" },
    users = { "" },
    users2 = { "U+E125" },
    user_no = { "U+E1E0" },
    pin = { "" },
    unpin = { "U+E196" },
    windows = { "" },
    turning = { "" },
    turning2 = { "" },
    arrow_double = { "" },
    clip = { "" },
    clipboard = { "U+E16D" },
    exclamation = { "" },
    time = { "" },
    clock = { "U+E2AD" },
    paper = { "" },
    paper2 = { "" },
    link = { "" },
    link2 = { "U+E167" },
    wrench = { "" },
    url = { "" },
    speaker = { "" },
    house = { "" },
    pallete = { "" },
    lock = { "" },
    lock_open = { "" },
    tsarrow_left = { "" },
    tsarrow_right = { "" },
    tsarrow_up = { "" },
    tsarrow_up = { "" },
    warning = { "⚠︎" },
    video = { "" },
    connection = { "" },
    heart = { "" },
    triangle_upside = { "⛛" },
    music_note = { "U+E142" },
    test = { "U+E2B1" },
    keyboard = { "U+E0D2" },
    latency0 = { "U+E1E5" },
    latency1 = { "U+E1E6" },
    latency2 = { "U+E1E7" },
    latency3 = { "U+E1E8" },
    latency4 = { "U+E1E9" },
    expand = { "U+E1D9" },
    monitor = { "U+E2F0" },
    rain = { "U+E28A" },
    likedislike = { "U+E19D" },
    text = { "U+E1C8" },
    back = { "U+E10E" },
    folder = { "U+E1C1" },
    menu = { "U+E179" },
    menu2 = { "U+E1A0" },
    at = { "U+E168" },
    circle = { "U+E235" },
    updown = { "U+E174" },

}

local u386= {}

local function u387(u388)
    if u388 == nil then return "ERROR" end
    if type(u388) ~= "string" then u388 = tostring(u388) end
    if u388 == "ERROR" then return "ERROR" end
    local u389= u388:match('^U%+([0-9A-Fa-f]+)$') or u388:match('^u%+([0-9A-Fa-f]+)$') or u388:match('^0x([0-9A-Fa-f]+)$')
    if u389 then
        local u390= tonumber(u389, 16)
        if u390 then
            local u391= nil
            if type(utf8) == 'table' and type(utf8.char) == 'function' then
                pcall(function() u391 = utf8.char(u390) end)
            end
            if not u391 then
                local function u392(u393)
                    if u393 < 0x80 then return string.char(u393) end
                    if u393 < 0x800 then return string.char(0xC0 + math.floor(u393 / 0x40), 0x80 + (u393 % 0x40)) end
                    if u393 < 0x10000 then return string.char(0xE0 + math.floor(u393 / 0x1000), 0x80 + (math.floor(u393 / 0x40) % 0x40), 0x80 + (u393 % 0x40)) end
                    if u393 < 0x110000 then return string.char(0xF0 + math.floor(u393 / 0x40000), 0x80 + (math.floor(u393 / 0x1000) % 0x40), 0x80 + (math.floor(u393 / 0x40) % 0x40), 0x80 + (u393 % 0x40)) end
                    return '?'
                end
                u391 = u392(u390)
            end
            u388 = u391 or u388
        end
    end
    if u388:sub(-1) == " " then return u388 end
    return u388 .. " "
end

function M.get(u394,u395,u396)
    if not u394 then return "ERROR" end
    local u397= u385[u394]
    if u397 == nil then return "ERROR" end
    if type(u397) == "string" then return u387(u397) end
    if type(u397) == "table" then
        if u396 == nil then
            return u387(u397[1])
        end
        local u398= tonumber(u396) or 1
        return u387(u397[u398])
    end
    return "ERROR"
end

function M.set(u394,u399)
	if not u394 then return false end
	if type(u399) == "string" then
		u385[u394] = { u399 }
	else
		u385[u394] = u399
	end
	return true
end

function M.list()
	local u400= {}
	for k, u397 in pairs(u385) do
		if type(u397) == "table" then
			local u401= {}
			for u398 = 1, #u397 do u401[u398] = u397[u398] end
			u400[k] = u401
		else
			u400[k] = u397
		end
	end
	return u400
end

setmetatable(u386, {
    __index = function(u402,u403)
        local u397= u385[u403]
        if u397 == nil then return "ERROR" end
        if type(u397) == "table" then return u387(u397[1]) end
        return u387(u397)
    end,
})

return u386]]
u743["require/help/enemies"] = [[local u388= {}

local u389= entity
local u390= client
local u391= globals

function M.list()
    return u389 and u389.get_players and u389.get_players(true) or {}
end

function M.is_alive(u392)
    return u392 and u389.is_alive and u389.is_alive(u392) or false
end

function M.is_dormant(u392)
    return u392 and u389.is_dormant and u389.is_dormant(u392) or false
end

function M.player_name(u392)
    return u392 and u389.get_player_name and u389.get_player_name(u392) or nil
end

function M.steam64(u392)
    return u392 and u389.get_steam64 and u389.get_steam64(u392) or nil
end

function M.health(u392)
    return u392 and u389.get_prop and u389.get_prop(u392, 'm_iHealth') or 0
end

function M.current_threat()
    return u390 and u390.current_threat and u390.current_threat() or nil
end

local u393= {}

function M.is_afk(u392,u394,u395)
    u394 = u394 or 5
    u395 = u395 or 20
    local u396, u397, u398= u389.get_prop(u392, 'm_vecVelocity')
    local u399= 0
    if u396 and u397 and u398 then
        u399 = math.sqrt(u396 * u396 + u397 * u397 + u398 * u398)
    end
    local u400= u391 and u391.realtime and u391.realtime() or os.clock()
    if not u393[u392] then
        u393[u392] = { last_active = u400, last_check = u400 }
    end
    if u399 >= u394 then
        u393[u392].last_active = u400
    end
    u393[u392].last_check = u400
    return (u400 - u393[u392].last_active) > u395
end

function M.distance(u392,u401)
    if not u392 or not u389.get_origin then return nil end
    local u402, u403, u404= u389.get_origin(u392)
    if not u402 then return nil end
    if not u401 then
        u401 = u389.get_local_player and u389.get_local_player()
    end
    local u405, u406, u407= u389.get_origin(u401)
    if not u405 then return nil end
    local u408, u409, u410= u402 - u405, u403 - u406, u404 - u407
    return math.sqrt(u408 * u408 + u409 * u409 + u410 * u410)
end


local function u411(u412)
    if not u412 then return "" end
    return tostring(u412):lower()
end

local function u413(u414)
    local u415= ""
    if u414 and u389.get_classname then u415 = u389.get_classname(u414) or "" end
    if u415 == "" and u414 and u390.get_model_name then
        u415 = u390.get_model_name(u414) or ""
    end
    return u411(u415)
end

function M.has_knife(u392)
    if not u392 or not u389.get_player_weapon then return false end
    local u414= u389.get_player_weapon(u392)
    if not u414 then return false end
    local u416= u413(u414)
    return u416:find('knife') ~= nil
end

function M.has_nade(u392)
    if not u392 or not u389.get_player_weapon then return false end
    local u414= u389.get_player_weapon(u392)
    if not u414 then return false end
    local u416= u413(u414)
    local u417= {'grenade', 'hegrenade', 'flashbang', 'smoke', 'molotov', 'incendiary', 'decoy', 'frag', 'nade'}
    for i = 1, #u417 do
        if u416:find(u417[i]) then return true end
    end
    return false
end

function M.has_taser(u392)
    if not u392 or not u389.get_player_weapon then return false end
    local u414= u389.get_player_weapon(u392)
    if not u414 then return false end
    local u416= u413(u414)
    return u416:find('taser') ~= nil or u416:find('zeus') ~= nil
end

return u388]]
u743["require/help/ffi"] = [[local u391= rawget(_G, 'ffi')
local u392= {}

function M.available()
  return u391 ~= nil
end

function M.cdef(u393)
  if not u391 then error('ffi not available') end
  return u391.cdef(u393)
end

function M.typeof(u394)
  if not u391 then error('ffi not available') end
  return u391.typeof(u394)
end

function M.new(u394,...)
  if not u391 then error('ffi not available') end
  return u391.new(u394, ...)
end

function M.cast(u394,u395)
  if not u391 then error('ffi not available') end
  return u391.cast(u394, u395)
end

function M.string(u396,u397)
  if not u391 then error('ffi not available') end
  return u391.string(u396, u397)
end

function M.copy(u398,u399,u397)
  if not u391 then error('ffi not available') end
  return u391.copy(u398, u399, u397)
end

function M.fill(u398,u400,u397)
  if not u391 then error('ffi not available') end
  return u391.fill(u398, u400, u397)
end

function M.sizeof(u394)
  if not u391 then error('ffi not available') end
  return u391.sizeof(u394)
end

function M.alignof(u394)
  if not u391 then error('ffi not available') end
  return u391.alignof(u394)
end

function M.errno()
  if not u391 then error('ffi not available') end
  return u391.errno()
end

function M.gc(u396,u401)
  if not u391 then error('ffi not available') end
  return u391.gc(u396, u401)
end

function M.load(u402,u403)
  if not u391 then error('ffi not available') end
  return u391.load(u402, u403)
end

function M.metatype(u394,u404)
  if not u391 then error('ffi not available') end
  return u391.metatype(u394, u404)
end

function M.offsetof(u394,u405)
  if not u391 then error('ffi not available') end
  return u391.offsetof(u394, u405)
end

function M.istype(u394,u395)
  if not u391 then error('ffi not available') end
  return u391.istype(u394, u395)
end

u392.raw = u391

return u392]]
u743["require/help/globals"] = [[local u394= {}

u394.raw = globals

function M.absoluteframetime()
  return globals.absoluteframetime()
end

function M.chokedcommands()
  return globals.chokedcommands()
end

function M.commandack()
  return globals.commandack()
end

function M.curtime()
  return globals.curtime()
end

function M.framecount()
  return globals.framecount()
end

function M.frametime()
  return globals.frametime()
end

function M.lastoutgoingcommand()
  return globals.lastoutgoingcommand()
end

function M.mapname()
  return globals.mapname()
end

function M.maxplayers()
  return globals.maxplayers()
end

function M.oldcommandack()
  return globals.oldcommandack()
end

function M.realtime()
  return globals.realtime()
end

function M.servertickcount()
  return globals.servertickcount()
end

function M.tickcount()
  return globals.tickcount()
end

function M.tickinterval()
  return globals.tickinterval()
end

return u394]]
u743["require/help/json"] = [[local u397= rawget(_G, 'json')
local u398= {}

function M.available()
  return u397 ~= nil
end

function M.decode_invalid_numbers(u399)
  if not u397 then error('json not available') end
  if u399 == nil then
    return u397.decode_invalid_numbers()
  end
  return u397.decode_invalid_numbers(u399)
end

function M.decode_max_depth(u400)
  if not u397 then error('json not available') end
  if u400 == nil then
    return u397.decode_max_depth()
  end
  return u397.decode_max_depth(u400)
end

function M.encode_invalid_numbers(u399)
  if not u397 then error('json not available') end
  if u399 == nil then
    return u397.encode_invalid_numbers()
  end
  return u397.encode_invalid_numbers(u399)
end

function M.encode_max_depth(u400)
  if not u397 then error('json not available') end
  if u400 == nil then
    return u397.encode_max_depth()
  end
  return u397.encode_max_depth(u400)
end

function M.encode_number_precision(u401)
  if not u397 then error('json not available') end
  if u401 == nil then
    return u397.encode_number_precision()
  end
  return u397.encode_number_precision(u401)
end

function M.encode_sparse_array(...)
  if not u397 then error('json not available') end
  return u397.encode_sparse_array(...)
end

function M.parse(u402)
  if not u397 then error('json not available') end
  if u397.parse then
    return u397.parse(u402)
  end
  if u397.decode then
    return u397.decode(u402)
  end
  error('json.parse / json.decode not available')
end

function M.stringify(u403)
  if not u397 then error('json not available') end
  if u397.stringify then
    return u397.stringify(u403)
  end
  if u397.encode then
    return u397.encode(u403)
  end
  error('json.stringify / json.encode not available')
end

u398.raw = u397

return u398]]
u743["require/help/libs"] = [[local function u400(u401)
	local u402, u403= pcall(require, u401)
	return u402 and u403 or nil
end

local u404= {
	antiaim_funcs   = 'gamesense/antiaim_funcs',
	base64          = 'gamesense/base64',
	clipboard       = 'gamesense/clipboard',
	http            = 'gamesense/http',
	csgo_weapons    = 'gamesense/csgo_weapons',
	icons           = 'gamesense/icons',
	entity          = 'gamesense/entity',
	vector          = 'vector',
	bit             = 'bit',
	ffi             = 'ffi',
	pui             = 'gamesense/pui',
	trace           = 'gamesense/trace',
	md5             = 'gamesense/md5',
	websocket       = 'gamesense/websocket',
	surface         = 'gamesense/surface',
	color           = 'gamesense/color',
}

local u405= {}
for k, v in pairs(u404) do
	u405[k] = u400(v)
end

local u406= {
	antiaim_funcs = {
		get_tickbase_shifting = "Returns true if tickbase shifting is active.",
		get_fake_lag = "Returns current fake lag value.",
		get_desync = "Returns current desync value.",
		get_manual_direction = "Returns manual anti-aim direction.",
		get_antiaim_condition = "Returns current anti-aim condition.",
		get_body_yaw = "Returns current body yaw value.",
		get_yaw_base = "Returns current yaw base value.",
		get_pitch = "Returns current pitch value.",
		get_yaw_jitter = "Returns current yaw jitter value.",
		get_enabled = "Returns if anti-aim is enabled.",
		get_fakelag_mode = "Returns fakelag mode.",
		get_fakelag_limit = "Returns fakelag limit.",
		get_fakelag_variance = "Returns fakelag variance.",
		get_fakelag_enabled = "Returns if fakelag is enabled.",
		get_double_tap = "Returns true if double tap exploit is active.",
		get_overlap = "Returns overlap value (exploit related).",
	},
	base64 = {
		encode = "Encodes a string to base64.",
		decode = "Decodes a base64 string.",
	},
	clipboard = {
		get = "Gets clipboard contents as string.",
		set = "Sets clipboard contents to string.",
	},
	http = {
		get = "Performs HTTP GET request.",
		post = "Performs HTTP POST request.",
		download = "Downloads a file from URL.",
	},
	csgo_weapons = {
		get_weapon_name = "Returns weapon name by id.",
		get_weapon_id = "Returns weapon id by name.",
		get_weapon_type = "Returns weapon type by id.",
		get_weapon_group = "Returns weapon group by id.",
		get_weapon_slot = "Returns weapon slot by id.",
		get_weapon_price = "Returns weapon price by id.",
	},
	icons = {
		hero = "Table of hero icons.",
		get_texture = "Returns texture id for icon name.",
		get_icon = "Returns icon object by name.",
		get_all_icons = "Returns all available icons.",
	},
	entity = {
		get_local_player = "Returns entindex of local player.",
		get_all = "Returns array of entindices for all entities.",
		get_players = "Returns array of player entindices.",
		get_game_rules = "Returns entindex of game rules proxy.",
		get_player_resource = "Returns entindex of player resource.",
		get_classname = "Returns classname of entity.",
		set_prop = "Sets netvar property.",
		get_prop = "Gets netvar property.",
		is_enemy = "Returns true if entity is enemy.",
		is_alive = "Returns true if entity is alive.",
		is_dormant = "Returns true if entity is dormant.",
		get_player_name = "Returns player name.",
		get_player_weapon = "Returns active weapon entindex.",
		hitbox_position = "Returns world position of hitbox.",
		get_steam64 = "Returns SteamID3.",
		get_bounding_box = "Returns bounding box coordinates.",
		get_origin = "Returns world origin of entity.",
		get_esp_data = "Returns ESP data for player.",
	},
	vector = {
		new = "Creates a new vector object.",
		dot = "Returns dot product of two vectors.",
		cross = "Returns cross product of two vectors.",
		length = "Returns length of vector.",
		normalize = "Normalizes vector.",
		add = "Adds two vectors.",
		sub = "Subtracts two vectors.",
		mul = "Multiplies vector by scalar.",
		div = "Divides vector by scalar.",
		dist = "Returns distance between two vectors.",
	},
	bit = {
		arshift = "Arithmetic right shift.",
		band = "Bitwise AND.",
		bnot = "Bitwise NOT.",
		bor = "Bitwise OR.",
		bswap = "Byte swap (endian conversion).",
		bxor = "Bitwise XOR.",
		lshift = "Logical left shift.",
		rol = "Bitwise left rotation.",
		ror = "Bitwise right rotation.",
		rshift = "Logical right shift.",
		tobit = "Normalize to 32-bit signed.",
		tohex = "Convert to hexadecimal string.",
	},
	ffi = {
		cdef = "Define C types/functions.",
		cast = "Cast value to C type.",
		new = "Allocate new C object.",
		typeof = "Get C type object.",
		string = "Convert C data to Lua string.",
	},
	pui = {
		create_panel = "Creates a custom UI panel.",
		add_icon = "Adds an icon to a panel.",
		set_icon = "Sets the icon for a panel.",
		set_panel_visible = "Shows/hides a panel.",
		set_panel_position = "Sets panel position.",
		set_panel_size = "Sets panel size.",
	},
	trace = {
		trace_line = "Performs a line trace.",
		trace_bullet = "Performs a bullet trace.",
		trace_hull = "Performs a hull trace.",
	},
	md5 = {
		sumhexa = "Returns MD5 hash as hex string.",
		sum = "Returns MD5 hash as raw bytes.",
	},
	websocket = {
		connect = "Connects to a WebSocket server.",
		send = "Sends data over WebSocket.",
		close = "Closes the WebSocket connection.",
		on_message = "Callback for incoming messages.",
	},
	surface = {
		text = "Draws text on screen.",
		rectangle = "Draws a rectangle.",
		line = "Draws a line.",
		circle = "Draws a circle.",
		gradient = "Draws a gradient rectangle.",
		load_texture = "Loads a texture from file.",
	},
	color = {
		blend = "Blends two colors.",
		lighten = "Lightens a color.",
		darken = "Darkens a color.",
		hex_to_rgba = "Converts hex to RGBA.",
		rgba_to_hex = "Converts RGBA to hex.",
	},
}

local function u407(u401)
	return u405[u401]
end

function u408()
	local u409= {}
	for k, v in pairs(_G) do
		if type(v) == "table" or type(v) == "userdata" then
			u409[#u409+1] = k
		end
	end
	return u409
end

function u410(u411)
	local u412= u406[u411]
	if not u412 then return {} end
	local u409= {}
	for k, v in pairs(u412) do
		u409[#u409+1] = k .. " - " .. v
	end
	return u409
end

return {
	get = u407,
	list = u408,
	list_features = u410,
	features = u406,
	libs = u405,
	lib_defs = u404
}
]]
u743["require/help/math"] = [[local u403= {}

function M.clamp(u404,u405,u406)
    if not u405 and not u406 then return u404 end
    u405 = tonumber(u405) or 0
    u406 = tonumber(u406) or u405
    if u405 > u406 then u405, max = u406, u405 end
    u404 = tonumber(u404) or u405
    if u404 < u405 then return u405 end
    if u404 > u406 then return u406 end
    return u404
end

function M.clamp01(u404)
    return u403.clamp(u404, 0, 1)
end

function M.abs(u404)
    u404 = tonumber(u404) or 0
    return math.abs(u404)
end

function M.max(...)
    local u407= {...}
    if #u407 == 0 then return 0 end
    local u408= nil
    for i = 1, #u407 do
        local u409= tonumber(u407[i]) or 0
        if u408 == nil or u409 > u408 then u408 = u409 end
    end
    return u408
end

function M.min(...)
    local u407= {...}
    if #u407 == 0 then return 0 end
    local u408= nil
    for i = 1, #u407 do
        local u409= tonumber(u407[i]) or 0
        if u408 == nil or u409 < u408 then u408 = u409 end
    end
    return u408
end

function M.atan2(u410,u411)
    u410 = tonumber(u410) or 0
    u411 = tonumber(u411) or 0
    return math.atan(u410, u411)
end

function M.floor(u404)
    u404 = tonumber(u404) or 0
    return math.floor(u404)
end

function M.round(u404,u412)
    u404 = tonumber(u404) or 0
    u412 = tonumber(u412) or 0
    local u413= 10 ^ u412
    return math.floor(u404 * u413 + 0.5) / u413
end

function M.lerp(u414,u415,u416)
    u414 = tonumber(u414) or 0
    u415 = tonumber(u415) or 0
    u416 = tonumber(u416) or 0
    return u414 + (u415 - u414) * u416
end

function M.distance2d(u417,u418,u419,u420)
    u417 = tonumber(u417) or 0
    u418 = tonumber(u418) or 0
    u419 = tonumber(u419) or 0
    u420 = tonumber(u420) or 0
    return math.sqrt((u419 - u417)^2 + (u420 - u418)^2)
end

function M.distance3d(u417,u418,u421,u419,u420,u422)
    u417 = tonumber(u417) or 0
    u418 = tonumber(u418) or 0
    u421 = tonumber(u421) or 0
    u419 = tonumber(u419) or 0
    u420 = tonumber(u420) or 0
    u422 = tonumber(u422) or 0
    return math.sqrt((u419 - u417)^2 + (u420 - u418)^2 + (u422 - u421)^2)
end

function M.sign(u404)
    u404 = tonumber(u404) or 0
    return (u404 > 0 and 1) or (u404 < 0 and -1) or 0
end

function M.frac(u404)
    u404 = tonumber(u404) or 0
    return u404 - math.floor(u404)
end

function M.is_even(u404)
    u404 = tonumber(u404) or 0
    return u404 % 2 == 0
end

function M.is_odd(u404)
    u404 = tonumber(u404) or 0
    return u404 % 2 ~= 0
end

function M.sqr(u404)
    u404 = tonumber(u404) or 0
    return u404 * u404
end

function M.cube(u404)
    u404 = tonumber(u404) or 0
    return u404 * u404 * u404
end

function M.approximately(u414,u415,u423)
    u414 = tonumber(u414) or 0
    u415 = tonumber(u415) or 0
    u423 = tonumber(u423) or 1e-6
    return math.abs(u414 - u415) < u423
end

function M.rad_to_deg(u424)
    u424 = tonumber(u424) or 0
    return u424 * (180 / math.pi)
end

function M.deg_to_rad(u425)
    u425 = tonumber(u425) or 0
    return u425 * (math.pi / 180)
end

function M.wrap_degrees(u426)
    local u414= tonumber(u426) or 0
    u414 = u414 % 360
    if u414 < 0 then u414 = u414 + 360 end
    return u414
end

function M.normalize_angle(u426)
    local u414= tonumber(u426) or 0
    u414 = u414 % 360
    if u414 > 180 then u414 = u414 - 360 end
    return u414
end

function M.angle_diff(u414,u415)
    u414 = tonumber(u414) or 0
    u415 = tonumber(u415) or 0
    local u427= (u414 - u415) % 360
    if u427 > 180 then u427 = u427 - 360 end
    return u427
end

function M.lerp_angle(u414,u415,u416)
    u414 = tonumber(u414) or 0
    u415 = tonumber(u415) or 0
    u416 = tonumber(u416) or 0
    local u427= u403.angle_diff(u415, u414)
    return (u414 + u427 * u416) % 360
end

function M.map(u404,u428,u429,u430,u431)
    u404 = tonumber(u404) or 0
    u428 = tonumber(u428) or 0
    u429 = tonumber(u429) or u428
    u430 = tonumber(u430) or 0
    u431 = tonumber(u431) or u430
    if u429 == u428 then return u430 end
    return (u404 - u428) * (u431 - u430) / (u429 - u428) + u430
end

function M.smoothstep(u432,u433,u411)
    u432 = tonumber(u432) or 0
    u433 = tonumber(u433) or u432
    u411 = tonumber(u411) or 0
    if u433 == u432 then return 0 end
    local u416= u403.clamp((u411 - u432) / (u433 - u432), 0, 1)
    return u416 * u416 * (3 - 2 * u416)
end

function M.random_float(u405,u406)
    u405 = tonumber(u405) or 0
    u406 = tonumber(u406) or u405
    if u405 > u406 then u405, max = u406, u405 end
    return u405 + math.random() * (u406 - u405)
end

function M.random_int(u405,u406)
    u405 = tonumber(u405) or 0
    u406 = tonumber(u406) or u405
    if u405 > u406 then u405, max = u406, u405 end
    return math.random(u405, u406)
end

function M.mean(u434)
    if type(u434) ~= 'table' or #u434 == 0 then return 0 end
    local u435= 0
    for i = 1, #u434 do u435 = u435 + (tonumber(u434[i]) or 0) end
    return u435 / #u434
end

function M.swap(u414,u415)
    return u415, u414
end

return u403]]
u743["require/help/panorama"] = [[local u406= {}

u406.raw = panorama

function M.loadstring(u407,u408)
  return panorama.loadstring(u407, u408)
end

function M.open(u408)
  return panorama.open(u408)
end

return u406]]
u743["require/help/plist"] = [[local u409= {}

u409.raw = plist

function M.get(u410,u411)
  return plist.get(u410, u411)
end

function M.set(u410,u411,u412)
  return plist.set(u410, u411, u412)
end

return u409]]
u743["require/help/reference"] = [[local u412= {}

u412.known_items = {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

function M.add_known(u413)
    for _, it in ipairs(u413 or {}) do
        table.insert(u412.known_items, it)
    end
end

function M.get(u414,u415,u416)
    return ui.reference(u414, u415, u416)
end

function M.build(u417)
    local u418= {}
    local u419= {}
    for i, item in ipairs(u417) do
        local u420= {ui.reference(item[1], item[2], item[3])}
        u418[i] = u420
        for _, ref in ipairs(u420) do
            if ref ~= nil then
                u419[ref] = true
            end
        end
    end
    return u418, u419
end

function M.build_known()
    return u412.build(u412.known_items)
end

function M.get_all_known()
    return u412.known_items
end

return u412]]
u743["require/help/references_old"] = [[

local u415= {}

local function u416(u417)
    
    if type(u417) ~= 'table' then
        local u418= u417
        return {
            raw = u418,
            get = function()
                local u419, u420= pcall(ui.get, u418)
                if u419 then return u420 end
                return nil
            end
        }
    end

    
    
    
    local u421= u417
    return {
        raw = u421,
        get = function()
            if u421[2] ~= nil then
                local u419, u420= pcall(ui.get, u421[2])
                if u419 then return u420 end
            end
            if u421[1] ~= nil then
                local u419, u420= pcall(ui.get, u421[1])
                if u419 then return u420 end
            end
            return nil
        end
    }
end


u415.minimum_damage = u416(ui.reference("RAGE", "Aimbot", "Minimum damage"))
u415.minimum_damage_override = u416({ ui.reference("RAGE", "Aimbot", "Minimum damage override") })
u415.doubletap = u416({ ui.reference("RAGE", "Aimbot", "Double tap") })
u415.force_body_aim = u416({ ui.reference("RAGE", "Aimbot", "Force body aim") })
u415.force_safe_point = u416({ ui.reference("RAGE", "Aimbot", "Force safe point") })
u415.duck_peek_assist = u416({ ui.reference("RAGE", "Other", "Duck peek assist") })
u415.quick_peek_assist = u416({ ui.reference("RAGE", "Aimbot", "Quick peek assist") })


u415.pitch = u416(ui.reference("AA", "Anti-aimbot angles", "Pitch"))
u415.yaw_base = u416(ui.reference("AA", "Anti-aimbot angles", "Yaw base"))
u415.yaw = u416(ui.reference("AA", "Anti-aimbot angles", "Yaw"))
u415.yaw_jitter = u416(ui.reference("AA", "Anti-aimbot angles", "Yaw jitter"))
u415.body_yaw = u416(ui.reference("AA", "Anti-aimbot angles", "Body yaw"))
u415.roll = u416(ui.reference("AA", "Anti-aimbot angles", "Roll"))

return u415]]
u743["require/help/renderer"] = [[local u418= {}

u418.raw = renderer

function M.blur(u419,u420,u421,u422,u423,u424)
  return renderer.blur(u419, u420, u421, u422, u423, u424)
end

function M.circle(u419,u420,u425,u426,u427,u428,u429,u430,u431)
  return renderer.circle(u419, u420, u425, u426, u427, u428, u429, u430, u431)
end

function M.circle_outline(u419,u420,u425,u426,u427,u428,u429,u430,u431,u432)
  return renderer.circle_outline(u419, u420, u425, u426, u427, u428, u429, u430, u431, u432)
end

function M.gradient(u419,u420,u421,u422,u433,u434,u435,u436,u437,u438,u439,u440,u441)
  return renderer.gradient(u419, u420, u421, u422, u433, u434, u435, u436, u437, u438, u439, u440, u441)
end

function M.indicator(u425,u426,u427,u428,...)
  return renderer.indicator(u425, u426, u427, u428, ...)
end

function M.line(u442,u443,u444,u445,u425,u426,u427,u428)
  return renderer.line(u442, u443, u444, u445, u425, u426, u427, u428)
end

function M.load_jpg(u446,u447,u448)
  return renderer.load_jpg(u446, u447, u448)
end

function M.load_png(u446,u447,u448)
  return renderer.load_png(u446, u447, u448)
end

function M.load_rgba(u446,u447,u448)
  return renderer.load_rgba(u446, u447, u448)
end

function M.load_svg(u446,u447,u448)
  return renderer.load_svg(u446, u447, u448)
end

function M.measure_text(u449,...)
  return renderer.measure_text(u449, ...)
end

function M.rectangle(u419,u420,u421,u422,u425,u426,u427,u428)
  return renderer.rectangle(u419, u420, u421, u422, u425, u426, u427, u428)
end

function M.text(u419,u420,u425,u426,u427,u428,u449,u450,...)
  return renderer.text(u419, u420, u425, u426, u427, u428, u449, u450, ...)
end

function M.texture(u451,u419,u420,u421,u422,u425,u426,u427,u428,u452)
  return renderer.texture(u451, u419, u420, u421, u422, u425, u426, u427, u428, u452)
end

function M.triangle(u442,u443,u444,u445,u453,u454,u425,u426,u427,u428)
  return renderer.triangle(u442, u443, u444, u445, u453, u454, u425, u426, u427, u428)
end

function M.world_to_screen(u419,u420,u455)
  return renderer.world_to_screen(u419, u420, u455)
end

function M.rectangle_outline(u419,u420,u421,u422,u425,u426,u427,u428,u432)
  u432 = u432 or 1
  for i = 0, u432 - 1 do
    renderer.line(u419 + i, u420 + i, u419 + u421 - i, u420 + i, u425, u426, u427, u428)
    renderer.line(u419 + i, u420 + u422 - i, u419 + u421 - i, u420 + u422 - i, u425, u426, u427, u428)
    renderer.line(u419 + i, u420 + i, u419 + i, u420 + u422 - i, u425, u426, u427, u428)
    renderer.line(u419 + u421 - i, u420 + i, u419 + u421 - i, u420 + u422 - i, u425, u426, u427, u428)
  end
end

function M.text_centered(u419,u420,u425,u426,u427,u428,u449,u450,...)
  local u421, u422= renderer.measure_text(u449, ...)
  if not u421 or not u422 then return end
  return renderer.text(u419 - u421 / 2, u420 - u422 / 2, u425, u426, u427, u428, u449, u450, ...)
end

function M.texture_from_file(u456)
  local u446= readfile(u456)
  if not u446 then return nil end
  local u451= renderer.load_png(u446)
  if not u451 then
    u451 = renderer.load_jpg(u446)
  end
  return u451
end

return u418]]
u743["require/help/safe"] = [[local u421= {}

function M.safe_call(u422,...)
	local u423, u424= pcall(u422, ...)
	return u423 and u424 or nil
end

function M.safe_set(u425,u426)
	local u423= pcall(function() ui.set(u425, u426) end)
	return u423
end

function M.safe_get(u425)
	local u423, u424= pcall(function() return ui.get(u425) end)
	return u423 and u424 or nil
end

return u421]]
u743["require/help/self"] = [[local u424= {}

local u425= entity
local u426= globals
local u427= client

function M.index()
	return u425 and u425.get_local_player and u425.get_local_player() or nil
end

function M.exists()
	return u424.index() ~= nil
end

function M.is_alive()
	local u428= u424.index()
	return u428 and u425.is_alive and u425.is_alive(u428) or false
end

function M.health()
	local u428= u424.index()
	return u428 and u425.get_prop and u425.get_prop(u428, 'm_iHealth') or 0
end

function M.ping()
	return u427 and u427.latency and u427.latency() or 0
end

function M.velocity()
	local u428= u424.index()
	if not u428 or not u425.get_prop then return 0 end
	local u429, u430, u431= u425.get_prop(u428, 'm_vecVelocity')
	if u429 and u430 and u431 then
		return math.sqrt(u429 * u429 + u430 * u430 + u431 * u431)
	end
	return 0
end

function M.velocity2d()
	local u428= u424.index()
	if not u428 or not u425.get_prop then return 0 end
	local u429, u430= u425.get_prop(u428, 'm_vecVelocity')
	if u429 and u430 then
		return math.sqrt(u429 * u429 + u430 * u430)
	end
	return 0
end

function M.weapon()
	local u428= u424.index()
	return u428 and u425.get_player_weapon and u425.get_player_weapon(u428) or nil
end

function M.tickbase_shifted()
	
	return false
end

function M.simtime()
	local u428= u424.index()
	return u428 and u425.get_prop and u425.get_prop(u428, 'm_flSimulationTime') or 0
end

function M.eye_angles()
	return u427 and u427.camera_angles and u427.camera_angles() or nil
end

function M.fps()
	local u432= u426 and u426.absoluteframetime and u426.absoluteframetime() or u426.frametime and u426.frametime() or 0.01
	if u432 > 0 then
		return math.floor(1 / u432 + 0.5)
	end
	return 0
end

function M.map()
	return u426 and u426.mapname and u426.mapname() or nil
end

function M.is_dormant()
	local u428= u424.index()
	return u428 and u425.is_dormant and u425.is_dormant(u428) or false
end

function M.team_number()
	local u428= u424.index()
	return u428 and u425.get_prop and u425.get_prop(u428, 'm_iTeamNum') or 0
end

function M.player_name()
	local u428= u424.index()
	return u428 and u425.get_player_name and u425.get_player_name(u428) or nil
end

function M.steam64()
	local u428= u424.index()
	return u428 and u425.get_steam64 and u425.get_steam64(u428) or nil
end

function M.ammo_count()
	local u433= u424.weapon()
	return u433 and u425.get_prop and u425.get_prop(u433, 'm_iClip1') or 0
end

function M.has_armor()
	local u428= u424.index()
	return u428 and u425.get_prop and u425.get_prop(u428, 'm_ArmorValue') > 0 or false
end

function M.has_helmet()
	local u428= u424.index()
	return u428 and u425.get_prop and u425.get_prop(u428, 'm_bHasHelmet') == 1 or false
end

function M.current_tick()
	return u426 and u426.tickcount and u426.tickcount() or 0
end

function M.tick_interval()
	return u426 and u426.tickinterval and u426.tickinterval() or 0
end

function M.current_frame()
	return u426 and u426.framecount and u426.framecount() or 0
end

function M.current_time()
	return u426 and u426.curtime and u426.curtime() or 0
end

function M.real_latency()
	return u427 and u427.real_latency and u427.real_latency() or 0
end

function M.system_time()
	return u427 and u427.system_time and u427.system_time() or {0,0,0,0}
end

function M.unix_time()
	return u427 and u427.unix_time and u427.unix_time() or 0
end

function M.kills()
	local u428= u424.index()
	if not u428 or not u425.get_prop then return 0 end
	local u434= u425.get_player_resource and u425.get_player_resource()
	if u434 then
		return u425.get_prop(u434, 'm_iKills', u428) or 0
	end
	return 0
end

function M.deaths()
	local u428= u424.index()
	if not u428 or not u425.get_prop then return 0 end
	local u434= u425.get_player_resource and u425.get_player_resource()
	if u434 then
		return u425.get_prop(u434, 'm_iDeaths', u428) or 0
	end
	return 0
end

function M.assists()
	local u428= u424.index()
	if not u428 or not u425.get_prop then return 0 end
	local u434= u425.get_player_resource and u425.get_player_resource()
	if u434 then
		return u425.get_prop(u434, 'm_iAssists', u428) or 0
	end
	return 0
end

return u424
]]
u743["require/help/string"] = [[local u427= {}

function S.lower(u428)
	return string.lower(u428)
end

function S.upper(u428)
	return string.upper(u428)
end

function S.capitalize(u428)
	return (u428:gsub("^%l", string.upper):gsub("^(%u)(.*)", function(u429,u430) return u429 .. string.lower(u430) end))
end

function S.title(u428)
	return (u428:gsub("%S+", function(u431)
		return u431:sub(1,1):upper() .. u431:sub(2):lower()
	end))
end

function S.random_case(u428)
	local u432= {}
	for i = 1, #u428 do
		local u433= u428:sub(i,i)
		if math.random() < 0.5 then
			u432[i] = string.lower(u433)
		else
			u432[i] = string.upper(u433)
		end
	end
	return table.concat(u432)
end

function S.startswith(u428,u434)
	return u428:sub(1, #u434) == u434
end

function S.endswith(u428,u435)
	return u435 == '' or u428:sub(-#u435) == u435
end

function S.byte(u428,u436,u437)
	return string.byte(tostring(u428 or ""), u436, u437)
end

function S.char(...)
	return string.char(...)
end

function S.find(u428,u438,u439,u440)
	return string.find(tostring(u428 or ""), u438, u439, u440)
end

function S.format(u441,...)
	return string.format(u441, ...)
end

function S.gmatch(u428,u438)
	return string.gmatch(tostring(u428 or ""), u438)
end

function S.gsub(u428,u438,u442,u443)
	return string.gsub(tostring(u428 or ""), u438, u442, u443)
end

function S.split(u428,u444)
	local u445= {}
	if u444 == '' then
		for u436 = 1, #u428 do u445[u436] = u428:sub(u436,u436) end
		return u445
	end
	local u438= string.format("([^%s]+)", u444)
	for part in u428:gmatch(u438) do
		u445[#u445+1] = part
	end
	return u445
end

function S.join(u446,u444)
	return table.concat(u446, u444)
end

function S.replace(u428,u438,u442)
	return u428:gsub(u438, u442)
end

function S.reverse(u428)
	return string.reverse(u428)
end

function S.repeat_str(u428,u443)
	return string.rep(u428, u443)
end

function S.rep(u428,u443)
	return string.rep(tostring(u428 or ""), u443)
end

function S.contains(u428,u447)
	return u428:find(u447, 1, true) ~= nil
end

function S.count(u428,u447)
	if u447 == '' then return 0 end
	local u448= 0
	local u449= 1
	while true do
		local u450= u428:find(u447, u449, true)
		if not u450 then break end
		u448 = u448 + 1
		u449 = u450 + #u447
	end
	return u448
end

function S.is_empty(u428)
	return u428 == nil or u428 == ''
end

function S.is_digit(u428)
	return u428:match("^%d+$") ~= nil
end

function S.is_alpha(u428)
	return u428:match("^%a+$") ~= nil
end

function S.random_string(u451)
	local u452= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local u432= {}
	for u436 = 1, u451 do
		local u453= math.random(1, #u452)
		u432[u436] = u452:sub(u453, u453)
	end
	return table.concat(u432)
end

function S.safe_substr(u428,u436,u437)
	local u454= tostring(u428 or "")
	local u443= #u454
	local u450= tonumber(u436) or 1
	if u450 < 0 then u450 = u443 + 1 + u450 end
	if u450 < 1 then u450 = 1 end
	if u437 == nil then
		return u454:sub(u450)
	end
	local u455= tonumber(u437)
	if not u455 then
		return u454:sub(u450)
	end
	if u455 >= 0 then
		return u454:sub(u450, math.min(u443, u450 + u455 - 1))
	else
		local u456= u443 + u455
		if u456 < u450 then return "" end
		return u454:sub(u450, u456)
	end
end

function S.sub(u428,u454,u457)
	return string.sub(tostring(u428 or ""), u454, u457)
end

function S.len(u428)
	return string.len(tostring(u428 or ""))
end

function S.match(u428,u438,u439)
	return string.match(tostring(u428 or ""), u438, u439)
end

function S.trim(u428)
	return (tostring(u428 or ""):gsub("^%s*(.-)%s*$", "%1"))
end

function S.ltrim(u428)
	return (tostring(u428 or ""):gsub("^%s*(.-)$", "%1"))
end

function S.rtrim(u428)
	return (tostring(u428 or ""):gsub("^(.-)%s*$", "%1"))
end

function S.escape_pattern(u428)
	return tostring(u428 or ""):gsub("([%%%$%(%)%.%[%]%*%+%-%?%^])", "%%%1")
end

function S.ensure_prefix(u428,u434)
	local u454= tostring(u428 or "")
	local u458= tostring(u434 or "")
	if u458 == "" then return u454 end
	if u454:sub(1, #u458) == u458 then return u454 end
	return u458 .. u454
end

function S.ensure_suffix(u428,u435)
	local u454= tostring(u428 or "")
	local u459= tostring(u435 or "")
	if u459 == "" then return u454 end
	if u454:sub(-#u459) == u459 then return u454 end
	return u454 .. u459
end

function S.truncate(u428,u460,u461)
	local u454= tostring(u428 or "")
	local u462= tonumber(u460) or 0
	if u462 <= 0 or #u454 <= u462 then return u454 end
	local u457= tostring(u461 or "...")
	local u463= u462 - #u457
	if u463 <= 0 then return u457:sub(1, u462) end
	return u454:sub(1, u463) .. u457
end

local u464= {
	a = '4', A = '4', e = '3', E = '3', i = '1', I = '1', o = '0', O = '0',
	s = '5', S = '5', t = '7', T = '7', b = '8', B = '8', g = '6', G = '6',
	z = '2', Z = '2', l = '1', L = '1'
}

function S.leet(u428,u465)
	local u454= tostring(u428 or "")
	local u458= tonumber(u465) or 1
	if u458 <= 0 then return u454 end
	local u432= {}
	for u436 = 1, #u454 do
		local u433= u454:sub(u436,u436)
		local u430= u464[u433]
		if u430 and math.random() <= u458 then u432[#u432+1] = u430 else u432[#u432+1] = u433 end
	end
	return table.concat(u432)
end

function S.pipeline(u428,...)
	local u454= tostring(u428 or "")
	for u436 = 1, select('#', ...) do
		local u466= select(u436, ...)
		if type(u466) == 'function' then
			u454 = u466(u454)
		elseif type(u466) == 'string' and u427[u466] then
			u454 = u427[u466](u454)
		end
	end
	return u454
end

return u427]]
u743["require/help/time"] = [[local u430= {}

local u431= client
local u432= globals

local function u433()
	if u432 and u432.realtime then
		return u432.realtime()
	end
	if u431 and u431.timestamp then
		local u434= u431.timestamp()
		if u434 then return u434 / 1000 end
	end
	return 0
end

function T.simtime()
	if u432 and u432.curtime then return u432.curtime() end
	return u433()
end

function T.realtime()
	return u433()
end

function T.tickcount()
	if u432 and u432.tickcount then return u432.tickcount() end
	local u435= u430.tickinterval()
	if u435 and u435 > 0 then return math.floor(u433() / u435) end
	return 0
end

function T.tickinterval()
	if u432 and u432.tickinterval then return u432.tickinterval() end
	return 0.015625
end

function T.seconds_to_ticks(u436)
	local u437= u430.tickinterval()
	if u437 and u437 > 0 then return math.floor(u436 / u437 + 0.5) end
	return math.floor(u436 * 64 + 0.5)
end

function T.ticks_to_seconds(u438)
	local u437= u430.tickinterval()
	if u437 then return u438 * u437 end
	return u438 * 0.015625
end

function T.frametime()
	if u432 and u432.frametime then return u432.frametime() end
	return 0
end

function T.absoluteframetime()
	if u432 and u432.absoluteframetime then return u432.absoluteframetime() end
	return 0
end

function T.framecount()
	if u432 and u432.framecount then return u432.framecount() end
	return 0
end

function T.framecount_to_seconds(u439)
	local u440= u430.frametime()
	return u439 * (u440 or 0)
end

function T.seconds_to_framecount(u436)
	local u440= u430.frametime()
	if u440 and u440 > 0 then return math.floor(u436 / u440 + 0.5) end
	return math.floor(u436 * 60 + 0.5)
end

function T.new(u441)
	return { start = u433(), duration = u441 or 0 }
end

function T.expired(u442)
	return u433() - (u442.start or 0) >= (u442.duration or 0)
end

function T.reset(u442,u441)
	u442.start = u433()
	if u441 then u442.duration = u441 end
end

function T.elapsed(u442)
	return u433() - (u442.start or 0)
end

function T.interval(u437,u443)
	local u444= u433()
	return function(...)
		local u445= u433()
		if u445 - u444 >= u437 then
			u444 = u445
			u443(...)
		end
	end
end

function T.timeout(u446,u443)
	local u447= false
	local u448= u433()
	return function(...)
		if not u447 and u433() - u448 >= u446 then
			u447 = true
			u443(...)
		end
	end
end

function T.debounce(u437,u443)
	local u444= 0
	return function(...)
		local u445= u433()
		if u445 - u444 >= u437 then
			u444 = u445
			u443(...)
		end
	end
end

function T.throttle(u437,u443)
	local u444= 0
	return function(...)
		local u445= u433()
		if u445 - u444 >= u437 then
			u444 = u445
			u443(...)
		end
	end
end

function T.wait(u446)
	local u448= u433()
	return function()
		return u433() - u448 >= u446
	end
end

function T.stopwatch()
	local u449= { running = false, start = 0, elapsed = 0 }
	function sw:start()
		if not self.running then
			self.running = true
			self.start = u433()
		end
	end
	function sw:stop()
		if self.running then
			self.running = false
			self.elapsed = self.elapsed + (u433() - (self.start or 0))
		end
	end
	function sw:reset()
		self.running = false
		self.start = 0
		self.elapsed = 0
	end
	function sw:get()
		if self.running then
			return self.elapsed + (u433() - (self.start or 0))
		else
			return self.elapsed
		end
	end
	return u449
end

u430.Scheduler = {}
u430.Scheduler.__index = u430.Scheduler

function T.Scheduler.new()
    return setmetatable({ tasks = {} }, u430.Scheduler)
end

function T.Scheduler:add(u437,u443)
	self.tasks[#self.tasks+1] = { interval = u437, callback = u443, last = u433() }
end

function T.Scheduler:remove(u443)
    for i = #self.tasks, 1, -1 do
        if self.tasks[i].callback == u443 then
            table.remove(self.tasks, i)
        end
    end
end

function T.Scheduler:run(...)
	local u445= u433()
	for _, task in ipairs(self.tasks) do
		if u445 - task.last >= task.interval then
			task.last = u445
			task.callback(...)
		end
	end
end

function T.safe_timeout(u446,u443)
	local u448= u433()
	local u447= false
	return function(...)
		if not u447 and u433() - u448 >= u446 then
			u447 = true
			u443(...)
		end
	end
end

function T.lerp(u450,u451,u445)
	return u450 + (u451 - u450) * u445
end

function T.ease_in_out(u445)
	if u445 < 0 then u445 = 0 end
	if u445 > 1 then u445 = 1 end
	return u445 < 0.5 and 2 * u445 * u445 or -1 + (4 - 2 * u445) * u445
end

function T.ping_pong(u445,u452)
	if u452 <= 0 then return 0 end
	local u453= u445 % (u452 * 2)
	if u453 < u452 then return u453 / u452 end
	return 1 - ((u453 - u452) / u452)
end

function T.apply_animation(u441,u454,u455)
	local u448= u433()
	return function()
		local u445= (u433() - u448) / (u441 or 1)
		if u445 >= 1 then
			u454(1)
			if u455 then u455() end
			return true
		else
			u454(u445)
			return false
		end
	end
end

function T.within_ticks_window(u456,u457)
	local u458= u430.tickcount()
	if not u458 or not u456 then return false end
	return u458 - u456 <= (u457 or 0)
end

return u430]]
u743["require/help/trace"] = [[]]
u743["require/help/ui"] = [[local u436= {}

u436.raw = ui

local function u437()
    if type(ui) ~= 'table' then
        error('ui library is not available in this environment')
    end
end

function M.available()
    return type(ui) == 'table'
end

function M.get(u438)
    u437()
    return ui.get(u438)
end

function M.is_menu_open()
    u437()
    return ui.is_menu_open()
end

function M.menu_position()
    u437()
    return ui.menu_position()
end

function M.menu_size()
    u437()
    return ui.menu_size()
end

function M.mouse_position()
    u437()
    return ui.mouse_position()
end

function M.name(u438)
    u437()
    return ui.name(u438)
end


function M.new_button(u439,u440,u441,u442)
    u437()
    return ui.new_button(u439, u440, u441, u442)
end

function M.new_checkbox(u439,u440,u441)
    u437()
    return ui.new_checkbox(u439, u440, u441)
end

function M.new_color_picker(u439,u440,u441,u443,u444,u445,u446)
    u437()
    return ui.new_color_picker(u439, u440, u441, u443 or 0, u444 or 0, u445 or 0, u446 or 255)
end

function M.new_combobox(u439,u440,u441,...)
    u437()
    return ui.new_combobox(u439, u440, u441, ...)
end

function M.new_hotkey(u439,u440,u441,u447,u448)
    u437()
    return ui.new_hotkey(u439, u440, u441, u447 and true or false, u448)
end

function M.new_label(u439,u440,u441)
    u437()
    return ui.new_label(u439, u440, u441)
end

function M.new_listbox(u439,u440,u441,u449)
    u437()
    return ui.new_listbox(u439, u440, u441, u449)
end

function M.new_multiselect(u439,u440,u441,...)
    u437()
    return ui.new_multiselect(u439, u440, u441, ...)
end

function M.new_slider(u439,u440,u441,u450,u451,u452,u453,u454,u455,u456)
    u437()
    return ui.new_slider(u439, u440, u441, u450, u451, u452, u453, u454, u455, u456)
end

function M.new_string(u441,u457)
    u437()
    return ui.new_string(u441, u457)
end

function M.new_textbox(u439,u440,u441)
    u437()
    return ui.new_textbox(u439, u440, u441)
end

function M.reference(u439,u440,u441)
    u437()
    return ui.reference(u439, u440, u441)
end


function M.set(u438,...)
    u437()
    return ui.set(u438, ...)
end

function M.set_callback(u438,u442)
    u437()
    return ui.set_callback(u438, u442)
end

function M.set_enabled(u438,u458)
    u437()
    return ui.set_enabled(u438, u458)
end

function M.set_visible(u438,u459)
    u437()
    return ui.set_visible(u438, u459)
end

function M.type(u438)
    u437()
    return ui.type(u438)
end

function M.update(u438,...)
    u437()
    if ui.update then
        return ui.update(u438, ...)
    end
    error('ui.update is not supported in this environment')
end

function M.get_color(u438)
    u437()
    local u443,u444,u445,u446= ui.get(u438)
    if u443 == nil then return nil end
    return { r = u443, g = u444, b = u445, a = u446 }
end

function M.set_color(u438,u460)
    u437()
    if type(u460) == 'table' then
        return ui.set(u438, u460.r or 0, u460.g or 0, u460.b or 0, u460.a or 255)
    else
        error('color must be a table {r,g,b,a}')
    end
end

function M.get_multiselect(u438)
    u437()
    local u461= ui.get(u438)
    return u461
end

function M.list_refs(u439,u440)
    u437()
    local u462= {}
    for _, u441 in ipairs(ui.get_children and ui.get_children(u439, u440) or {}) do
        u462[#u462+1] = ui.reference(u439, u440, u441)
    end
    return u462
end

return u436]]
u743["require/help/vector"] = [[local u439
do
    local function u440(u441,u442,u443)
        local u444= { x = 0, y = 0, z = 0 }
        if type(u441) == "table" then
            u444.x = u441.x or u441[1] or 0
            u444.y = u441.y or u441[2] or 0
            u444.z = u441.z or u441[3] or 0
        elseif type(u441) == "number" then
            u444.x = u441
            u444.y = u442 or 0
            u444.z = u443 or 0
        elseif u441 ~= nil then
            u444.x = (u441.x or u441[1]) or 0
            u444.y = (u441.y or u441[2]) or 0
            u444.z = (u441.z or u441[3]) or 0
        end
        return setmetatable(u444, vector_mt)
    end

    local u445= {}

    vector_mt = {
        __index = function(u446,u447)
            if u447 == 1 then return rawget(u446,"x") end
            if u447 == 2 then return rawget(u446,"y") end
            if u447 == 3 then return rawget(u446,"z") end
            local u444= rawget(u446,u447)
            if u444 ~= nil then return u444 end
            return u445[u447]
        end,
        __sub = function(u441,u442)
            return u440((u441.x or 0) - (u442.x or 0), (u441.y or 0) - (u442.y or 0), (u441.z or 0) - (u442.z or 0))
        end,
        __add = function(u441,u442)
            return u440((u441.x or 0) + (u442.x or 0), (u441.y or 0) + (u442.y or 0), (u441.z or 0) + (u442.z or 0))
        end,
        __mul = function(u441,u442)
            if type(u441) == 'number' then return u440(u441 * (u442.x or 0), u441 * (u442.y or 0), u441 * (u442.z or 0)) end
            if type(u442) == 'number' then return u440((u441.x or 0) * u442, (u441.y or 0) * u442, (u441.z or 0) * u442) end
            return nil
        end,
        __div = function(u441,u442)
            if type(u442) == 'number' and u442 ~= 0 then return u440((u441.x or 0) / u442, (u441.y or 0) / u442, (u441.z or 0) / u442) end
            return nil
        end,
        __unm = function(u441) return u440(-(u441.x or 0), -(u441.y or 0), -(u441.z or 0)) end,
        __tostring = function(u441) return string.format("vec(%.3f, %.3f, %.3f)", u441.x or 0, u441.y or 0, u441.z or 0) end
    }

    u445.length = function(u448) return math.sqrt((u448.x or 0)^2 + (u448.y or 0)^2 + (u448.z or 0)^2) end
    u445.dot = function(u441,u442) return (u441.x or 0)*(u442.x or 0) + (u441.y or 0)*(u442.y or 0) + (u441.z or 0)*(u442.z or 0) end
    u445.cross = function(u441,u442)
        return u440((u441.y or 0)*(u442.z or 0) - (u441.z or 0)*(u442.y or 0),
                        (u441.z or 0)*(u442.x or 0) - (u441.x or 0)*(u442.z or 0),
                        (u441.x or 0)*(u442.y or 0) - (u441.y or 0)*(u442.x or 0))
    end
    u445.normalized = function(u448)
        local u449= u445.length(u448)
        if u449 == 0 or u449 == nil then return u440(0,0,0) end
        return u440((u448.x or 0)/u449, (u448.y or 0)/u449, (u448.z or 0)/u449)
    end
    u445.normalize = function(u448)
        local u449= u445.length(u448)
        if u449 == 0 or u449 == nil then return u448 end
        u448.x = (u448.x or 0)/u449
        u448.y = (u448.y or 0)/u449
        u448.z = (u448.z or 0)/u449
        return u448
    end
    u445.copy = function(u448) return u440(u448.x or 0, u448.y or 0, u448.z or 0) end
    u445.distance_to = function(u448,u450)
        local u451= u450
        if type(u450) == 'number' then u451 = u439(u450) end
        local u452= (u448.x or 0) - (u451.x or 0)
        local u453= (u448.y or 0) - (u451.y or 0)
        local u454= (u448.z or 0) - (u451.z or 0)
        return math.sqrt(u452*u452 + u453*u453 + u454*u454)
    end
    u445.to_screen = function(u448)
        if not renderer or not renderer.world_to_screen then return nil end
        return renderer.world_to_screen(u448.x or 0, u448.y or 0, u448.z or 0)
    end
    u445.to_angles = function(u448,u450)
        local u451= u450
        if not u451 then return nil end
        local u452= (u451.x or 0) - (u448.x or 0)
        local u453= (u451.y or 0) - (u448.y or 0)
        local u454= (u451.z or 0) - (u448.z or 0)
        local u455= math.deg(math.atan2(u453, u452))
        local u456= math.sqrt(u452*u452 + u453*u453)
        local u457= -math.deg(math.atan2(u454, u456))
        return u457, u455
    end

    u439 = setmetatable({}, {
        __call = function(u458,u441,u442,u443)
            return u440(u441, u442, u443)
        end
    })
end
return u439]]
u743["main"] = [[


local function u442(u443)
    local u444, u445= pcall(require, u443)
    if u444 then
        return u445
    else
        return nil
    end
end




u442("require/brain/dll")





local function u446()

    u442("require/brain/test")

    local u447= {
        menu = u442("require/abc/menu_header"),
        login = u442("require/abc/login_system"),
        config = u442("require/abc/config_system"),
        player_condition = u442("require/aa/player_condition"),
        menu_setup = u442("require/abc/menu_setup"),
        gc = u442("require/abc/garbage_collector"),
        pushlog = u442("require/abc/push_logger"),
        screenlog = u442("require/abc/screen_logger"),
        self = u442("require/help/self"),
        enemies = u442("require/help/enemies"),
        COLORS = u442("require/help/color"),
        str = u442("require/help/string"),
        safe = u442("require/help/safe"),
        build_menu = u442("require/abc/build_menu"),
        menu_visibility = u442("require/abc/menu_visibility"),
        config_system = u442("require/abc/config_system"),
    }

    
    u442("require/abc/register")

    
    u442("require/features/aa/antiaim")

    
    
    u442("require/features/misc/resolver")
    u442("require/features/misc/analyze")
    u442("require/features/misc/dormant_aimbot")
    u442("require/features/misc/fakelag")
    u442("require/features/misc/hotkeys")
    u442("require/features/misc/freestand_helper")
    u442("require/features/misc/enhance_osaa")
    u442("require/features/misc/roll")
    u442("require/features/misc/exploit_fakelag")
    u442("require/features/misc/walkbot")
    u442("require/features/misc/backstab_assist")
    u442("require/features/misc/spin_on_dead_enemies")
    u442("require/features/misc/localdebug")

    
    u442("require/features/paint/world_hitmarker_plus")
    u442("require/features/paint/onshot_skeleton")
    u442("require/features/paint/damage")
    u442("require/features/paint/damage_penetration")
    u442("require/features/paint/aimbot_logs")
    u442("require/features/paint/aspect_ratio")
    u442("require/features/paint/third_person_distance")
    u442("require/features/paint/watermark_solus")
    u442("require/features/paint/watermark_gamesense")
    u442("require/features/paint/entidx")
    u442("require/features/paint/target_info")
    u442("require/features/paint/clantag")
    u442("require/features/paint/indicators_bold")
    u442("require/features/paint/indicators_small")
    u442("require/features/paint/hit_miss_indicator")
    u442("require/features/paint/bomb_esp")
    u442("require/features/paint/presmoke_warning")
    u442("require/features/paint/self_skeleton")
    u442("require/features/paint/performance_mode")
    
    u442("require/features/paint/minimum_damage")
    u442("require/features/paint/filter_console")
    u442("require/features/paint/warnings")
    u442("require/features/paint/text_watermark")
    u442("require/features/paint/bullet_tracer")
    u442("require/features/paint/animations")
    u442("require/features/paint/lagcomp_box")
    u442("require/features/paint/insults")
    u442("require/features/paint/molotov_particles")
    
    

    
    u447.pushlog("The lua has initialized", 4, 255, 255, 0, 255)
    u447.screenlog("The lua has initialized", 4, 255, 255, 255, 255)

    
    local function u448()
        local u449= database.read('cached_credentials')
        if u449 and u449.username and u449.password then
            u447.safe.safe_set(u447.menu_setup.ui.login_username, u449.username)
            u447.safe.safe_set(u447.menu_setup.ui.login_password, u449.password)
            u447.safe.safe_set(u447.menu_setup.ui.cache_credentials, true)
            
            local u450= u447.login.login(u449.username, u449.password)
            if u450 then
                local u451,u452,u453= u447.COLORS.get("green", "log")
                u447.screenlog("Auto-login successful!", 3, u451, u452, u453, 255)
                u447.pushlog("Auto-login successful!", 3, 255, 255, 0, 255)
            else
                local u451,u452,u453= u447.COLORS.get("red", "log")
                u447.screenlog("Auto-login failed!", 3, u451, u452, u453, 255)
                u447.pushlog("Auto-login failed!", 3, 255, 255, 0, 255)
            end
        end
    end

    
    u447.build_menu(u447)
    u447.menu_visibility.setup_callbacks(u447)

    
    local function u454()
        local u455= u447.login.logged_in
        if not u455 then return end
        u447.menu.draw_menu()
        if u447.menu.is_menu_open() then
            local u456= u447.menu.tab_sections()
            local u457, u458= u447.menu.mouse_position()
            local u459= u447.menu.current_tab_index()
            local u460= u447.menu.current_tab()
            local u461, u462= u447.menu.menu_position()
            local u463, u464= u447.menu.menu_size()
        end
    end

    
    local function u465(u466)
        if not u447.menu.is_menu_open() then return end
        if not u447.menu.is_mouse_outside_menu() then
            u466.in_attack = false
        end
    end

    
    local function u467()
        if u447.gc then
            if u447.gc.dynamic then
                u447.gc.dynamic()
            elseif u447.gc.step then
                u447.gc.step(100)
            end
        end
    end

    
    local function u468()
        u448()
        u447.menu_visibility.update(u447)
    end

    u468()

    local u469

    
    client.set_event_callback('setup_command', function(u466)
        u465(u466)
    end)

    client.set_event_callback('paint', function()
        u454()
        
    end)

    client.set_event_callback('paint_ui', function()

        if not u447.menu.is_menu_open() then return end
        local u460= u447.menu.current_tab()

        u447.menu_setup.toggle_gamesense_menu(false)

        if u460 ~= u469 then
            u469 = u460
            u447.menu_visibility.update(u447)
        end

    end)

    client.set_event_callback('shutdown', function(u466)
        u447.menu_setup.toggle_gamesense_menu(true)
    end)
end

_G.loader_init_after_hwid = u446
u442("require/abc/hwid_check")]]

return u746("main")
