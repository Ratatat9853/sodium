
local e661= {}
local e662= {}
local e663= require

local function e664(e665)
    if e662[e665] then
        return e662[e665]
    end

    local e666= e661[e665]
    if not e666 then
        return e663(e665)
    end
    local e667= {}
    setmetatable(e667, { __index = _G })
    e667.require = e664

    local e668, e669
    if type(setfenv) == "function" then
        e668, e669 = load(e666, e665)
        if not e668 then
            error("Failed to load module: " .. e665 .. " (" .. tostring(e669) .. ")")
        end
        setfenv(e668, e667)
    else
        e668, e669 = load(e666, e665, nil, e667)
        if not e668 then
            error("Failed to load module: " .. e665 .. " (" .. tostring(e669) .. ")")
        end
    end

    local e670= e668()
    e662[e665] = e670 or true
    return e662[e665]
end

e661["require/aa/player_condition"] = [[
local e45= require("require/help/libs")
local e46= e45.get("antiaim_funcs")
local entity= e45.get("entity") or entity
local bit= e45.get("bit") or bit
local e47= require('require/abc/menu_setup')
local e48= { last_air = false, last_tick = 0, last_cond = nil }

local function e49(e50)
    if e50 == 'global' then return true end
    if not e47 or not e47.ui then return true end
    local e51= 'enable_' .. e50
    local e52= e47.ui[e51]
    if not e52 then
        return true
    end
    local e53, e54= pcall(ui.get, e52)
    return e53 and e54 == true
end


local function e55()
    local e56= entity.get_local_player()
    if not e56 or not entity.is_alive(e56) then
        return nil
    end
    
    if client.key_state(0x45) then
        if e49('legit') then return "legit" end
    end

    local e57= false
    if e46 and e46.get_double_tap then
        e57 = e46.get_double_tap()
    else
        e57 = true
    end

    if e57 == false then
        if e49('fakelag') then return "fakelag" end
    end

    if misc_gs_hotkey_slowmotion and ui.get(misc_gs_hotkey_slowmotion) == true then
        if e49('walk') then return "walk" end
    end
    
    if client.key_state(0x10) then
        local e58, e59= entity.get_prop(e56, 'm_vecVelocity')
        local e60= math.sqrt((e58 or 0)^2 + (e59 or 0)^2)
        if e60 >= 20 and e60 <= 140 then
            if e49('walk') then return "walk" end
        end
    end

    local e58, e59= entity.get_prop(e56, 'm_vecVelocity')
    local e60= math.sqrt((e58 or 0)^2 + (e59 or 0)^2)
    local e61= entity.get_prop(e56, 'm_flDuckAmount') > 0.5
    local e62= bit.band(entity.get_prop(e56, 'm_fFlags') or 0, 1) == 1
    local e63= globals.tickcount()

    if not e62 then
        if e61 then
            e48.last_air = true
            e48.last_tick = e63
            e48.last_cond = "jump+"
            if e49('jump+') then return "jump+" end
        else
            e48.last_air = true
            e48.last_tick = e63
            e48.last_cond = "jump"
            if e49('jump') then return "jump" end
        end
    else
        if e48.last_air and (e63 - e48.last_tick <= 2) then
            if e48.last_cond and e49(e48.last_cond) then
                return e48.last_cond
            end
        end
        e48.last_air = false
        e48.last_cond = nil
    end

    if e61 then
        if e60 >= 2 then
            if e49('duck+') then return "duck+" end
        else
            if e49('duck') then return "duck" end
        end
    else
        if e60 >= 2 then
            if e49('move') then return "move" end
        else
            if e49('stand') then return "stand" end
        end
    end

    return "global"
end

return {
    get = e55
}]]
e661["require/abc/build_menu"] = [[tab = {
    "RAGE",
    "AA",
    "LEGIT",
    "VISUALS",
    "MISC",
    "PLIST",
    "CONFIG",
    "LUA"
}

cont = {
    {
        "Aimbot",
        "Other"
    },
    {
        "Anti-aimbot angles",
        "Fake lag",
        "Other"
    },
    {},
    {
        "Player ESP",
        "Other ESP",
        "Colored models",
        "Effects"
    },
    {},
    {},
    {},
    {
        "A",
        "B",
    }
}

local e48= {
    "global",
    "stand",
    "move",
    "duck",
    "duck+",
    "jump",
    "jump+",
    "walk",
    "fakelag",
    "legit",
}

local e47= require("require/abc/menu_setup")
local e49= require("require/help/color")
local e50= require("require/abc/screen_logger")
local e51= require("require/help/emojis")

local function e52(e53)
    local e54= 'inDGnidgdisgndsin'

    local function e55()
        local e56= database.read(e54)
        return type(e56) == 'table' and e56 or {}
    end

    local function e57(e56)
        database.write(e54, e56)
    end

    local function e58(e56,e59)
        for e60 = 1, #e56 do if e56[e60] == e59 then return e60 end end
        return nil
    end

    local function e61()
        if not (e53 and e53.menu_setup and e53.menu_setup.ui and e53.menu_setup.ui.paint_logger) then
            return false
        end
        local e53, e54= pcall(ui.get, e53.menu_setup.ui.paint_logger)
        if not e53 or not e54 then return false end
        if type(e54) == 'table' then
            for e62, e63 in ipairs(e54) do
                if tostring(e63) == 'config' then return true end
            end
            return false
        else
            return tostring(e54) == 'config'
        end
    end

    local function e64(e65)
        local e66= e55()
        if #e66 == 0 then e66 = {'(empty)'} end
            if e47.ui.cfg_listbox then
                pcall(ui.set_visible, e47.ui.cfg_listbox, false)
            end
            e47.ui.cfg_listbox = e47.register_ui(
                ui.new_listbox(tab[2], cont[2][1], 'Configs', e66),
                { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
            )
        if e65 then
            local e67= e58(e66, e65)
            if e67 then ui.set(e47.ui.cfg_listbox, e67-1) end
        end
    end
 
    
    
    
    e47.ui.cache_credentials = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("pin") .. e49.get("default", "ui") .. 'Cache credentials'),
        { requires_login = false, key = 'cache_credentials', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e47.ui.login_username = e47.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Username', 'username'),
        { requires_login = false, key = 'login_username', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    e47.ui.login_password = e47.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Password', 'password'),
        { requires_login = false, key = 'login_password', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    e47.ui.login_howto_header = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], e49.get("grey", "ui") .. '───────[ ' .. e49.get("white", "ui") .. 'How to ' .. e49.get("green", "ui") .. 'log in' .. e49.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'login_howto_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.login_console_register = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], e49.get("grey", "ui") .. '1. In console -> "register ' .. e49.get("green", "ui") .. 'user' .. e49.get("grey", "ui") .. ' ' .. e49.get("red", "ui") .. 'pass' .. e49.get("grey", "ui") .. ' ' .. e49.get("blue", "ui") .. 'code' .. e49.get("grey", "ui") .. '"'),
        { requires_login = false, key = 'login_console_register', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.login_menu_credentials = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], e49.get("grey", "ui") .. '2. Write password & username in the menu.'),
        { requires_login = false, key = 'login_menu_credentials', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.login_press_login = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], e49.get("grey", "ui") .. '3. Press log in and enjoy ' .. e49.get("green", "ui") .. 'premium features' .. e49.get("grey", "ui") .. '.'),
        { requires_login = false, key = 'login_press_login', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.login_spacer1 = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer1', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.reset_header = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], e49.get("grey", "ui") .. '───────[ ' .. e49.get("white", "ui") .. 'How to ' .. e49.get("yellow", "ui") .. 'reset pass' .. e49.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'reset_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.reset_step1 = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], e49.get("grey", "ui") .. '1. Write username -> press reset.'),
        { requires_login = false, key = 'reset_step1', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.reset_step2 = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], e49.get("grey", "ui") .. '2. Login with your oldest password.'),
        { requires_login = false, key = 'reset_step2', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.login_spacer2 = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer2', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.support_header = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], e49.get("grey", "ui") .. '───────[ ' .. e49.get("red", "ui") .. 'Support & Other' .. e49.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'support_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.support_discord = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], e49.get("grey", "ui") .. '1. Join the ' .. e49.get("discord", "ui") .. 'discord ' .. e49.get("grey", "ui") .. 'for support.'),
        { requires_login = false, key = 'support_discord', tab = 'AA', visible = true, config_type = 'label' }
    )

    e47.ui.login_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("lock_open") .. e49.get("default", "ui") .. 'Login', function()
            local e68= e53.safe.safe_get(e47.ui.login_username)
            local e69= e53.safe.safe_get(e47.ui.login_password)
            local e70= e53.safe.safe_get(e47.ui.cache_credentials)
            if e68 ~= '' and e69 ~= '' then
                local e71= e53.login.login(e68, e69)
                if e71 then
                    e53.pushlog("Welcome back, " .. e53.str.capitalize(e68) .. ". You logged in successfully.", 3, 75, 145, 55, 255)
                    if e70 then
                        database.write('cached_credentials', { username = e68, password = e69 })
                    else
                        database.write('cached_credentials', nil)
                    end
                    local e72,e73,e74= e49.get("green", "log")
                    e53.screenlog("Login successful!", 4, e72, e73, e74, 255)
                else
                    local e72,e73,e74= e49.get("red", "log")
                    e53.screenlog("Login failed!", 4, e72, e73, e74, 255)
                end
            end
                if e53.menu_visibility and e53.menu_visibility.update then
                    e53.menu_visibility.update(e53)
                end
        end),
        { requires_login = false, key = 'login_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    e47.ui.logout_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][3], e49.get("red", "ui") .. e51.get("lock") .. e49.get("default", "ui") .. 'Logout', function()
            e53.login.logout()
            local e72,e73,e74= e49.get("red", "log")
            e53.screenlog("Logged out!", 4, e72, e73, e74, 255)
                if e53.menu_visibility and e53.menu_visibility.update then
                    e53.menu_visibility.update(e53)
                end
        end),
        { requires_login = true, key = 'logout_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e47.ui.reset_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][1], e49.get("yellow", "ui") .. e51.get("warning") .. e49.get("default", "ui") .. 'Reset', function()
            local e68= e53.safe.safe_get(e47.ui.login_username)
            e53.login.reset_password(e68)
            local e72,e73,e74= e49.get("yellow", "log")
            e53.screenlog("Password reset.", 4, e72, e73, e74, 255)
            e53.pushlog("Password reset for user: " .. e68, 5, 255, 255, 0, 255)
                if e53.menu_visibility and e53.menu_visibility.update then
                    e53.menu_visibility.update(e53)
                end
        end),
        { requires_login = true, key = 'reset_button', tab = 'AA', visible = true, config_type = 'button' }
    )

    e47.ui.discord_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][3], e49.get("discord", "ui") .. e51.get("chat") .. e49.get("default", "ui") .. 'Discord', function()
            local e75= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            e53.safe.safe_set(e75, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://discord.gg/a2bFbVWWg9')
        end),
        { requires_login = true, key = 'discord_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    e47.ui.youtube_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][3], e49.get("youtube", "ui") .. e51.get("play") .. e49.get("default", "ui") .. 'YouTube', function()
            local e75= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            e53.safe.safe_set(e75, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://www.youtube.com/@vile-gs/videos')
        end),
        { requires_login = true, key = 'youtube_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    e47.ui.sellhub_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][3], e49.get("sellhub", "ui") .. e51.get("folder") .. e49.get("default", "ui") .. 'Sellhub', function()
            local e75= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            e53.safe.safe_set(e75, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://sodium.sellhub.cx/#products-list')
        end),
        { requires_login = true, key = 'sellhub_button', tab = 'AA', visible = true, config_type = 'button' }
    )


    
    
    
    e47.ui.condition_label = e47.register_ui(
        ui.new_label(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("menu") .. e49.get("default", "ui") .. 'Condition', unpack(e48)),
        { requires_login = true, key = 'condition_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.condition = e47.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nCondition', unpack(e48)),
        { requires_login = true, key = 'condition', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e47.ui.condition_label2 = e47.register_ui(
        ui.new_label(tab[2], cont[2][1], '\ncondition label'),
        { requires_login = true, key = 'condition_label2', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.misc_resolver = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("wrench") .. e49.get("default", "ui") .. 'Resolver'),
        { requires_login = true, key = 'misc_resolver', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e47.ui.misc_ragebot = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("arrow_double") .. e49.get("default", "ui") .. 'Ragebot'),
        { requires_login = true, key = 'misc_ragebot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e47.ui.misc_dormantaimbot = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("time") .. e49.get("default", "ui") .. 'Dormant aimbot'),
        { requires_login = true, key = 'misc_dormantaimbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e47.ui.misc_dormantaimbot_key = e47.register_ui(
        ui.new_hotkey(tab[2], cont[2][1], '\ndormant aimbot key', true),
        { requires_login = true, key = 'misc_dormantaimbot_key', tab = 'MISC', visible = true, config_type = 'hotkey' }
    )
    e47.ui.misc_dormantaimbot_value = e47.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\ndormant aimbot value', 60, 100, 0, true, '%'),
        { requires_login = true, key = 'misc_dormantaimbot_value', tab = 'MISC', visible = true, config_type = 'slider' }
    )
    e47.ui.misc_exploit_fakelag = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("latency3") .. e49.get("default", "ui") .. 'Limit exploit fakelag'),
        { requires_login = true, key = 'misc_exploit_fakelag', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e47.ui.misc_walkbot = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("arrow_up") .. e49.get("default", "ui") .. 'Walkbot'),
        { requires_login = true, key = 'misc_walkbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e47.ui.misc_backstab = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("triangle_upside") .. e49.get("default", "ui") .. 'Backstab Assist'),
        { requires_login = true, key = 'misc_backstab', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e47.ui.misc_spindead = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("turning2") .. e49.get("default", "ui") .. 'Spin on dead enemies'),
        { requires_login = true, key = 'misc_spindead', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e47.ui.aa_gskey_freestandh = e47.register_ui(
        ui.new_label(tab[2], cont[2][3], e49.get("green", "ui") .. e51.get("turning2") .. e49.get("default", "ui") .. 'Freestand'),
        { requires_login = false, key = 'aa_gskey_freestandh', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.aa_gskey_freestand = e47.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'freestand', true),
        { requires_login = true, key = 'aa_gskey_freestand', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    e47.ui.aa_gskey_slowmotionh = e47.register_ui(
        ui.new_label(tab[2], cont[2][3], e49.get("green", "ui") .. e51.get("gear") .. e49.get("default", "ui") .. 'Slowmotion'),
        { requires_login = false, key = 'aa_gskey_slowmotionh', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.aa_gskey_slowmotion = e47.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'slowmotion', true),
        { requires_login = true, key = 'aa_gskey_slowmotion', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    e47.ui.aa_gskey_edgeyawh = e47.register_ui(
        ui.new_label(tab[2], cont[2][3], e49.get("green", "ui") .. e51.get("recycle") .. e49.get("default", "ui") .. 'Edge Yaw'),
        { requires_login = false, key = 'aa_gskey_edgeyawh', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.aa_gskey_edgeyaw = e47.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'edge yaw', true),
        { requires_login = true, key = 'aa_gskey_edgeyaw', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    e47.ui.aa_gskey_onshoth = e47.register_ui(
        ui.new_label(tab[2], cont[2][3], e49.get("green", "ui") .. e51.get("arrow_double") .. e49.get("default", "ui") .. 'On-shot aa'),
        { requires_login = false, key = 'aa_gskey_onshoth', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.aa_gskey_onshot = e47.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'on-shot aa', true),
        { requires_login = true, key = 'aa_gskey_onshot', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    
    for e62, e50 in ipairs(e48) do
        local e51= 'enable_' .. e50
        e47.ui[e51] = e47.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("accept") .. e49.get("default", "ui") .. 'Enable ' .. e50),
            { requires_login = true, key = e51, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        e47.ui['pitch_' .. e50] = e47.register_ui(
            ui.new_combobox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("triangle_upside") .. e49.get("default", "ui") .. 'Pitch', 'off', 'up', 'down', 'minimal', 'ideal'),
            { requires_login = true, key = 'pitch_' .. e50, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e47.ui['yaw_base_' .. e50] = e47.register_ui(
            ui.new_combobox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("recycle") .. e49.get("default", "ui") .. 'Yaw Base', 'target', 'view', 'threat', 'distance', 'smart'),
            { requires_login = true, key = 'yaw_base_' .. e50, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e47.ui['yaw_' .. e50] = e47.register_ui(
            ui.new_combobox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("turning2") .. e49.get("default", "ui") .. 'Yaw', 'off', 'spin', '180', '3way', 'ideal'),
            { requires_login = true, key = 'yaw_' .. e50, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e47.ui['label1_' .. e50] = e47.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label1_' .. e50, tab = 'AA', visible = true, config_type = 'label' }
        )
        e47.ui['body_yaw_base_' .. e50] = e47.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Base', -90, 90, 0, true, '°'),
            { requires_login = true, key = 'body_yaw_base_' .. e50, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e47.ui['body_yaw_left_' .. e50] = e47.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Left', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_left_' .. e50, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e47.ui['body_yaw_right_' .. e50] = e47.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Right', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_right_' .. e50, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e47.ui['randomize_yaw_' .. e50] = e47.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Randomize Yaw', 0, 30, 0, true, '%', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'randomize_yaw_' .. e50, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e47.ui['label2_' .. e50] = e47.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label2_' .. e50, tab = 'AA', visible = true, config_type = 'label' }
        )
        e47.ui['yaw_jitter_' .. e50] = e47.register_ui(
            ui.new_combobox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("turning") .. e49.get("default", "ui") .. 'Yaw Jitter', 'off', 'center', 'skitter'),
            { requires_login = true, key = 'yaw_jitter_' .. e50, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e47.ui['yaw_jitter_base_' .. e50] = e47.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Yaw Jitter - Base', 0, 120, 0, true, '°', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'yaw_jitter_base_' .. e50, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e47.ui['body_yaw_mode_' .. e50] = e47.register_ui(
            ui.new_combobox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("gear") .. e49.get("default", "ui") .. 'Body Yaw Mode', 'off', 'static', 'opposite', 'jitter'),
            { requires_login = true, key = 'body_yaw_mode_' .. e50, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e47.ui['static_body_yaw_' .. e50] = e47.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Static Body Yaw', -58, 58, 0, true, '°'),
            { requires_login = true, key = 'static_body_yaw_' .. e50, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e47.ui['body_yaw_value_' .. e50] = e47.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw Value', 1, 3, 2, true, '', 2, {
                [1] = 'left', [2] = 'back', [3] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_value_' .. e50, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e47.ui['delay_' .. e50] = e47.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Delay', 0, 17, 1, true, 't', 1, {
                [0] = 'jitter'
            }),
            { requires_login = true, key = 'delay_' .. e50, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e47.ui['label3_' .. e50] = e47.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label3_' .. e50, tab = 'AA', visible = true, config_type = 'label' }
        )
        e47.ui['fifty_fifty_' .. e50] = e47.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("question") .. e49.get("default", "ui") .. '50/50'),
            { requires_login = true, key = 'fifty_fifty_' .. e50, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        e47.ui['only_flip_on_0_choke_' .. e50] = e47.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("time") .. e49.get("default", "ui") .. 'Only Flip on 0 Choke'),
            { requires_login = true, key = 'only_flip_on_0_choke_' .. e50, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        e47.ui['aa_label_space' .. e50] = e47.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n abc'),
            { requires_login = true, key = 'aa_label_space', tab = 'AA', visible = true, config_type = 'label' }
        )
        e47.ui['aa_label_combo' .. e50] = e47.register_ui(
            ui.new_label(tab[2], cont[2][1], 'Send state -> state'),
            { requires_login = true, key = 'aa_label_combo', tab = 'AA', visible = true, config_type = 'label' }
        )
        e47.ui['send_combo' .. e50] = e47.register_ui(
            ui.new_combobox(tab[2], cont[2][1], '\n', unpack(e48)),
            { requires_login = true, key = 'send_combo' .. e50, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e47.ui['send_button' .. e50] = e47.register_ui(
            ui.new_button(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("upload") .. e49.get("default", "ui") .. 'Send', function() end),
            { requires_login = true, key = 'send_button', tab = 'AA', visible = true, config_type = 'button' }
        )

    end


    
    
    
    e47.ui.fakelag_mode = e47.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("gear") .. e49.get("default", "ui") .. 'Mode', 'defensive', 'stealer', 'fakelag', 'settings'),
        { requires_login = true, key = 'fakelag_mode', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e47.ui.fakelag_defensive = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("turning2") .. e49.get("default", "ui") .. 'Defensive'),
        { requires_login = true, key = 'fakelag_defensive', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e47.ui.fakelag_force = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("exclamation") .. e49.get("default", "ui") .. 'Force'),
        { requires_login = true, key = 'fakelag_force', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e47.ui.fakelag_fakedef = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("globe") .. e49.get("default", "ui") .. 'Unmatched.gg'),
        { requires_login = true, key = 'fakelag_fakedef', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e47.ui.fakelag_force_on = e47.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("clip") .. e49.get("default", "ui") .. 'Force whilst', 'peek', 'reload', 'shot', 'damaged'),
        { requires_login = true, key = 'fakelag_force_on', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    
    
    
    e47.ui.cfg_load_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("arrow_double") .. e49.get("default", "ui") .. 'Load', function()
            local e66= e55()
            local e67= ui.get(e47.ui.cfg_listbox)
            local e76= e66[(e67 or 0) + 1]
            local e77= ui.get(e47.ui.cfg_input_box)
            local e59= (e76 and e76 ~= '(empty)' and e76 ~= '') and e76 or e77

            if e59 and e59 ~= '' and e59 ~= '(empty)' then
                local e78= require("require/abc/config_system")
                local function e79()
                    if not e47.ui.cfg_selection then return nil end
                    local e53, e80= pcall(ui.get, e47.ui.cfg_selection)
                    if not e53 or not e80 or type(e80) ~= 'table' or #e80 == 0 then return nil end
                    local e81= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local e82= {}
                    for e62, e63 in ipairs(e80) do
                        local e56= e81[tostring(e63)]
                        if e56 then e82[#e82+1] = e56 end
                    end
                    if #e82 == 0 then return nil end
                    return e82
                end
                local e83= e79()
                e78.load(e59, e83)
                e53.screenlog('[Config] Loaded config: ' .. e59, 4, 120, 180, 255, 255)
                if e53 and e53.pushlog and e61() then
                    e53.pushlog('Loaded config: ' .. e59, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for load.')
                if e53 and e53.pushlog and e61() then
                    e53.pushlog('No config name selected for load.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_load_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e47.ui.cfg_save_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("config") .. e49.get("default", "ui") .. 'Save', function()
            local e66= e55()
            local e67= ui.get(e47.ui.cfg_listbox)
            local e76= e66[(e67 or 0) + 1]
            local e77= ui.get(e47.ui.cfg_input_box)
            local e59= (e76 and e76 ~= '(empty)' and e76 ~= '') and e76 or e77

            if e59 and e59 ~= '' then
                local e78= require("require/abc/config_system")
                local function e79()
                    if not e47.ui.cfg_selection then return nil end
                    local e53, e80= pcall(ui.get, e47.ui.cfg_selection)
                    if not e53 or not e80 or type(e80) ~= 'table' or #e80 == 0 then return nil end
                    local e81= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local e82= {}
                    for e62, e63 in ipairs(e80) do
                        local e56= e81[tostring(e63)]
                        if e56 then e82[#e82+1] = e56 end
                    end
                    if #e82 == 0 then return nil end
                    return e82
                end
                local e83= e79()
                e78.save(e59, e83)
                local e66= e55()
                if not e58(e66, e59) then
                    e66[#e66+1] = e59
                    e57(e66)
                end
                e64(e59)
                e53.screenlog('[Config] Saved config: ' .. e59, 4, 120, 180, 255, 255)
                if e53 and e53.pushlog and e61() then
                    e53.pushlog('Saved config: ' .. e59, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name provided for save.')
                if e53 and e53.pushlog and e61() then
                    e53.pushlog('No config name provided for save.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_save_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e47.ui.cfg_create_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("plus") .. e49.get("default", "ui") .. 'Create', function()
            local e77= ui.get(e47.ui.cfg_input_box)
            if not e77 or e77 == '' then
                client.error_log('[Config] No config name provided for create.')
                if e53 and e53.pushlog and e61() then
                    e53.pushlog('No config name provided for create.', 4, 255, 255, 255, 255)
                end
                return
            end

            local e66= e55()
            if e58(e66, e77) then
                client.error_log('[Config] Config with that name already exists: ' .. e77)
                if e53 and e53.pushlog and e61() then
                    e53.pushlog('Config already exists: ' .. e77, 4, 255, 255, 255, 255)
                end
                return
            end

            local e78= require("require/abc/config_system")
            local function e79()
                if not e47.ui.cfg_selection then return nil end
                local e53, e80= pcall(ui.get, e47.ui.cfg_selection)
                if not e53 or not e80 or type(e80) ~= 'table' or #e80 == 0 then return nil end
                local e81= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local e82= {}
                for e62, e63 in ipairs(e80) do
                    local e56= e81[tostring(e63)]
                    if e56 then e82[#e82+1] = e56 end
                end
                if #e82 == 0 then return nil end
                return e82
            end
            local e83= e79()
            e78.save(e77, e83)
            e66[#e66+1] = e77
            e57(e66)
            e64(e77)
            e53.screenlog('[Config] Created config: ' .. e77, 4, 120, 180, 255, 255)
            if e53 and e53.pushlog and e61() then
                e53.pushlog('Created config: ' .. e77, 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_create_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e47.ui.cfg_delete_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][1], e49.get("red", "ui") .. e51.get("trash") .. e49.get("default", "ui") .. 'Delete', function()
            local e66= e55()
            local e67= ui.get(e47.ui.cfg_listbox)
            local e76= e66[(e67 or 0) + 1]
            local e77= ui.get(e47.ui.cfg_input_box)
            local e59= (e76 and e76 ~= '(empty)' and e76 ~= '') and e76 or e77

            if e59 and e59 ~= '' and e59 ~= '(empty)' then
                local e78= require("require/abc/config_system")
                e78.delete(e59)
                local e66= e55()
                local e67= e58(e66, e59)
                if e67 then
                    table.remove(e66, e67)
                    e57(e66)
                end
                e64()
                e53.screenlog('[Config] Deleted config: ' .. e59, 4, 255, 80, 80, 255)
                if e53 and e53.pushlog and e61() then
                    e53.pushlog('Deleted config: ' .. e59, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for delete.')
                if e53 and e53.pushlog and e61() then
                    e53.pushlog('No config name selected for delete.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_delete_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e47.ui.cfg_refresh_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("turning") .. e49.get("default", "ui") ..'Refresh', function()
            e64()
            e53.screenlog('[Config] Refreshed config list.', 4, 120, 180, 255, 255)
            if e53 and e53.pushlog and e61() then
                e53.pushlog('Refreshed config list.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_refresh_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    
    local e78= require("require/abc/config_system")
    local e84, e85= pcall(require, 'gamesense/clipboard')
    local e86= e85
    if not e84 or not e86 then
        e86 = {
            set = function(e62) end,
            get = function() return '' end,
        }
    end


    e47.ui.cfg_export_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("upload") .. e49.get("default", "ui") .. 'Export', function()
            local function e79()
                if not e47.ui.cfg_selection then return nil end
                local e53, e80= pcall(ui.get, e47.ui.cfg_selection)
                if not e53 or not e80 or type(e80) ~= 'table' or #e80 == 0 then return nil end
                local e81= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local e82= {}
                for e62, e63 in ipairs(e80) do
                    local e56= e81[tostring(e63)]
                    if e56 then e82[#e82+1] = e56 end
                end
                if #e82 == 0 then return nil end
                return e82
            end
            local e83= e79()
            local e87= e78.build(e83)
            e86.set(e87)
            client.log('[Config] Exported config string:')
            client.log(e87)
            e53.screenlog('[Config] Exported config string to clipboard and console.', 4, 120, 180, 255, 255)
            if e53 and e53.pushlog and e61() then
                e53.pushlog('Exported config string to clipboard.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_export_button', tab = 'CFG', visible = true, config_type = 'button' }
    )

    e47.ui.cfg_import_button = e47.register_ui(
        ui.new_button(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("download") .. e49.get("default", "ui") .. 'Import', function()
            local e88= e86.get()
            if e88 and e88 ~= '' then
                local function e79()
                    if not e47.ui.cfg_selection then return nil end
                    local e53, e80= pcall(ui.get, e47.ui.cfg_selection)
                    if not e53 or not e80 or type(e80) ~= 'table' or #e80 == 0 then return nil end
                    local e81= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local e82= {}
                    for e62, e63 in ipairs(e80) do
                        local e56= e81[tostring(e63)]
                        if e56 then e82[#e82+1] = e56 end
                    end
                    if #e82 == 0 then return nil end
                    return e82
                end
                local e83= e79()
                e78.apply(e88, e83)
                e53.screenlog('[Config] Imported config string from clipboard.', 4, 120, 180, 255, 255)
                if e53 and e53.pushlog and e61() then
                    e53.pushlog('Imported config string from clipboard.', 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config string found in clipboard.')
                if e53 and e53.pushlog and e61() then
                    e53.pushlog('No config string found in clipboard for import.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_import_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e47.ui.cfg_selection = e47.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\n selection', 'antiaim', 'paint', 'misc'),
        { requires_login = true, key = 'cfg_selection', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    e47.ui.cfg_input_box = e47.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Config name'),
        { requires_login = true, key = 'cfg_input_box', tab = 'CFG', visible = true, config_type = 'textbox' }
    )
    e47.ui.cfg_listbox = e47.register_ui(
        ui.new_listbox(tab[2], cont[2][1], 'Configs', {}),
        { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    e64()

    e47.ui.cfg_cloud_apply = e47.register_ui(
        ui.new_button(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("globe") .. e49.get("default", "ui") .. ' Apply cloud', function()
            local e53, e80= pcall(ui.get, e47.ui.cfg_cloud)
            if not e53 then
                client.log('cfg_cloud_apply: failed to read selection')
                return
            end

            local e89= { 'Reset', 'Defensive', 'Unmatched', 'Community' }
            local e59= nil

            if type(e80) == 'number' then
                local e67= e80 + 1
                e59 = e89[e67]
            elseif type(e80) == 'table' then
                if #e80 > 0 and type(e80[1]) == 'number' then
                    e59 = e89[e80[1] + 1]
                else
                    e59 = tostring(e80[1])
                end
            else
                e59 = tostring(e80)
            end

            if not e59 or e59 == '' then
                client.log('cfg_cloud_apply: no selection')
                return
            end

            local e90, e91= pcall(require, 'require/abc/config_cloud')
            if not e90 or not e91 then
                client.log('cfg_cloud_apply: failed to load config_cloud module')
                return
            end

            local e92= e91[e59]
            if not e92 then
                client.log('cfg_cloud_apply: no cloud config string for', tostring(e59))
                return
            end

            local e93, e78= pcall(require, 'require/abc/config_system')
            if not e93 or not e78 or not e78.apply then
                client.log('cfg_cloud_apply: config_system.apply not available')
                return
            end

            e78.apply(e92)
            client.log('cfg_cloud_apply: applied cloud config', tostring(e59))
        end),
        { requires_login = true, key = 'cfg_cloud_apply', tab = 'AA', visible = true, config_type = 'button' }
    )

    e47.ui.cfg_cloud = e47.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'Cloud', { e49.get("red", "ui") .. 'Reset', e49.get("reddark", "ui") .. 'Defensive', e49.get("yellow", "ui") .. 'Unmatched', e49.get("grey", "ui") .. 'Community'}),
        { requires_login = true, key = 'cfg_cloud', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    e47.ui.fakelag_stealer = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("download") .. e49.get("default", "ui") .. 'Stealer' .. e49.get("blue", "ui") .. ' [BETA]' ),
        { requires_login = true, key = 'fakelag_stealer', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e47.ui.fakelag_stealer_type = e47.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("gear") .. e49.get("default", "ui") .. 'Type', 'mimic', 'import'),
        { requires_login = true, key = 'fakelag_stealer_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e47.ui.fakelag_stealer_target = e47.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("id") .. e49.get("default", "ui") .. 'Target', 'threat', 'closest', 'random', 'best kdas'),
        { requires_login = true, key = 'fakelag_stealer_target', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e47.ui.fakelag_stealer_list = e47.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'target list', {'-'}),
        { requires_login = true, key = 'fakelag_stealer_list', tab = 'AA', visible = true, config_type = 'listbox' }
    )
    e47.ui.fakelag_stealer_refresh = e47.register_ui(
        ui.new_button(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("refresh") .. e49.get("default", "ui") .. 'Refresh', function() end),
        { requires_login = true, key = 'fakelag_stealer_refresh', tab = 'AA', visible = true, config_type = 'button' }
    )
    e47.ui.fakelag_stealer_steal = e47.register_ui(
        ui.new_button(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("clip") .. e49.get("default", "ui") .. 'Steal', function() end),
        { requires_login = true, key = 'fakelag_stealer_steal', tab = 'AA', visible = true, config_type = 'button' }
    )
    e47.ui.fakelag_fakelag = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("latency3") .. e49.get("default", "ui") .. 'Fakelag'),
        { requires_login = true, key = 'fakelag_fakelag', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e47.ui.fakelag_fakelag_type = e47.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("gear") .. e49.get("default", "ui") .. 'Type', 'gamesense', 'sodium'),
        { requires_login = true, key = 'fakelag_fakelag_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e47.ui.fakelag_fakelag_amount = e47.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("plus") .. e49.get("default", "ui") .. 'Amount', 'dynamic', 'maximum', 'fluctuate'),
        { requires_login = true, key = 'fakelag_fakelag_amount', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e47.ui.fakelag_fakelag_variance = e47.register_ui(
        ui.new_slider(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("recycle") .. e49.get("default", "ui") .. 'Variance', 0, 100, 0, true, '%'),
        { requires_login = true, key = 'fakelag_fakelag_variance', tab = 'AA', visible = true, config_type = 'slider' }
    )
    e47.ui.fakelag_fakelag_limit = e47.register_ui(
        ui.new_slider(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("lock") .. e49.get("default", "ui") .. 'Limit', 1, 15, 1, true, 't'),
        { requires_login = true, key = 'fakelag_fakelag_limit', tab = 'AA', visible = true, config_type = 'slider' }
    )
    e47.ui.fakelag_fakelag_type2 = e47.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("config") .. e49.get("default", "ui") .. 'Preset', 'jitter', 'max'),
        { requires_login = true, key = 'fakelag_fakelag_type2', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e47.ui.fakelag_settings_freestanding = e47.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("turning2") .. e49.get("default", "ui") .. 'Freestanding options', 'static', 'zero pitch', 'defensive', 'side flip', 'pitch flip'),
        { requires_login = true, key = 'fakelag_settings_freestanding', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    e47.ui.fakelag_settings_enhance_onshot = e47.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("arrow_double") .. e49.get("default", "ui") .. 'Enhance on-shot aa', 'defensive', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_enhance_onshot', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    e47.ui.fakelag_settings_antibrute = e47.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("exclamation") .. e49.get("default", "ui") .. 'Antibrute', 'defensive', 'flip', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_antibrute', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    e47.ui.fakelag_settings_roll_checkbox = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], '\nuse roll'),
        { requires_login = true, key = 'fakelag_settings_roll_checkbox', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e47.ui.fakelag_settings_roll_label = e47.register_ui(
        ui.new_label(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("recycle") .. e49.get("default", "ui") .. 'Roll'),
        { requires_login = false, key = 'label_roll', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.fakelag_settings_roll = e47.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nroll', 0, 45, 0, true, '°'),
        { requires_login = true, key = 'fakelag_settings_roll', tab = 'AA', visible = true, config_type = 'slider' }
    )
    e47.ui.fakelag_settings_side = e47.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nside', 1, 3, 1, true, '', 1, {
            [1] = 'left', [2] = 'swap', [3] = 'right'
        }),
        { requires_login = true, key = 'fakelag_settings_side', tab = 'AA', visible = true, config_type = 'slider' }
    )

    
    
    
    e47.ui.paint_advertisement = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nadvertisement', true),
        { requires_login = true, key = 'paint_advertisement', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_advertisement_animation = e47.register_ui(
        ui.new_slider(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("speaker") .. e49.get("default", "ui") .. 'Advertisement', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_advertisement_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    e47.ui.paint_advertisement_color = e47.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'rizz546456', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_advertisement_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e47.ui.paint_watermark = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nwatermark'),
        { requires_login = true, key = 'paint_watermark', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_watermark_type = e47.register_ui(
        ui.new_slider(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("text") .. e49.get("default", "ui") .. 'Watermark', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_watermark_type', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    e47.ui.paint_watermark_color = e47.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'sigma9745', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_watermark_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e47.ui.label_space2 = e47.register_ui(
        ui.new_label(tab[2], cont[2][1], '\n abc'),
        { requires_login = false, key = 'label_space2', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.label_space3 = e47.register_ui(
        ui.new_label(tab[2], cont[2][1], e49.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space3', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.paint_entidx = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'entidx'),
        { requires_login = true, key = 'paint_entidx', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_target_info = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'target info'),
        { requires_login = true, key = 'paint_target_info', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_filter_console = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'filter console'),
        { requires_login = true, key = 'paint_filter_console', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_minimum_damage = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'minimum damage'),
        { requires_login = true, key = 'paint_minimum_damage', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_show_damage_penetration = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'show damage penetration'),
        { requires_login = true, key = 'paint_show_damage_penetration', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_hitmiss_indicator = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'hit/miss indicator'),
        { requires_login = true, key = 'paint_hitmiss_indicator', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_self_skeleton = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'self skeleton'),
        { requires_login = true, key = 'paint_self_skeleton', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_bullet_tracer = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'bullet tracer'),
        { requires_login = true, key = 'paint_bullet_tracer', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_lagcomp_box = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lagcomp box'),
        { requires_login = true, key = 'paint_lagcomp_box', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_lagcomp_box_color = e47.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'lagcomp box color', 47, 117, 221, 255),
        { requires_login = true, key = 'paint_lagcomp_box_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e47.ui.paint_presmoke = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'presmoke warning'),
        { requires_login = true, key = 'paint_presmoke', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_bombwarning = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'c4 warning'),
        { requires_login = true, key = 'paint_bombwarning', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_insults = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'insults'),
        { requires_login = true, key = 'paint_insults', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_rainbow_esp = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'rainbow esp'),
        { requires_login = true, key = 'paint_rainbow_esp', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_molotov = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'molotov particles'),
        { requires_login = true, key = 'paint_molotov', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_lag_record = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lag record'),
        { requires_login = true, key = 'paint_lag_record', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.label_space4 = e47.register_ui(
        ui.new_label(tab[2], cont[2][1], e49.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space4', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.paint_clantag = e47.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("id") .. e49.get("default", "ui") .. 'Clantag', 'off', 'gamesense', 'sodium'),
        { requires_login = true, key = 'paint_clantag', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    e47.ui.paint_aimbot_logs = e47.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("clipboard") .. e49.get("default", "ui") .. 'Aimbot logs', 'off', 'gamesense', 'gamesense beta', 'sodium'),
        { requires_login = true, key = 'paint_aimbot_logs', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    e47.ui.label_space1 = e47.register_ui(
        ui.new_label(tab[2], cont[2][1], '\nextra space'),
        { requires_login = false, key = 'label_space1', tab = 'AA', visible = true, config_type = 'label' }
    )
    
    e47.ui.paint_indicators_enable = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n enable'),
        { requires_login = true, key = 'paint_indicators_enable', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_indicators_label = e47.register_ui(
        ui.new_label(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("pallete") .. e49.get("default", "ui") .. 'Indicators'),
        { requires_login = false, key = 'paint_indicators_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.paint_indicators = e47.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nIndicators', 'off', 'small', 'bold'),
        { requires_login = true, key = 'paint_indicators', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    e47.ui.paint_indicator_color = e47.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_indicator_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e47.ui.paint_indicators_bar = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n bar'),
        { requires_login = true, key = 'paint_indicators_bar', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_indicators_animation = e47.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_indicators_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    e47.ui.paint_logger_checkbox = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n abc'),
        { requires_login = true, key = 'paint_logger_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_logger_label = e47.register_ui(
        ui.new_label(tab[2], cont[2][1], e49.get("green", "ui") .. e51.get("pen") .. e49.get("default", "ui") .. 'Logger'),
        { requires_login = false, key = 'paint_logger_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    e47.ui.paint_logger = e47.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\nLogger', 'aimbot', 'config', 'anti-aim', 'other'),
        { requires_login = true, key = 'paint_logger', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    e47.ui.paint_logger_color = e47.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_logger_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e47.ui.paint_logger_animation = e47.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_logger_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    e47.ui.paint_hitmarker = e47.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("reject") .. e49.get("default", "ui") .. 'Hitmarkers', 'world +', 'skeleton', 'damage'),
        { requires_login = true, key = 'paint_hitmarker', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    e47.ui.paint_hitmarker_color = e47.register_ui(
        ui.new_color_picker(tab[2], cont[2][2], '\n + color', 0, 225, 225, 255),
        { requires_login = true, key = 'paint_hitmarker_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e47.ui.paint_warnings = e47.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("warning") .. e49.get("default", "ui") .. 'Warnings', 'lethal', 'cant fire', 'low bullets'),
        { requires_login = true, key = 'paint_warnings', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    e47.ui.paint_performance_mode = e47.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("latency4") .. e49.get("default", "ui") .. 'Performance mode', 'blood', 'ragdolls', 'particles', 'lens flare', 'animations', 'feature updates'),
        { requires_login = true, key = 'paint_performance_mode', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    e47.ui.paint_animations = e47.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e49.get("green", "ui") .. e51.get("turning2") .. e49.get("default", "ui") .. 'Animations', 'kingaru', 'body lean', 'gamesense legs', 'moonwalk', 'allah', 'static legs', 'no pitch on land', 'reversed legs', 'earthquake', 't-pose', 'blind', 'pitch up'),
        { requires_login = true, key = 'paint_animations', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    e47.ui.paint_aspect_ratio_checkbox = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], e49.get("green", "ui") .. e51.get("expand") .. e49.get("default", "ui") .. 'Aspect ratio'),
        { requires_login = true, key = 'paint_aspect_ratio_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_aspect_ratio = e47.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\naspect ratio', 0, 300, 0, true, '', 0.01, {
            [0] = 'default', [125] = '5:4', [133] = '4:3', [150] = '3:2', [160] = '16:10', [177] = '16:9'
        }),
        { requires_login = true, key = 'paint_aspect_ratio', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    e47.ui.paint_third_person_distance_checkbox = e47.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], e49.get("green", "ui") .. e51.get("camera") .. e49.get("default", "ui") .. 'Third person distance'),
        { requires_login = true, key = 'paint_third_person_distance_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e47.ui.paint_third_person_distance = e47.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\nthird person distance', 30, 166, 150, true, '', 1, {
            [150] = 'default'
        }),
        { requires_login = true, key = 'paint_third_person_distance', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    
    
    
    
    local e94= {
        checkbox = 'c',
        slider = 's',
        combobox = 'o',
        multiselect = 'm',
    }
    for e95, e52 in pairs(e47.ui) do
        for e62, e96 in ipairs(e47.registered_items or {}) do
            if e96.key == e95 and e96.config_type and e94[e96.config_type] then
                e78.register(e95, e52, e94[e96.config_type], e96.tab)
            end
        end
    end
end

return e52]]
e661["require/abc/callbacks"] = [[




local e51= {}

local e52= 1
local e53= {}          
local e54= {}      
local e55= {}   

local function e56()
	local e53, e57= pcall(require, "require/abc/login_system")
	if not e53 or not e57 then return false end
	return e57.logged_in == true
end

local function e58(e59)
	if not e59 then return true end
	if e59.menu_only and not (ui and ui.is_menu_open and ui.is_menu_open()) then return false end
	if e59.alive_only then
		local e56= (entity and entity.get_local_player) and entity.get_local_player()
		if not e56 or not entity.is_alive(e56) then return false end
	end
	if e59.require_login then
		if not e56() then return false end
	end
	return true
end

local function e60(e61)
	return function(e62)
		local e63= e54[e61]
		if not e63 then return end
		local e64= {}
		for e60=1,#e63 do e64[e60] = e63[e60] end
		for e60=1,#e64 do
			local e65= e64[e60]
			local e66= e53[e65]
			if e66 and e66.wrapper then
				local e53, e669= pcall(e66.wrapper, e62)
				if not e53 then
					local e67= nil
					pcall(function()
						e67 = debug.getinfo(e66.user_fn, "Sln")
					end)
					local e68= e67 and e67.short_src or "<unknown>"
					local e69= e67 and (e67.linedefined or -1) or -1
					pcall(client.error_log, string.format("callback[%d] error: %s (source=%s:%d)", e65, tostring(e669), e68, e69))
				end
			end
		end
	end
end



function e51.register(e61,e668,e70,e74,e71)
	if type(e61) ~= 'string' then error('event must be a string') end
	if type(e668) ~= 'function' then error('callback must be a function') end

	local e59= nil
	if type(e70) == 'table' then e59 = e70
	else
		e59 = { menu_only = (e70 == true), alive_only = (e74 == true), require_login = (e71 == true) }
	end

	local e65= e52; e52 = e52 + 1
	local e72= function(e62)
		if e58(e59) then
			return e668(e62)
		end
	end

	e53[e65] = { event = e61, wrapper = e72, user_fn = e668, opts = e59 }
	e54[e61] = e54[e61] or {}
	e54[e61][#e54[e61] + 1] = e65

	
	if not e55[e61] then
		local e73= e60(e61)
		e55[e61] = e73
		pcall(client.set_event_callback, e61, e73)
	end

	return e65
end

function e51.callback(e61,e70,e74,e71,e74)
	if type(e70) == 'function' then
		return e51.register(e61, e70, e74)
	end
	if type(e74) == 'function' then
		local e668= e74
		local e59= { menu_only = (e70 == true), alive_only = (e74 == true), require_login = (e71 == true) }
		return e51.register(e61, e668, e59)
	end
	error('invalid callback signature')
end

function e51.unregister(e65)
	local e66= e53[e65]
	if not e66 then return false end
	local e61= e66.event
	e53[e65] = nil
	local e75= e54[e61]
	if e75 then
		for e60=#e75,1,-1 do if e75[e60] == e65 then table.remove(e75, e60) end end
		if #e75 == 0 then
			e54[e61] = nil
			local e73= e55[e61]
			if e73 then pcall(client.unset_event_callback, e61, e73) end
			e55[e61] = nil
		end
	end
	return true
end

function e51.clear_all()
	for e61, e73 in pairs(e55) do
		pcall(client.unset_event_callback, e61, e73)
	end
	e53 = {}
	e54 = {}
	e55 = {}
end

function e51._list()
	return { regs = e53, by_event = e54 }
end

pcall(function()
	if lua and lua.defer then
		lua.defer(e51.clear_all)
	else
		pcall(client.set_event_callback, 'shutdown', e51.clear_all)
	end
end)

return e51
]]
e661["require/abc/config_cloud"] = [[local e54= {
    Reset = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfbW92ZXx0PW98dj1vZmYKeWF3X2Zha2VsYWd8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wK3x0PXN8dj0wCmZha2VsYWdfc2V0dGluZ3Nfc2lkZXx0PXN8dj0xCnBpdGNoX21vdmV8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbW92ZXx0PXN8dj0wCmZha2VsYWdfZm9yY2Vfb258dD1tfHY9CmZha2VsYWdfZGVmZW5zaXZlfHQ9Y3x2PWZhbHNlCnlhd193YWxrfHQ9b3x2PW9mZgpzdGF0aWNfYm9keV95YXdfZmFrZWxhZ3x0PXN8dj0wCnBpdGNoX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfanVtcHx0PXN8dj0yCmJvZHlfeWF3X21vZGVfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXArfHQ9c3x2PTIKeWF3X2ppdHRlcl9iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfYmFzZV9kdWNrK3x0PW98dj10YXJnZXQKb25seV9mbGlwX29uXzBfY2hva2VfZHVjayt8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PWZhbHNlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9MApib2R5X3lhd19sZWZ0X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19zdGFuZHx0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19nbG9iYWx8dD1zfHY9MApwaXRjaF9kdWNrfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PW9mZgp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRhcmdldApmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wfHQ9c3x2PTAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PQpzZW5kX2NvbWJvanVtcHx0PW98dj1nbG9iYWwKc2VuZF9jb21ib2p1bXArfHQ9b3x2PWdsb2JhbApvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj1mYWxzZQpzdGF0aWNfYm9keV95YXdfbW92ZXx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVjayt8dD1zfHY9MAp5YXdfYmFzZV9nbG9iYWx8dD1vfHY9dGFyZ2V0CmVuYWJsZV9sZWdpdHx0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PQpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9kdWNrK3x0PXN8dj0yCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfdmFsdWVfbGVnaXR8dD1zfHY9Mgpib2R5X3lhd19iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfanVtcCt8dD1vfHY9b2ZmCmRlbGF5X3dhbGt8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdHlwZTJ8dD1vfHY9aml0dGVyCnlhd19sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9zdGFuZHx0PXN8dj0wCmVuYWJsZV9qdW1wK3x0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZmFrZWxhZ3x0PW98dj1nbG9iYWwKeWF3X2ppdHRlcl9iYXNlX2R1Y2t8dD1zfHY9MApmaWZ0eV9maWZ0eV9qdW1wfHQ9Y3x2PWZhbHNlCnBpdGNoX2xlZ2l0fHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfc3RhbmR8dD1zfHY9MAp5YXdfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfanVtcHx0PW98dj1vZmYKYm9keV95YXdfcmlnaHRfZHVja3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVjayt8dD1zfHY9MApib2R5X3lhd19tb2RlX3dhbGt8dD1vfHY9b2ZmCmJvZHlfeWF3X3JpZ2h0X2p1bXArfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10YXJnZXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj1mYWxzZQp5YXdfanVtcHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV93YWxrfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19nbG9iYWx8dD1zfHY9MApmaWZ0eV9maWZ0eV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfbW92ZXx0PW98dj1vZmYKeWF3X2Jhc2VfanVtcCt8dD1vfHY9dGFyZ2V0CnBpdGNoX2R1Y2srfHQ9b3x2PW1pbmltYWwKYm9keV95YXdfbW9kZV9qdW1wK3x0PW98dj1vZmYKc2VuZF9jb21ib2R1Y2t8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfZmFrZWxhZ3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVja3x0PW98dj1vZmYKZmFrZWxhZ19zdGVhbGVyX3RhcmdldHx0PW98dj10aHJlYXQKZmlmdHlfZmlmdHlfZHVjayt8dD1jfHY9ZmFsc2UKb25seV9mbGlwX29uXzBfY2hva2VfanVtcHx0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTAKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0wCmRlbGF5X2R1Y2srfHQ9c3x2PTEKYm9keV95YXdfbW9kZV9sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfZHVja3x0PXN8dj0yCmVuYWJsZV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PW9mZgp5YXdfYmFzZV9zdGFuZHx0PW98dj10YXJnZXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PW9mZgp5YXdfaml0dGVyX3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2xlZ2l0fHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19iYXNlX2xlZ2l0fHQ9b3x2PXRhcmdldApzdGF0aWNfYm9keV95YXdfd2Fsa3x0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X2Zha2VsYWd8dD1zfHY9MApkZWxheV9kdWNrfHQ9c3x2PTEKZmFrZWxhZ19zZXR0aW5nc19yb2xsfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2xpbWl0fHQ9c3x2PTEKZmFrZWxhZ19mYWtlbGFnX3ZhcmlhbmNlfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2Ftb3VudHx0PW98dj1keW5hbWljCmZha2VsYWdfZmFrZWxhZ190eXBlfHQ9b3x2PWdhbWVzZW5zZQpyYW5kb21pemVfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9nbG9iYWx8dD1zfHY9MApyYW5kb21pemVfeWF3X3dhbGt8dD1zfHY9MApjZmdfc2VsZWN0aW9ufHQ9bXx2PWFudGlhaW0KYm9keV95YXdfdmFsdWVfbW92ZXx0PXN8dj0yCmZpZnR5X2ZpZnR5X21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfbW92ZXx0PWN8dj1mYWxzZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ3x0PWN8dj1mYWxzZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfd2Fsa3x0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9zdGFuZHx0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZHVjayt8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnlhd19qaXR0ZXJfanVtcCt8dD1vfHY9b2ZmCnlhd19iYXNlX2p1bXB8dD1vfHY9dGFyZ2V0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKcGl0Y2hfanVtcCt8dD1vfHY9b2ZmCnlhd19kdWNrfHQ9b3x2PW9mZgpkZWxheV9qdW1wK3x0PXN8dj0xCmRlbGF5X3N0YW5kfHQ9c3x2PTEKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj0wCmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVja3x0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10YXJnZXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9MApib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgpib2R5X3lhd19sZWZ0X2dsb2JhbHx0PXN8dj0wCmRlbGF5X21vdmV8dD1zfHY9MQpkZWxheV9qdW1wfHQ9c3x2PTEKZW5hYmxlX2p1bXB8dD1jfHY9ZmFsc2UKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PTAKYm9keV95YXdfbGVmdF9qdW1wK3x0PXN8dj0wCnlhd19tb3ZlfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PWZhbHNlCmZha2VsYWdfZmFrZWRlZnx0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX2dsb2JhbHx0PW98dj1vZmYKZmlmdHlfZmlmdHlfanVtcCt8dD1jfHY9ZmFsc2UKY29uZGl0aW9ufHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X21vdmV8dD1zfHY9MApkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PWZhbHNl0000',
    Defensive = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9dHJ1ZQp5YXdfd2Fsa3x0PW98dj0xODAKc3RhdGljX2JvZHlfeWF3X2Zha2VsYWd8dD1zfHY9MApwaXRjaF9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXB8dD1zfHY9Mgpib2R5X3lhd19tb2RlX3N0YW5kfHQ9b3x2PWppdHRlcgpib2R5X3lhd192YWx1ZV9qdW1wK3x0PXN8dj0yCnlhd19qaXR0ZXJfYmFzZV9mYWtlbGFnfHQ9c3x2PTAKeWF3X2Jhc2VfZHVjayt8dD1vfHY9dGhyZWF0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2srfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PXRydWUKZGVsYXlfbGVnaXR8dD1zfHY9MQp5YXdfc3RhbmR8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVja3x0PXN8dj0wCmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKcGl0Y2hfZHVja3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfZHVjayt8dD1vfHY9aml0dGVyCnlhd19iYXNlX21vdmV8dD1vfHY9dGhyZWF0CmZha2VsYWdfbW9kZXx0PW98dj1zZXR0aW5ncwpwaXRjaF93YWxrfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9iYXNlX2p1bXB8dD1zfHY9MTIwCnNlbmRfY29tYm93YWxrfHQ9b3x2PWdsb2JhbApmYWtlbGFnX3NldHRpbmdzX2ZyZWVzdGFuZGluZ3x0PW18dj1zdGF0aWMJemVybyBwaXRjaAlkZWZlbnNpdmUJc2lkZSBmbGlwCnNlbmRfY29tYm9qdW1wfHQ9b3x2PWdsb2JhbApzZW5kX2NvbWJvanVtcCt8dD1vfHY9Z2xvYmFsCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXArfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9dHJ1ZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PWRlZmVuc2l2ZQlyb2xsCWppdHRlcgpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9MgpzZW5kX2NvbWJvbGVnaXR8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfbGVnaXR8dD1zfHY9LTU4Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTQKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9MApyYW5kb21pemVfeWF3X2R1Y2srfHQ9c3x2PTAKYm9keV95YXdfbW9kZV93YWxrfHQ9b3x2PXN0YXRpYwpib2R5X3lhd19yaWdodF9qdW1wK3x0PXN8dj0zNwpvbmx5X2ZsaXBfb25fMF9jaG9rZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmZha2VsYWdfc2V0dGluZ3NfYW50aWJydXRlfHQ9bXx2PQp5YXdfYmFzZV93YWxrfHQ9b3x2PXRocmVhdApmYWtlbGFnX3N0ZWFsZXJ8dD1jfHY9ZmFsc2UKZW5hYmxlX3N0YW5kfHQ9Y3x2PXRydWUKeWF3X2p1bXB8dD1vfHY9MTgwCmJvZHlfeWF3X2Jhc2Vfd2Fsa3x0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19zdGFuZHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZ2xvYmFsfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZHVja3x0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX21vdmV8dD1vfHY9aml0dGVyCnlhd19iYXNlX2p1bXArfHQ9b3x2PXRocmVhdApwaXRjaF9kdWNrK3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2p1bXB8dD1zfHY9MTgKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0tMwpkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjcKc2VuZF9jb21ib21vdmV8dD1vfHY9Z2xvYmFsCnJhbmRvbWl6ZV95YXdfbW92ZXx0PXN8dj0wCnBpdGNoX2p1bXB8dD1vfHY9ZG93bgp5YXdfYmFzZV9zdGFuZHx0PW98dj10aHJlYXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9zdGFuZHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2dsb2JhbHx0PWN8dj1mYWxzZQp5YXdfYmFzZV9sZWdpdHx0PW98dj10aHJlYXQKc3RhdGljX2JvZHlfeWF3X3dhbGt8dD1zfHY9MApib2R5X3lhd19yaWdodF9mYWtlbGFnfHQ9c3x2PTAKZGVsYXlfZHVja3x0PXN8dj01CmZha2VsYWdfc2V0dGluZ3Nfcm9sbHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19saW1pdHx0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ192YXJpYW5jZXx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19hbW91bnR8dD1vfHY9ZHluYW1pYwpmYWtlbGFnX2Zha2VsYWdfdHlwZXx0PW98dj1zb2RpdW0KcmFuZG9taXplX3lhd19qdW1wfHQ9c3x2PTAKeWF3X2ppdHRlcl9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKcmFuZG9taXplX3lhd193YWxrfHQ9c3x2PTAKY2ZnX3NlbGVjdGlvbnx0PW18dj1hbnRpYWltCmJvZHlfeWF3X3ZhbHVlX21vdmV8dD1zfHY9MgpmaWZ0eV9maWZ0eV9tb3ZlfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfYmFzZV9kdWNrK3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX21vdmV8dD1jfHY9dHJ1ZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0yNApmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV93YWxrfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCnNlbmRfY29tYm9kdWNrK3x0PW98dj1nbG9iYWwKYm9keV95YXdfcmlnaHRfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9qdW1wK3x0PW98dj1vZmYKeWF3X2Jhc2VfanVtcHx0PW98dj10aHJlYXQKb25seV9mbGlwX29uXzBfY2hva2VfbGVnaXR8dD1jfHY9dHJ1ZQpib2R5X3lhd19tb2RlX2R1Y2t8dD1vfHY9c3RhdGljCnN0YXRpY19ib2R5X3lhd19sZWdpdHx0PXN8dj0wCnBpdGNoX2p1bXArfHQ9b3x2PWRvd24KeWF3X2R1Y2t8dD1vfHY9MTgwCmRlbGF5X2p1bXArfHQ9c3x2PTMKZGVsYXlfc3RhbmR8dD1zfHY9NApmYWtlbGFnX2ZvcmNlfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X3JpZ2h0X2R1Y2srfHQ9c3x2PTQ0CmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0tMTUKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTE0Cnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9NTgKYm9keV95YXdfdmFsdWVfZ2xvYmFsfHQ9c3x2PTIKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApkZWxheV9tb3ZlfHQ9c3x2PTEKZGVsYXlfanVtcHx0PXN8dj0xCmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTQKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PS0xNgpib2R5X3lhd19sZWZ0X2p1bXArfHQ9c3x2PS05Cnlhd19tb3ZlfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PS0xNQpzdGF0aWNfYm9keV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3dhbGt8dD1jfHY9dHJ1ZQpmYWtlbGFnX2Zha2VkZWZ8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9nbG9iYWx8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmNvbmRpdGlvbnx0PW98dj1zdGFuZApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfbW92ZXx0PXN8dj00MgpkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PXRydWU00=',
    Unmatched = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9MgplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9ZmFsc2UKeWF3X3dhbGt8dD1vfHY9MTgwCnN0YXRpY19ib2R5X3lhd19mYWtlbGFnfHQ9c3x2PTAKcGl0Y2hfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9qdW1wfHQ9c3x2PTIKYm9keV95YXdfbW9kZV9zdGFuZHx0PW98dj1qaXR0ZXIKYm9keV95YXdfdmFsdWVfanVtcCt8dD1zfHY9Mgp5YXdfaml0dGVyX2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19iYXNlX2R1Y2srfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV9kdWNrK3x0PWN8dj10cnVlCnlhd19iYXNlX2Zha2VsYWd8dD1vfHY9dGFyZ2V0CnNlbmRfY29tYm9nbG9iYWx8dD1vfHY9Z2xvYmFsCnN0YXRpY19ib2R5X3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3dhbGt8dD1zfHY9MgplbmFibGVfd2Fsa3x0PWN8dj10cnVlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9LTM0CmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIxCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX3dhbGt8dD1zfHY9MApib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PWppdHRlcgpmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9ZG93bgp5YXdfaml0dGVyX2Jhc2VfanVtcHx0PXN8dj0xMjAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PXN0YXRpYwlkZWZlbnNpdmUKc2VuZF9jb21ib2p1bXB8dD1vfHY9Z2xvYmFsCnNlbmRfY29tYm9qdW1wK3x0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9ZmFsc2UKZmFrZWxhZ19zZXR0aW5nc19lbmhhbmNlX29uc2hvdHx0PW18dj1kZWZlbnNpdmUJcm9sbAlqaXR0ZXIKc3RhdGljX2JvZHlfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2Jhc2VfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF93YWxrfHQ9c3x2PTIzCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTIKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9NDQKcmFuZG9taXplX3lhd19kdWNrK3x0PXN8dj0wCmJvZHlfeWF3X21vZGVfd2Fsa3x0PW98dj1zdGF0aWMKYm9keV95YXdfcmlnaHRfanVtcCt8dD1zfHY9NTQKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10aHJlYXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj10cnVlCnlhd19qdW1wfHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3dhbGt8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfc3RhbmR8dD1zfHY9MApyYW5kb21pemVfeWF3X2dsb2JhbHx0PXN8dj0wCmZpZnR5X2ZpZnR5X2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9tb3ZlfHQ9b3x2PWppdHRlcgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9zdGFuZHx0PWN8dj10cnVlCmJvZHlfeWF3X2Jhc2VfanVtcHx0PXN8dj03CmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTI0CnJhbmRvbWl6ZV95YXdfZmFrZWxhZ3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfanVtcCt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9zdGFuZHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfanVtcCt8dD1zfHY9MApkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PWRvd24KeWF3X2Jhc2Vfc3RhbmR8dD1vfHY9dGhyZWF0Cnlhd19qaXR0ZXJfZmFrZWxhZ3x0PW98dj1vZmYKc2VuZF9jb21ib3N0YW5kfHQ9b3x2PWdsb2JhbApwaXRjaF9zdGFuZHx0PW98dj1kb3duCnlhd19qaXR0ZXJfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbGVnaXR8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV9nbG9iYWx8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfbGVnaXR8dD1vfHY9dGFyZ2V0CnN0YXRpY19ib2R5X3lhd193YWxrfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfZmFrZWxhZ3x0PXN8dj0wCmRlbGF5X2R1Y2t8dD1zfHY9NQpmYWtlbGFnX3NldHRpbmdzX3JvbGx8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfbGltaXR8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdmFyaWFuY2V8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfYW1vdW50fHQ9b3x2PWR5bmFtaWMKZmFrZWxhZ19mYWtlbGFnX3R5cGV8dD1vfHY9c29kaXVtCnlhd19qaXR0ZXJfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2dsb2JhbHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfd2Fsa3x0PXN8dj0wCmNmZ19zZWxlY3Rpb258dD1tfHY9YW50aWFpbQpib2R5X3lhd192YWx1ZV9tb3ZlfHQ9c3x2PTIKZmlmdHlfZmlmdHlfbW92ZXx0PWN8dj1mYWxzZQpkZWxheV9tb3ZlfHQ9c3x2PTMKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmZha2VsYWdfc3RlYWxlcl90eXBlfHQ9b3x2PW1pbWljCmJvZHlfeWF3X3JpZ2h0X3N0YW5kfHQ9c3x2PTQwCnBpdGNoX2R1Y2t8dD1vfHY9ZG93bgpmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQplbmFibGVfbW92ZXx0PWN8dj10cnVlCmVuYWJsZV9nbG9iYWx8dD1jfHY9ZmFsc2UKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApib2R5X3lhd19yaWdodF9tb3ZlfHQ9c3x2PTQyCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXArfHQ9b3x2PW9mZgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj10cnVlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1qaXR0ZXIKZGVsYXlfc3RhbmR8dD1zfHY9MQp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApwaXRjaF9qdW1wK3x0PW98dj1kb3duCmRlbGF5X2p1bXArfHQ9c3x2PTUKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQplbmFibGVfZmFrZWxhZ3x0PWN8dj1mYWxzZQpvbmx5X2ZsaXBfb25fMF9jaG9rZV9tb3ZlfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX21vdmV8dD1zfHY9MAp5YXdfZ2xvYmFsfHQ9b3x2PW9mZgpjYWNoZV9jcmVkZW50aWFsc3x0PWN8dj10cnVlCnJhbmRvbWl6ZV95YXdfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF9sZWdpdHx0PXN8dj0wCmRlbGF5X2dsb2JhbHx0PXN8dj0xCmRlbGF5X2p1bXB8dD1zfHY9MQpib2R5X3lhd19sZWZ0X2p1bXB8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2xlZnRfd2Fsa3x0PXN8dj0tMTYKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcCt8dD1zfHY9LTE4Cnlhd19kdWNrfHQ9b3x2PTE4MAp5YXdfYmFzZV9qdW1wK3x0PW98dj10aHJlYXQKeWF3X21vdmV8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVjayt8dD1zfHY9LTE1CmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKZmFrZWxhZ19mYWtlZGVmfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZ2xvYmFsfHQ9b3x2PW9mZgp5YXdfYmFzZV9qdW1wfHQ9b3x2PXRocmVhdApjb25kaXRpb258dD1vfHY9ZHVjaysKc2VuZF9jb21ib2R1Y2srfHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj00NAp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX2R1Y2srfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2Zha2VsYWd8dD1vfHY9b2ZmCmRlbGF5X2Zha2VsYWd8dD1zfHY9MQpzdGF0aWNfYm9keV95YXdfZHVjayt8dD1zfHY9MAp5YXdfaml0dGVyX2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXB8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X3dhbGt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfZmFrZWxhZ3x0PWN8dj1mYWxzZQpwaXRjaF9kdWNrK3x0PW98dj1kb3du0000',
    Community = '',
}
return e54]]
e661["require/abc/config_system"] = [[


local e74='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

local function e57(e58)
    return ((e58:gsub('.', function(e59)
        local e72,e74='',e59:byte()
        for e60=8,1,-1 do e72=e72..(e74%2^e60-e74%2^(e60-1)>0 and '1' or '0') end
        return e72
    end)..'0000'):gsub('%d%d%d%d%d%d', function(e59)
        if (#e59 < 6) then return '' end
        return e74:sub(tonumber(e59,2)+1,tonumber(e59,2)+1)
    end)..({ '', '==', '=' })[#e58%3+1])
end

local function e60(e58)
    e58 = string.gsub(e58, '[^'..e74..'=]', '')
    return (e58:gsub('.', function(e59)
        if e59 == '=' then return '' end
        local e72,e61='',(e74:find(e59)-1)
        for e60=6,1,-1 do e72=e72..(e61%2^e60-e61%2^(e60-1)>0 and '1' or '0') end
        return e72
    end):gsub('%d%d%d%d%d%d%d%d', function(e59)
        if (#e59 ~= 8) then return '' end
        local e71=0
        for e60=1,8 do e71=e71+(e59:sub(e60,e60)=='1' and 2^(8-e60) or 0) end
        return string.char(e71)
    end))
end





local database= database

local e62= {}
local e63= {}

local function e64(e95,e75,e65,e66)
    if not e95 or e95 == '' or not e75 or e63[e95] then return end
    e62[#e62+1] = { key = e95, ref = e75, type = e65, tab = e66 }
    e63[e95] = e62[#e62]
end

local function e67(e83)
    local function e68(e69,e83)
        if not e83 or #e83 == 0 then return true end
        if e69 == 'CFG' then return true end
        if not e69 then return true end
        for e62, e56 in ipairs(e83) do if e56 == e69 then return true end end
        return false
    end

    local e70= { 'v=1' }
    for e60 = 1, #e62 do
        local e52= e62[e60]
        if e68(e52.tab, e83) then
            local e56= e52.type
            local e63= ui.get(e52.ref)
            if e56 == 'c' then
                e70[#e70+1] = e52.key .. '|t=c|v=' .. (e63 and 'true' or 'false')
            elseif e56 == 's' then
                e70[#e70+1] = e52.key .. '|t=s|v=' .. tostring(e63 or 0)
            elseif e56 == 'o' then
                e70[#e70+1] = e52.key .. '|t=o|v=' .. tostring(e63 or '')
            elseif e56 == 'm' then
                if type(e63) == 'table' then
                    e70[#e70+1] = e52.key .. '|t=m|v=' .. table.concat(e63, '\t')
                end
            end
        end
    end
    return e57(table.concat(e70, '\n'))
end

local function e71(e92,e83)
    if not e92 or e92 == '' then return end
    local e53, e72= pcall(e60, e92)
    if not e53 or not e72 or e72 == '' then return end
    local function e68(e69,e83)
        if not e83 or #e83 == 0 then return true end
        if e69 == 'CFG' then return true end
        if not e69 then return true end
        for e62, e56 in ipairs(e83) do if e56 == e69 then return true end end
        return false
    end
    for e73 in e72:gmatch('([^\n]+)') do
        if e73 ~= 'v=1' then
            local e95, e74, e75= e73:match('^(.-)|t=(.)|v=(.*)$')
            if e95 and e74 and e75 then
                local e52= e63[e95]
                if e52 and e52.type == e74 and e68(e52.tab, e83) then
                    if e74 == 'c' then
                        ui.set(e52.ref, e75 == 'true')
                    elseif e74 == 's' then
                        local e76= tonumber(e75)
                        if e76 ~= nil then
                            ui.set(e52.ref, e76)
                        end
                    elseif e74 == 'o' then
                        pcall(ui.set, e52.ref, e75)
                    elseif e74 == 'm' then
                        local e77= {}
                        for e78 in e75:gmatch('[^\t]+') do e77[#e77+1] = e78 end
                        ui.set(e52.ref, e77)
                    end
                end
            end
        end
    end
end


local function e79(e59,e83)
    if not e59 or e59 == '' then return end
    local e92= e67(e83)
    database.write('cfg:' .. e59, e92)
end


local function e80(e59,e83)
    if not e59 or e59 == '' then return end
    local e92= database.read('cfg:' .. e59)
    if e92 then e71(e92, e83) end
end


local function e81(e59)
    if not e59 or e59 == '' then return end
    database.write('cfg:' .. e59, nil)
end


local e78= {
    register = e64,
    build = e67,
    apply = e71,
    save = e79,
    load = e80,
    delete = e81,
}

return e78]]
e661["require/abc/garbage_collector"] = [[local e60= {}

local e61= {
    pause = 200,
    stepmul = 600,
    mode = "collect"
}

function e60.tune(e59)
	if type(e59) == "table" then
		if e59.pause then
			collectgarbage("setpause", e59.pause)
			e61.pause = e59.pause
		end
		if e59.stepmul then
			collectgarbage("setstepmul", e59.stepmul)
			e61.stepmul = e59.stepmul
		end
		if e59.mode then
			e61.mode = e59.mode
		end
	end
end

function e60.collect(e62)
	collectgarbage(e62 or e61.mode)
end

function e60.step(e63)
	return collectgarbage("step", e63 or 0)
end

function e60.stop()
	collectgarbage("stop")
end

function e60.restart()
	collectgarbage("restart")
end

function e60.memory()
	return collectgarbage("count")
end

function e60.status()
	return {
		memory = e60.memory(),
		pause = e61.pause,
		stepmul = e61.stepmul,
		mode = e61.mode
	}
end

local e64= 0
function e60.dynamic(e59)
	e59 = type(e59) == "table" and e59 or {}
	local e65= e59.min_interval or 0.6
	local e66= (globals and globals.realtime) and globals.realtime() or (e64 + e65)
	if e66 - e64 < e65 then
		return
	end
	e64 = e66

	local e63= e59.step_size or 20
	local e67= e59.full_threshold_kb or 65536
	local e68= e59.aggressive_threshold_kb or 12288

	local e53, e69= pcall(collectgarbage, "count")
	if not e53 or type(e69) ~= "number" then
		pcall(collectgarbage, "step", e63)
		return
	end

	if e69 >= e67 then
		pcall(collectgarbage, "collect")
		return
	end

	if e69 >= e68 then
		pcall(collectgarbage, "step", e63)
		pcall(collectgarbage, "step", e63)
		return
	end

	pcall(collectgarbage, "step", e63)
end

if lua and lua.defer then
	lua.defer(function()
		e60.collect()
	end)
end

return e60]]
e661["require/abc/hwid_check"] = [[local e63= require("ffi")
local e64= require("require/brain/dll")
local e65= 2
local e66= 1

local function e67()
    return globals.curtime and globals.curtime() or 0
end

local function e68()
    local shared= rawget(_G, "loader_shared")
    if not shared or type(shared) ~= "table" then
    return nil, "missing"
    end
    local e69= tonumber(shared.expires) or 0
    if e67() > e69 then
    return nil, "expired"
    end
    if type(shared.hwids) ~= "table" then
    return nil, "bad_hwids"
    end
    return shared, nil
end

local e70= false

local function e71()
    if not e64 or type(e64) ~= "table" or type(e64.get_hwid) ~= "function" then
        print("invalid hwid 1")
    return
    end

    local e72
    
    local e73, e54= pcall(e64.get_hwid)
    if e73 and e54 and e54 ~= e63.NULL then
    if type(e54) == "cdata" then
        local e74, e75= pcall(e63.string, e54)
        if e74 then e72 = e75 end
    else
        e72 = tostring(e54)
    end
    end

    if not e72 or e72 == "" then
        print("invalid hwid 2")
    end

    local shared, e76= e68()
    if not shared then
        print("invalid hwid 3")
    end

    local e77= shared.hwids
    local e78= false
    for e60 = 1, #e77 do
    local e96= tostring(e77[e60] or "")
    if e96:find(tostring(e72), 1, true) then
        e78 = true
        break
    end
    end


    if e78 then
        local e79= rawget(_G, "loader_init_after_hwid")
        if not e70 and type(e79) == "function" then
        e70 = true
        local e80, e669= pcall(e79)
        if not e80 then
            print("invalid hwid 4: " .. tostring(e669))
        end
        end
    else
        print("invalid hwid 5")
    end
end

local e81= 0
local function e63()
    e81 = e81 + 1
    local shared= rawget(_G, "loader_shared")
    if shared then
    e71()
    return
    end
    print(e81 .. "/" .. e65)
    if e81 > e65 then
        print("invalid hwid 6")
        return
    end

    if type(client.delay_call) == "function" then
        client.delay_call(e66, e63)
    else
        e71()
    end

end


e63()]]
e661["require/abc/login_system"] = [[local e66= {}


local function e67(e68)
	if client.hash_sha256 then
		return client.hash_sha256(e68)
	end
	
	return tostring(e68):reverse()
end


local e69= "acc_" .. "897ntv45ynvttyjt980745nyv0t485vn87t6"

local function e70()
	local e71= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local e72= ""
	for e60 = 1, 16 do
		local e67= math.random(1, #e71)
		e72 = e72 .. e71:sub(e67, e67)
	end
	return e72
end

function e66.hash_password(e69,e72)
	return e67(e72 .. e69)
end

function e66.verify_password(e69,e73,e72)
	return e66.hash_password(e69, e72) == e73
end

function e66.get_hwid()
	
	return tostring(client.userid_to_entindex(client.userid_to_entindex(1)))
end

function e66.store_credentials(e68,e69)
	local e72= e70()
	local e73= e66.hash_password(e69, e72)
	database.write("login_credentials", { username = e68, hash = e73, salt = e72 })
end

function e66.load_credentials()
	return database.read("login_credentials")
end


function e66.login(e68,e69)
	
	local e74= database.read(e69) or {}
	local e75= e74[e68]
	if e75 and e75.enabled ~= false then
		if e66.verify_password(e69, e75.hash, e75.salt) then
			e66.logged_in = true
			return true
		end
	end
	
	local e76= e66.load_credentials()
	if e76 and e76.username == e68 then
		if e66.verify_password(e69, e76.hash, e76.salt) then
			e66.logged_in = true
			return true
		end
	end
	e66.logged_in = false
	return false
end

function e66.logout()
	e66.logged_in = false
end

function e66.reset_password(e77)
	
	database.write("login_credentials", nil)
end



function e66.is_valid_invite(e78)
	if not e78 or e78 == "" then
		return false, nil
	end
	local e79= database.read(e69 .. ":invites") or {}
	local e96= e79[e78]
	if not e96 then
		return false, nil
	end
	if e96.used then
		return false, e96
	end
	return true, e96
end

function e66.add_account(e68,e69)
	local e72= e70()
	local e73= e66.hash_password(e69, e72)
	local e74= database.read(e69) or {}
	e74[e68] = { hash = e73, salt = e72, role = "user", enabled = true, orig_password = e69 }
	database.write(e69, e74)
end

function e66.register_with_invite(e78,e68,e69)
	if not e78 or e78 == '' then return false, 'no invite provided' end
	local e79= database.read(e69 .. ":invites") or {}
	local e96= e79[e78]
	if not e96 then return false, 'invalid invite' end
	if e96.used then return false, 'invite already used' end

	e66.add_account(e68, e69)

	e96.used = true
	e96.used_by = e68
	e96.redeemed_at = client.unix_time()
	e79[e78] = e96
	database.write(e69 .. ":invites", e79)

	return true
end

function e66.invalidate_invite(e78)
	local e79= database.read(e69 .. ":invites") or {}
	if e79[e78] then
		e79[e78] = nil
		database.write(e69 .. ":invites", e79)
		return true
	end
	return false
end

return e66
]]
e661["require/abc/menu_header"] = [[local e69, e70, e71= 1, 398, 49
local e72= 0.85 
local e73= { "AA", "PAINT", "MISC", "CFG" }
local e74= e73[e69]
local e75= {}
local e76= {
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS1.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS2.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS3.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS4.png"
}
local e77

local e78= {
    size = {
        x = 6,
        y = 6,
        w = 120,
        h = 72, 
    },
    skeet_cur_tab = 8,
}

local function e79()
    local e80= { ui.menu_position() }
    local e81= { ui.mouse_position() }
    if not e80[1] or not e80[2] or not e81[1] or not e81[2] then
        return e78.skeet_cur_tab
    end

    for e60 = 1, 9 do
        local e82= { e78.size.x, e78.size.y + e78.size.h * (e60 - 1) }
        if e81[1] >= e80[1] + e82[1]
           and e81[1] <= e80[1] + e78.size.w + e82[1]
           and e81[2] >= e80[2] + e82[2]
           and e81[2] <= e80[2] + e78.size.h + e82[2] then
            return e60
        end
    end

    return e78.skeet_cur_tab
end

local function e83()
    if not renderer.load_png or not readfile then return end
    for e60, e665 in ipairs(e76) do
        if not e75[e60] then
            local e84= readfile(e665)
            if e84 then
                e75[e60] = renderer.load_png(e84, e70, e71)
            end
        end
    end
end


local function e85()
    local e86= ui.is_menu_open()
    local e59, e87= ui.menu_position()
    local e88, e89= ui.menu_size()
    e88 = e88-2
    e59 = e59+1
    if e86 and e59 and e87 and e88 and e89 then
        local e90= (e78.skeet_cur_tab == 2)
        local e91= math.floor(90 * e72)
        local e92= math.max(1, math.floor(4 * e72))
        local e93= math.max(1, math.floor(3 * e72))
        local e94= math.max(1, math.floor(2 * e72))
        local e95= math.max(0, math.floor(1 * e72))
        local e96= 0
        local e97= e59 + e92
        local e98= e87 - math.floor(7 * e72) - e91
        local e99= e88 - 2 * e92

        if e90 then
            renderer.rectangle(e97-e92*1.3, e98-8, e99+2*e92*1.5-1, e91+16, 12, 12, 12, 255)
            renderer.rectangle(e97-e93*1.5, e98-7, e99+2*e93*1.5, e91+14, 60, 60, 60, 255)
            renderer.rectangle(e97-e94*1.51, e98-6, e99+2*e94*2, e91+12, 40, 40, 40, 255)
            renderer.rectangle(e97-e95, e98-3, e99+2*e95, e91+6, 60, 60, 60, 255)
            renderer.rectangle(e97-e96, e98-2, e99+2*e96, e91+4, 12, 12, 12, 255)

            local e100= nil
            if renderer.load_rgba then
                local e53, e101= pcall(renderer.load_rgba,
                    string.char(
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
                    ), 4, 4)
                if e53 and e101 then e100 = e101 end
            end
            if e100 and renderer.texture then
                renderer.texture(e100, e97-e96, e98-2, e99+2*e96, e91+4, 255,255,255,255, 'r')
            end

            if renderer.gradient then
                renderer.gradient(e97-e96, e98-2, (e99+2*e96)/2+1, 1, 59,175,222,255, 202,70,205,255, true)
                renderer.gradient(e97-e96+(e99+2*e96)/2+1, e98-2, (e99+2*e96)/2-1, 1, 202,70,205,255, 204,227,53,255, true)
            end

            local e102= math.max(1, math.floor(2 * e72))
            local e103= e98 - math.floor(8 * e72)

            local e104= math.max(1, math.floor(5 * e72))
            local e105= 60
            renderer.circle(e97-e92+e104, e103+e102/2, e104, 59,175,222, e105, 16)
            renderer.circle(e97+e99-e92-e96-e104, e103+e102/2, e104, 204,227,53, e105, 16)
        end

        local e106= 4
        local e107= e98 + e91 / 2
        local e108, e109= ui.mouse_position()
        local e110= {}
        local e111= e91
            local e112= math.max(1, math.floor(59 * e72))
            local e113= math.max(1, math.floor(e70 * e72))
            local e114= math.max(1, math.floor(e71 * e72))
            local e115= e106 * e113 + (e106 - 1) * e112
            local e116= math.max(0, e99 * 0.5)
            local e117= e97 + e116 + (e99 - 2 * e116 - e115) / 2
            if e115 > e99 then
                e112 = math.max(0, math.floor((e99 - e106 * e113) / (e106 - 1)))
                e115 = e106 * e113 + (e106 - 1) * e112
                e117 = e97 + (e99 - e115) / 2
            end
        e83()
        local e118= e99 / e106
        for e60=1,e106 do
            local e119= e97 + (e60-1) * e118
            local e120= e98
            e110[e60] = {x=e119, y=e120, w=e118, h=e111}
            if e90 then
                if e69 == e60 then
                    renderer.rectangle(e119, e120, e118, e111+1, 32,32,32, 85)
                end
                local e121= e119 + e118/2 - e113/2
                local e122= e120 + e111/2 - e114/2
                if e75[e60] then
                    renderer.texture(e75[e60], e121, e122, e113, e114, 255,255,255,255, "f")
                else
                    renderer.text(e121 + e113/2, e122 + e114/2, 255,255,255,255, '+c', 0, tostring(e60))
                end
            end
        end

        local e123= client.key_state(1)
        if e86 and e108 and e109 and ui.is_menu_open() then
            if e123 and not prev_mouse_down then
                for e60=1,e106 do
                    local e66= e110[e60]
                    if e108 >= e66.x and e108 <= e66.x+e66.w and e109 >= e66.y and e109 <= e66.y+e66.h then
                        e69 = e60
                        e74 = e73[e69]
                    end
                end
                local e124= { ui.menu_position() }
                if e124[1] and e124[2] then
                    for e125 = 1, 9 do
                        local e82= { e78.size.x, e78.size.y + e78.size.h * (e125 - 1) }
                        if e108 >= e124[1] + e82[1]
                           and e108 <= e124[1] + e78.size.w + e82[1]
                           and e109 >= e124[2] + e82[2]
                           and e109 <= e124[2] + e78.size.h + e82[2] then
                            e78.skeet_cur_tab = e125
                            break
                        end
                    end
                end
            end
            prev_mouse_down = e123
        else
            prev_mouse_down = false
        end
        local e126= e79()
        local e127= e78.skeet_cur_tab or 0
        local e128= "Skeet sel: " .. tostring(e127)
        if e126 and e126 ~= e127 then
            e128 = e128 .. "  (hover: " .. tostring(e126) .. ")"
        end
        if e90 then
            if renderer.measure_text then
                pcall(function() renderer.measure_text(nil, e128) end)
            end
            renderer.text(e97 + 6, e98 + e91 + 6, 200,200,200,255, nil, 0, e128)
        end
    end
end

local function e129()
    if not ui.is_menu_open() then return false end
    local e108, e109= ui.mouse_position()
    local e130, e131= ui.menu_position()
    local e132, e133= ui.menu_size()
    local e91= math.floor(90 * e72)
    local e92= math.max(1, math.floor(4 * e72))
    local e97, e98, e99= e130 + e92, e131 - math.floor(7 * e72) - e91, e132 - 2 * e92
    return not (
        e108 >= e130 and e108 <= e130 + e132 and e109 >= e131 and e109 <= e131 + e133
        or e108 >= e97 and e108 <= e97 + e99 and e109 >= e98 and e109 <= e98 + e91
    )
end

return {
    current_tab = function() return e74 end,
    current_tab_index = function() return e69 end,
    tab_names = e73,
    tab_sections = function() return e77 end,
    menu_position = function() return ui.menu_position() end,
    menu_size = function() return ui.menu_size() end,
    is_menu_open = function() return ui.is_menu_open() end,
    mouse_position = function() return ui.mouse_position() end,
    is_mouse_outside_menu = e129,
    draw_menu = e85
}]]
e661["require/abc/menu_setup"] = [[local e72= {
    ui = {},
    registered_items = {},
}

function e72.register_ui(e52,e59)
    
    
    
    if e59 and e59.key then
        for e60 = #e72.registered_items, 1, -1 do
            local e96= e72.registered_items[e60]
            if e96 and e96.key == e59.key then
                
                pcall(function()
                    if e96.item then ui.set_visible(e96.item, false) end
                end)
                table.remove(e72.registered_items, e60)
            end
        end
    end

    table.insert(e72.registered_items, {
        item = e52,
        key = e59.key,
        requires_login = e59.requires_login,
        tab = e59.tab,
        visible = e59.visible ~= false,
        config_type = e59.config_type,
        show_condition = e59.show_condition,
    })
    return e52
end

function e72.update_visibility(e73)
    for e62, e96 in ipairs(e72.registered_items) do
        local e74= e96.visible
        if e96.requires_login and not e73 then
            e74 = false
        end
        if e96.show_condition then
            e74 = e96.show_condition()
        end
        if e96.item then
            ui.set_visible(e96.item, e74)
        end
    end
end

function e72.save_config()
    local config= {}
    for e62, e96 in ipairs(e72.registered_items) do
        if e96.key and e96.item then
            config[e96.key] = ui.get(e96.item)
        end
    end
    return config
end

function e72.load_config(e75)
    for e62, e96 in ipairs(e72.registered_items) do
        if e96.key and e96.item and e75[e96.key] ~= nil then
            ui.set(e96.item, e75[e96.key])
        end
    end
end

local e76= {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

local e77= {

    { 'Rage', 'other', 'accuracy boost' },
    { 'Rage', 'other', 'anti-aim correction' },
    { 'rage', 'other', 'automatic fire' },
    { 'Rage', 'other', 'automatic penetration' },
    { 'Rage', 'other', 'silent aim' },
    { 'Rage', 'other', 'remove recoil' },
    { 'Rage', 'other', 'reduce aimstep' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'log misses due to spread' },
    { 'Rage', 'other', 'low fps mitigations ' },
    { 'rage', 'other', 'delay shot' },
    { 'Rage', 'other', 'quick peek assist' },
    { 'Rage', 'other', 'quick peek assist mode' },
    { 'Rage', 'other', 'quick peek assist distance' },
    { 'Rage', 'other', 'reduce aim step' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'low fps mitigations' },
    { 'Rage', 'other', 'duck peek assist' },


}

function e72.toggle_gamesense_menu(e74)
    e72.state = e72.state or {}
    e72.hidden_refs = e72.hidden_refs or {}
    for e62, e96 in ipairs(e76) do
        local e53, e78, e79, e80, e81= pcall(ui.reference, e96[1], e96[2], e96[3], e96[4])
        if e53 then
            if e96[1] == 'AA' and e96[2] == 'Anti-aimbot angles' and e96[3] == 'Enabled' then
                e72.state.gs_enabled_ref = e78
                if e78 ~= nil and e74 then
                    if e72.state.gs_enabled_previous ~= nil then
                        ui.set(e78, e72.state.gs_enabled_previous)
                    end
                elseif e78 ~= nil and not e74 then
                    e72.state.gs_enabled_previous = ui.get(e78)
                    ui.set(e78, true)
                end
            end
            local e82= { e78, e79, e80, e81 }
            local e83= {}
            for e62, e75 in ipairs(e82) do
                if e75 ~= nil then
                    ui.set_visible(e75, e74)
                    e83[#e83 + 1] = e75
                end
            end
            if not e74 and #e83 > 0 then
                table.insert(e72.hidden_refs, e83)
            end
        end
    end
    e72.state.gs_hidden = not e74
end

function e72.toggle_rage_menu(e74)
    e72.state = e72.state or {}
    e72.hidden_rage_refs = e72.hidden_rage_refs or {}
    e72.hidden_rage_refs = {} 

    for e62, e96 in ipairs(e77) do
        local e53, e78, e79, e80, e81= pcall(ui.reference, e96[1], e96[2], e96[3])
        if e53 then
            local e82= { e78, e79, e80, e81 }
            local e83= {}
            for e62, e75 in ipairs(e82) do
                if e75 ~= nil then
                    pcall(function() ui.set_visible(e75, e74) end)
                    e83[#e83 + 1] = e75
                end
            end
            if not e74 and #e83 > 0 then
                table.insert(e72.hidden_rage_refs, e83)
            end
        end
    end
    e72.state.rage_hidden = not e74
end

return e72]]
e661["require/abc/menu_visibility"] = [[local e48= {
	"global",
	"stand",
	"move",
	"duck",
	"duck+",
	"jump",
	"jump+",
	"walk",
	"fakelag",
	"legit",
}

local e66= require("require/abc/login_system")

local function e75(e53)
	if e53.menu_setup and e53.menu_setup.refresh_cfg_listbox then
		e53.menu_setup.refresh_cfg_listbox()
	end

	if e53 and not e53.login then
		e53.login = e66
	end
	e53.menu_setup.toggle_gamesense_menu(false)
	e53.menu_setup.toggle_rage_menu(true)
	e53.menu_setup.update_visibility(e53.login and e53.login.logged_in)
	local e76= (e53.login and e53.login.logged_in) or false

	local e74= not e76
	local e77= (e53.menu_header and e53.menu_header.current_tab and e53.menu_header.current_tab()) or e53.menu.current_tab()
	 	
	ui.set_visible(e53.menu_setup.ui.login_howto_header, e74)
	ui.set_visible(e53.menu_setup.ui.login_console_register, e74)
	ui.set_visible(e53.menu_setup.ui.login_menu_credentials, e74)
	ui.set_visible(e53.menu_setup.ui.login_press_login, e74)
	ui.set_visible(e53.menu_setup.ui.login_spacer1, e74)
	ui.set_visible(e53.menu_setup.ui.reset_header, e74)
	ui.set_visible(e53.menu_setup.ui.reset_step1, e74)
	ui.set_visible(e53.menu_setup.ui.reset_step2, e74)
	ui.set_visible(e53.menu_setup.ui.login_spacer2, e74)
	ui.set_visible(e53.menu_setup.ui.support_header, e74)
	ui.set_visible(e53.menu_setup.ui.support_discord, e74)
	ui.set_visible(e53.menu_setup.ui.login_username, e74)
	ui.set_visible(e53.menu_setup.ui.login_password, e74)
	ui.set_visible(e53.menu_setup.ui.cache_credentials, e74)
	ui.set_visible(e53.menu_setup.ui.login_button, e74)
	ui.set_visible(e53.menu_setup.ui.reset_button, e74)
	ui.set_visible(e53.menu_setup.ui.discord_button, e74)
	ui.set_visible(e53.menu_setup.ui.youtube_button, e74)
	ui.set_visible(e53.menu_setup.ui.sellhub_button, e74)
	ui.set_visible(e53.menu_setup.ui.logout_button, e76 and e77 == "CFG")

	if e53.menu_setup.ui.condition then
		local e78= ui.get(e53.menu_setup.ui.condition)
		for e62, e50 in ipairs(e48) do
			local e79= e76 and e77 == "AA" and e78 == e50
			local e51= 'enable_' .. e50
			if e53.menu_setup.ui[e51] then
				ui.set_visible(e53.menu_setup.ui[e51], e79)
				local e80= e53.safe.safe_get(e53.menu_setup.ui[e51])

				local e81= e53.menu_setup.ui['yaw_' .. e50] and ui.get(e53.menu_setup.ui['yaw_' .. e50]) or nil
				local e82= e53.menu_setup.ui['yaw_jitter_' .. e50] and ui.get(e53.menu_setup.ui['yaw_jitter_' .. e50]) or nil
				local e83= e53.menu_setup.ui['body_yaw_mode_' .. e50] and ui.get(e53.menu_setup.ui['body_yaw_mode_' .. e50]) or nil
				local e84= e53.menu_setup.ui['delay_' .. e50] and ui.get(e53.menu_setup.ui['delay_' .. e50]) or nil
				ui.set_visible(e53.menu_setup.ui['pitch_' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['yaw_base_' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['yaw_' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['label1_' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['label2_' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['label3_' .. e50], e79 and e80)
				local e85= e79 and e80 and (e81 ~= 'off' and e81 ~= 'ideal' and e81 ~= '3way')
				ui.set_visible(e53.menu_setup.ui['body_yaw_base_' .. e50], e85)
				local e86= e79 and e80 and (e81 == '180' or e81 == '3way')
				ui.set_visible(e53.menu_setup.ui['body_yaw_left_' .. e50], e86)
				ui.set_visible(e53.menu_setup.ui['body_yaw_right_' .. e50], e86)
				local e87= e79 and e80 and (e81 ~= 'off' and e81 ~= 'ideal')
				ui.set_visible(e53.menu_setup.ui['randomize_yaw_' .. e50], e87)
				local e88= e79 and e80 and (e82 ~= 'off')
				ui.set_visible(e53.menu_setup.ui['yaw_jitter_base_' .. e50], e88)
				local e89= e79 and e80 and (e83 == 'static')
				ui.set_visible(e53.menu_setup.ui['static_body_yaw_' .. e50], e89)
				local e90= e79 and e80 and (e83 == 'jitter' and e84 and e84 <= 0)
				ui.set_visible(e53.menu_setup.ui['body_yaw_value_' .. e50], e90)
				local e91= e79 and e80 and (e83 == 'jitter')
				ui.set_visible(e53.menu_setup.ui['delay_' .. e50], e91)
				ui.set_visible(e53.menu_setup.ui['yaw_jitter_' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['body_yaw_mode_' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['fifty_fifty_' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['only_flip_on_0_choke_' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['aa_label_space' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['aa_label_combo' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['send_button' .. e50], e79 and e80)
				ui.set_visible(e53.menu_setup.ui['send_combo' .. e50], e79 and e80)
			end
		end
		ui.set_visible(e53.menu_setup.ui.condition, e76 and e77 == "AA")
		ui.set_visible(e53.menu_setup.ui.condition_label, e76 and e77 == "AA")
		ui.set_visible(e53.menu_setup.ui.condition_label2, e76 and e77 == "AA")


		ui.set_visible(e53.menu_setup.ui.fakelag_mode, e76 and e77 == "AA")
		if e53.menu_setup.ui.fakelag_mode then
			local e62= ui.get(e53.menu_setup.ui.fakelag_mode)
			local e92= e76 and e77 == "AA"
			local e93= e92 and e62 == "defensive"
			local e94= e53.safe.safe_get(e53.menu_setup.ui.fakelag_defensive) == true
			ui.set_visible(e53.menu_setup.ui.fakelag_defensive, e93)
			ui.set_visible(e53.menu_setup.ui.fakelag_force, e93 and e94)
			ui.set_visible(e53.menu_setup.ui.fakelag_force_on, e93 and e94)
			ui.set_visible(e53.menu_setup.ui.fakelag_fakedef, e93 and e94)

			local e95= e92 and e62 == "stealer"
			local e96= e53.safe.safe_get(e53.menu_setup.ui.fakelag_stealer) == true
			ui.set_visible(e53.menu_setup.ui.fakelag_stealer, e95)
			ui.set_visible(e53.menu_setup.ui.fakelag_stealer_type, e95 and e96)
			ui.set_visible(e53.menu_setup.ui.fakelag_stealer_target, e95 and e96)
			ui.set_visible(e53.menu_setup.ui.fakelag_stealer_list, e95 and e96)
			ui.set_visible(e53.menu_setup.ui.fakelag_stealer_refresh, e95 and e96)
			ui.set_visible(e53.menu_setup.ui.fakelag_stealer_steal, e95 and e96)

			local e97= e92 and e62 == "fakelag"
			local e98= e53.safe.safe_get(e53.menu_setup.ui.fakelag_fakelag) == true
			local e99= e53.safe.safe_get(e53.menu_setup.ui.fakelag_fakelag_type) == "sodium"
			ui.set_visible(e53.menu_setup.ui.fakelag_fakelag, e97)
			ui.set_visible(e53.menu_setup.ui.fakelag_fakelag_type, e97 and e98)
			ui.set_visible(e53.menu_setup.ui.fakelag_fakelag_amount, e97 and e98 and not e99)
			ui.set_visible(e53.menu_setup.ui.fakelag_fakelag_variance, e97 and e98 and not e99)
			ui.set_visible(e53.menu_setup.ui.fakelag_fakelag_limit, e97 and e98 and not e99)
			ui.set_visible(e53.menu_setup.ui.fakelag_fakelag_type2, e97 and e98 and e99)

			local e100= e92 and e62 == "settings"
			ui.set_visible(e53.menu_setup.ui.fakelag_settings_freestanding, e100)
			ui.set_visible(e53.menu_setup.ui.fakelag_settings_enhance_onshot, e100)
			ui.set_visible(e53.menu_setup.ui.fakelag_settings_antibrute, e100)
			ui.set_visible(e53.menu_setup.ui.fakelag_settings_roll_label, e100)
			ui.set_visible(e53.menu_setup.ui.fakelag_settings_roll_checkbox, e100)
			local e101= e100 and e53.safe.safe_get(e53.menu_setup.ui.fakelag_settings_roll_checkbox) == true
			ui.set_visible(e53.menu_setup.ui.fakelag_settings_roll, e101)
			ui.set_visible(e53.menu_setup.ui.fakelag_settings_side, e101)
		end

		local e102= e76 and e77 == "PAINT" and ui.get(e53.menu_setup.ui.paint_indicators_enable) == true
		local e103= e76 and e77 == "PAINT" and e102 and ui.get(e53.menu_setup.ui.paint_indicators) ~= "off"
		local e104= e76 and e77 == "PAINT" and e102 and ui.get(e53.menu_setup.ui.paint_indicators) == "small"
		ui.set_visible(e53.menu_setup.ui.paint_indicators, e102)
		ui.set_visible(e53.menu_setup.ui.paint_indicators_enable, e103)
		ui.set_visible(e53.menu_setup.ui.paint_indicators_animation, e103)
		ui.set_visible(e53.menu_setup.ui.paint_indicators_bar, e104)
		ui.set_visible(e53.menu_setup.ui.paint_indicator_color, e103)

		local e105= e76 and e77 == "PAINT" and ui.get(e53.menu_setup.ui.paint_advertisement) == true
		ui.set_visible(e53.menu_setup.ui.paint_advertisement_color, e105)

		local e106= e76 and e77 == "PAINT" and ui.get(e53.menu_setup.ui.paint_watermark) == true
		ui.set_visible(e53.menu_setup.ui.paint_watermark_color, e106)

		local e107= e76 and e77 == "MISC" and e53.safe.safe_get(e53.menu_setup.ui.misc_dormantaimbot) == true
		ui.set_visible(e53.menu_setup.ui.misc_dormantaimbot_key, e107)
		ui.set_visible(e53.menu_setup.ui.misc_dormantaimbot_value, e107)

		local e108= e76 and e77 == "PAINT" and e53.safe.safe_get(e53.menu_setup.ui.paint_logger_checkbox) == true
		ui.set_visible(e53.menu_setup.ui.paint_logger, e108)
		ui.set_visible(e53.menu_setup.ui.paint_logger_animation, e108)
		ui.set_visible(e53.menu_setup.ui.paint_logger_color, e108)

		local e109= e76 and e77 == "PAINT" and e53.safe.safe_get(e53.menu_setup.ui.paint_aspect_ratio_checkbox) == true
		ui.set_visible(e53.menu_setup.ui.paint_aspect_ratio, e109)

		local e110= e76 and e77 == "PAINT" and e53.safe.safe_get(e53.menu_setup.ui.paint_third_person_distance_checkbox) == true
		ui.set_visible(e53.menu_setup.ui.paint_third_person_distance, e110)

	end

	local e111= {
		'aa_gskey_freestand',
		'aa_gskey_freestandh',
		'aa_gskey_slowmotion',
		'aa_gskey_slowmotionh',
		'aa_gskey_edgeyaw',
		'aa_gskey_edgeyawh',
		'aa_gskey_onshot',
		'aa_gskey_onshoth',
	}
	for e62, e95 in ipairs(e111) do
		if e53.menu_setup.ui[e95] then
			ui.set_visible(e53.menu_setup.ui[e95], e77 == "AA")
		end
	end

	local e112= {
		'misc_resolver',
		'misc_ragebot',
		'misc_dormantaimbot',
		'misc_exploit_fakelag',
		'misc_walkbot',
		'misc_backstab',
		'misc_spindead',
	}
	for e62, e95 in ipairs(e112) do
		if e53.menu_setup.ui[e95] then
			ui.set_visible(e53.menu_setup.ui[e95], e77 == "MISC")
		end
	end

	local e113= {
		'paint_target_info',
		'label_space2',
		'label_space3',
		'label_space4',
		'paint_entidx',
		'paint_filter_console',
		'paint_minimum_damage',
		'paint_show_damage_penetration',
		'paint_hitmiss_indicator',
		'paint_self_skeleton',
		'paint_bullet_tracer',
		'paint_lagcomp_box',
		'paint_lagcomp_box_color',
		'paint_presmoke',
		'paint_bombwarning',
		'paint_insults',
		'paint_rainbow_esp',
		'paint_molotov',
		'paint_lag_record',
		'paint_advertisement',
		'paint_advertisement_animation',
		'paint_clantag',
		'paint_aimbot_logs',
		'paint_indicators_label',
		'paint_indicators_enable',
		'label_space1',
		'paint_watermark',
		'paint_watermark_type',
		'paint_logger_label',
		'paint_logger_checkbox',
		'paint_hitmarker',
		'paint_hitmarker_color',
		'paint_warnings',
		'paint_animations',
		'paint_performance_mode',
		'paint_aspect_ratio_checkbox',
		'paint_third_person_distance_checkbox',
	}
	for e62, e95 in ipairs(e113) do
		if e53.menu_setup.ui[e95] then
			ui.set_visible(e53.menu_setup.ui[e95], e77 == "PAINT")
		end
	end

		local e114= {
			'cfg_load_button',
			'cfg_save_button',
			'cfg_delete_button',
			'cfg_refresh_button',
			'cfg_create_button',
			'cfg_export_button',
			'cfg_import_button',
			'cfg_input_box',
			'cfg_listbox',
			'cfg_selection',
			'cfg_cloud',
			'cfg_cloud_apply',
		}
		for e62, e95 in ipairs(e114) do
			if e53.menu_setup.ui[e95] then
				ui.set_visible(e53.menu_setup.ui[e95], e76 and e77 == "CFG")
			end
		end

end

local function e115(e53)
	local e116= {
		e53.menu_setup.ui.condition,
		e53.menu_setup.ui.fakelag_mode,
	}
	for e62, e52 in ipairs(e116) do
		if e52 then
			ui.set_callback(e52, function()
				e75(e53)
			end)
		end
	end

	for e62, e50 in ipairs(e48) do
		local e117= {
			'enable_' .. e50,
			'yaw_' .. e50,
			'yaw_jitter_' .. e50,
			'body_yaw_mode_' .. e50,
			'fifty_fifty_' .. e50,
			'only_flip_on_0_choke_' .. e50,
			'aa_label_space' .. e50,
			'aa_label_combo' .. e50,
			'send_button' .. e50,
			'send_combo' .. e50,
		}
		for e62, e95 in ipairs(e117) do
			local e52= e53.menu_setup.ui[e95]
			if e52 then
				ui.set_callback(e52, function()
					e75(e53)
				end)
			end
		end
	end

	local e118= {
		'fakelag_defensive',
		'fakelag_stealer',
		'fakelag_fakelag',
		'fakelag_fakelag_type',
		'fakelag_settings_roll_label',
		'fakelag_settings_roll_checkbox',
	}
	for e62, e95 in ipairs(e118) do
		local e52= e53.menu_setup.ui[e95]
		if e52 then
			ui.set_callback(e52, function()
				e75(e53)
			end)
		end
	end

	if e53.menu_setup.ui.paint_indicators then
		ui.set_callback(e53.menu_setup.ui.paint_indicators, function()
			e75(e53)
		end)
	end

	if e53.menu_setup.ui.paint_advertisement then
		ui.set_callback(e53.menu_setup.ui.paint_advertisement, function()
			e75(e53)
		end)
	end
	
	if e53.menu_setup.ui.paint_watermark then
		ui.set_callback(e53.menu_setup.ui.paint_watermark, function()
			e75(e53)
		end)
	end

	if e53.menu_setup.ui.misc_dormantaimbot then
		ui.set_callback(e53.menu_setup.ui.misc_dormantaimbot, function()
			e75(e53)
		end)
	end

	if e53.menu_setup.ui.paint_logger_checkbox then
		ui.set_callback(e53.menu_setup.ui.paint_logger_checkbox, function()
			e75(e53)
		end)
	end

	if e53.menu_setup.ui.paint_aspect_ratio_checkbox then
		ui.set_callback(e53.menu_setup.ui.paint_aspect_ratio_checkbox, function()
			e75(e53)
		end)
	end

	if e53.menu_setup.ui.paint_third_person_distance_checkbox then
		ui.set_callback(e53.menu_setup.ui.paint_third_person_distance_checkbox, function()
			e75(e53)
		end)
	end

	if e53.menu_setup.ui.paint_indicators_enable then
		ui.set_callback(e53.menu_setup.ui.paint_indicators_enable, function()
			e75(e53)
		end)
	end

	if e53.login and type(e53.login.add_state_callback) == 'function' then
		e53.login.add_state_callback(function()
			e75(e53)
		end)
	end
end

return {
	update = e75,
	setup_callbacks = e115
}]]
e661["require/abc/push_gamesense"] = [[local renderer= renderer
local globals= globals
local e78= string.char

local e79= nil
local function e80()
    if e79 then return e79 end
    if renderer.load_rgba then
        local e53, e101= pcall(renderer.load_rgba,
            string.char(
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
            ), 4, 4)
        if e53 and e101 then e79 = e101 end
    end
    return e79
end


local function e81(e59,e87,e88,e89,e70,e82)
    local e83= e59 - 3
    local e84= e87 - 40
    local e85= e88 + 5
    local e86= e89 + 1
    renderer.rectangle(e59 - 10, e87 - 48, e88 + 20, e89 + 16, 0, 0, 0, 200)
    renderer.rectangle(e59 - 9, e87 - 47, e88 + 18, e89 + 14, 60, 60, 60, 255)
    renderer.rectangle(e59 - 8, e87 - 46, e88 + 16, e89 + 12, 40, 40, 40, 255)
    renderer.rectangle(e59 - 5, e87 - 43, e88 + 10, e89 + 6, 60, 60, 60, 255)
    renderer.rectangle(e59 - 4, e87 - 42, e88 + 8, e89 + 4, 12, 12, 12, 255)
    renderer.rectangle(e59 - 4, e87 - 42, e88 + 8, e89 + 4, 32, 32, 32, 255)
    local e100= e80()
    if e100 and renderer.texture then
        renderer.texture(e100, e83, e84, e85, e86, 255,255,255,e70, 'r')
    else
        renderer.rectangle(e83, e84, e85, e86, 0, 0, 0, 0)
    end

    
    if renderer.gradient then
        renderer.gradient(e59 - 4, e87 - 42, e88 / 2 + 1, 1, 59, 175, 222, 255, 202, 70, 205, 255, true)
        renderer.gradient(e59 - 4 + e88 / 2, e87 - 42, e88 / 2 + 8.5, 1, 202, 70, 205, 255, 204, 227, 53, 255, true)
    end
    renderer.text(e59, e87 - 40, 255, 255, 255, 255, '', nil, e82)
end

return e81
]]
e661["require/abc/push_logger"] = [[local renderer= renderer
local globals= globals
local client= client
local entity= entity
local e81= table.insert
local e82= table.remove
local e83= math.floor
local e84= math.sqrt
local e78= string.char


local e85, e47= pcall(require, "require/abc/menu_setup")


local e86, e87= pcall(ui.reference, 'misc', 'settings', 'menu color')

local e88= {}
local e89= 5

local function e90(e82,e91,e72,e73,e74,e70)
    if #e88 >= e89 then
        e82(e88, 1)
    end
    e81(e88, {
        text = tostring(e82),
        duration = e91 or 5,
        color = { e72 or 255, e73 or 255, e74 or 255, e70 or 255 },
        timestamp = globals and globals.curtime and globals.curtime() or os.clock(),
    })
end

local function e92(e68)
    local e53, e88, e89= pcall(renderer.measure_text, '', e68)
    if e53 and type(e88) == 'number' then return e88, e89 or 0 end
    e53, e88, e89 = pcall(renderer.measure_text, e68)
    if e53 and type(e88) == 'number' then return e88, e89 or 0 end
    return 0, 0
end

local function e93(e63,e94,e95)
    if e63 < e94 then return e94 end
    if e63 > e95 then return e95 end
    return e63
end


local function e96()
    if e85 and e47 and e47.ui and e47.ui.paint_logger then
        local e53, e54= pcall(ui.get, e47.ui.paint_logger)
        if e53 and e54 then return true end
        return false
    end
    
    return true
end


local function e97()
    if e85 and e47 and e47.ui and e47.ui.paint_logger_animation then
        local e53, e63= pcall(ui.get, e47.ui.paint_logger_animation)
        if e53 and type(e63) == 'number' then return e63 end
    end
    return 0
end


local e98, e99= pcall(require, "require/abc/push_modern")
local e100, e81= pcall(require, "require/abc/push_gamesense")


local function e101(e102)
    local e103= 80
    local e104= e102 - 80
    local e105= 40
    local e106= e102 / 2 - 300
    local e107= e102 - e106 - 10
    e107 = e93(e107, e103 + e105, e104 - e105)
    local e108= e107 - e105
    local e109= e107 + e105
    return e108, e109, e107
end

local function e110()
    if not renderer or not renderer.text then return end
    if not e96() then return end

    local e111= e97() or 0
    local e66= globals and globals.curtime and globals.curtime()
    local e112, e102= client and client.screen_size and client.screen_size() or 800, 600
    local e113= e102 * 0.5 + (e102 * 0.5 * 1.8)
    local e82= 0
    for e60 = #e88, 1, -1 do
        local e114= e88[e60]
        local e115= (e114.timestamp + e114.duration) - e66
        if e115 <= 0 then
            e82(e88, e60)
        else
            local e116, e117= e92(e114.text)
            local e118= (e111 == 1) and 4 or 2
            local e119= 2
            local e59= e112 / 2 - e116 / 2
            local e87= e113 + e82
            local e120= 5
            local e121= e83((e114.color[4] or 255) * math.min(1, (e115 / e114.duration) * e120))
            local e122= (e114.duration - e115)
            local e123= (e114.duration > 0 and e114.duration or 1)
            local e56= e122 / e123
            local e124= 6
            local e125= e93(e56 * e124, 0, 1)
            local e126= e125
            
            
            local e127= math.min(0.5, e123 * 0.25)
            if e115 <= e127 then
                local e128= e115 / e127 
                e126 = e93(e128, 0, 1)
            end
            if e111 == 1 then
                e99(e59, e87, e116, 13, e121, e114.text, e126)
                e82 = e82 + (e117 + e118 * 2 + e84(e119 / 10) * 4)
            else
                e81(e59, e87, e116, 13, e121, e114.text)
                e82 = e82 + (e117 + e118 * 2 + e84(e119 / 10) * 35)
            end
        end
    end
end

if client and client.set_event_callback then
    client.set_event_callback('paint', e110)
else
    
    client.set_event_callback('paint', e110)
end

return e90
]]
e661["require/abc/push_modern"] = [[local renderer= renderer
local ui= ui
local e83= math.floor

local e85, e47= pcall(require, "require/abc/menu_setup")
local e86, e87= pcall(ui.reference, 'misc', 'settings', 'menu color')

local function e84(e59,e87,e88,e89,e85,e72,e73,e74,e70)
    if not e85 or e85 <= 0 then
        renderer.rectangle(e59, e87, e88, e89, e72,e73,e74,e70)
        return
    end
    renderer.rectangle(e59 + e85, e87, e88 - (e85 * 2), e89, e72,e73,e74,e70)
    renderer.rectangle(e59, e87 + e85, e88, e89 - (e85 * 2), e72,e73,e74,e70)
    renderer.circle(e59 + e85, e87 + e85, e72,e73,e74,e70, e85, 0, 1)
    renderer.circle(e59 + e88 - e85, e87 + e85, e72,e73,e74,e70, e85, 0, 1)
    renderer.circle(e59 + e85, e87 + e89 - e85, e72,e73,e74,e70, e85, 0, 1)
    renderer.circle(e59 + e88 - e85, e87 + e89 - e85, e72,e73,e74,e70, e85, 0, 1)
end

local function e86(e87,e88,e89,e90)
    local e91, e92, e93, e94= e87 or 255, e88 or 140, e89 or 0, e90 or 255
    
    if e85 and e47 and e47.ui and e47.ui.paint_logger_color then
        local e95, e96, e97, e98, e99= pcall(ui.get, e47.ui.paint_logger_color)
        if e95 then
            if type(e96) == 'number' then
                e91 = e83(e96 or e91)
                e92 = e83(e97 or e92)
                e93 = e83(e98 or e93)
                e94 = e83(e99 or e94)
            elseif type(e96) == 'string' and #e96 == 12 then
                local e53
                e53, e91 = pcall(function() return tonumber(e96:sub(1,3)) end)
                e53, e92 = pcall(function() return tonumber(e96:sub(4,6)) end)
                e53, e93 = pcall(function() return tonumber(e96:sub(7,9)) end)
                e53, e94 = pcall(function() return tonumber(e96:sub(10,12)) end)
                e91 = e91 or e87; e92 = e92 or e88; e93 = e93 or e89; e94 = e94 or e90
            end
            return e91, e92, e93, e94
        end
    end

    
    if e86 and e87 then
        local e95, e96, e97, e98, e99= pcall(ui.get, e87)
        if e95 then
            if type(e96) == 'number' then
                e91 = e83(e96 or e91)
                e92 = e83(e97 or e92)
                e93 = e83(e98 or e93)
                e94 = e83(e99 or e94)
            elseif type(e96) == 'string' and #e96 == 12 then
                local e53
                e53, e91 = pcall(function() return tonumber(e96:sub(1,3)) end)
                e53, e92 = pcall(function() return tonumber(e96:sub(4,6)) end)
                e53, e93 = pcall(function() return tonumber(e96:sub(7,9)) end)
                e53, e94 = pcall(function() return tonumber(e96:sub(10,12)) end)
                e91 = e91 or e87; e92 = e92 or e88; e93 = e93 or e89; e94 = e94 or e90
            end
        end
    end
    return e91, e92, e93, e94
end

local function e99(e59,e87,e88,e89,e121,e82,e126)
    local e83= e59 - 4
    local e84= e87 - 40
    local e85= e88 + 8
    local e86= e89 + 1

    local e100= 6
    if e86 < 12 then e100 = math.max(1, math.floor(e86 / 2)) end
    local e101= math.max(1, e100 - 1)

    local e91, e92, e93, e94= e86(255, 140, 0, 255)
    local e102= e83((e94 or 255) * 0.95)

    e126 = math.max(0, math.min(1, e126 or 1))
    local e103= e83 - 1
    local e104= e84 - 1
    local e105= e85 + 2
    local e106= e86 + 2
    local e107= e105 / 2 + (e105 * 0.1)
    local e108= e83(e107 * e126)

    if e108 > 0 then
        local e109= math.min(e100 + 1, e83(e106 / 2), e83(e108 / 2))
        e84(e103, e104, e108, e106, e109, e91, e92, e93, e102)
        e84(e103 + e105 - e108, e104, e108, e106, e109, e91, e92, e93, e102)
    end
    e84(e83, e84, e85, e86, e100, 10, 10, 10, 230)
    e84(e83 + 1, e84 + 1, e85 - 2, e86 - 2, e101, 6, 6, 6, 220)
    if renderer.gradient then
        renderer.gradient(e83 + 2, e84 + 1, math.max(0, e85 - 4), 2, e91, e92, e93, e83(e102 * 0.14), e91, e92, e93, 0, true)
    end
    renderer.text(e59, e87 - 40, 255, 255, 255, 255, '', nil, e82)
end

return e99]]
e661["require/abc/register"] = [[local e66= require("require.abc.login_system")
local e69= "acc_" .. "OIDFGNSOIGNSFGIOSNGOISNGIOS"

local function e87(e88)
    local e89= {}
    for e90 in e88:gmatch("%S+") do
        table.insert(e89, e90)
    end
    return e89
end

client.set_event_callback("console_input", function(e82)
    local e89= e87(e82 or "")
    if #e89 == 0 then return end

    local e91= e89[1]:lower()
    if e91 ~= "register" then
        
        return
    end

    if #e89 < 4 then
        client.log("Usage: register <username> <password> <invite>")
        return
    end

    local e68= e89[2]
    local e69= e89[3]
    local e92= e89[4]

    local e93, e96= e66.is_valid_invite(e92)
    if not e93 then
        client.log("Register failed: invalid or used invite")
        return
    end

    local e74= database.read(e69) or {}
    if e74[e68] then
        client.log("Register failed: username already exists - ", e68)
        return
    end

    local e53, e669= e66.register_with_invite(e92, e68, e69)
    if e53 then
        client.log("Registered user:", e68)
    else
        client.log("Register failed:", e669 or "unknown error")
    end
end)]]
e661["require/abc/screen_logger"] = [[local renderer= renderer
local globals= globals
local client= client
local e81= table.insert
local e82= table.remove
local e83= math.floor




local e88= {}
local e90= 12

local function e92(e68)
    local e53, e88, e89= pcall(renderer.measure_text, '', e68)
    if e53 and type(e88) == 'number' then return e88, e89 or 0 end
    e53, e88, e89 = pcall(renderer.measure_text, e68)
    if e53 and type(e88) == 'number' then return e88, e89 or 0 end
    return 0, 0
end

local function e91(e82,e91,e72,e73,e74,e70)
    if not e82 then return end
    e91 = e91 or 4
    if #e88 >= e90 then
        e82(e88, 1)
    end
    e81(e88, {
        text = tostring(e82),
        duration = e91,
        color = { e72 or 255, e73 or 255, e74 or 255, e70 or 255 },
        ts = globals and globals.curtime and globals.curtime() or os.clock(),
    })
    return true
end

local function e110()
    if not renderer or not renderer.text then return end
    local e66= globals and globals.curtime and globals.curtime() or os.clock()
    local e92, e93= client and client.screen_size and client.screen_size() or 800, 600

    local e94= 8
    local e95= 6
    local e96= 14
    local e97= 2

    local e87= e95

    for e60 = #e88, 1, -1 do
        local e52= e88[e60]
        if not e52 then goto continue end
        local e122= e66 - (e52.ts or 0)
        local e98= (e52.duration or 4) - e122
        if e98 <= 0 then
            e82(e88, e60)
        else
            local e62, e99= e92(e52.text)
            
            local e121= e83(e52.color[4] or 255)
            
            pcall(renderer.text, e94, e87, e52.color[1] or 255, e52.color[2] or 255, e52.color[3] or 255, e121, 'b', 0, e52.text)
            e87 = e87 + (e99 > 0 and e99 or e96) + e97
        end
        ::continue::
    end
end

if client and client.set_event_callback then
    client.set_event_callback('paint', e110)
end

return e91]]
e661["require/brain/dll"] = [=[local ffi = require("ffi")

ffi.cdef([[
struct Vec3 { double x; double y; double z; };
struct AspectState { double original; double last; double last_update; int initialized; };
const char* clipboard_get();
int clipboard_set(const char* text);
int clipboard_empty();
int clantag_anim(double start_time, double now, char* out_buf, int out_buf_len);
void tracer_reset();
void tracer_push_shot(double sx, double sy, double sz, double t);
void tracer_set_impact(double ix, double iy, double iz, double t);
int tracer_collect(double now, double tracer_life, double fade_fraction, double pitch, double yaw, double fallback_dist, double base_alpha, double* out_buf, int max_lines);
 ]])


local function hex(val)
    local ok, num = pcall(ffi.cast, "uintptr_t", val)
    if not ok then return "<na>" end
    return string.format("0x%X", tonumber(num))
end

local function resolve_call_trampoline()
    local tramp = client.find_signature("engine.dll", "\xFF\xE1")
    if tramp == nil then
        return nil
    end
    return ffi.cast("void*", tramp)
end

local function make_import_thunk(sig_pattern, cast_type)
    local addr = client.find_signature("engine.dll", sig_pattern)
    if addr == nil then
        return nil
    end
    local ptr = ffi.cast("void***", ffi.cast("uintptr_t", addr) + 2)[0][0]
    return ptr
end

local call_trampoline = resolve_call_trampoline()
local gm_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B", "void *")
local gpa_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05", "void *")

if gm_thunk and gpa_thunk then
else
    return
end

local function via_trampoline(target, signature, label)
    local fn = ffi.cast(signature, call_trampoline)
    return function(...)
        return fn(target, ...)
    end
end

local function to_wide(str)
    local buf = ffi.new("wchar_t[?]", #str + 1)
    for i = 1, #str do buf[i - 1] = string.byte(str, i) end
    buf[#str] = 0
    return buf
end

local GetModuleHandleA_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const char *)", "GMH A")
local GetModuleHandleW_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const wchar_t *)", "GMH W")
local GetProcAddress_tr   = via_trampoline(gpa_thunk, "void *(__thiscall *)(void *, void *, const char *)", "GPA")

local function call_GetModuleHandle(name)
    local ok1, res1 = pcall(GetModuleHandleA_tr, name)
    if not ok1 then dbg("GetModuleHandleA tramp err", res1) end
    if ok1 and res1 ~= nil and res1 ~= ffi.NULL then
        return res1, "tramp ansi"
    end

    local ok2, res2 = pcall(GetModuleHandleW_tr, to_wide(name))
    if not ok2 then dbg("GetModuleHandleW tramp err", res2) end
    if ok2 and res2 ~= nil and res2 ~= ffi.NULL then
        return res2, "tramp wide"
    end

    return nil, "failed"
end

local function call_GetProcAddress(mod, name)
    local ok, res = pcall(GetProcAddress_tr, mod, name)
    if not ok then dbg("GetProcAddress tramp err", res) end
    if ok and res ~= nil and res ~= ffi.NULL then return res end
    return nil
end

local mod, gm_variant = call_GetModuleHandle("sodiumdll.dll")
if mod == nil then
    return
end

local function bind_export(name, cdecl_sig)
    local addr = call_GetProcAddress(mod, name)
    if addr == nil then
        return nil
    end
    return addr, ffi.cast(cdecl_sig, addr)
end

local add_addr, add_fn = bind_export("add", "int(__cdecl*)(int, int)")
local get_value_addr, get_value_fn = bind_export("get_value", "int(__cdecl*)(void)")
local pin_module_addr, pin_module_fn = bind_export("pin_module", "void(__cdecl*)(void)")
local release_module_addr, release_module_fn = bind_export("release_module", "void(__cdecl*)(void)")
local get_hwid_addr, get_hwid_fn = bind_export("get_hwid", "const char*(__cdecl*)(void)")
local clipboard_get_addr, clipboard_get_fn = bind_export("clipboard_get", "const char*(__cdecl*)(void)")
local clipboard_set_addr, clipboard_set_fn = bind_export("clipboard_set", "int(__cdecl*)(const char*)")
local clipboard_empty_addr, clipboard_empty_fn = bind_export("clipboard_empty", "int(__cdecl*)(void)")
local clantag_anim_addr, clantag_anim_fn = bind_export("clantag_anim", "int(__cdecl*)(double, double, char*, int)")
local tracer_reset_addr, tracer_reset_fn = bind_export("tracer_reset", "void(__cdecl*)(void)")
local tracer_push_shot_addr, tracer_push_shot_fn = bind_export("tracer_push_shot", "void(__cdecl*)(double, double, double, double)")
local tracer_set_impact_addr, tracer_set_impact_fn = bind_export("tracer_set_impact", "void(__cdecl*)(double, double, double, double)")
local tracer_collect_addr, tracer_collect_fn = bind_export("tracer_collect", "int(__cdecl*)(double, double, double, double, double, double, double, double*, int)")

local vec_make_addr, vec_make_fn = bind_export("vec_make", "struct Vec3(__cdecl*)(double, double, double)")
local vec_add_addr, vec_add_fn = bind_export("vec_add", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_sub_addr, vec_sub_fn = bind_export("vec_sub", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_mul_scalar_addr, vec_mul_scalar_fn = bind_export("vec_mul_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_div_scalar_addr, vec_div_scalar_fn = bind_export("vec_div_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_unm_addr, vec_unm_fn = bind_export("vec_unm", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_length_addr, vec_length_fn = bind_export("vec_length", "double(__cdecl*)(struct Vec3)")
local vec_dot_addr, vec_dot_fn = bind_export("vec_dot", "double(__cdecl*)(struct Vec3, struct Vec3)")
local vec_cross_addr, vec_cross_fn = bind_export("vec_cross", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_normalized_addr, vec_normalized_fn = bind_export("vec_normalized", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_distance_addr, vec_distance_fn = bind_export("vec_distance", "double(__cdecl*)(struct Vec3, struct Vec3)")

local m_clamp_addr, m_clamp_fn = bind_export("m_clamp", "double(__cdecl*)(double, double, double)")
local m_clamp01_addr, m_clamp01_fn = bind_export("m_clamp01", "double(__cdecl*)(double)")
local m_abs_addr, m_abs_fn = bind_export("m_abs", "double(__cdecl*)(double)")
local m_lerp_addr, m_lerp_fn = bind_export("m_lerp", "double(__cdecl*)(double, double, double)")
local m_distance2d_addr, m_distance2d_fn = bind_export("m_distance2d", "double(__cdecl*)(double, double, double, double)")
local m_distance3d_addr, m_distance3d_fn = bind_export("m_distance3d", "double(__cdecl*)(double, double, double, double, double, double)")
local m_rad_to_deg_addr, m_rad_to_deg_fn = bind_export("m_rad_to_deg", "double(__cdecl*)(double)")
local m_deg_to_rad_addr, m_deg_to_rad_fn = bind_export("m_deg_to_rad", "double(__cdecl*)(double)")
local m_wrap_degrees_addr, m_wrap_degrees_fn = bind_export("m_wrap_degrees", "double(__cdecl*)(double)")
local m_normalize_angle_addr, m_normalize_angle_fn = bind_export("m_normalize_angle", "double(__cdecl*)(double)")
local m_angle_diff_addr, m_angle_diff_fn = bind_export("m_angle_diff", "double(__cdecl*)(double, double)")
local m_lerp_angle_addr, m_lerp_angle_fn = bind_export("m_lerp_angle", "double(__cdecl*)(double, double, double)")
local m_map_addr, m_map_fn = bind_export("m_map", "double(__cdecl*)(double, double, double, double, double)")
local m_smoothstep_addr, m_smoothstep_fn = bind_export("m_smoothstep", "double(__cdecl*)(double, double, double)")
local aspect_update_addr, aspect_update_fn = bind_export("aspect_update", "void(__cdecl*)(void*, double, double, double, double*, int*)")

if not (add_fn and get_value_fn and pin_module_fn and release_module_fn and get_hwid_fn and
    vec_make_fn and vec_add_fn and vec_sub_fn and vec_mul_scalar_fn and vec_div_scalar_fn and
    vec_unm_fn and vec_length_fn and vec_dot_fn and vec_cross_fn and vec_normalized_fn and vec_distance_fn and
    m_clamp_fn and m_clamp01_fn and m_abs_fn and m_lerp_fn and m_distance2d_fn and m_distance3d_fn and
    m_rad_to_deg_fn and m_deg_to_rad_fn and m_wrap_degrees_fn and m_normalize_angle_fn and m_angle_diff_fn and
    m_lerp_angle_fn and m_map_fn and m_smoothstep_fn and aspect_update_fn and
    clipboard_get_fn and clipboard_set_fn and clipboard_empty_fn and clantag_anim_fn and
    tracer_reset_fn and tracer_push_shot_fn and tracer_set_impact_fn and tracer_collect_fn) then
    return
end

local Call_add = via_trampoline(add_addr, "int(__thiscall *)(void*, int, int)", "add")
local Call_get_value = via_trampoline(get_value_addr, "int(__thiscall *)(void*)", "get_value")
local Call_pin_module = via_trampoline(pin_module_addr, "void(__thiscall *)(void*)", "pin_module")
local Call_release_module = via_trampoline(release_module_addr, "void(__thiscall *)(void*)", "release_module")
local Call_get_hwid = via_trampoline(get_hwid_addr, "const char*(__thiscall *)(void*)", "get_hwid")
local Call_clipboard_get = via_trampoline(clipboard_get_addr, "const char*(__thiscall *)(void*)", "clipboard_get")
local Call_clipboard_set = via_trampoline(clipboard_set_addr, "int(__thiscall *)(void*, const char*)", "clipboard_set")
local Call_clipboard_empty = via_trampoline(clipboard_empty_addr, "int(__thiscall *)(void*)", "clipboard_empty")
local Call_clantag_anim = via_trampoline(clantag_anim_addr, "int(__thiscall *)(void*, double, double, char*, int)", "clantag_anim")
local Call_tracer_reset = via_trampoline(tracer_reset_addr, "void(__thiscall *)(void*)", "tracer_reset")
local Call_tracer_push_shot = via_trampoline(tracer_push_shot_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_push_shot")
local Call_tracer_set_impact = via_trampoline(tracer_set_impact_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_set_impact")
local Call_tracer_collect = via_trampoline(tracer_collect_addr, "int(__thiscall *)(void*, double, double, double, double, double, double, double, double*, int)", "tracer_collect")
local Call_vec_make = via_trampoline(vec_make_addr, "struct Vec3(__thiscall *)(void*, double, double, double)", "vec_make")
local Call_vec_add = via_trampoline(vec_add_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_add")
local Call_vec_sub = via_trampoline(vec_sub_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_sub")
local Call_vec_mul_scalar = via_trampoline(vec_mul_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_mul_scalar")
local Call_vec_div_scalar = via_trampoline(vec_div_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_div_scalar")
local Call_vec_unm = via_trampoline(vec_unm_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_unm")
local Call_vec_length = via_trampoline(vec_length_addr, "double(__thiscall *)(void*, struct Vec3)", "vec_length")
local Call_vec_dot = via_trampoline(vec_dot_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_dot")
local Call_vec_cross = via_trampoline(vec_cross_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_cross")
local Call_vec_normalized = via_trampoline(vec_normalized_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_normalized")
local Call_vec_distance = via_trampoline(vec_distance_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_distance")

local Call_m_clamp = via_trampoline(m_clamp_addr, "double(__thiscall *)(void*, double, double, double)", "m_clamp")
local Call_m_clamp01 = via_trampoline(m_clamp01_addr, "double(__thiscall *)(void*, double)", "m_clamp01")
local Call_m_abs = via_trampoline(m_abs_addr, "double(__thiscall *)(void*, double)", "m_abs")
local Call_m_lerp = via_trampoline(m_lerp_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp")
local Call_m_distance2d = via_trampoline(m_distance2d_addr, "double(__thiscall *)(void*, double, double, double, double)", "m_distance2d")
local Call_m_distance3d = via_trampoline(m_distance3d_addr, "double(__thiscall *)(void*, double, double, double, double, double, double)", "m_distance3d")
local Call_m_rad_to_deg = via_trampoline(m_rad_to_deg_addr, "double(__thiscall *)(void*, double)", "m_rad_to_deg")
local Call_m_deg_to_rad = via_trampoline(m_deg_to_rad_addr, "double(__thiscall *)(void*, double)", "m_deg_to_rad")
local Call_m_wrap_degrees = via_trampoline(m_wrap_degrees_addr, "double(__thiscall *)(void*, double)", "m_wrap_degrees")
local Call_m_normalize_angle = via_trampoline(m_normalize_angle_addr, "double(__thiscall *)(void*, double)", "m_normalize_angle")
local Call_m_angle_diff = via_trampoline(m_angle_diff_addr, "double(__thiscall *)(void*, double, double)", "m_angle_diff")
local Call_m_lerp_angle = via_trampoline(m_lerp_angle_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp_angle")
local Call_m_map = via_trampoline(m_map_addr, "double(__thiscall *)(void*, double, double, double, double, double)", "m_map")
local Call_m_smoothstep = via_trampoline(m_smoothstep_addr, "double(__thiscall *)(void*, double, double, double)", "m_smoothstep")
local Call_aspect_update = via_trampoline(aspect_update_addr, "void(__thiscall *)(void*, void*, double, double, double, double*, int*)", "aspect_update")


return {
    add = function(a, b)
        return Call_add(a, b)
    end,
    get_value = function()
        return Call_get_value()
    end,
    pin_module = function()
        return Call_pin_module()
    end,
    release_module = function()
        return Call_release_module()
    end,
    get_hwid = function()
        return Call_get_hwid()
    end,
    clipboard_get = function()
        return Call_clipboard_get()
    end,
    clipboard_set = function(text)
        return Call_clipboard_set(text)
    end,
    clipboard_empty = function()
        return Call_clipboard_empty()
    end,
    clantag_anim = function(start_time, now, out_buf, out_buf_len)
        return Call_clantag_anim(start_time, now, out_buf, out_buf_len)
    end,
    tracer_reset = function()
        return Call_tracer_reset()
    end,
    tracer_push_shot = function(sx, sy, sz, t)
        return Call_tracer_push_shot(sx, sy, sz, t)
    end,
    tracer_set_impact = function(ix, iy, iz, t)
        return Call_tracer_set_impact(ix, iy, iz, t)
    end,
    tracer_collect = function(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
        return Call_tracer_collect(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
    end,
    vec_make = function(x, y, z)
        return Call_vec_make(x, y, z)
    end,
    vec_add = function(a, b)
        return Call_vec_add(a, b)
    end,
    vec_sub = function(a, b)
        return Call_vec_sub(a, b)
    end,
    vec_mul_scalar = function(v, s)
        return Call_vec_mul_scalar(v, s)
    end,
    vec_div_scalar = function(v, s)
        return Call_vec_div_scalar(v, s)
    end,
    vec_unm = function(v)
        return Call_vec_unm(v)
    end,
    vec_length = function(v)
        return Call_vec_length(v)
    end,
    vec_dot = function(a, b)
        return Call_vec_dot(a, b)
    end,
    vec_cross = function(a, b)
        return Call_vec_cross(a, b)
    end,
    vec_normalized = function(v)
        return Call_vec_normalized(v)
    end,
    vec_distance = function(a, b)
        return Call_vec_distance(a, b)
    end,
    m_clamp = function(val, minVal, maxVal)
        return Call_m_clamp(val, minVal, maxVal)
    end,
    m_clamp01 = function(val)
        return Call_m_clamp01(val)
    end,
    m_abs = function(val)
        return Call_m_abs(val)
    end,
    m_lerp = function(a, b, t)
        return Call_m_lerp(a, b, t)
    end,
    m_distance2d = function(x1, y1, x2, y2)
        return Call_m_distance2d(x1, y1, x2, y2)
    end,
    m_distance3d = function(x1, y1, z1, x2, y2, z2)
        return Call_m_distance3d(x1, y1, z1, x2, y2, z2)
    end,
    m_rad_to_deg = function(rad)
        return Call_m_rad_to_deg(rad)
    end,
    m_deg_to_rad = function(deg)
        return Call_m_deg_to_rad(deg)
    end,
    m_wrap_degrees = function(angle)
        return Call_m_wrap_degrees(angle)
    end,
    m_normalize_angle = function(angle)
        return Call_m_normalize_angle(angle)
    end,
    m_angle_diff = function(a, b)
        return Call_m_angle_diff(a, b)
    end,
    m_lerp_angle = function(a, b, t)
        return Call_m_lerp_angle(a, b, t)
    end,
    m_map = function(val, in_min, in_max, out_min, out_max)
        return Call_m_map(val, in_min, in_max, out_min, out_max)
    end,
    m_smoothstep = function(edge0, edge1, x)
        return Call_m_smoothstep(edge0, edge1, x)
    end,
    aspect_update = function(state, raw_slider, current_aspect, now, out_target, out_dirty)
        return Call_aspect_update(state, raw_slider, current_aspect, now, out_target, out_dirty)
    end,
    module_base = mod,
}]=]
e661["require/brain/test"] = [[local e96= require("require/brain/api/math/math")
local e97= require("require/brain/api/health/health")
local e98= require("require/brain/api/hwid/hwid")
local e64= require("require/brain/dll")


client.set_event_callback("paint_ui", function()
    local e53, e63= pcall(e96.add, 2, math.random(1, 100))
    if e53 then
        
    end

end)

local e99, e100= pcall(e98.get_hwid)
if e99 and e100 and e100 ~= "" then
    
else
    
end]]
e661["require/brain/api/clipboard/clipboard"] = [[]]
e661["require/brain/api/health/health"] = [[local e64= require("require/brain/dll")

if not e64 then
	error("sodiumdll exports unavailable")
end

return {
	pin_module = function()
		return e64.pin_module()
	end,
	release_module = function()
		return e64.release_module()
	end,
	module_base = e64.module_base,
}]]
e661["require/brain/api/hwid/hwid"] = [[local e63= require("ffi")
local e64= require("require/brain/dll")

if not e64 or not e64.get_hwid then
    error("sodiumdll hwid export missing")
end

return {
	get_hwid = function()
		local e105= e64.get_hwid()
		if not e105 or e105 == e63.NULL then
			return ""
		end
		return e63.string(e105)
	end,
}]]
e661["require/brain/api/ip/ip"] = [[
local e64= require("require/brain/dll")

if not e64 or not e64.get_public_ip then
	return error("sodiumdll ip export missing")
end

return {
	get_public_ip = function(e108,e109)
		return e64.get_public_ip(e108, e109)
	end,
}]]
e661["require/brain/api/math/math"] = [[local e64= require("require/brain/dll")

if not e64 or not e64.m_clamp then
	error("sodiumdll math exports missing")
end

return {
	add = function(e70,e74)
		return e64.add(e70, e74)
	end,
	get_value = function()
		return e64.get_value()
	end,
	m_clamp = function(e54,e111,e112)
		return e64.m_clamp(e54, e111, e112)
	end,
	m_clamp01 = function(e54)
		return e64.m_clamp01(e54)
	end,
	m_abs = function(e54)
		return e64.m_abs(e54)
	end,
	m_lerp = function(e70,e74,e56)
		return e64.m_lerp(e70, e74, e56)
	end,
	m_distance2d = function(e113,e114,e115,e116)
		return e64.m_distance2d(e113, e114, e115, e116)
	end,
	m_distance3d = function(e113,e114,e117,e115,e116,e118)
		return e64.m_distance3d(e113, e114, e117, e115, e116, e118)
	end,
	m_rad_to_deg = function(e100)
		return e64.m_rad_to_deg(e100)
	end,
	m_deg_to_rad = function(e119)
		return e64.m_deg_to_rad(e119)
	end,
	m_wrap_degrees = function(e120)
		return e64.m_wrap_degrees(e120)
	end,
	m_normalize_angle = function(e120)
		return e64.m_normalize_angle(e120)
	end,
	m_angle_diff = function(e70,e74)
		return e64.m_angle_diff(e70, e74)
	end,
	m_lerp_angle = function(e70,e74,e56)
		return e64.m_lerp_angle(e70, e74, e56)
	end,
	m_map = function(e54,e121,e122,e123,e124)
		return e64.m_map(e54, e121, e122, e123, e124)
	end,
	m_smoothstep = function(e125,e126,e59)
		return e64.m_smoothstep(e125, e126, e59)
	end,
}]]
e661["require/brain/api/vector/vector"] = [[local e63= require("ffi")
local e64= require("require/brain/dll")

if not e64 or not e64.vec_make or not e64.vec_add or not e64.vec_sub or not e64.vec_mul_scalar or
   not e64.vec_div_scalar or not e64.vec_unm or not e64.vec_length or not e64.vec_dot or
   not e64.vec_cross or not e64.vec_normalized or not e64.vec_distance or not e64.aspect_update then
    error("sodiumdll vector exports missing")
end

local e114= e63.typeof("struct Vec3")

local function e115(e63)
    if e63.istype(e114, e63) then
        return e63
    end
    local e59= (e63 and e63.x) or 0
    local e87= (e63 and e63.y) or 0
    local e116= (e63 and e63.z) or 0
    return e64.vec_make(e59, e87, e116)
end

return {
    Vec3 = e114,
    make = function(e59,e87,e116)
        return e64.vec_make(e59 or 0, e87 or 0, e116 or 0)
    end,
    add = function(e70,e74)
        return e64.vec_add(e115(e70), e115(e74))
    end,
    sub = function(e70,e74)
        return e64.vec_sub(e115(e70), e115(e74))
    end,
    mul_scalar = function(e63,e88)
        return e64.vec_mul_scalar(e115(e63), e88)
    end,
    div_scalar = function(e63,e88)
        return e64.vec_div_scalar(e115(e63), e88)
    end,
    unm = function(e63)
        return e64.vec_unm(e115(e63))
    end,
    length = function(e63)
        return e64.vec_length(e115(e63))
    end,
    dot = function(e70,e74)
        return e64.vec_dot(e115(e70), e115(e74))
    end,
    cross = function(e70,e74)
        return e64.vec_cross(e115(e70), e115(e74))
    end,
    normalized = function(e63)
        return e64.vec_normalized(e115(e63))
    end,
    distance = function(e70,e74)
        return e64.vec_distance(e115(e70), e115(e74))
    end,
    aspect_update = e64.aspect_update,
}]]
e661["require/brain/examples/boxes"] = [[local e63= require("ffi")
local e117= {


}


e117.GetModuleHandlePtr = 
    e63.cast(
        "void***", 
        e63.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B")) + 2
    )[0][0]

e117.GetProcAddressPtr = 
    e63.cast(
        "void***", 
        e63.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05")) + 2
    )[0][0]


e117.reinterpret_cast = function(e118,e119) 
    return function(...) 
        return e63.cast(e119, client.find_signature("engine.dll", "\xFF\xE1"))(e118, ...) 
    end
end


e117.fnGetModuleHandle = e117.reinterpret_cast(
    e117.GetModuleHandlePtr, 
    "void*(__thiscall*)(void*, const char*)"
)

e117.GetModuleHandle = function(e120)
    return e117.fnGetModuleHandle(e120)
end 


e117.fnGetProcAddress = e117.reinterpret_cast(
    e117.GetProcAddressPtr, 
    "void*(__thiscall*)(void*, void*, const char*)"
)

e117.GetProcAddress = function(e120,e121)
    local e118= e117.fnGetProcAddress(e120, e121)
    return e118
end 


e117.lib = {}
e117.lib.user32 = e117.GetModuleHandle("user32.dll")


e117.export = {}
e117.export.user32 = {}

e117.export.user32.MessageBoxPtr = e117.GetProcAddress(e117.lib.user32, "MessageBoxA")
e117.export.user32.MessageBox = e117.reinterpret_cast(
    e117.export.user32.MessageBoxPtr,
    "int(__thiscall*)(void*, void*, const char*, const char*, unsigned int)"
)


local e122= 0x00000000
local e123= 0x00000001
local e124= 0x00000004
local e125= 0x00000010
local e126= 0x00000020
local e127= 0x00000030
local e128= 0x00000040


local e129= 1
local e130= 2
local e131= 6
local e132= 7


local function e133(e82,e134,type)
    e134 = e134 or "Gamesense"
    type = type or e122
    
    local e670= e117.export.user32.MessageBox(nil, e82, e134, type)
    return e670
end


local function e135(e82,e134)
    return e133(e82, e134, e122 + e128)
end

local function e136(e82,e134)
    return e133(e82, e134, e122 + e127)
end

local function e137(e82,e134)
    return e133(e82, e134, e122 + e125)
end

local function e138(e82,e134)
    local e670= e133(e82, e134, e124 + e126)
    return e670 == e131
end
e135("test", "test")]]
e661["require/brain/features/aspectratio"] = [[local e63= require("ffi")
local e64= require("require/brain/dll")

if not e64 or not e64.aspect_update then
    error("sodiumdll aspect_update export missing")
end

return {
    aspect_update = function(e120,e121,e122,e66)
        local e123= e63.new("double[1]")
        local e124= e63.new("int[1]")

        e64.aspect_update(e120 or e63.NULL, e121, e122, e66, e123, e124)

        return e123[0], e124[0]
    end,
}]]
e661["require/features/aa/aa_collect"] = [[
local e123= entity
local e47= require('require/abc/menu_setup')
local e124= require('require/aa/player_condition')

local e125= {}
e125.last_side = 'left'

local function e126()
    local e53, e50= pcall(e124.get)
    if not e53 or not e50 then return nil end
    local e95= 'delay_' .. e50
    if not (e47 and e47.ui) then return nil end
    local e127= e47.ui[e95]
    if not e127 then return nil end
    local e128, e54= pcall(ui.get, e127)
    if not e128 then return nil end
    local e129= tonumber(e54)
    if e129 then return e129 end
    return e54
end

local function e130()
    local e53, e50= pcall(e124.get)
    if not e53 or not e50 then return nil end
    local e95= 'fifty_fifty_' .. e50
    if not (e47 and e47.ui) then return nil end
    local e127= e47.ui[e95]
    if not e127 then return nil end
    local e128, e54= pcall(ui.get, e127)
    if not e128 then return nil end
    local e129= tonumber(e54)
    if e129 then return e129 end
    return e54
end

local function e131()
    local e53, e50= pcall(e124.get)
    if not e53 or not e50 then return nil end
    local e95= 'body_yaw_mode_' .. e50
    if not (e47 and e47.ui) then return nil end
    local e127= e47.ui[e95]
    if not e127 then return nil end
    local e128, e54= pcall(ui.get, e127)
    if not e128 then return nil end
    local e129= tonumber(e54)
    if e129 then return e129 end
    return e54
end

local function e132(e133)
    if not (e123 and e123.get_prop and e133) then return e125.last_side end
    local e134= e123.get_prop(e133, 'm_flPoseParameter', 11)
    if e134 == nil then
        return e125.last_side
    end
    local e135= (e134 > 0.5) and 'right' or 'left'
    e125.last_side = e135
    return e135
end

local function e136()
    local e84= e126() + 1
    local e129= tonumber(e84) or 1
    if e129 < 1 then e129 = 1 end
    if e129 > 17 then e129 = 17 end

    local e63= globals.tickcount()
    if not e63 then return e125.last_side end

    local e137= math.floor(e63 / e129) % 2
    local e135= (e137 == 0) and 'left' or 'right'
    e125.last_side = e135
    return e135
end




local function e138()

    local e139= e130()

    if e139 then
        local e72= math.random(0, 1)
        local e135= (e72 == 0) and 'left' or 'right'
        e125.last_side = e135
        return e135
    end

    local e84= e126()
    local e129= tonumber(e84)

    if e131() ~= 'jitter' then
        return e132(e123.get_local_player())
    end

    if not e129 or e129 == 0 then
        local e133= e123.get_local_player()
        if not e133 or e133 == 0 then return e125.last_side end
        return e132(e133)
    else
        return e136()
    end
end





e125.resolve_side = e132
e125.resolve_local_side = e138
e125.get_delay_for_current_condition = e126

return e125]]
e661["require/features/aa/antiaim"] = [[local e126= require('require/features/aa/builder')
local e127= require('require/features/aa/defensive')

local e51= require('require/abc/callbacks')

local function e128()
    local e129= (globals.maxplayers and globals.maxplayers() or 64)
    local e130, e131, e132= entity.get_classname, entity.is_enemy, entity.is_alive
    if not (e130 and e131 and e132) then return 0 end
    local e133= 0
    for e60=1,e129 do
        if e130(e60) == 'CCSPlayer' and e131(e60) and e132(e60) then e133 = e133 + 1 end
    end
    return e133
end

e51.register('setup_command', function(e91)
    if e126 and e126.activate then
        e126.activate(e91)
    end

end, { alive_only = true, require_login = true })]]
e661["require/features/aa/antibrute"] = [[]]
e661["require/features/aa/builder"] = [[local e47= require('require/abc/menu_setup')
local e124= require('require/aa/player_condition')
local e132= require('require/features/aa/aa_collect')
local e133= require('require/help/math')
local e134= require('require/help/vector')
local e135= require('require/help/time')
local e136= require('require/help/string')

local e137= {}
client.set_event_callback('weapon_fire', function(e138)
  if not e138 or not e138.userid then return end
  local e139, e140= pcall(client.userid_to_entindex, e138.userid)
  if not e139 or not e140 or e140 == 0 then return end
  e137[e140] = e135.tickcount()
end)

local function e141(e50)
	if not e50 then return nil end

	local e117= {
		pitch = 'pitch_',
		yaw_base = 'yaw_base_',
		yaw = 'yaw_',
		body_yaw_base = 'body_yaw_base_',
		body_yaw_left = 'body_yaw_left_',
		body_yaw_right = 'body_yaw_right_',
		randomize_yaw = 'randomize_yaw_',
		yaw_jitter = 'yaw_jitter_',
		yaw_jitter_base = 'yaw_jitter_base_',
		body_yaw_mode = 'body_yaw_mode_',
		static_body_yaw = 'static_body_yaw_',
		body_yaw_value = 'body_yaw_value_',
		delay = 'delay_',
		fifty_fifty = 'fifty_fifty_',
		only_flip_on_0_choke = 'only_flip_on_0_choke_',
	}

	local e82= { condition = e50 }
	for e59, e142 in pairs(e117) do
		local e95= e142 .. e50
		local e127= e47.ui and e47.ui[e95]
		if e127 then
			local e53, e54= pcall(ui.get, e127)
			if e53 then e82[e59] = e54 else e82[e59] = nil end
		else
			e82[e59] = nil
		end
	end

	return e82
end




local function e143()
  local e53, e50= pcall(e124.get)
  if not e53 or not e50 then
    return nil
  end
  local e144= e141(e50)
  return e144 and e144.pitch or nil
end




local function e145()
  local e53, e50= pcall(e124.get)
  if not e53 or not e50 then
    return nil
  end
  local e144= e141(e50)
  local e72= e144 and e144.yaw_base or nil
  if e72 == nil then return nil end
  local e88= e136.lower(tostring(e72))
  if e88 == 'threat' then
    return 'local view'
  elseif e88 == 'distance' then
    return 'local view'
  elseif e88 == 'target' then
    return 'at targets'
  elseif e88 == 'view' then
    return 'local view'
  elseif e88 == 'smart' then
    return 'local view'
  else
    return tostring(e72)
  end
end




local function e146()
	local e53, e50= pcall(e124.get)
	if not e53 or not e50 then
		return nil
	end
	local e144= e141(e50)
	return e144 and e144.yaw or nil
end




local function e147()
    local e53, e50= pcall(e124.get)
    if not e53 or not e50 then
        return nil
    end
    local e144= e141(e50)
    return e144 and e144.yaw_jitter or nil
end




local function e148()
  local e53, e50= pcall(e124.get)
  if not e53 or not e50 then
    return nil
  end
  local e144= e141(e50)
  return e144 and e144.yaw_jitter_base or nil
end




local function e149()
  local e53, e50= pcall(e124.get)
  if not e53 or not e50 then return nil end
  local e144= e141(e50)
  if not e144 then return nil end
  local e63= e144.randomize_yaw
  if e63 == nil then return nil end
  local e129= tonumber(e63)
  if not e129 then return nil end
  if e129 < 0 then e129 = 0 end
  if e129 > 30 then e129 = 30 end
  return math.floor(e129)
end




local function e131()
    local e53, e50= pcall(e124.get)
    if not e53 or not e50 then
        return nil
    end
  local e144= e141(e50)
  local e62= e144 and e144.body_yaw_mode or nil
  if not e62 then return nil end
  local e150= e136.lower(tostring(e62))
  if e150 == 'jitter' then
    local e84= e132.get_delay_for_current_condition and e132.get_delay_for_current_condition() or nil
    local e129= tonumber(e84) or 0
    if e129 > 0 then
      return 'static'
    else
      return 'jitter'
    end
  end
  return e62
end




local function e151()
  local e53, e50= pcall(e124.get)
  if not e53 or not e50 then
    return nil
  end
  local e144= e141(e50)
  if not e144 then return nil end


  local e62= e144.body_yaw_mode
  if e62 ~= nil then e62 = e136.lower(tostring(e62)) end

  if e62 == 'jitter' then
    local e84= e132.get_delay_for_current_condition and e132.get_delay_for_current_condition() or nil
    local e152= tonumber(e84) or 0
    if e152 > 0 then
      local e135= e132.resolve_local_side and e132.resolve_local_side() or nil
      if e135 == 'right' then
        return -58
      else
        return 58
      end
    end

    local e72= e144.body_yaw_value
    local e129= tonumber(e72) or nil
    if e129 == 1 then
      return -180
    elseif e129 == 2 then
      return 0
    elseif e129 == 3 then
      return 180
    end
    return nil
  elseif e62 == 'static' then
    if e144.static_body_yaw ~= nil then
      local e76= tonumber(e144.static_body_yaw)
      if e76 then return e76 end
    end
    local e72= e144.body_yaw_value
    local e129= tonumber(e72) or nil
    if e129 == 1 then
      return -180
    elseif e129 == 2 then
      return 0
    elseif e129 == 3 then
      return 180
    end
    return nil
  else
    return 0
  end
end




local function e153()
  local e53, e50= pcall(e124.get)
  if not e53 or not e50 then
    return nil
  end
  local e144= e141(e50)
  return e144 and e144.body_yaw_base or nil
end




local function e154()
    local e53, e50= pcall(e124.get)
    if not e53 or not e50 then
        return nil
    end
    local e144= e141(e50)
    return e144 and e144.body_yaw_left or nil
end




local function e155()
    local e53, e50= pcall(e124.get)
    if not e53 or not e50 then
        return nil
    end
    local e144= e141(e50)
    return e144 and e144.body_yaw_right or nil
end




local function e156()
    local e53, e50= pcall(e124.get)
    if not e53 or not e50 then
        return nil
    end
    local e144= e141(e50)
    if not e144 then return nil end
    local e63= e144.only_flip_on_0_choke
    if e63 == nil then return nil end
    return not not e63
end




local function e126()
  local e53, e50= pcall(e124.get)
  if not e53 or not e50 then
    return nil
  end
  local e95= 'delay_' .. e50
  if not (e47 and e47.ui) then return nil end
  local e127= e47.ui[e95]
  if not e127 then return nil end
  local e128, e54= pcall(ui.get, e127)
  if e128 then return e54 end
  return nil
end




local function e130()
  local e53, e50= pcall(e124.get)
  if not e53 or not e50 then return nil end
  local e144= e141(e50)
  if not e144 then return nil end
  local e63= e144.fifty_fifty
  if e63 == nil then return nil end
  return not not e63
end





local function e157(e62)
  local e150= e136.lower(tostring(e62 or 'threat'))

  local e158= nil
  if e150 == 'distance' then
    local e159, e160= pcall(entity.get_players, true)
    if not e159 or not e160 or #e160 == 0 then return nil end
    local e133= entity.get_local_player()
    if not e133 then return nil end
    local e161, e162, e163, e164= pcall(entity.get_origin, e133)
    if not e161 or not e162 then return nil end
    local e165= nil
    local e166= nil
    for e62, e140 in ipairs(e160) do
      if e140 and entity.is_alive and entity.is_alive(e140) and entity.is_enemy and entity.is_enemy(e140) then
        local e167, e168, e169, e170= pcall(entity.get_origin, e140)
        if e167 and e168 then
          local e171= e133.distance2d(e162, e163, e168, e169)
          if not e166 or e171 < e166 then
            e166 = e171
            e165 = e140
          end
        end
      end
    end
    e158 = e165
    elseif e150 == 'smart' then
      local e159, e160= pcall(entity.get_players, true)
      if e159 and e160 and #e160 > 0 then
        local e133= entity.get_local_player()
        if e133 then
          local e161, e162, e163, e164= pcall(entity.get_origin, e133)
          if e161 and e162 then
            local e165= nil
            local e166= nil
            for e62, e140 in ipairs(e160) do
              if e140 and entity.is_alive and entity.is_alive(e140) and entity.is_enemy and entity.is_enemy(e140) then
                local e167, e168, e169, e170= pcall(entity.get_origin, e140)
                if e167 and e168 then
                  local e172= e137[e140]
                  if e172 and e135.within_ticks_window(e172, 10) then goto continue_smart end
                  local e173, e88= pcall(entity.get_player_weapon, e140)
                  if e173 and e88 and e88 ~= 0 then
                    local e174, e175= pcall(entity.get_classname, e88)
                    local e176= e136.lower(e174 and e175 and tostring(e175) or '')
                    if e176:find('knife') or e176:find('grenade') or e176:find('taser') or e176:find('zeus') then goto continue_smart end
                  end
                  do
                    local e171= e133.distance2d(e162, e163, e168, e169)
                    if not e166 or e171 < e166 then
                      e166 = e171
                      e165 = e140
                    end
                  end
                  ::continue_smart::
                end
              end
            end
            e158 = e165
          end
        end
      end
      if not e158 then
        local e177, e56= pcall(client.current_threat)
        if e177 and e56 then e158 = e56 end
      end
    else
      local e177, e56= pcall(client.current_threat)
      if e177 and e56 then e158 = e56 end
    end

  if not e158 then return nil end
  if not (entity.is_alive and entity.is_enemy and entity.is_alive(e158) and entity.is_enemy(e158)) then
    return nil
  end

  local e133= entity.get_local_player()
  if not e133 then return nil end

  local e178, e162, e163, e164= pcall(entity.get_origin, e133)
  local e179, e168, e169, e170= pcall(entity.get_origin, e158)
  if not e178 or not e179 or not e162 or not e168 then return nil end

  local e180= e168 - e162
  local e181= e169 - e163
  local e182= math.atan2(e181, e180)
  local e183= e133.rad_to_deg(e182)

  local e184, e185, e186= pcall(client.camera_angles)
  local e187= e184 and e186 or 0

  local e188= e133.normalize_angle(e183 - e187)
  return e133 and e133.round and e133.round(e188) or math.floor(e188 + 0.5)

end




local e189= {}
local e190= {}
for e60, e52 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
    for e62, e75 in ipairs(e82) do
        e190[e75] = true
    end
end





local function e191(e91)
  if weaponn ~= nil and entity.get_classname(weaponn) == "CC4" then
    if e91.in_attack == 1 then
        e91.in_attack = 0 
        e91.in_use = 1
    end
  else
    if e91.chokedcommands == 0 then
        e91.in_use = 0
    end
  end

end





local function e192(e91)

    local e193= e91.chokedcommands
    
    if e156() then
        if e193 > 0 then
            return
        end
    end

    local e135= e132.resolve_local_side()

    
    
    
    ui.set(e189[2][1], tostring(e143()))

    
    
    
    ui.set(e189[3][1], tostring(e145()))

    
    
    
    local e194= e146()
    if e194 == "3way" then
      e194 = '180'
    elseif e194 == "ideal" then
      e194 = '180'
    end
    ui.set(e189[4][1], e194)

    
    
    
    ui.set(e189[5][1], tostring(e147()))

    
    
    
    ui.set(e189[5][2], tostring(e148()))

    
    
    
    ui.set(e189[6][1], tostring(e131()))

    
    
    
    ui.set(e189[6][2], tostring(e151()))

    
    
    
    local e195= tonumber(e153()) or 0
    local e82= 0
    if ui.get(e189[4][1]) == '180' then
      if e135 == 'right' then
        e82 = tonumber(e154()) or 0
      elseif e135 == 'left' then
        e82 = tonumber(e155()) or 0
      end
    end
    local e196= e195 + e82
    local e197= tonumber(e149()) or 0
    if e197 > 0 then
      local e198= math.abs(e196) * (e197 / 100)
      local e199= (e133.random_int(-1000, 1000) / 1000)
      local e200= e199 * e198
      e196 = e196 + e200
    end

    do
      local e201, e50= pcall(e124.get)
      if e201 and e50 then
        local e144= e141(e50)
        if e144 then
          local e202= e136.lower(tostring(e144.yaw_base or ''))
          if e202 == 'threat' or e202 == 'distance' then
            local e203= e157(e202)
            if e203 then
              e196 = e196 + tonumber(e203) or e196
            end
          end
        end
      end
    end

    local e204= e133.normalize_angle(e196)
    ui.set(e189[4][2], e133.round(e204))

    
    
    
    e191(e91)

end


return {
  gather = e141,
  activate = e192,
  print_current = e192,
}]]
e661["require/features/aa/defensive"] = [[local e135= {}
e135.active = nil
e135.activate = nil
local e136= require('require/help/time')
local e47= require('require/abc/menu_setup')
local e137= require('require/features/aa/defensive_presets')
local e124= require('require/aa/player_condition')
local e50= require('require/abc/screen_logger')
local e138, e51= pcall(require, 'require/abc/callbacks')




local e189= {}
local e190= {}
for e60, e52 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'RAGE', 'Aimbot', 'Double tap' },
    { 'RAGE', 'Other', 'Duck peek assist' },

}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
    for e62, e75 in ipairs(e82) do
        e190[e75] = true
    end
end


local e139= {
    cond = nil,
    idx = nil,
    preset = nil,
    selected_tick = 0,
}
local e140= false
local e141= 0





local e142= {
    last = false,
    pending_until = nil,
}
local function e143()
    local e53, e63= pcall(ui.get, e189[10][2])
    local e144= e53 and not not e63 or false
    local e63= e136.tickcount() or (globals and globals.tickcount and globals.tickcount()) or 0
    if e144 and not e142.last then
        e142.pending_until = e63 + 32
    end
    if not e144 then
        e142.pending_until = nil
    end
    e142.last = e144
    if e142.pending_until then
        return e63 >= e142.pending_until
    end
    return e144
end

local function e145()
    local e82= e189[11]
    if not e82 or not e82[1] then
        return false
    end
    local e53, e63= pcall(ui.get, e82[1])
    return e53 and not not e63 or false
end

local function e146()
  local e56= entity.get_local_player()
  if not e56 or not entity.is_alive(e56) then
    return false
  end
  local e147= entity.get_player_weapon(e56)
  if not e147 then
    return false
  end
  local e148= entity.get_classname(e147)
  return e148 == "CKnife"
end




local function e149()
    if not e47 or type(e47) ~= 'table' or not e47.ui then
        return false
    end
    local e75= e47.ui.fakelag_defensive
    if not e75 then
        return false
    end
    local e53, e63= pcall(ui.get, e75)
    return e53 and not not e63 or false
end

local function e150()
    if not e47 or type(e47) ~= 'table' or not e47.ui then
        return false
    end
    local e75= e47.ui.fakelag_force
    if not e75 then
        return false
    end
    local e53, e63= pcall(ui.get, e75)
    return e53 and not not e63 or false
end

local function e151(e91)

    


    local e63= (globals and globals.tickcount and globals.tickcount()) or e136.tickcount() or 0
    e141 = e63
end




local function e152(e153)

    e153 = e153 or 20
    local e154= entity.get_local_player()
    if not e154 then return false end
    local e155= entity.get_prop(e154, "m_flSimulationTime")
    local e156= 1 / globals.tickinterval()
    if not e155 or e156 == 0 then return false end
    local e157= math.floor(e155 * e156 + 0.5)
    local e158= globals.tickcount()
    nigga = e158 >= e157 and e158 <= e157 + e153

    return e158 >= e157 and e158 <= e157 + e153

end







local function e159(e91)
    
    
    
    local e80= false
    local e160= e149()
    local e161= e143()
    local e162= e145()
    local e163= e146()
    local e164= e152()
    

    e80 = e160 and e161 and not e162 and not e163 
    e135.active = e80


    local e63= (globals and globals.tickcount and globals.tickcount()) or e136.tickcount() or 0
    local e165= false
    if e63 and (e141 == nil or e63 - e141 >= 64) then
        e165 = true
        e151(e91)
    end



    
    
    

    
    
    
    if e80 then
        local e50= e124.get() or 'global'
        if (not e140) or (e139.cond ~= e50) or (not e139.preset) then
            local e67, e166= e137.get_random_for_condition(e50)
            if e67 and e166 then
                e139.cond = e50
                e139.idx = e67
                e139.preset = e166
                e139.selected_tick = globals.tickcount()
            else
                e139.cond = e50
                e139.idx = nil
                e139.preset = nil
                e139.selected_tick = 0
            end
        end

        if not e165 then
            if e139.preset and type(e139.preset.apply) == 'function' then
                e139.preset.apply(e139, e91)
            end
        end
    else
        if e140 then
            e139.cond = nil
            e139.idx = nil
            e139.preset = nil
            e139.selected_tick = 0
        end
    end

    e140 = e80

end


e135.activate = e159
e135.reset = e151


e51.register('setup_command', function(e91)
    e159(e91)
end, { alive_only = true, require_login = true })


return e135]]
e661["require/features/aa/defensive_presets"] = [[local e124= require('require/aa/player_condition')
local e136= require('require/help/time')
local e50= require('require/abc/screen_logger')



local e189= {}
local e190= {}
for e60, e52 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },

}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
    for e62, e75 in ipairs(e82) do
        e190[e75] = true
    end
end


local e54= {}

local function e93(e63,e70,e74) if e63 < e70 then return e70 end if e63 > e74 then return e74 end return e63 end

local function e138(e139,e140,e141)
    local e82= e189[e139]
    if not e82 or not e82[e140] then return false end
    pcall(ui.set, e82[e140], e141)
    return true
end



local e142, e47= pcall(require, "require/abc/menu_setup")



local function e143(e91)

    local e144, e47= pcall(require, "require/abc/menu_setup")
    if not e144 or not e47 or not e47.ui then return end
    local e145, e146= pcall(ui.get, e47.ui.fakelag_fakedef)

    
    if e146 then 
        e91.force_defensive = false
    else
        e91.force_defensive = true
    end

end

do
    local e138, e51= pcall(require, "require/abc/callbacks")

    ticks = ticks or {}
    ticks.tickbase_max = ticks.tickbase_max or nil
    ticks.tickbase_diff = ticks.tickbase_diff or nil
    ticks.current_cmd = ticks.current_cmd or nil

    ticks.runc = function(e91)
        if not e91 then return end
        ticks.current_cmd = e91.command_number
    end

    ticks.tickcalc = function(e91)
        if not e91 then return end
        if e91.command_number == ticks.current_cmd then
            ticks.current_cmd = nil
            local e56= entity.get_local_player()
            if not e56 then return end
            local e147= entity.get_prop(e56, "m_nTickBase")
            if e147 then
                if ticks.tickbase_max ~= nil then
                    ticks.tickbase_diff = e147 - ticks.tickbase_max
                end
                ticks.tickbase_max = math.max(e147, ticks.tickbase_max or 0)
            end
        end
    end

    if e138 and e51 and e51.callback then
        e51.callback('run_command', ticks.runc, { alive_only = true, require_login = true })
        e51.callback('predict_command', ticks.tickcalc, { alive_only = true, require_login = true })
    end
end

client.set_event_callback("level_init", function()
    ticks.tickbase_max = nil
    ticks.tickbase_diff = nil
end)


local function e148(e149)
    local e56= entity.get_local_player()
    if not e56 then return false end

    local e150= entity.get_prop(e56, 'm_nTickBase')
    if not e150 then return false end

    local e151= e152 and e152.tickbase_max or 0

    if math.abs(e150 - e151) > 64 then
        e151 = 0
    end

    local e153= 0

    if e150 > e151 then
        e151 = e150
    elseif e151 > e150 then
        e153 = math.min(14, math.max(0, e151 - e150 - 1))
    end

    e149 = e149 or 7

    return e153 > e149
end




local e154= {



    stand = {

        [1] = {
            name = "jitter -90/90",
            apply = function(e120,e91)

                local e63= globals.tickcount()
                local e137= math.floor(e63 / 2) % 2

                local function e155()
                    local e63= globals.tickcount()

                    if not e120._next_change_at then
                        e120._next_change_at = e63 + math.random(24, 64)
                        e120._mode = math.random(1, 3)
                        e120._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        e120._spin_speed = math.random(45, 55)
                        e120._spin_angle = (e137 == 0) and -90 or 90
                    end

                    if e63 >= (e120._next_change_at or 0) then
                        e120._next_change_at = e63 + math.random(24, 64)
                        e120._mode = math.random(1, 3)
                        e120._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        e120._spin_speed = math.random(45, 55)
                        e120._spin_angle = (e137 == 0) and -90 or 90

                        if e120._mode == 2 then
                            e120._spin_until = e63 + math.random(12, 24)
                        elseif e120._mode == 3 then
                            local e156= math.ceil(360 / e120._spin_speed)
                            e120._spin_until = e63 + e156
                            e120._rest_until = e63 + e156 + math.random(24, 64)
                            e120._spin_done = false
                        else
                            e120._spin_until = nil
                            e120._rest_until = nil
                        end
                    end

                    if e120._mode == 1 then
                        local e135= (e137 == 0) and -120 or 120
                        local e157= 0
                        return e135, e157

                    elseif e120._mode == 2 then
                        if e120._spin_until and e63 <= e120._spin_until then
                            e120._spin_angle = (e120._spin_angle or ((e137 == 0) and -90 or 90)) + (e120._spin_dir * (e120._spin_speed or 50))
                            if e120._spin_angle > 180 then e120._spin_angle = e120._spin_angle - 360 end
                            if e120._spin_angle < -180 then e120._spin_angle = e120._spin_angle + 360 end
                            return e120._spin_angle, 0
                        end
                        local e135= (e137 == 0) and -90 or 90
                        return e135, 0
                    else
                        if e120._spin_until and e63 <= e120._spin_until then
                            e120._spin_angle = (e120._spin_angle or ((e137 == 0) and -90 or 90)) + (e120._spin_dir * (e120._spin_speed or 50))
                            if e120._spin_angle > 180 then e120._spin_angle = e120._spin_angle - 360 end
                            if e120._spin_angle < -180 then e120._spin_angle = e120._spin_angle + 360 end
                            return e120._spin_angle, -89
                        end

                        if e120._rest_until and e63 <= e120._rest_until then
                            return nil, nil
                        end

                        local e135= (e137 == 0) and -90 or 90
                        return e135, 0
                    end
                end

                local e135, e157= e155()

                if e135 ~= nil and e91.chokedcommands > 0 and (e152.tickbase_diff > -12) and (not e152.tickbase_diff ~= 1) and (not (e148(6))) then
                    e143(e91)
                    e138(4, 2, e135)
                    e138(2, 1, 'Custom')
                    e138(2, 2, e157)
                    e138(5, 1, 'off')
                    e138(6, 1, 'off')
                end

            end
        }
    },

    move = {

        [1] = {
            name = "jitter -90/90",
            apply = function(e120,e91)


                local e63= globals.tickcount()
                local e137= math.floor(e63 / 2) % 2
                local e135= (e137 == 0) and -135 or 135
                e120._side = e135
                e120._pitch = -55


                if e91.chokedcommands > 0 and (e152.tickbase_diff > -12) and (not e152.tickbase_diff ~= 1) and (not (e148(3))) then
                    e143(e91)
                    e138(4, 2, e120._side)
                    e138(2, 1, 'Custom')
                    e138(2, 2, e120._pitch)
                    e138(5, 1, 'off')
                    e138(6, 1, 'off')
                    e138(3, 1, 'at targets')
                end
            end
        }
    },

    walk = {

        [1] = {
            name = "jitter -90/90",
            apply = function(e120,e91)

                local e63= globals.tickcount()
                local e137= math.floor(e63 / 2) % 2
                local e158= (e137 == 0) and -130 or 130

                
                local e135, e157
                if (e63 % 8) == 0 then
                    e135 = 0
                    e157 = 89
                else
                    e135 = e158
                    e157 = -65
                end

                e120._side = e135
                e120._pitch = e157





                if e91.chokedcommands > 0 and (e152.tickbase_diff > -12) and (not e152.tickbase_diff ~= 1) and (not (e148(3))) then
                    e143(e91)
                    e138(4, 2, e120._side)
                    e138(2, 1, 'Custom')
                    e138(2, 2, e120._pitch)
                    e138(5, 1, 'off')
                    e138(6, 1, 'off')
                    e138(3, 1, 'at targets')
                end
            end
        },
    },

    duck = {
        
        [1] = {
            name = "jitter -90/90",
            apply = function(e120,e91)

                local e63= globals.tickcount()
                local e137= math.floor(e63 / 2) % 2

                local function e155()
                    local e63= globals.tickcount()

                    
                    if not e120._next_change_at then
                        e120._next_change_at = e63 + math.random(24, 64)
                        e120._mode = 1 
                    end

                    if e63 >= (e120._next_change_at or 0) then
                        e120._next_change_at = e63 + math.random(24, 64)
                        e120._mode = math.random(1, 5)
                        
                        e120._spin_dir = nil
                        e120._spin_speed = nil
                        e120._spin_angle = nil
                        e120._jitter_yaw = nil
                        e120._jitter_pitch = nil
                        e120._rand_yaw = nil
                        e120._rand_pitch = nil
                        e120._rand_until = nil
                        e120._phase_tick = e63
                    end

                    
                    
                    
                    
                    
                    

                    if e120._mode == 1 then
                        if not e120._spin_dir then
                            e120._spin_dir = (math.random(0,1) == 0) and -1 or 1
                            e120._spin_speed = 35
                            e120._spin_angle = (e137 == 0) and -90 or 90
                        end

                        if e63 % 10 == 0 then
                            return nil, nil
                        end

                        e120._spin_angle = (e120._spin_angle or ((e137 == 0) and -90 or 90)) + (e120._spin_dir * (e120._spin_speed or 45))
                        if e120._spin_angle > 180 then e120._spin_angle = e120._spin_angle - 360 end
                        if e120._spin_angle < -180 then e120._spin_angle = e120._spin_angle + 360 end
                        return e120._spin_angle, 0

                    elseif e120._mode == 2 then
                        local e81= math.random(-100, 100)
                        return e81, -50

                    elseif e120._mode == 3 then
                        local e81= math.random(-180, 180)
                        local e157= math.random(-89, 89)
                        return e81, e157

                    elseif e120._mode == 4 then
                        if not e120._rand_until then
                            e120._rand_yaw = math.random(-180, 180)
                            e120._rand_pitch = math.random(-89, 89)
                            e120._rand_until = e63 + 2
                            e120._rand_rest = e63 + 3
                        end
                        if e63 <= e120._rand_until then
                            return e120._rand_yaw, e120._rand_pitch
                        elseif e63 <= e120._rand_rest then
                            return nil, nil
                        else
                            e120._rand_until = nil
                            e120._rand_rest = nil
                            return nil, nil
                        end

                    else
                        
                        if not e120._ramp then
                            e120._ramp = {}
                            e120._ramp.yaw = math.random(-180, 180)
                            e120._ramp.pitch = 89
                            e120._ramp.dir = -1 
                        end

                        
                        if not e120._ramp.step then e120._ramp.step = 30 end
                        if e120._ramp.pitch == 89 then
                            
                            e120._ramp.pitch = e120._ramp.pitch + (e120._ramp.dir * e120._ramp.step)
                            if e120._ramp.pitch < -89 then e120._ramp.pitch = -89 end
                            return e120._ramp.yaw, 89
                        else
                            
                            local e159= e120._ramp.pitch
                            e120._ramp.pitch = e120._ramp.pitch + (e120._ramp.dir * e120._ramp.step)
                            if e120._ramp.pitch <= -89 then
                                
                                e120._ramp = nil
                            end
                            return e120._ramp and e120._ramp.yaw or math.random(-180,180), e159
                        end
                    end
                end

                local e135, e157= e155()

                if e135 ~= nil and e91.chokedcommands == 1 and (e152.tickbase_diff > -12) and (not e152.tickbase_diff ~= 1) and (not (e148(8))) then
                    e143(e91)
                    e138(4, 2, e135)
                    e138(2, 1, 'Custom')
                    e138(2, 2, e157)
                    e138(5, 1, 'off')
                    e138(6, 1, 'off')
                    e138(3, 1, 'at targets')
                end
            end
        }
    },

    ["duck+"] = {
        
        [1] = {

            name = "jitter -90/90",
            apply = function(e120,e91)


                local e63= globals.tickcount()
                local e137= math.floor(e63 / 2) % 2
                local e135= (e137 == 0) and -90 or 90
                e120._side = 180
                e120._pitch = -76


                if e91.chokedcommands > 0 and (e152.tickbase_diff > -12) and (not e152.tickbase_diff ~= 1) and (not (e148(1))) then
                    e143(e91)
                    e138(4, 2, e120._side)
                    e138(2, 1, 'Custom')
                    e138(2, 2, e120._pitch)
                    e138(5, 1, 'off')
                    e138(6, 1, 'off')
                    e138(3, 1, 'at targets')
                end

            end
        }
    },

    ['jump'] = {
        [1] = {
            name = "jitter -90/90",
            apply = function(e120,e91)

                local e63= globals.tickcount()
                
                if not e120._spin_choice_at then
                    e120._spin_choice_at = e63 + 64
                    e120._spin_dir = (math.random(0,1) == 0) and -1 or 1
                    e120._spin_angle = 0
                end

                if e63 >= (e120._spin_choice_at or 0) then
                    e120._spin_choice_at = e63 + 64
                    e120._spin_dir = (math.random(0,1) == 0) and -1 or 1
                end

                
                if (e63 % 10) == 0 then
                    return
                end

                
                e120._spin_angle = (e120._spin_angle or 0) + (e120._spin_dir * 35)
                if e120._spin_angle > 180 then e120._spin_angle = e120._spin_angle - 360 end
                if e120._spin_angle < -180 then e120._spin_angle = e120._spin_angle + 360 end

                local e135= e120._spin_angle
                e120._side = e135
                e120._pitch = 0

                if e91.chokedcommands > 0 and (e152.tickbase_diff > -12) and (not e152.tickbase_diff ~= 1) and (not (e148(8))) then
                    e143(e91)
                    e138(4, 2, e120._side)
                    e138(2, 1, 'Custom')
                    e138(2, 2, e120._pitch)
                    e138(5, 1, 'off')
                    e138(6, 1, 'off')
                    e138(3, 1, 'at targets')
                end
            end
        },

    },

    ['jump+'] = {
        [0] = {
            name = "jitter -90/90",
            apply = function(e120,e91)

                local e63= globals.tickcount()
                local e137= math.floor(e63 / 2) % 2
                local e135= (e137 == 0) and -90 or 90
                e120._side = e135
                e120._pitch = 0

                if e91.chokedcommands > 0 and (not (e148(6))) then
                    e143(e91)
                    e138(4, 2, e120._side)
                    e138(2, 1, 'Custom')
                    e138(2, 2, e120._pitch)
                    e138(5, 1, 'off')
                    e138(6, 1, 'off')
                    e138(3, 1, 'at targets')
                end
            end
        },
    },

    
    global = {
        [0] = {
            name = "back",
            apply = function(e120,e91)

            end
        }
    }


}





local function e160(e56)
    local e161= {}
    for e162, e62 in pairs(e56) do
        if type(e162) == 'number' then table.insert(e161, e162) end
    end
    table.sort(e161)
    return e161
end

function e54.get_presets_for_condition(e50)
    e50 = e50 or e124.get() or 'global'
    return e154[e50] or e154['global'] or {}
end

function e54.get_preset_by_index(e50,e67)
    local e75= e54.get_presets_for_condition(e50)
    return e75[e67]
end

function e54.get_random_for_condition(e50)
    local e75= e54.get_presets_for_condition(e50)
    local e161= e160(e75)
    if #e161 == 0 then return nil, nil end
    local e163= e161[math.random(1, #e161)]
    return e163, e75[e163]
end

function e54.get_random_for_current_condition()
    return e54.get_random_for_condition(e124.get())
end


function e54.get_next_for_condition(e50,e164)
    local e75= e54.get_presets_for_condition(e50)
    local e161= e160(e75)
    if #e161 == 0 then return nil, nil end
    
    local e80= 1
    for e60, e162 in ipairs(e161) do
        if e162 == e164 then e80 = e60; break end
    end
    local e165= (e80 % #e161) + 1
    local e166= e161[e165]
    return e166, e75[e166]
end


function e54.available_conditions()
    local e82= {}
    for e162, e62 in pairs(e154) do table.insert(e82, e162) end
    table.sort(e82)
    return e82
end

e54._presets = e154

return e54]]
e661["require/features/misc/analyze"] = [[local function e141(e120)
	while e120 > 180 do e120 = e120 - 360 end
	while e120 < -180 do e120 = e120 + 360 end
	return e120
end

local e142= _G.player_labels or {}
_G.player_labels = e142

local e143= function(e140)
	return (_G.player_history and _G.player_history[e140]) or nil
end

local e144, e145= pcall(require, "require/features/misc/resolver_dispatcher")
local e51= require('require/abc/callbacks')

local function e146(e140)
	
	local e147= e143(e140)
	if not e147 or #e147 < 2 then
		e142[e140] = nil
		return
	end

	
	
	local e148, e66= pcall(function() return (globals and globals.curtime and globals.curtime()) or nil end)
	if e147[1] and e147[1].last_shot_time and e148 and e66 then
		local e149= e66 - e147[1].last_shot_time
		if e149 >= 0 and e149 <= 0.25 then
			e142[e140] = "ON SHOT"
			return
		end
	end

	
	local e150= {}
	for e60 = 1, #e147 - 1 do
		local e70= e147[e60] and e147[e60].yaw
		local e74= e147[e60+1] and e147[e60+1].yaw
		if e70 ~= nil and e74 ~= nil then
			e150[#e150 + 1] = e141(e70 - e74)
		end
	end

	if #e150 == 0 then
		e142[e140] = nil
		return
	end

	
	local e151, e152= 0, 0
	local e153, e154= -1e9, 1e9
	for e62, e63 in ipairs(e150) do
		e151 = e151 + e63
		e152 = e152 + math.abs(e63)
		if e63 > e153 then e153 = e63 end
		if e63 < e154 then e154 = e63 end
	end
	local e155= e151 / #e150
	local e156= e152 / #e150

	local e157= 0
	for e62, e63 in ipairs(e150) do
		e157 = e157 + (e63 - e155) ^ 2
	end
	local e158= math.sqrt(e157 / #e150)

	local e159= 0
	for e60 = 2, #e150 do
		if (e150[e60] > 0 and e150[e60-1] < 0) or (e150[e60] < 0 and e150[e60-1] > 0) then
			e159 = e159 + 1
		end
	end

	
	local e160= e150[1]
	local e161= e153 - e154

	
	local e162= {}
	for e60, e63 in ipairs(e150) do e162[e60] = e63 end
	table.sort(e162)
	local e163= e162[math.ceil(#e162 / 2)]

	
	local e164= {
		deltas = e150,
		mean = e155,
		meanabs = e156,
		std = e158,
		sign_changes = e159,
		max_delta = e153,
		min_delta = e154,
		total_range = e161,
		median = e163,
		last_delta = e160,
		samples = #e150,
		last_yaw = e147[1] and e147[1].yaw,
		oldest_yaw = e147[#e147] and e147[#e147].yaw,
		hist = e147
	}

	
	do
		local e165, e166= 0, 0
		local e167, e168, e169
		for e60=1,math.min(#e147, 20) do
			local e88= e147[e60]
			if e88 then
				if e88.moveSpeedAnim then e165 = e165 + (e88.moveSpeedAnim or 0); e166 = e166 + 1 end
				if e88.speed2d then e165 = e165 + (e88.speed2d or 0); e166 = e166 + 1 end
				if not e167 and e88.feetYaw then e167 = e88.feetYaw end
				if not e168 and e88.goalFeetYaw then e168 = e88.goalFeetYaw end
				if not e169 and e88.moveSpeedAnim then e169 = e88.moveSpeedAnim end
			end
		end
		local e170= (e166 > 0) and (e165 / e166) or 0
		e164.movement = e170 >= 1.2
		e164.avg_speed = e170
		e164.feet_yaw = e167
		e164.goal_feet_yaw = e168
		e164.move_anim = e169
	end

	local e171= nil
	if detect_static and detect_static(e164, e140) then e171 = "STATIC" end
	if detect_spin and detect_spin(e164, e140) then e171 = "SPIN" end
	if detect_jitter_minus and detect_jitter_minus(e164, e140) then e171 = "JITTER-" end
	if detect_jitter and detect_jitter(e164, e140) then e171 = "JITTER" end
	if detect_jitter_plus and detect_jitter_plus(e164, e140) then e171 = "JITTER+" end
	if detect_sway and detect_sway(e164, e140) then e171 = "SWAY" end
	if detect_skitter and detect_skitter(e164, e140) then e171 = "SKITTER" end
	if detect_defensive and detect_defensive(e164, e140) then e171 = "DEFENSIVE" end
	if detect_random and detect_random(e164, e140) then e171 = "RANDOM" end
	if detect_delayed and detect_delayed(e164, e140) then e171 = "DELAYED" end

	if not e171 then e171 = "?" end
	pcall(function()
		local e59= nil
		pcall(function() e59 = entity.get_player_name(e140) end)
		local e172= "nil"
		if e147 and e147[1] and e147[1].last_shot_time then
			e172 = string.format("%.3f", e147[1].last_shot_time)
		end
		local e173= e164.feet_yaw and string.format("%.2f", e164.feet_yaw) or "nil"
		local e174= e164.goal_feet_yaw and string.format("%.2f", e164.goal_feet_yaw) or "nil"

	end)

	e142[e140] = e171

	
	if e144 and e145 and type(e145.process_entity) == "function" then
		pcall(function() e145.process_entity(e140, e171, e164) end)
	end
end



function e175(e164,e140)
	local e156= e164.meanabs or 0
	local e158= e164.std or 0
	local e176= e164.samples or 0
	local e150= e164.deltas or {}
	local e177= 1.0
	local e178= 1.5
	local e179= 2.5

	if e156 <= e177 and e158 <= e178 then
		return true
	end

	local e180= 0
	local e181= nil
	for e60, e74 in ipairs(e150) do
		if math.abs(e74) >= e179 then
			e180 = e180 + 1
			if not e181 then
				e181 = e60
			end
		end
	end

	if e180 == 0 then
		return true
	end

	if e180 == 1 and e181 and e181 > 20 then
		return true
	end

	return false
end

function e182(e164,e140)
	local e156= e164.meanabs or 0
	local e158= e164.std or 0
	local e176= e164.samples or 0
	local e159= e164.sign_changes or 0
	local e183= math.max(math.abs(e164.max_delta or 0), math.abs(e164.min_delta or 0))

	local e670= false

	if e176 >= 4 then
		local e184= 5.0
		local e185= 12.0
		local e186= 22.0
		local e187= 40.0

		if e156 >= e184 and e156 < e185 and e158 <= e186 and e183 <= e187 then
			e670 = true
		end
	end

	return e670
end

function e188(e164,e140)
	local e156= e164.meanabs or 0
	local e158= e164.std or 0
	local e176= e164.samples or 0
	local e159= e164.sign_changes or 0
	local e183= math.max(math.abs(e164.max_delta or 0), math.abs(e164.min_delta or 0))

	local e670= false

	if e176 >= 4 then
		local e184= (e164.movement and 8.0) or 6.0
		local e185= 24.0
		local e189= 34.0
		local e190= 28.0
		local e191= 100.0

		if e156 >= e184 and e156 < e185 and e158 <= e189 then
			if e159 >= 2 or e183 <= e191 or (e156 < 12.0 and e158 <= e190) then
				e670 = true
			end
		end
	end

	return e670
end

function e192(e164,e140)
	local e156= e164.meanabs or 0
	local e158= e164.std or 0
	local e176= e164.samples or 0
	local e159= e164.sign_changes or 0
	local e183= math.max(math.abs(e164.max_delta or 0), math.abs(e164.min_delta or 0))

	local e670= false

	if e176 >= 4 then
		local e184= 18.0
		local e193= 22.0
		local e194= 26.0
		local e195= 70.0

		if e156 >= e184 and (e158 >= e194 or e183 >= e195) then
			if e156 >= e193 or e183 >= e195 or e158 >= (e194 + 8) then
				e670 = true
			end
		end
	end
	
	return e670
end

function e196(e164,e140)
	local e156= e164.meanabs or 0
	local e158= e164.std or 0
	local e176= e164.samples or 0
	local e159= e164.sign_changes or 0
	local e161= e164.total_range or 0
	local e183= math.max(math.abs(e164.max_delta or 0), math.abs(e164.min_delta or 0))

	local e670= false

	if e176 >= 6 then
		local e184= 2.5
		local e185= 15.0
		local e197= 0.08
		local e198= 30.0
		local e199= 180.0

		if e156 >= e184 and e156 < e185 and e158 <= 40.0 and e161 >= e198 and e161 <= e199 then
			if (e159 / math.max(1, e176)) >= e197 then
				e670 = true
			end
		end
	end

	return e670
end

function e200(e164,e140)
	local e156= e164.meanabs or 0
	local e158= e164.std or 0
	local e176= e164.samples or 0
	local e159= e164.sign_changes or 0
	local e161= e164.total_range or 0
	local e160= e164.last_delta or 0
	local e183= math.max(math.abs(e164.max_delta or 0), math.abs(e164.min_delta or 0))

	local e150= e164.deltas or {}

	local e201, e202, e203= 0, 0, 0
	for e62, e63 in ipairs(e150) do
		if e63 > 0.5 then e201 = e201 + 1
		elseif e63 < -0.5 then e202 = e202 + 1
		else e203 = e203 + 1 end
	end

	local e204= math.max(e201, e202) / math.max(1, e176)
	local e205= math.abs(e201 - e202) / math.max(1, (e201 + e202))

	local e206, e207, e208= 0, 0, 0
	for e62, e63 in ipairs(e150) do
		local e88= 0
		if e63 > 0.5 then e88 = 1 elseif e63 < -0.5 then e88 = -1 end
		if e88 ~= 0 and e88 == e208 then
			e207 = e207 + 1
		else
			e207 = (e88 ~= 0) and 1 or 0
			e208 = e88
		end
		if e207 > e206 then e206 = e207 end
	end

	local e209= e206 / math.max(1, e176)

	local e670= false

	if e176 >= 6 then
		if e161 >= 300 and (e204 >= 0.60 or e205 >= 0.60) then
			e670 = true
		end

		if not e670 and e161 >= 140 and e156 >= 9 and (e204 >= 0.75 or e205 >= 0.70 or e159 <= 1) then
			e670 = true
		end

		if not e670 and e209 >= 0.50 and e156 >= 8 and e161 >= 120 then
			e670 = true
		end

		if not e670 and e183 >= 120 and (e204 >= 0.60 or e205 >= 0.60) then
			e670 = true
		end
	end
	local e210= nil
	if not e670 and e176 > 0 then
		local e211= math.min(e161, 360) / 360.0
		local e212= math.min(e156, 60) / 60.0
		local e213= (e159 or 0) / math.max(1, e176)
		e210 = e211 * 0.45 + e212 * 0.35 + e205 * 0.15 + e204 * 0.05 - e213 * 0.20
		if e210 >= 0.42 and e161 >= 200 and e156 >= 6 then
			e670 = true
		end
		e164.spin_score = e210
	end

	return e670
end

function e214(e164,e140)
	
	return false
end

function e215(e164,e140)
	
	return false
end

function e216(e164,e140)
	local e156= e164.meanabs or 0
	local e158= e164.std or 0
	local e176= e164.samples or 0
	local e159= e164.sign_changes or 0
	local e161= e164.total_range or 0
	local e183= math.max(math.abs(e164.max_delta or 0), math.abs(e164.min_delta or 0))
	local e150= e164.deltas or {}

	if e176 < 6 then return false end

	local e217= e159 / math.max(1, e176)
	local e218= e164.movement
	if e217 >= 0.45 and e158 >= (e218 and 12.0 or 18.0) and e156 >= (e218 and 4.0 or 6.0) then
		return true
	end

	if e183 >= 120 and e217 >= 0.30 and e158 >= 12.0 then
		return true
	end

	if e161 >= 60 and e161 <= 300 and e217 >= 0.40 and e158 >= 14.0 and e156 >= 4.0 then
		return true
	end

	if e158 >= 30.0 and e217 >= 0.25 and e156 >= 5.0 then
		return true
	end

	return false
end

function e219(e164,e140)
	local e156= e164.meanabs or 0
	local e158= e164.std or 0
	local e176= e164.samples or 0
	local e159= e164.sign_changes or 0
	local e161= e164.total_range or 0
	local e183= math.max(math.abs(e164.max_delta or 0), math.abs(e164.min_delta or 0))

	if e176 >= 6 then
		local e184= 2.5
		local e185= 24.0
		local e220= 9.0
		local e221= 40.0
		local e198= 10.0

		if e156 >= e184 and e156 < e185 and e158 >= e220 and e158 <= e221 and e161 >= e198 then
			local e222= (e159 or 0) / math.max(1, e176)
			if e159 <= 3 or e222 <= 0.12 or e183 >= 40 then
				return true
			end
		end
	end

	return false
end

local function e223()
	local e53, e160= pcall(entity.get_players, true)
	if not e53 or type(e160) ~= "table" then return end
	for e62, e140 in ipairs(e160) do
		if entity.is_alive(e140) and not entity.is_dormant(e140) then
			pcall(e146, e140)
		else
			e142[e140] = nil
		end
	end
end

local function e224(e140)
	if not entity.is_alive(entity.get_local_player()) then return end
	if not e140 or e140 == 0 then return end

	local e225= e142[e140]


	if e225 then
		return true, e225
	end

	local e147= e143(e140)
	if e147 and e147[1] and e147[1].yaw ~= nil then
		return true, tostring(e147[1].yaw)
	end
end

client.register_esp_flag("Resolver", 255, 255, 255, e224)

e51.register('net_update_end', function()
	local e226, e47= pcall(require, "require/abc/menu_setup")
	if e226 and e47 and e47.ui and e47.ui.misc_resolver then
		local e145, e80= pcall(ui.get, e47.ui.misc_resolver)
		if e145 and e80 then
			pcall(e223)
		end
	end
end, { alive_only = true, require_login = true })
]]
e661["require/features/misc/backstab_assist"] = [[local e47= require("require/abc/menu_setup")
local e51= require('require/abc/callbacks')
local e144= require('require/help/enemies')

local e145= ui.reference("AA", "Anti-aimbot angles", "Pitch")
local e146= ui.reference("AA", "Anti-aimbot angles", "Yaw base")
local e147, e148= ui.reference("AA", "Anti-aimbot angles", "Yaw")
local e149= nil

local function e70()
	if e149 then return end
	e149 = {}
	if e145 then e149.pitch = ui.get(e145) end
	if e146 then e149.yaw_base = ui.get(e146) end
	if e147 then e149.yaw = ui.get(e147) end
	if e148 then e149.yaw_slider = ui.get(e148) end
end

local function e150()
	if not e149 then return end
	if e145 and e149.pitch ~= nil then pcall(ui.set, e145, e149.pitch) end
	if e146 and e149.yaw_base ~= nil then pcall(ui.set, e146, e149.yaw_base) end
	if e147 and e149.yaw ~= nil then pcall(ui.set, e147, e149.yaw) end
	if e148 and e149.yaw_slider ~= nil then pcall(ui.set, e148, e149.yaw_slider) end
	e149 = nil
end

local function e151()
	e70()
	if e145 then pcall(ui.set, e145, "Off") end
	if e146 then pcall(ui.set, e146, "At targets") end
	if e147 then pcall(ui.set, e147, "180") end
	if e148 then pcall(ui.set, e148, 180) end
end

local function e152(e153)
	local e56= entity.get_local_player()
	if not e56 or not entity.is_alive(e56) then return false end
	local e75= e144.list() or {}
	for e62, e154 in ipairs(e75) do
		if e144.is_alive(e154) and not e144.is_dormant(e154) and e144.has_knife(e154) then
			local e171= e144.distance(e154)
			if e171 and e171 <= e153 then
				return true
			end
		end
	end
	return false
end

local function e155(e91)
	if not (e47 and e47.ui and e47.ui.misc_backstab) then e150() return end
	local e53, e80= pcall(ui.get, e47.ui.misc_backstab)
	if not e53 or not e80 then e150() return end
	local e153= 200
	if e152(e153) then
		e151()
	else
		e150()
	end
end

if e47 and e47.ui and e47.ui.misc_backstab then
	ui.set_callback(e47.ui.misc_backstab, function()
		local e53, e54= pcall(ui.get, e47.ui.misc_backstab)
		if not e53 or not e54 then e150() end
	end)
end

e51.register("setup_command", e155, { alive_only = true, require_login = true })
e51.register("shutdown", e150, { alive_only = true, require_login = true })]]
e661["require/features/misc/collect"] = [=[
local M = {}


do
    local ok, ffi = pcall(require, "ffi")
    if ok and ffi and client and client.create_interface then
        local status, entity_list_ptr = pcall(function()
            return client.create_interface("client.dll", "VClientEntityList003")
        end)

        if status and entity_list_ptr then
            local pointer_type = ffi.typeof("void***")
            local entity_list = ffi.cast(pointer_type, entity_list_ptr)
            local ok_cast, get_client_entity = pcall(function()
                return ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
            end)

            if ok_cast and get_client_entity then
                
                local animstate_offset = 0x9960

                
                
                
                ffi.cdef[[
                struct animation_layer_t {
                    char  pad_0000[20];
                    uint32_t m_nOrder;
                    uint32_t m_nSequence;
                    float m_flPrevCycle;
                    float m_flWeight;
                    float m_flWeightDeltaRate;
                    float m_flPlaybackRate;
                    float m_flCycle;
                    void *m_pOwner;
                    char  pad_0038[4];
                };
                ]]

                
                
                

                ffi.cdef[[
                struct c_animstate_min {
                    char pad0[3];
                    char m_bForceWeaponUpdate;
                    char pad1[91];
                    void* m_pBaseEntity;
                    void* m_pActiveWeapon;
                    void* m_pLastActiveWeapon;
                    float m_flLastClientSideAnimationUpdateTime;
                    int m_iLastClientSideAnimationUpdateFramecount;
                    float m_flAnimUpdateDelta;
                    float m_flEyeYaw;
                    float m_flPitch;
                    float m_flGoalFeetYaw;
                    float m_flCurrentFeetYaw;
                    float m_flCurrentTorsoYaw;
                    float m_flUnknownVelocityLean;
                    float m_flLeanAmount;
                    char pad2[4];
                    float m_flFeetCycle;
                    float m_flFeetYawRate;
                    char pad3[4];
                    float m_fDuckAmount;
                    float m_fLandingDuckAdditiveSomething;
                    char pad4[4];
                    float m_vOriginX;
                    float m_vOriginY;
                    float m_vOriginZ;
                    float m_vLastOriginX;
                    float m_vLastOriginY;
                    float m_vLastOriginZ;
                    float m_vVelocityX;
                    float m_vVelocityY;
                    char pad5[4];
                    float m_flUnknownFloat1;
                    char pad6[8];
                    float m_flUnknownFloat2;
                    float m_flUnknownFloat3;
                    float m_flUnknown;
                    float m_flSpeed2D;
                    float m_flUpVelocity;
                    float m_flSpeedNormalized;
                    float m_flFeetSpeedForwardsOrSideWays;
                    float m_flFeetSpeedUnknownForwardOrSideways;
                    float m_flTimeSinceStartedMoving;
                    float m_flTimeSinceStoppedMoving;
                    bool m_bOnGround;
                    bool m_bInHitGroundAnimation;
                    char pad7[2];
                    float m_flTimeSinceInAir;
                    float m_flLastOriginZ;
                    float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
                    float m_flStopToFullRunningFraction;
                    float m_flMagicFraction;
                    char pad8[60];
                    float m_flWorldForce;
                    char pad9[462];
                    float m_flMaxYaw;
                };
                ]]

                
                M._get_animstate = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    
                    
                    local base = ffi.cast("char*", ent_ptr)
                    local anim_ptr_ptr = ffi.cast("struct c_animstate_min**", base + animstate_offset)
                    if anim_ptr_ptr == nil or anim_ptr_ptr == ffi.NULL then return nil end
                    local anim_ptr = anim_ptr_ptr[0]
                    if anim_ptr == nil or anim_ptr == ffi.NULL then return nil end
                    return anim_ptr
                end
                
                M._get_entity_ptr = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    return ent_ptr
                end
            end
        end
    end
end



function M.get_sim_time(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flSimulationTime") end)
    if ok then return val end
    return nil
end


function M.get_enemies_simtimes()
    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        out[ent] = M.get_sim_time(ent)
    end
    return out
end


function M.get_velocity_3d(ent)
    local ok, vals = pcall(function() return { entity.get_prop(ent, "m_vecVelocity") } end)
    if not ok or type(vals) ~= "table" then return nil end
    if #vals >= 3 then
        return { vals[1], vals[2], vals[3] }
    end
    return nil
end


function M.get_speed_2d(ent)
    local v = M.get_velocity_3d(ent)
    if not v then return nil end
    local x, y = v[1] or 0, v[2] or 0
    return math.sqrt(x * x + y * y)
end




function M.get_origin(ent)
    local ok, x, y, z = pcall(function() return entity.get_prop(ent, "m_vecOrigin") end)
    if ok and x then
        
        if type(x) == "table" then
            return x[1], x[2], x[3]
        elseif y and z then
            return x, y, z
        end
    end
    return nil
end


function M.get_view_offset(ent)
    local tries = { "m_vecViewOffset[0]", "m_vecViewOffset" }
    for _, prop in ipairs(tries) do
        local ok, v1, v2, v3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and v1 then
            if type(v1) == "table" then
                return v1[1], v1[2], v1[3]
            elseif v2 and v3 then
                return v1, v2, v3
            end
        end
    end
    return nil
end


function M.get_eye_pos(ent)
    local ox, oy, oz = M.get_origin(ent)
    local vx, vy, vz = M.get_view_offset(ent)
    if ox and vx then
        return ox + vx, oy + vy, oz + vz
    end
    return nil
end


function M.get_eye_angles(ent)
    local tries = { "m_angEyeAngles[0]", "m_angEyeAngles", "m_angRotation", "m_angNetworkAngles" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return nil
end


function M.get_abs_angles(ent)
    local tries = { "m_angAbsRotation", "m_angAbsAngles", "m_angAbsOrigin" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return M.get_eye_angles(ent)
end


function M.get_lower_body_yaw(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flLowerBodyYawTarget") end)
    if ok and val then return val end
    return nil
end


function M.get_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flCurrentFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    
    return M.get_lower_body_yaw(ent)
end

function M.get_goal_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flGoalFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    return M.get_feet_yaw(ent)
end


function M.get_speed(ent)
    
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flVelocityModifier") end)
    if ok and val then return val end
    
    local v = M.get_velocity_3d(ent)
    if v then
        return math.sqrt((v[1] or 0) * (v[1] or 0) + (v[2] or 0) * (v[2] or 0) + (v[3] or 0) * (v[3] or 0))
    end
    return nil
end

function M.get_move_speed_anim(ent)
    
    
    
    
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local try_fields = { "m_flFeetSpeedForwardsOrSideWays", "m_flSpeed2D", "m_flSpeedNormalized", "m_flFeetSpeedUnknownForwardOrSideways" }
            for _, f in ipairs(try_fields) do
                local okf, val = pcall(function() return tonumber(anim[f]) end)
                if okf and val and val ~= 0 then
                    return val
                end
            end
        end
    end

    
    local ok_nv, nv = pcall(function() return entity.get_prop(ent, "m_flMaxspeed") end)
    if ok_nv and nv then return nv end

    
    return M.get_speed_2d(ent)
end


function M.get_flags(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_fFlags") end)
    if ok and val then return val end
    ok, val = pcall(function() return entity.get_prop(ent, "m_iFlags") end)
    if ok and val then return val end
    return nil
end



function M.read_animstate(ent)
    if not M._get_animstate then return nil end
    local ok, anim = pcall(function() return M._get_animstate(ent) end)
    if not ok or not anim then return nil end
    local out = {}
    pcall(function()
        out.m_flEyeYaw = tonumber(anim.m_flEyeYaw)
        out.m_flPitch = tonumber(anim.m_flPitch)
        out.m_flGoalFeetYaw = tonumber(anim.m_flGoalFeetYaw)
        out.m_flCurrentFeetYaw = tonumber(anim.m_flCurrentFeetYaw)
        out.m_flCurrentTorsoYaw = tonumber(anim.m_flCurrentTorsoYaw)
        out.m_flUnknownVelocityLean = tonumber(anim.m_flUnknownVelocityLean)
        out.m_flLeanAmount = tonumber(anim.m_flLeanAmount)
        out.m_flFeetCycle = tonumber(anim.m_flFeetCycle)
        out.m_flFeetYawRate = tonumber(anim.m_flFeetYawRate)
        out.m_fDuckAmount = tonumber(anim.m_fDuckAmount)
        out.m_fLandingDuckAdditiveSomething = tonumber(anim.m_fLandingDuckAdditiveSomething)
        out.m_vOrigin = { tonumber(anim.m_vOriginX), tonumber(anim.m_vOriginY), tonumber(anim.m_vOriginZ) }
        out.m_vLastOrigin = { tonumber(anim.m_vLastOriginX), tonumber(anim.m_vLastOriginY), tonumber(anim.m_vLastOriginZ) }
        out.m_vVelocity = { tonumber(anim.m_vVelocityX), tonumber(anim.m_vVelocityY) }
        out.m_flUnknownFloat1 = tonumber(anim.m_flUnknownFloat1)
        out.m_flUnknownFloat2 = tonumber(anim.m_flUnknownFloat2)
        out.m_flUnknownFloat3 = tonumber(anim.m_flUnknownFloat3)
        out.m_flUnknown = tonumber(anim.m_flUnknown)
        out.m_flSpeed2D = tonumber(anim.m_flSpeed2D)
        out.m_flUpVelocity = tonumber(anim.m_flUpVelocity)
        out.m_flSpeedNormalized = tonumber(anim.m_flSpeedNormalized)
        out.m_flFeetSpeedForwardsOrSideWays = tonumber(anim.m_flFeetSpeedForwardsOrSideWays)
        out.m_flFeetSpeedUnknownForwardOrSideways = tonumber(anim.m_flFeetSpeedUnknownForwardOrSideways)
        out.m_flTimeSinceStartedMoving = tonumber(anim.m_flTimeSinceStartedMoving)
        out.m_flTimeSinceStoppedMoving = tonumber(anim.m_flTimeSinceStoppedMoving)
        out.m_bOnGround = (anim.m_bOnGround ~= 0)
        out.m_bInHitGroundAnimation = (anim.m_bInHitGroundAnimation ~= 0)
        out.m_flTimeSinceInAir = tonumber(anim.m_flTimeSinceInAir)
        out.m_flLastOriginZ = tonumber(anim.m_flLastOriginZ)
        out.m_flHeadHeightOrOffsetFromHittingGroundAnimation = tonumber(anim.m_flHeadHeightOrOffsetFromHittingGroundAnimation)
        out.m_flStopToFullRunningFraction = tonumber(anim.m_flStopToFullRunningFraction)
        out.m_flMagicFraction = tonumber(anim.m_flMagicFraction)
        out.m_flWorldForce = tonumber(anim.m_flWorldForce)
        out.m_flMaxYaw = tonumber(anim.m_flMaxYaw)
    end)
    return out
end



function M.read_anim_layers(ent)
    if not M._get_entity_ptr then return nil end
    local ok_ent, ent_ptr = pcall(function() return M._get_entity_ptr(ent) end)
    if not ok_ent or not ent_ptr then return nil end
    local ok, res = pcall(function()
        local ffi = require("ffi")
        local base = ffi.cast("char*", ent_ptr)
        local layers_ptr = ffi.cast("struct animation_layer_t**", base + 0x2990)
        if layers_ptr == nil or layers_ptr == ffi.NULL then return nil end
        local owner = layers_ptr[0]
        if owner == nil or owner == ffi.NULL then return nil end
        local out = {}
        for i = 0, 15 do
            local layer = owner[i]
            if layer == nil or layer == ffi.NULL then break end
            local t = {}
            t.m_nOrder = tonumber(layer.m_nOrder)
            t.m_nSequence = tonumber(layer.m_nSequence)
            t.m_flPrevCycle = tonumber(layer.m_flPrevCycle)
            t.m_flWeight = tonumber(layer.m_flWeight)
            t.m_flWeightDeltaRate = tonumber(layer.m_flWeightDeltaRate)
            t.m_flPlaybackRate = tonumber(layer.m_flPlaybackRate)
            t.m_flCycle = tonumber(layer.m_flCycle)
            t.m_pOwner = tostring(layer.m_pOwner)
            table.insert(out, t)
        end
        return out
    end)
    if not ok then return nil end
    return res
end


function M.get_tick_from_simtime(simtime)
    if not simtime or not globals or not globals.tickinterval then return nil end
    local ti = globals.tickinterval()
    if not ti or ti == 0 then return nil end
    return math.floor(simtime / ti + 0.5)
end

function M.get_tick(ent)
    local sim = M.get_sim_time(ent)
    if sim then return M.get_tick_from_simtime(sim) end
    return nil
end








function M.get_enemies_snapshot(opts)
    opts = opts or {}
    local heavy = true 

    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        local snap = {}

        
        snap.is_alive = (pcall(function() return entity.is_alive(ent) end) and entity.is_alive(ent)) or false
        snap.is_dormant = (pcall(function() return entity.is_dormant(ent) end) and entity.is_dormant(ent)) or false

        
        local ok_name, name = pcall(function() return entity.get_player_name(ent) end)
        snap.name = ok_name and name or nil

        
        snap.simtime = M.get_sim_time(ent)
        do
            local base_tick = snap.simtime and M.get_tick_from_simtime(snap.simtime) or nil
            
            local ok_flags, esp_flags = pcall(function()
                local d = entity.get_esp_data and entity.get_esp_data(ent)
                return (d and d.flags) or 0
            end)

            local adjusted_tick = base_tick
            if ok_flags and esp_flags and base_tick then
                
                local ok_bit, is_backtrack = pcall(function()
                    return bit and bit.band(esp_flags, bit.lshift(1, 17)) ~= 0
                end)
                if ok_bit and is_backtrack then
                    adjusted_tick = base_tick - 14
                end
            end
            snap.simTicks = adjusted_tick
        end

        
        do
            local ok, ox, oy, oz = pcall(function() return M.get_origin(ent) end)
            if ok and ox then snap.origin = { ox, oy, oz } end
        end
        do
            local ok, vx, vy, vz = pcall(function() return M.get_view_offset(ent) end)
            if ok and vx then snap.viewOffset = { vx, vy, vz } end
        end
        do
            local ok, ex, ey, ez = pcall(function() return M.get_eye_pos(ent) end)
            if ok and ex then snap.eyePos = { ex, ey, ez } end
        end

        
        do
            local ok, a1, a2, a3 = pcall(function() return M.get_eye_angles(ent) end)
            if ok and a1 then snap.eyeAngles = { a1, a2, a3 } end
        end
        do
            local ok, aa1, aa2, aa3 = pcall(function() return M.get_abs_angles(ent) end)
            if ok and aa1 then snap.absAngles = { aa1, aa2, aa3 } end
        end

        
        snap.lowerBodyYaw = (pcall(function() return M.get_lower_body_yaw(ent) end) and M.get_lower_body_yaw(ent)) or nil
        snap.feetYaw = (pcall(function() return M.get_feet_yaw(ent) end) and M.get_feet_yaw(ent)) or snap.lowerBodyYaw
        snap.goalFeetYaw = (pcall(function() return M.get_goal_feet_yaw(ent) end) and M.get_goal_feet_yaw(ent)) or snap.feetYaw

        
        snap.velocity3d = (pcall(function() return M.get_velocity_3d(ent) end) and M.get_velocity_3d(ent)) or nil
        if snap.velocity3d then
            snap.speed2d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0))
            snap.speed3d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0) + (snap.velocity3d[3] or 0) * (snap.velocity3d[3] or 0))
        else
            snap.speed2d = M.get_speed_2d(ent)
            snap.speed3d = M.get_speed(ent)
        end

        
        do
            local ok_ms, ms = pcall(function() return M.get_move_speed_anim(ent) end)
            if ok_ms and ms then
                snap.moveSpeedAnim = ms
            else
                snap.moveSpeedAnim = nil
            end
        end

        
        snap.flags = (pcall(function() return M.get_flags(ent) end) and M.get_flags(ent)) or nil

        
        local ok_head, hx, hy, hz = pcall(function() return entity.hitbox_position(ent, "head") end)
        if ok_head and hx then snap.headPos = { hx, hy, hz } end

        
        local ok_w, w = pcall(function() return entity.get_player_weapon(ent) end)
        snap.weapon = ok_w and w or nil

        

        
        local ok_b, bones = pcall(function() return entity.get_bone_matrices and entity.get_bone_matrices(ent) end)
        if ok_b and bones then snap.bones = bones end

        local ok_as, as = pcall(function() return M.read_animstate(ent) end)
        if ok_as and as then snap.animstate_full = as end
        local ok_layers, layers = pcall(function() return M.read_anim_layers(ent) end)
        if ok_layers and layers then snap.animLayers = layers end

        out[ent] = snap
    end
    return out
end

return M
]=]
e661["require/features/misc/dormant_aimbot"] = [[local e150, e151, e152, e153= client.visible, client.eye_position, client.log, client.trace_bullet
local e154, e155, e156, e157, e158, e159, e160, e161, e162, e163= entity.get_bounding_box, entity.get_local_player, entity.get_origin, entity.get_player_name, entity.get_player_resource, entity.get_player_weapon, entity.get_prop, entity.is_dormant, entity.is_enemy, entity.is_alive
local e164, e165, e166= globals.curtime, globals.maxplayers, globals.tickcount
local e167, e168, e84= math.max, math.min, math.sqrt
local e169, e170, e171= renderer.indicator, string.format, table.unpack or unpack
local e172, e173, e174, e175, e176, e177, e178, e179, e180, e181= ui.get, ui.new_checkbox, ui.new_color_picker, ui.new_hotkey, ui.new_multiselect, ui.new_slider, ui.reference, ui.set, ui.set_callback, ui.set_visible
local e182, e183= plist.get, entity.hitbox_position
local e63= require("ffi")
local e134= require("vector")
local e184= require("gamesense/csgo_weapons")
local e185= vtable_bind("client_panorama.dll", "VClientEntityList003", 3, "void*(__thiscall*)(void*, int)")
local e186= vtable_thunk(166, "bool(__thiscall*)(void*)")
local e187= vtable_thunk(483, "float(__thiscall*)(void*)")
local e188= {
	mindamage = e178("RAGE", "Aimbot", "Minimum damage"),
	dormant_esp = e178("VISUALS", "Player ESP", "Dormant"),
	override_mindamage = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}
local e47= require("require/abc/menu_setup")
local e51= require('require/abc/callbacks')

local e189= {}
local function e190(e59)
	if type(e47) ~= 'table' then return false end
	if e189[e59] == nil then e189[e59] = e47.ui and e47.ui[e59] end
	local e191= e189[e59]
	if not e191 then return false end
	local e53, e54= pcall(e172, e191)
	if not e53 then
		e189[e59] = e47.ui and e47.ui[e59]
		e191 = e189[e59]
		if not e191 then return false end
		e53, e54 = pcall(e172, e191)
		if not e53 then return false end
	end
	return e54
end

local e192= { "Head", "Chest", "Stomach" }
local e193= {
	"generic",
	"head",
	"chest",
	"stomach",
	"left arm",
	"right arm",
	"left leg",
	"right leg",
	"neck",
	"?",
	"gear"
}

local e194= {
	"",
	"Head",
	"Chest",
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs",
	"Head",
	"",
	""
}

local e195= {
	{ scale = 5, hitbox = "Stomach", vec = e134(0, 0, 40) },
	{ scale = 6, hitbox = "Chest", vec = e134(0, 0, 50) },
	{ scale = 3, hitbox = "Head", vec = e134(0, 0, 58) },
	{ scale = 4, hitbox = "Legs", vec = e134(0, 0, 20) }
}

local e196= {
	[0] = "Head",
	nil,
	"Stomach",
	nil,
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs"
}

local e197= 0
local e198= {}
local e199= {}
local e200= 1
local e201= false
local e202
local e203
local e204
local e205
local e206= false
local e207= {}

local e208= {
	0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18
}

local function e209(e210,e211,e85)
	local e62, e81= e210:to(e211):angles()
	local e212= math.rad(e81 + 90)
	local e213= e134(math.cos(e212), math.sin(e212), 0) * e85

	return {
		{ text = "Middle", vec = e211 },
		{ text = "Left", vec = e211 + e213 },
		{ text = "Right", vec = e211 - e213 }
	}
end

local function e214(e75,e141)
	for e60 = 1, #e75 do if e75[e60] == e141 then return true end end
	return false
end
local function e215(e75,e141)
	for e60 = 1, #e75 do local e63= e75[e60] if type(e63) == 'table' and e63[1] == e141 then return e60 end end
end
local function e216(e75,e217) return e215(e75, e217) ~= nil end
local function e218(e75,e217) local e67= e215(e75, e217) if e67 then table.remove(e75, e67) end end

local function e219(e91,e220)
	local e221= e84(e91.forwardmove*e91.forwardmove + e91.sidemove*e91.sidemove)
	if e220<=0 or e221<=0 then return end
	if e91.in_duck==1 then e220 = e220*2.94117647 end
	if e221<=e220 then return end
	local e88= e220/e221; e91.forwardmove = e91.forwardmove*e88; e91.sidemove = e91.sidemove*e88
end

local function e222()
	local e138, e72= {}, e158()
	for e60=1,e165() do if e160(e72, "m_bConnected", e60)==1 and e60~=e155() and e162(e60) then e138[#e138+1]=e60 end end
	return e138
end
local function e223()
	local e138, e72= {}, e158()
	for e60=1,e165() do if e160(e72, "m_bConnected", e60)==1 and not e182(e60, "Add to whitelist") and e161(e60) and e162(e60) then e138[#e138+1]=e60 end end
	return e138
end

local function e224()
	for e62,e154 in ipairs(e222()) do
		local e62,e62,e62,e62,e121= e154(e154)
		if e121<1 then if not e216(e199,e154) then e199[#e199+1]={e154,e166()} end else e218(e199,e154) end
	end
end

local function e225(e226)
	local e227= e172(e188.override_mindamage[1]) and e172(e188.override_mindamage[2])
	local e228= e227 and e172(e188.override_mindamage[3]) or e172(e188.mindamage)
	local e99= entity.get_esp_data(e226).health
	if e228>100 then e228 = e228 - 100 + e99 end
	return e228
end

local function e229(e88,e88) return (e88.type=="sniperrifle" and e88) and e88.max_player_speed_alt or e88.max_player_speed end

local function e230(e226,e231,e80)
	local e232= {}
	local e233= e160(e226, "m_flDuckAmount") or 0
	for e62,e166 in ipairs(e195) do
		if #e80==0 or e214(e80,e166.hitbox) then
			local e234= e166.vec
			if e166.hitbox=="Head" then e234 = e234 - e134(0,0,e233*10) elseif e166.hitbox=="Chest" then e234 = e234 - e134(0,0,e233*4) end
			e232[#e232+1]={vec=e231+e234,scale=e166.scale,hitbox=e166.hitbox}
		end
	end
	for e60=1,7 do
		local e235= e196[e60-1]
		if e235 and (#e80==0 or e214(e80,e235)) then
			local e80= e183(e226,e60-1)
			if e80 then e232[#e232+1]={vec=e134(e80),scale=3,hitbox=e235} end
		end
	end
	return e232
end

local function e236(e56,e237,e238,e239,e240)
	for e62,e166 in ipairs(e239) do
		for e62,e234 in ipairs(e209(e238,e166.vec,3)) do
			local e62,e74= e153(e56, e238.x,e238.y,e238.z, e234.vec.x,e234.vec.y,e234.vec.z, true)
			if e166.hitbox=="Head" then e74=e74*4 end
			if e74>e240 then return e234.vec,e74,e166.hitbox,e234.text end
		end
	end
end

local function e241(e91)
	e224()

	if not e190('misc_dormantaimbot') and e190('misc_dormantaimbot_key') then
		return
	end

	local e154= e155()
	if not e154 or not e163(e154) then
		return
	end

	local e147= e159(e154)
	if not e147 then
		return
	end

	local e242= e185(e147)
	if not e242 or not e186(e242) then
		return
	end

	local e243= e187(e242)
	if not e243 then
		return
	end

	local e244= e134(e151())
	local e245= e160(e154, "m_flSimulationTime")
	local e63= e166()
	local e246= e184(e147)
	local e247= e160(e154, "m_bIsScoped") == 1
	local e62= bit.band(e160(e154, "m_fFlags"), bit.lshift(1, 0))

	local e248= e223()
	if #e248 == 0 then
		e198 = {}
		return
	end

	if e63 % #e248 ~= 0 then
		e200 = e200 + 1
	else
		e200 = 1
	end

	local e226= e248[e200]
	if not e226 then
		e198 = {}
		return
	end

	if e63 < e197 then
		e198 = {}
		return
	end

	if e246.type == "grenade" or e246.type == "knife" then
		e198 = {}
		return
	end

	if e91.in_jump == 1 and e62 == 0 then
		e198 = {}
		return
	end

	local e249= e192
	local e250= e134(e156(e226))
	local e62, e62, e62, e62, e251= e154(e226)

	e198[e226] = nil

	if e251 < 1 then
		if not e216(e207, e226) then
			e207[#e207 + 1] = { e226, e63 }
		end
	else
		e218(e207, e226)
	end

	local e252= e230(e226, e250, e249)
	local e253= e225(e226)

	local e254
	if e246.is_revolver then
		e254 = e245 > e160(e147, "m_flNextPrimaryAttack")
	else
		e254 = e245 > e167(
			e160(e154, "m_flNextAttack"),
			e160(e147, "m_flNextPrimaryAttack"),
			e160(e147, "m_flNextSecondaryAttack")
		)
	end

	if not e254 then
		return
	end

	local e255, e256, e257, e258= e236(
		e154,
		e246,
		e244,
		e252,
		e253
	)

	if not e255 then
		return
	end

	if e150(e255.x, e255.y, e255.z) then
		return
	end

	e219(e91, e229(e246, e247) * 0.33)

	local e157, e81= e244:to(e255):angles()

	if not e247 and e246.type == "sniperrifle" and e91.in_jump == 0 and e62 == 1 then
		e91.in_attack2 = 1
	end

	e198[e226] = true

	if e243 < 0.01 then
		e91.pitch = e157
		e91.yaw = e81
		e91.in_attack = 1
		e201 = true
		e202 = e257
		e203 = e258
		e204 = e226
		e205 = (e172(e47.ui.misc_dormantaimbot_value) or 0)
	end
end

local function e259(e61)
	client.delay_call(0.03, function()
		local e154= e155()
		if client.userid_to_entindex(e61.userid) ~= e154 then
			return
		end

		if e201 and not e206 then
			client.fire_event("dormant_miss", {
				userid = e204,
				aim_hitbox = e202,
				aim_point = e203,
				accuracy = e205
			})
		end

		e206 = false
		e201 = false
		e202 = nil
		e203 = nil
		e204 = nil
		e205 = nil
	end)
end

local function e260(e61)
	local e261= client.userid_to_entindex(e61.userid)
	local e262= client.userid_to_entindex(e61.attacker)

	if e262 == e155() and e261 ~= nil and e201 then
		e206 = true

		client.fire_event("dormant_hit", {
			userid = e261,
			attacker = e262,
			health = e61.health,
			armor = e61.armor,
			weapon = e61.weapon,
			dmg_health = e61.dmg_health,
			dmg_armor = e61.dmg_armor,
			hitgroup = e61.hitgroup,
			accuracy = e205 or 0,
			aim_hitbox = e202
		})
	end
end

local function e263()
	local e264= (cvar.mp_freezetime:get_float() + 1) / globals.tickinterval()
	e197 = e166() + e264
end

e51.register("setup_command", e241, { alive_only = true, require_login = true })
e51.register("round_prestart", e263, { alive_only = true, require_login = true })
e51.register("player_hurt", e260, { alive_only = true, require_login = true })
e51.register("weapon_fire", e259, { alive_only = true, require_login = true })

client.register_esp_flag("DA", 255, 255, 255, function(e217)
	if e190('misc_dormantaimbot') and e190('misc_dormantaimbot_key') and e163(e155()) then
		return e198[e217]
	end
end)


e51.register("paint", function()
	if not e163(e155()) then return end
	if e190('misc_dormantaimbot') and e190('misc_dormantaimbot_key') then
		local e265= {255,255,255,200}
		for e62,e63 in pairs(e198) do if e63 then e265={143,194,21,255}; break end end
		if #e223()==0 then e265={255,0,50,255} end
		e169(e265[1],e265[2],e265[3],e265[4],"DA")
	end
end, { alive_only = true, require_login = true })]]
e661["require/features/misc/enhance_osaa"] = [[local e142, e47= pcall(require, "require/abc/menu_setup")

local e51= require('require/abc/callbacks')

local e189= {}
local e190= {}
for e60, e52 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
    for e62, e75 in ipairs(e82) do
        e190[e75] = true
    end
end

local e153= {}
local e154= {}

e51.register("weapon_fire", function(e138)
    local e154= entity.get_local_player()
    if e154 and client.userid_to_entindex(e138.userid) == e154 then
        e153[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

e51.register("player_hurt", function(e138)
    local e154= entity.get_local_player()
    if e154 and client.userid_to_entindex(e138.userid) == e154 then
        e154[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

local function e155()
    local e66= globals.tickcount()
    local e156= nil
    for e56 = e66-20, e66 do
        if e153[e56] then
            e156 = e56
            break
        end
    end
    if e156 then
        if e66 - e156 <= 4 then
            return true
        end
        return true
    end
    return false
end



local function e157(e91)

    local e155= e155()

    local function e158(e144,e59)
        if type(e144) ~= 'table' then return false end
        for e62, e63 in ipairs(e144) do if tostring(e63) == tostring(e59) then return true end end
        return false
    end

    local e159= ui.get(e47.ui.fakelag_settings_enhance_onshot) or {}

    if e47 and e47.ui and e155 then
            if e158(e159, 'defensive') then
                e91.force_defensive = true
            end

            if e158(e159, 'roll') then
                ui.set(e189[3][1], math.random(-45, 45))
            end

            local e160= globals.tickcount() % 4 < 2
            if e158(e159, 'jitter') then
                ui.set(e189[2][1], '180')
                ui.set(e189[2][2], e160 and 55 or -48)
            end
    end
end

e51.register('setup_command', function(e91)

    e157(e91)

end, { alive_only = true, require_login = true })]]
e661["require/features/misc/events"] = [[local e156= {}
local globals= globals

e156.last_hit = {}
e156.last_miss = {}

e156.shots_queue = {}
e156.shots_by_id = {}

function e156.record_weapon_fire(e157)
  if not e157 or not e157.t then return end
  e156.shots_queue[#e156.shots_queue+1] = e157
end

function e156.record_aim_fire(e65,e157)
  if not e65 or not e157 then return end
  e156.shots_by_id[e65] = e157
end

function e156.record_aim_miss(e65,e261,e158)
  if not e261 then return end
  local e66= globals.curtime()
  local e159= e158 or {}
  e159.time = e66
  e156.last_miss[e261] = e159
  if e65 then e156.shots_by_id[e65] = nil end
end

function e156.record_player_hurt(e65,e261,e158)
  if not e261 then return end
  local e66= globals.curtime()
  local e159= e158 or {}
  e159.time = e66
  e156.last_hit[e261] = e159
  if e65 then e156.shots_by_id[e65] = nil end
end

function e156.link_recent_shot_to_victim(e261,e160)
  e160 = e160 or 0.35
  local e66= globals.curtime()
  for e60=#e156.shots_queue,1,-1 do
    local e88= e156.shots_queue[e60]
    if e88 and e88.target == e261 and (e66 - (e88.t or e66)) <= e160 and not e88.linked then
      e156.shots_queue[e60].linked = true
      return e156.shots_queue[e60]
    end
  end
  return nil
end

return e156
]]
e661["require/features/misc/exploit_fakelag"] = [[local e142, e47= pcall(require, "require/abc/menu_setup")

local e51= require('require/abc/callbacks')

local e189= {}
local e190= {}
for e60, e52 in ipairs({
    { 'rage', 'aimbot', 'double tap' },
    { 'aa', 'other', 'on shot anti-aim' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },

}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
    for e62, e75 in ipairs(e82) do
        e190[e75] = true
    end
end


local function e159(e91)

    local e160= ui.get(e47.ui.misc_exploit_fakelag)

    local e161= (ui.get(e189[1][1]) and ui.get(e189[1][2]))
    local e162= (ui.get(e189[2][1]) and ui.get(e189[2][2]))

    local e163= e160 and (e161 or e162)

    if e163 then
        ui.set(e189[3][1], false)
    end

end

e51.register('setup_command', function(e91)

    e159(e91)

end, { alive_only = true, require_login = true })]]
e661["require/features/misc/fakelag"] = [[local e189= {}
local e190= {}
for e60, e52 in ipairs({
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
    for e62, e75 in ipairs(e82) do
        e190[e75] = true
    end
end

local e162, e163= pcall(require, "require/abc/menu_setup")

local e51= require('require/abc/callbacks')

e51.register("setup_command", function()
    if not (e162 and e163 and e163.ui) then return end

    local e164, e80= pcall(ui.get, e163.ui.fakelag_fakelag)
    if not e164 or not e80 then return end

    local e165, e166= pcall(ui.get, e163.ui.fakelag_fakelag_type)
    if not e165 then return end

    if tostring(e166) == "gamesense" then
        ui.set(e189[1][1], true)
        local e167, e168= pcall(ui.get, e163.ui.fakelag_fakelag_amount)
        local e169, e157= pcall(ui.get, e163.ui.fakelag_fakelag_variance)
        local e170, e171= pcall(ui.get, e163.ui.fakelag_fakelag_limit)

        if e167 and e168 and e189[2] and e189[2][1] then
            pcall(ui.set, e189[2][1], e168)
        end
        if e169 and e157 and e189[3] and e189[3][1] then
            pcall(ui.set, e189[3][1], e157)
        end
        if e170 and e171 and e189[4] and e189[4][1] then
            pcall(ui.set, e189[4][1], e171)
        end

        return
    end

    if tostring(e166) == "sodium" then
        ui.set(e189[1][1], true)
        local e172, e173= pcall(ui.get, e163.ui.fakelag_fakelag_type2)
        if not e172 then return end

        if tostring(e173) == "jitter" then
            if e189[2] and e189[2][1] then
                pcall(ui.set, e189[2][1], "dynamic")
            end
            local e63= globals.tickcount() or 0
            local e174= math.max(e63 % 101, 100)
            local e175= math.min(math.random(7) + (e63 % 15), 11)
            if e189[3] and e189[3][1] then pcall(ui.set, e189[3][1], e174) end
            if e189[4] and e189[4][1] then pcall(ui.set, e189[4][1], 15) end

            return
        end

        if tostring(e173) == "max" then
            if e189[2] and e189[2][1] then
                pcall(ui.set, e189[2][1], "dynamic")
            end
            if e189[3] and e189[3][1] then
                pcall(ui.set, e189[3][1], 0)
            end
            local e171= 14 + ((globals.tickcount() or 0) % 2)
            if e189[4] and e189[4][1] then pcall(ui.set, e189[4][1], e171) end

            return
        end
    end
end, { alive_only = true, require_login = true })]]
e661["require/features/misc/freestand_helper"] = [[local e189= {}
local e190= {}
for e60, e52 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
    for e62, e75 in ipairs(e82) do
        e190[e75] = true
    end
end

local e142, e47= pcall(require, "require/abc/menu_setup")

local e51= require('require/abc/callbacks')

local function e165(e91)
    if not (e47 and e47.ui and e47.ui.aa_gskey_freestand) then return end
    if not ui.get(e47.ui.aa_gskey_freestand) then return end

    local function e158(e144,e59)
        if type(e144) ~= 'table' then return false end
        for e62, e63 in ipairs(e144) do if tostring(e63) == tostring(e59) then return true end end
        return false
    end

    local e159= ui.get(e47.ui.fakelag_settings_freestanding) or {}


    localplayer = entity.get_local_player()
    local e166, e167, e168= entity.get_prop(localplayer, 'm_vecVelocity')
    if e166 and e167 and e168 then
        velvel =  math.sqrt(e166 * e166 + e167 * e167 + e168 * e168)
    end
    


    if e158(e159, 'static') then
        ui.set(e189[1][1], true)
        ui.set(e189[5][1], '180')
        ui.set(e189[5][2], 6)
        ui.set(e189[6][1], 'off')
        ui.set(e189[7][1], 'off')
    end

    if e158(e159, 'zero pitch') and velvel > 5 then
        ui.set(e189[3][1], 'Off')
    end

    if e158(e159, 'defensive') then
        e91.force_defensive = true
    end

    local e160= globals.tickcount() % 4 < 2
    if e158(e159, 'side flip') and velvel > 5 then
        ui.set(e189[5][1], '180')
        ui.set(e189[5][2], e160 and -90 or 90)
    end

    local e160= globals.tickcount() % 6 < 2
    if e158(e159, 'pitch flip') and velvel > 5 then
        ui.set(e189[3][1], 'custom')
        ui.set(e189[3][2], e160 and -89 or 89)
    end

end

e51.register('setup_command', function(e91)
    e165(e91)
end, { alive_only = true, require_login = true })]]
e661["require/features/misc/history"] = [[
local e168= {}

local e169= 20
local e170= {}

local function e171(e217)
  if not e170[e217] then e170[e217] = { buf = {} } end
  return e170[e217]
end

function e168.push(e217,e172)
  if not e217 or not e172 then return end
  local e173= e171(e217)
  e173.buf[#e173.buf+1] = e172
  if #e173.buf > e169 then table.remove(e173.buf, 1) end
end

function e168.get_last_n(e217,e129)
  e129 = e129 or e169
  local e173= e170[e217]
  if not e173 or #e173.buf == 0 then return {} end
  local e174= {}
  local e175= #e173.buf
  local e176= math.max(1, e175 - e129 + 1)
  for e60 = e176, e175 do e174[#e174+1] = e173.buf[e60] end
  return e174
end

function e168.clear(e217)
  if not e217 then e170 = {} return end
  e170[e217] = nil
end

return e168
]]
e661["require/features/misc/hotkeys"] = [[local e189= {}
local e190= {}
for e60, e52 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
    for e62, e75 in ipairs(e82) do
        e190[e75] = true
    end
end

local e142, e47= pcall(require, "require/abc/menu_setup")

local e51= require('require/abc/callbacks')

local function e171()

    if ui.get(e47.ui.aa_gskey_freestand) then
        ui.set(e189[3][1], true)
        ui.set(e189[3][2], 'Always on')
    else
        ui.set(e189[3][1], false)
        ui.set(e189[3][2], 'On hotkey')
    end

    if ui.get(e47.ui.aa_gskey_slowmotion) then
        ui.set(e189[4][1], true)
    else
        ui.set(e189[4][1], false)
    end

    if e47 and e47.ui and ui.get(e47.ui.aa_gskey_edgeyaw) then
        ui.set(e189[2][1], true)
    else
        ui.set(e189[2][1], false)
    end

    if e47 and e47.ui and ui.get(e47.ui.aa_gskey_onshot) then
        ui.set(e189[6][2], 'Always on')
    else
        ui.set(e189[6][2], 'On hotkey')
    end

end

e51.register('setup_command', function()

    e171()

end, { alive_only = true, require_login = true })]]
e661["require/features/misc/localdebug"] = [=[local callbacks_ok, callbacks = pcall(require, "require/abc/callbacks")
local M = {}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")

local state = {
    last_yaw = nil,
    last_pitch = nil,
    last_defensive = false,
    skel_list = {},
    last_choked = 0,
    shot_ticks = {},
    shot_ticks_aim = {},
    skel_history = {},
}

local function normalize_angle(a)
    if not a then return a end
    local ang = tonumber(a) or 0
    while ang > 180 do ang = ang - 360 end
    while ang <= -180 do ang = ang + 360 end
    return ang
end

local function on_weapon_fire(ev)
    if not ev then return end
    local attacker_ent = client.userid_to_entindex(ev.userid)
    local lp = entity.get_local_player()
    if attacker_ent ~= lp then return end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks, t)
    while #state.shot_ticks > 200 do table.remove(state.shot_ticks, 1) end
end

local function on_aim_fire(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    if ev.attacker then
        local attacker_ent = client.userid_to_entindex(ev.attacker)
        if attacker_ent ~= lp then return end
    end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks_aim, t)
    while #state.shot_ticks_aim > 200 do table.remove(state.shot_ticks_aim, 1) end
end

local function had_recent_shot(ticks_back)
    ticks_back = ticks_back or 30
    local now = globals.tickcount and globals.tickcount() or 0
    for i = #state.shot_ticks_aim, 1, -1 do
        local s = state.shot_ticks_aim[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    for i = #state.shot_ticks, 1, -1 do
        local s = state.shot_ticks[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    return false
end

local function safe_tonumber(v)
    local n = tonumber(v)
    if n then return n end
    return 0
end


local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {
    head={names={'head','Head','HEAD'},idx={0}},
    neck={names={'neck','Neck'},idx={1}},
    chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},
    stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},
    pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},
    l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},
    l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},
    l_hand={names={'left hand','Left Hand'},idx={14}},
    r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},
    r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},
    r_hand={names={'right hand','Right Hand'},idx={13}},
    l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},
    l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},
    l_foot={names={'left foot','Left Foot'},idx={12}},
    r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},
    r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},
    r_foot={names={'right foot','Right Foot'},idx={11}},
}

local function find_bone(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x,y,z = entity.hitbox_position(ent, def.names[i])
        if x then return x,y,z end
    end
    for i = 1, #(def.idx or {}) do
        local x,y,z = entity.hitbox_position(ent, def.idx[i])
        if x then return x,y,z end
    end
end

local function snap_ent(ent)
    if not ent then return end
    local pts = {}
    for key, def in pairs(boxes) do
        local x,y,z = find_bone(ent, def)
        if x then pts[key] = {x=x,y=y,z=z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local function paint_handler()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lag_record then
        local ok_enabled, enabled = pcall(ui.get, menu_setup.ui.paint_lag_record)
        if not ok_enabled or not enabled then return end
    end
    if not renderer or not renderer.world_to_screen or not renderer.line then return end
    local now = globals.realtime and globals.realtime() or os.time()
    local i = 1
    while i <= #state.skel_list do
        local it = state.skel_list[i]
        if not it or not it.t or (now - it.t) > 10 then
            table.remove(state.skel_list, i)
        else
            local SKEL_SCALE = 1.15
            
            local trail = it.trail or {}
            if trail and #trail > 0 then
                for ti = 1, #trail do
                    local entry = trail[ti]
                    local trail_pts = entry.pts or {}
                    
                    local ratio = ti / #trail
                    local r, g, b, alpha
                    if ti == #trail then
                        
                        r = 0
                        g = 140
                        b = 255
                        alpha = 200
                    else
                        
                        r = 255
                        g = math.floor(255 * (1 - ratio))
                        b = math.floor(255 * (1 - ratio))
                        alpha = math.floor(40 + ratio * (160 - 40))
                    end
                    
                    local center = trail_pts.pelvis or trail_pts.chest
                    if not center then
                        local sx, sy, sz, ccount = 0,0,0,0
                        for k, v in pairs(trail_pts) do
                            if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                        end
                        if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
                    end
                    for c = 1, #chains do
                        local chain = chains[c]
                        local from, to = trail_pts[chain[1]], trail_pts[chain[2]]
                        if from and to then
                            local fxw, fyw, fzw = from.x, from.y, from.z
                            local txw, tyw, tzw = to.x, to.y, to.z
                            if center and center.x then
                                fxw = center.x + (from.x - center.x) * SKEL_SCALE
                                fyw = center.y + (from.y - center.y) * SKEL_SCALE
                                fzw = center.z + (from.z - center.z) * SKEL_SCALE
                                txw = center.x + (to.x - center.x) * SKEL_SCALE
                                tyw = center.y + (to.y - center.y) * SKEL_SCALE
                                tzw = center.z + (to.z - center.z) * SKEL_SCALE
                            end
                            local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                            local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                            if fx and tx then renderer.line(fx,fy,tx,ty,r,g,b,alpha) end
                        end
                    end
                end
            end
            
            local pts = it.pts or {}
            local center = pts.pelvis or pts.chest
            if not center then
                local sx, sy, sz, ccount = 0,0,0,0
                for k, v in pairs(pts) do
                    if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                end
                if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
            end
            for c = 1, #chains do
                local chain = chains[c]
                local from, to = pts[chain[1]], pts[chain[2]]
                if from and to then
                    local fxw, fyw, fzw = from.x, from.y, from.z
                    local txw, tyw, tzw = to.x, to.y, to.z
                    if center and center.x then
                        fxw = center.x + (from.x - center.x) * SKEL_SCALE
                        fyw = center.y + (from.y - center.y) * SKEL_SCALE
                        fzw = center.z + (from.z - center.z) * SKEL_SCALE
                        txw = center.x + (to.x - center.x) * SKEL_SCALE
                        tyw = center.y + (to.y - center.y) * SKEL_SCALE
                        tzw = center.z + (to.z - center.z) * SKEL_SCALE
                    end
                    local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                    local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                    if fx and tx then renderer.line(fx,fy,tx,ty,255,0,0,220) end
                end
            end
            i = i + 1
        end
    end
end


local function on_setup_command(cmd)
    if not cmd then return end
    local aa_funcs = nil
    local ok_req, req_lib = pcall(require, 'gamesense/antiaim_funcs')
    if ok_req and req_lib then aa_funcs = req_lib end
    if not aa_funcs then
        local ok_libs, libs = pcall(require, 'require/help/libs')
        if ok_libs and libs and libs.get then
            aa_funcs = libs.get('antiaim_funcs')
        end
    end

    local pitch, yaw = nil, nil
    if aa_funcs then
        local okp, pval = pcall(function() return aa_funcs.get_pitch and aa_funcs.get_pitch() end)
        if okp and pval ~= nil then pitch = pval end
        local oky, yval = pcall(function() return aa_funcs.get_yaw_base and aa_funcs.get_yaw_base() end)
        if oky and yval ~= nil then yaw = yval end
        if yaw == nil then
            local okb, bval = pcall(function() return aa_funcs.get_body_yaw and aa_funcs.get_body_yaw() end)
            if okb and bval ~= nil then yaw = bval end
        end
    end

    if (pitch == nil or yaw == nil) then
        local lp = entity.get_local_player()
        if lp then
            local ax, ay = entity.get_prop(lp, "m_angEyeAngles")
            if ax and ay then
                if pitch == nil then pitch = ax end
                if yaw == nil then yaw = ay end
            end
        end
    end

    if pitch ~= nil then state.last_pitch = pitch end
    if yaw ~= nil then state.last_yaw = normalize_angle(yaw) end

    do
        local ok_def, def_mod = pcall(require, 'require/features/aa/defensive')
        if ok_def and def_mod and def_mod.active ~= nil then
            state.last_defensive = not not def_mod.active
        else
            if cmd and cmd.force_defensive ~= nil then
                state.last_defensive = not not cmd.force_defensive
            end
        end
    end
    if cmd and cmd.chokedcommands ~= nil then
        state.last_choked = tonumber(cmd.chokedcommands) or 0
    end
    local lp = entity.get_local_player()
    if lp then
        local tick = globals.tickcount and globals.tickcount() or 0
        local hist_pts = snap_ent(lp)
        if hist_pts then
            state.skel_history[#state.skel_history + 1] = { tick = tick, pts = hist_pts }
            if #state.skel_history > 128 then table.remove(state.skel_history, 1) end
        end
    end
end

local function on_player_death(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    local victim_ent = client.userid_to_entindex(ev.userid)
    local attacker_ent = nil
    if ev.attacker then attacker_ent = client.userid_to_entindex(ev.attacker) end

    if victim_ent == lp then
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then
                attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker)
            else
                attacker_name = tostring(ev.attacker)
            end
        end
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] DIED — last_yaw=%.2f last_pitch=%.2f attacker=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
        return
    end
    if attacker_ent == lp and victim_ent and victim_ent ~= 0 and victim_ent ~= lp then
        local victim_name = entity.get_player_name(victim_ent) or tostring(ev.userid)
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] KILLED — last_yaw=%.2f last_pitch=%.2f victim=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, victim_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end
end

if callbacks_ok and callbacks and callbacks.callback then
    callbacks.callback('setup_command', on_setup_command, { alive_only = false, require_login = false })
    callbacks.callback('player_death', on_player_death, { alive_only = false, require_login = false })
    callbacks.callback('paint', paint_handler, { alive_only = false, require_login = false })
    callbacks.callback('weapon_fire', on_weapon_fire, { alive_only = false, require_login = false })
    callbacks.callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end, { alive_only = false, require_login = false })
else
    client.set_event_callback('setup_command', on_setup_command)
    client.set_event_callback('player_death', on_player_death)
    client.set_event_callback('paint', paint_handler)
    client.set_event_callback('weapon_fire', on_weapon_fire)
    client.set_event_callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end)
end
]=]
e661["require/features/misc/resolver"] = [[














local e177, e178= pcall(require, "require/features/misc/collect")
local e179, e168= pcall(require, "require/features/misc/history")
local e180, e120= pcall(require, "require/features/misc/state")
local e181, e156= pcall(require, "require/features/misc/events")
local e182, e183= pcall(require, "require/help/vector")
local e134= e182 and e183 or nil
local e51= require('require/abc/callbacks')







if not e54 then e54 = {} end
e54.players = e54.players or {}


local function e184()
	pcall(function()
		if not e177 or type(e178) ~= "table" or not e178.get_enemies_snapshot then return end

		local e53, e185= pcall(function() return e178.get_enemies_snapshot() end)
		if not e53 or type(e185) ~= "table" then return end

		e54.players = e54.players or {}

		for e140, e64 in pairs(e185) do
			e54.players[e140] = e54.players[e140] or {}
			e54.players[e140].snapshot = e64

            
            
            
			e54.players[e140].simtime = e64.simtime
			e54.players[e140].simTicks = e64.simTicks
			e54.players[e140].lowerBodyYaw = e64.lowerBodyYaw
			e54.players[e140].speed2d = e64.speed2d
			e54.players[e140].velocity3d = e64.velocity3d
			e54.players[e140].is_alive = e64.is_alive
			e54.players[e140].is_dormant = e64.is_dormant
			e54.players[e140].feetYaw = e64.feetYaw
			e54.players[e140].goalFeetYaw = e64.goalFeetYaw
			e54.players[e140].moveSpeedAnim = e64.moveSpeedAnim
		end

		for e140, e64 in pairs(e185) do
			local e59= e64.name or "?"
			local e186= e64.simtime or 0
			local e187= e64.speed2d or 0
			local e188= e64.lowerBodyYaw or "nil"
			local e189= e64.moveSpeedAnim or 0
			local e173= e64.feetYaw or "nil"
			local e190= e64.goalFeetYaw or "nil"
			local e191= e64.animstate_full.m_fDuckAmount

		end
	end)
end



local function e141(e120)
    while e120 > 180 do
        e120 = e120 - 360
    end
    while e120 < -180 do
        e120 = e120 + 360
    end
    return e120
end


local function e192(e193,e194)
    local e188= e194 - e193
    local e120= math.atan(e188.y / e188.x)
    e120 = e141(e120 * 180 / math.pi)

    if e188.x >= 0 then
        e120 = e141(e120 + 180)
    end

    return e120
end



local e195= 100
local e196= {}
_G.player_history = e196

local function e197(e198)
    return math.floor(0.5 + e198 / globals.tickinterval())
end

local function e199(e154)
    local e200= entity.get_players(true)

	if #e200 == 0 then
		
		e196 = {}
		_G.player_history = e196
		return nil
	end


	for e60, e217 in ipairs(e200) do
		if entity.is_alive(e217) and not entity.is_dormant(e217) then

			local e201= 0
			local e202= entity.get_esp_data(e217).flags or 0

			if bit.band(e202, bit.lshift(1, 17)) ~= 0 then
				e201 = e197(entity.get_prop(e217, "m_flSimulationTime")) - 14
			else
				e201 = e197(entity.get_prop(e217, "m_flSimulationTime"))
			end

			
			local e147= e196[e217] or {}
			local e203= e147[1]

			if e203 == nil or (e201 - (e203.simtime or -999)) >= 1 then

				local e204= e134(entity.get_prop(e154, "m_vecOrigin"))
				local e205= e134(entity.get_prop(e217, "m_angEyeAngles"))
				local e206= e134(entity.get_prop(e217, "m_vecOrigin"))
				local e207= math.floor(e141(e205.y - e192(e204, e206)))
				

				local e64= {
					id = e217 or nil,
					origin = e134(entity.get_origin(e217)) or e134(nil,nil,nil),
					pitch = e205.x or nil,
					yaw = e207 or nil,
					yaw_backwards = backwards_angle or nil,
					simtime = e201 or nil,
					stance = stance or nil,
					esp_flags = entity.get_esp_data(e217).flags or 0,
					last_shot_time = last_shot_time or nil
				}

				table.insert(e147, 1, e64)
				while #e147 > e195 do
					table.remove(e147)
				end

				e196[e217] = e147
			end
		end
	end
end















client.set_event_callback('net_update_end', function()
    pcall(function()

        
        

        local e154= entity.get_local_player()
        if not entity.is_alive(e154) then
            return
        end
        e199(e154)


        local e63= (globals and globals.tickcount and globals.tickcount()) or (globals and globals.realtime and globals.realtime()) or os.time()
        

    end)
end, { alive_only = true, require_login = true })

e51.register('weapon_fire', function(e138)
    pcall(function()







        local e208= (e138 and e138.userid) and (client.userid_to_entindex and client.userid_to_entindex(e138.userid)) or (e138 and (e138.attacker or e138.userid)) or "?"
        local e88= (e138 and (e138.weapon or e138.weapon_name or e138.weaponid)) or "?"
        
    end)
    if EVENTS and EVENTS.record_weapon_fire then pcall(EVENTS.record_weapon_fire, e138) end
end, { alive_only = true, require_login = true })

e51.register('aim_fire', function(e138)
    pcall(function()








        local e65= e138 and e138.id or "?"
        local e209= e138 and e138.target or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_fire then pcall(EVENTS.record_aim_fire, e138) end
end, { alive_only = true, require_login = true })

e51.register('aim_hit', function(e138)
    pcall(function()








        local e65= e138 and e138.id or "?"
        local e209= e138 and e138.target or "?"
        local e210= e138 and e138.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_hit then pcall(EVENTS.record_aim_hit, e138) end
end, { alive_only = true, require_login = true })

e51.register('aim_miss', function(e138)
    pcall(function()






        local e65= e138 and e138.id or "?"
        local e76= e138 and e138.reason or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_miss then pcall(EVENTS.record_aim_miss, e138) end
end, { alive_only = true, require_login = true })

e51.register('player_hurt', function(e138)
    pcall(function()






        local e262= (e138 and e138.attacker) or (e138 and e138.userid) or "?"
        local e261= (e138 and e138.userid) or (e138 and e138.userid) or "?"
        local e210= e138 and e138.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_player_hurt then pcall(EVENTS.record_player_hurt, e138) end
end, { alive_only = true, require_login = true })

e51.register('bullet_impact', function(e138)
    pcall(function()




        local e208= (e138 and e138.userid) and (client.userid_to_entindex and client.userid_to_entindex(e138.userid)) or "?"
        local e59,e87,e116= e138 and e138.x or "?", e138 and e138.y or "?", e138 and e138.z or "?"
        
    end)
    if EVENTS and EVENTS.on_bullet_impact then pcall(EVENTS.on_bullet_impact, e138) end
    if EVENTS and EVENTS.record_bullet_impact then pcall(EVENTS.record_bullet_impact, e138) end
end, { alive_only = true, require_login = true })

e51.register('paint', function()
    pcall(function()

        

    end)
    if EVENTS and EVENTS.on_paint then pcall(EVENTS.on_paint) end
end, { alive_only = true, require_login = true })

e51.register("round_start", function(e138)
    pcall(function() print("[resolver] round_start") end)



    e54.players = {}
    if EVENTS and EVENTS.on_round_start then pcall(EVENTS.on_round_start, e138) end
end, { alive_only = true, require_login = true })

e51.register("shutdown", function()
    if client and client.unset_event_callback then



    end
end, { alive_only = true, require_login = true })
]]
e661["require/features/misc/resolver_dispatcher"] = [[local e54= {}


local e53= {}


_G.player_resolver_state = _G.player_resolver_state or {}

local function e180(e171)
    if not e171 or type(e171) ~= "string" then return nil end
    
    local e88= e171:lower()
    e88 = e88:gsub("%+", "plus")
    e88 = e88:gsub("%-% ", "minus_") 
    e88 = e88:gsub("%-%", "minus")
    e88 = e88:gsub("%s+", "_")
    e88 = e88:gsub("[^%w_]", "")
    return e88
end

local function e181(e171)
    local e95
    
    if e171 == "?" then
        e95 = "default"
    else
        e95 = e180(e171)
    end
    if not e95 or e95 == "" then return nil end
    if e53[e95] ~= nil then return e53[e95] end
    local e59= "require/features/misc/res_" .. e95
    local e53, e182= pcall(require, e59)
    if e53 and type(e182) == "table" then
        e53[e95] = e182
        return e182
    end
    e53[e95] = false
    return nil
end



function e54.process_entity(e140,e171,e164)
    local e53, e62= pcall(function()
        if not e140 or e140 == 0 then return end
        if not e171 or e171 == "?" then return end

        local e182= e181(e171)
        if not e182 then return end

        
        local e120= _G.player_resolver_state[e140]
        if not e120 then
            e120 = {}
            _G.player_resolver_state[e140] = e120
        end

        if type(e182.run) == "function" then
            
            pcall(function() e182.run(e140, e164 or {}, e120, e171) end)
        elseif type(e182.process) == "function" then
            pcall(function() e182.process(e140, e164 or {}, e120, e171) end)
        end
    end)
    return e53
end


e54._modules = e53
e54._sanitize_label = e180

return e54
]]
e661["require/features/misc/res_default"] = [[local e54= {}

local function e183(e140)
    pcall(function()
        if plist and type(plist.set) == "function" then
            
            plist.set(e140, "Force body yaw", false)
            plist.set(e140, "Force body yaw value", 0)
            plist.set(e140, "Force pitch", false)
            plist.set(e140, "Force pitch value", 0)
        end
    end)
end

function e54.run(e140,e164,e120,e171)
    
    if e171 ~= "?" and e171 ~= "DEFAULT" and e171 ~= "default" then return end

    e120.clears = (e120.clears or 0) + 1
    e120.last_seen = (globals and globals.curtime and globals.curtime()) or os.time()

    
    e183(e140)

    pcall(function()
        print(string.format("[res_default] ent=%d cleared_forces label=%s count=%d", e140, tostring(e171), e120.clears))
    end)
end

return e54
]]
e661["require/features/misc/res_static"] = [=[local M = {}
local ok_ffi, ffi = pcall(require, "ffi")
local ok_bit, bit = pcall(require, "bit")


local get_entity_ptr
local function init_ffi_helpers()
    if not ok_ffi or not client or not client.create_interface then return end
    local status, res = pcall(function()
        local pointer_type = ffi.typeof("void***")
        local entity_list_ptr = client.create_interface("client.dll", "VClientEntityList003")
        if not entity_list_ptr then return nil end
        local entity_list = ffi.cast(pointer_type, entity_list_ptr)
        local get_client_entity = ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
        return function(entindex)
            if not entindex or entindex == 0 then return nil end
            local ptr = get_client_entity(entity_list, entindex)
            if ptr == nil then return nil end
            return ptr
        end
    end)
    if status and type(res) == "function" then
        get_entity_ptr = res
    else
        get_entity_ptr = nil
    end
end
init_ffi_helpers()

local function get_speed2d(ent)
    
    local ok, vx, vy = pcall(function()
        local x,y,z = entity.get_prop(ent, "m_vecVelocity")
        return x or 0, y or 0
    end)
    if ok and vx and vy then
        return math.sqrt((vx or 0)*(vx or 0) + (vy or 0)*(vy or 0))
    end
    return 0
end

local function estimate_max_desync_ent(ent)
    
    if not ok_ffi or not get_entity_ptr then return nil end
    local ok_read, result = pcall(function()
        ffi.cdef[[
        struct c_animstate {
            char pad0[3];
            char m_bForceWeaponUpdate;
            char pad1[91];
            void* m_pBaseEntity;
            void* m_pActiveWeapon;
            void* m_pLastActiveWeapon;
            float m_flLastClientSideAnimationUpdateTime;
            int m_iLastClientSideAnimationUpdateFramecount;
            float m_flAnimUpdateDelta;
            float m_flEyeYaw;
            float m_flPitch;
            float m_flGoalFeetYaw;
            float m_flCurrentFeetYaw;
            float m_flCurrentTorsoYaw;
            float m_flUnknownVelocityLean;
            float m_flLeanAmount;
            char pad2[4];
            float m_flFeetCycle;
            float m_flFeetYawRate;
            char pad3[4];
            float m_fDuckAmount;
            float m_fLandingDuckAdditiveSomething;
            char pad4[4];
            float m_vOriginX;
            float m_vOriginY;
            float m_vOriginZ;
            float m_vLastOriginX;
            float m_vLastOriginY;
            float m_vLastOriginZ;
            float m_vVelocityX;
            float m_vVelocityY;
            char pad5[4];
            float m_flUnknownFloat1;
            char pad6[8];
            float m_flUnknownFloat2;
            float m_flUnknownFloat3;
            float m_flUnknown;
            float m_flSpeed2D;
            float m_flUpVelocity;
            float m_flSpeedNormalized;
            float m_flFeetSpeedForwardsOrSideWays;
            float m_flFeetSpeedUnknownForwardOrSideways;
            float m_flTimeSinceStartedMoving;
            float m_flTimeSinceStoppedMoving;
            bool m_bOnGround;
            bool m_bInHitGroundAnimation;
            char pad7[2];
            float m_flTimeSinceInAir;
            float m_flLastOriginZ;
            float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
            float m_flStopToFullRunningFraction;
            float m_flMagicFraction;
            char pad8[60];
            float m_flWorldForce;
            char pad9[462];
            float m_flMaxYaw;
        };
        ]]
        local ent_ptr = get_entity_ptr(ent)
        if not ent_ptr then return nil end
        local animstate_ptr = ffi.cast("struct c_animstate**", ffi.cast("uintptr_t", ent_ptr) + 0x9960)
        if animstate_ptr == nil or animstate_ptr == ffi.NULL then return nil end
        local anim = animstate_ptr[0]
        if anim == nil or anim == ffi.NULL then return nil end

        local duck_amount = tonumber(anim.m_fDuckAmount) or 0
        local speed2d_norm = tonumber(anim.m_flFeetSpeedForwardsOrSideWays) or 0
        local stop_to_full = tonumber(anim.m_flStopToFullRunningFraction) or 0
        local max_yaw = tonumber(anim.m_flMaxYaw) or 0

        local yaw_modifier = ((-0.3 * stop_to_full) - 0.2) * math.max(0, math.min(speed2d_norm, 1)) + 1.0
        if duck_amount > 0 then
            yaw_modifier = yaw_modifier + (duck_amount * 0.5) * (0.5 - yaw_modifier)
        end

        local raw_delta = max_yaw * yaw_modifier
        local velocity = get_speed2d(ent) or 0
        local velocity_clamped = math.min(math.max(velocity, 0), 260)
        local move_scale = 1.0 - (velocity_clamped / 260)
        move_scale = 0.35 + (move_scale * 0.65)
        local delta = raw_delta * move_scale
        if velocity >= 250 then
            delta = math.min(delta, 28)
        end
        local flags = nil
        if ok_bit and entity and entity.get_prop then
            flags = entity.get_prop(ent, "m_fFlags") or 0
        end
        local on_ground = true
        if flags then on_ground = bit.band(flags, 1) == 1 end
        if not on_ground then delta = delta * 0.55 end
        if duck_amount > 0.9 then delta = delta * 0.9 end
        delta = math.max(0, math.min(delta, 60))
        return delta
    end)
    if ok_read then return result end
    return nil
end

local function safe_unset(ent)
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", false)
            plist.set(ent, "Force body yaw value", 0)
        end
    end)
end

local function now_time()
    local ok, t = pcall(function() return (globals and globals.curtime and globals.curtime()) or os.time() end)
    return ok and t or os.time()
end

local function normalize_angle(angle)
    if not angle or type(angle) ~= "number" then return 0 end
    while angle > 180 do angle = angle - 360 end
    while angle < -180 do angle = angle + 360 end
    return angle
end

local function round(n)
    return math.floor((n or 0) + 0.5)
end

function M.run(ent, features, state, label)
    
    state.count = (state.count or 0) + 1
    state.last_seen = now_time()
    if state.last_label and state.last_label ~= label then state.count = 1 end
    state.last_label = label

    
    if not label or label ~= "STATIC" then return end

    
    local required_count = 3
    if state.count < required_count then return end

    
    if features and features.shot_age and tonumber(features.shot_age) and features.shot_age <= 0.25 then
        return
    end

    
    local avg_speed = tonumber((features and features.avg_speed) or 0) or 0
    if features and features.movement and features.movement == true then return end
    if avg_speed >= 1.2 then return end

    
    local max_mag_low = 58
    local max_mag_high = 28
    local speed_cap = 250
    local t = math.min(math.max(avg_speed / speed_cap, 0), 1)
    local max_mag = max_mag_low + (max_mag_high - max_mag_low) * t

    
    local ok_est, est = pcall(function() return estimate_max_desync_ent(ent) end)
    if ok_est and est and type(est) == "number" then
        max_mag = math.min(max_mag, est)
    end

    
    local on_ground = true
    pcall(function()
        if ok_bit and entity and entity.get_prop then
            local flags = entity.get_prop(ent, "m_fFlags") or 0
            on_ground = bit.band(flags, 1) == 1
        end
    end)
    if not on_ground then max_mag = max_mag * 0.55 end

    
    local forced_val = 0

    
    local last_yaw = (features and features.last_yaw)
    local ref_yaw = features and (features.goal_feet_yaw or features.feet_yaw)
    local desync = nil
    if last_yaw and ref_yaw then
        desync = normalize_angle(last_yaw - ref_yaw)
    end

    
    if not desync then
        forced_val = 0
    else
        local absd = math.abs(desync)
        
        if absd <= 10 then
            forced_val = 0
        else
            
            if ok_est and est and type(est) == "number" and est >= 8 then
                local mag = math.min(math.floor(max_mag + 0.5), math.floor(est + 0.5))
                local desired = math.min(absd, mag)
                
                if desired >= 8 then
                    forced_val = (desync >= 0) and desired or -desired
                else
                    forced_val = 0
                end
            else
                
                forced_val = 0
            end
        end
    end

    
    forced_val = round(forced_val)
    if forced_val > 60 then forced_val = 60 end
    if forced_val < -60 then forced_val = -60 end

    
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", true)
            plist.set(ent, "Force body yaw value", forced_val)
            state.forced = true
            state.forced_value = forced_val
            state.cooldown = now_time() + 0.5

            if client and type(client.delay_call) == "function" then
                client.delay_call(0.6, function()
                    pcall(function()
                        local t = now_time()
                        if not state.cooldown or t > state.cooldown then
                            safe_unset(ent)
                            state.forced = nil
                            state.forced_value = nil
                        end
                    end)
                end)
            end
        end
    end)
end

return M
]=]
e661["require/features/misc/roll"] = [[local e142, e47= pcall(require, "require/abc/menu_setup")

local e189= {}
local e190= {}
for e60, e52 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
    for e62, e75 in ipairs(e82) do
        e190[e75] = true
    end
end

local function e189(e91)
end

    local e190= 0
    local e135= 1

    if e142 and e47 and e47.ui then
        if e47.ui.fakelag_settings_roll ~= nil then
            local e53, e54= pcall(ui.get, e47.ui.fakelag_settings_roll)
            if e53 and e54 ~= nil then e190 = e54 end
        end
        if e47.ui.fakelag_settings_side ~= nil then
            local e53, e54= pcall(ui.get, e47.ui.fakelag_settings_side)
            if e53 and e54 ~= nil then e135 = e54 end
        end
    end

    local e133= entity.get_local_player()
    local e124= 0
    if e133 then
        local e191= entity.get_prop(e133, 'm_vecVelocity')
        if e191 then
            local e59= e191.x or e191[1] or 0
            local e87= e191.y or e191[2] or 0
            local e116= e191.z or e191[3] or 0
            e124 = math.sqrt(e59*e59 + e87*e87 + e116*e116)
        end
    end

    if e124 > 3 then
        pcall(ui.set, e189[1] and e189[1][1], 0)
        return
    end

    if e135 == 3 then
        pcall(ui.set, e189[1] and e189[1][1], -e190)
    elseif e135 == 2 then
        local e192= (globals.tickcount() % 20) < 10
        pcall(ui.set, e189[1] and e189[1][1], (e192 and e190 or -e190))
    elseif e135 == 1 then
        pcall(ui.set, e189[1] and e189[1][1], e190)
    end

end

client.set_event_callback('setup_command', function(e91)

    e189(e91)

end)]]
e661["require/features/misc/spin_on_dead_enemies"] = [[local e189= {}
for e60, e52 in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
end

local e138, e73, e192, e71= entity, globals, ui, client
local e47= require("require/abc/menu_setup")
local e193= (e71.random_int(1, 2) == 1) and 1 or -1

local function e151()
    local e81= {
        {2, 'Off'}, {3, 'Local view'}, {4, {'Spin', 45}}, {5, {'Off', 0}}, {6, {'Off', 0}},
    }
    local e193= (e71.random_int(1, 2) == 1) and 1 or -1
    for e62, e63 in ipairs(e81) do
        local e67, e54= e63[1], e63[2]
        local e82= e189[e67]
        if not e82 then goto continue end
        if type(e54) ~= 'table' then
            pcall(e192.set, e82[1], e54)
        else
            if e82[1] then pcall(e192.set, e82[1], e54[1]) end
            if e82[2] then
                if type(e54[2]) == 'number' and e54[1] == 'Spin' then
                    pcall(e192.set, e82[2], e54[2] * e193)
                else
                    pcall(e192.set, e82[2], e54[2])
                end
            end
        end
        ::continue::
    end
end

local function e128()
    local e129= (e73.maxplayers and e73.maxplayers() or 64)
    local e130, e131, e132= e138.get_classname, e138.is_enemy, e138.is_alive
    if not (e130 and e131 and e132) then return 0 end
    local e133= 0
    for e60=1,e129 do
        if e130(e60) == 'CCSPlayer' and e131(e60) and e132(e60) then e133 = e133 + 1 end
    end
    return e133
end

local function e63()
    if not e192.get(e47.ui.misc_spindead) then return end
    if e128() == 0 then e151() end
end

local e194, e51= pcall(require, "require/abc/callbacks")
if e194 and e51 then
    e51.callback('run_command', e63, { alive_only = true, require_login = true })
end
]]
e661["require/features/misc/walkbot"] = [[local e51= require("require/abc/callbacks")
local e47= require("require/abc/menu_setup")

local e665= nil
local e195= 1
local e196= 0
local e197= 40
local e65= 30
local e198= 450
local e199= 200
local e200= 8
local e201= {150, 300}
local e202= nil
local e211= nil
local e203= nil
local e204= 0
local e205= 700
local e206= 3

local e207= {}
local e208= 3
local e209= 4
local e210= 0
local e211= nil
local e212= 0
local e213= 500
local e214= 1500
local e215= 30
local e216= {}
local e217= false

local e218= 500 
local e219= 0

local e220= {
    { name = "A", x = -445.0, y = -1997.7, z = -180.0 },
    { name = "B", x = -2032.4, y = 259.8, z = -160.0 },
    { name = "Mid", x = -350.3, y = -617.1, z = -269.2 },
}

local function e221(e52)
    if not e52 then return false end
    local e53, e54= pcall(ui.get, e52)
    if not e53 then return false end
    return e54
end

local function e222(e70)
    while e70 > 180 do e70 = e70 - 360 end
    while e70 < -180 do e70 = e70 + 360 end
    return e70
end

local function e223(e224,e225,e226,e227,e228,e229)
    local e180, e181, e230= e224-e227, e225-e228, e226-e229
    return math.sqrt(e180*e180 + e181*e181 + e230*e230)
end

local function e231(e56,e232,e233,e234,e235,e236,e237)
    local e53, e238, e140= pcall(function()
        return client.trace_line(e56, e232, e233, e234, e235, e236, e237)
    end)
    if not e53 then return nil end
    return e238, e140
end

local function e239(e56,e59,e87,e116)
    local e240= e116 + 1000
    local e241= e116 - 1000
    local e238= e231(e56, e59, e87, e240, e59, e87, e241)
    if not e238 then return e116 end
    if type(e238) ~= 'number' then return e116 end
    local e242= e240 + (e241 - e240) * e238
    return e242
end

local function e243(e56,e232,e233,e234,e235,e236,e237)
    local e238= e231(e56, e232, e233, e234, e235, e236, e237)
    if not e238 then return false end
    if e238 >= 1 then return true end
    return false
end

local function e244(e59,e87)
    return tostring(math.floor(e59/50))..":"..tostring(math.floor(e87/50))
end

local function e245(e59,e87)
    local e162= e244(e59, e87)
    e207[e162] = (e207[e162] or 0) + 1
    if e207[e162] >= e208 then
        e216[e162] = true
    end
    return e207[e162]
end

local function e246(e59,e87)
    local e162= e244(e59, e87)
    e207[e162] = nil
end

local function e247(e56)
    local e248, e249, e250= entity.get_origin(e56)
    if not e248 then return nil end
    for e60=1,e65 do
        local e251= math.random()*math.pi*2
        local e171= 200 + math.random()*800
        local e235= e248 + math.cos(e251)*e171
        local e236= e249 + math.sin(e251)*e171
        local e237= e250
            local e238= e231(e56, e248, e249, e250 + 16, e235, e236, e237 + 16)
        if e238 and e238 >= 1 then
            local e252= e239(e56, e235, e236, e237)
            return { x = e235, y = e236, z = e252 }
        end
        if e238 and e238 < 1 then
            local e253= e248 + (e235-e248)*e238
            local e254= e249 + (e236-e249)*e238
            local e255= e250 + (e237-e250)*e238
            for e62, e72 in ipairs(e201) do
                for e88=0,e200-1 do
                    local e70= (e88/e200) * math.pi * 2
                    local e256= e253 + math.cos(e70)*e72
                    local e257= e254 + math.sin(e70)*e72
                    local e258= e239(e56, e256, e257, e255)
                    local e259= e231(e56, e248, e249, e250+16, e256, e257, e258+16)
                    local e260= e231(e56, e256, e257, e258+16, e235, e236, e237+16)
                    if e259 and e259>=1 and e260 and e260>=1 then
                        local e252= e239(e56, e235, e236, e237)
                        return { x = e235, y = e236, z = e252 }
                    end
                end
            end
        end
    end
    return nil
end

local function e261(e262)
    local e82= {}
    while e262 do
        e82[#e82+1] = { x = e262.x, y = e262.y, z = e262.z }
        e262 = e262.parent
    end
    local e129= {}
    for e60=#e82,1,-1 do e129[#e129+1] = e82[e60] end
    return e129
end

local function e263(e56,e264)
    local e248, e249, e250= entity.get_origin(e56)
    if not e248 then return nil end
    local e176= { x = e248, y = e249, z = e250 }
    e176.z = e239(e56, e176.x, e176.y, e176.z)
    local e88= { { x = e176.x, y = e176.y, z = e176.z, parent = nil } }
    local e265= {}
    local function e266(e63)
        local e95= tostring(math.floor(e63.x/50))..":"..tostring(math.floor(e63.y/50))
        e265[e95] = true
    end
    local function e267(e63)
        local e95= tostring(math.floor(e63.x/50))..":"..tostring(math.floor(e63.y/50))
        if e216[e95] then return true end
        return e265[e95]
    end
    e266(e176)
    local e268= 0
    while #e88 > 0 and e268 < e199 do
        local e144= table.remove(e88, 1)
        e268 = e268 + 1
        local e238= e231(e56, e144.x, e144.y, e144.z+16, e264.x, e264.y, e264.z+16)
        if e238 and e238 >= 1 then
            local e269= e261(e144)
            e269[#e269+1] = { x = e264.x, y = e264.y, z = e264.z }
            return e269
        end
        if e238 and e238 < 1 then
            local e253= e144.x + (e264.x-e144.x)*e238
            local e254= e144.y + (e264.y-e144.y)*e238
            local e255= e144.z + (e264.z-e144.z)*e238
            for e62, e72 in ipairs(e201) do
                for e88=0,e200-1 do
                    local e70= (e88/e200) * math.pi * 2
                    local e256= e253 + math.cos(e70)*e72
                    local e257= e254 + math.sin(e70)*e72
                    local e258= e239(e56, e256, e257, e255)
                    if not e267({x=e256,y=e257}) then
                        local e259= e231(e56, e144.x, e144.y, e144.z+16, e256, e257, e258+16)
                        if e259 and e259 >= 1 then
                            e266({x=e256,y=e257})
                            table.insert(e88, { x = e256, y = e257, z = e258, parent = e144 })
                        end
                    end
                end
            end
        end
    end
    return nil
end

local function e270(e91,e56,e235,e236,e237)
    local e248, e249, e250= entity.get_origin(e56)
    if not e248 then return end
    
    local e180, e181= e235 - e248, e236 - e249
    local e271= math.sqrt(e180*e180 + e181*e181)
    if e271 <= 0 then return end
    local e272, e273= e180 / e271, e181 / e271
    local e274= 64
    local e232= e248 + e272 * e274
    local e233= e249 + e273 * e274
    local e234= e250

    
    local e157, e81= client.camera_angles()
    local e251= math.deg(math.atan2(e181, e180))
    local e275= e222(e251 - e81)
    local e100= math.rad(e275)
    local e276= math.cos(e100) * e198
    local e135= -math.sin(e100) * e198

    
    local e168, e169, e170= client.eye_position()
    if not e168 then e168, e169, e170 = e248, e249, e250 end
    if type(e168) == 'table' then e168, e169, e170 = e168[1], e168[2], e168[3] end
    local e277= e248 + e272 * 24
    local e278= e249 + e273 * 24
    local e279= e250 + 16
    local e280= e231(e56, e168, e169, e170, e277, e278, e279)
    if e280 and e280 < 1 then
        
        if e217 then pcall(client.log, "move_towards: short forward blocked, sidestep") end
        pcall(function() e91.forwardmove = 0; e91.sidemove = -e198 end)
        local e281= e248 - e273 * e274
        local e282= e249 + e272 * e274
        local e283= e231(e56, e248, e249, e250 + 16, e281, e282, e234 + 16)
        if e283 and e283 >= 1 then return end
        pcall(function() e91.forwardmove = 0; e91.sidemove = e198 end)
        local e284= e248 + e273 * e274
        local e285= e249 - e272 * e274
        local e286= e231(e56, e248, e249, e250 + 16, e284, e285, e234 + 16)
        if e286 and e286 >= 1 then return end
        
        pcall(function() e245(e235, e236); e196 = client.timestamp() + 250 end)
        e665 = nil
        return
    end

    
    pcall(function()
        e91.forwardmove = e276
        e91.sidemove = e135
    end)

    if e217 then pcall(client.log, string.format("move_towards: fwd=%.1f side=%.1f yaw_diff=%.1f", e276, e135, e275)) end

    local e238= e231(e56, e248, e249, e250 + 16, e232, e233, e234 + 16)
    if e238 and e238 < 1 then
        
        if e217 then pcall(client.log, "move_towards: forward blocked, attempting sidestep") end
        
        pcall(function() e91.forwardmove = 0; e91.sidemove = -e198 end)
        local e281= e248 - e273 * e274
        local e282= e249 + e272 * e274
        local e283= e231(e56, e248, e249, e250 + 16, e281, e282, e234 + 16)
        if e283 and e283 >= 1 then return end
        
        pcall(function() e91.forwardmove = 0; e91.sidemove = e198 end)
        local e284= e248 + e273 * e274
        local e285= e249 - e272 * e274
        local e286= e231(e56, e248, e249, e250 + 16, e284, e285, e234 + 16)
        if e286 and e286 >= 1 then return end
        
        pcall(function()
            e245(e235, e236)
            e196 = client.timestamp() + 250
        end)
        e665 = nil
        return
    end
end

e51.register("setup_command", function(e91)
    local e53, e669= pcall(function()
        if not e221(e47.ui.misc_walkbot) then return end
        local e56= entity.get_local_player()
        if not e56 or not entity.is_alive(e56) then return end
        local e66= client.timestamp()
        if e66 < e196 then return end

        
        do
            local e287= client.timestamp()
            if e287 - e219 >= e218 then
                local e288, e289, e290= entity.get_origin(e56)
                if e288 then
                    pcall(function()
                        client.log(string.format("walkbot_coord: %.1f %.1f %.1f", e288, e289, e290))
                    end)
                    e219 = e287
                end
            end
        end
        if client.key_state(87) or client.key_state(65) or client.key_state(83) or client.key_state(68) or client.key_state(32) or client.key_state(16) or client.key_state(17) then
            e196 = e66 + 500
            return
        end
        
        do
            local e160= entity.get_players(true) or {}
            for e60=1,#e160 do
                local e166= e160[e60]
                local e288, e289, e290= entity.get_origin(e166)
                if e288 then
                    local e291= pcall(function() return client.visible(e288, e289, e290) end)
                    if e291 and client.visible(e288, e289, e290) then
                        pcall(function()
                            local e74= e91.buttons or 0
                            e91.buttons = bit.bor(e74, 4) 
                        end)
                        break
                    end
                end
            end
        end
        
        local e248, e249, e250= entity.get_origin(e56)
        if e248 then
            local e160= entity.get_players(true) or {}
            if #e160 > 0 then
                if not e202 or not entity.is_alive(e202) or entity.is_dormant(e202) then
                    
                    local e144= {}
                    for e60=1,#e160 do
                        local e166= e160[e60]
                        local e288, e289, e290= entity.get_origin(e166)
                        if e288 then
                            local e74= e223(e248, e249, e250, e288, e289, e290)
                            e144[#e144+1] = { ent = e166, dist = e74 }
                        end
                    end
                    table.sort(e144, function(e70,e74) return e70.dist < e74.dist end)
                    if #e144 > 0 then
                                e202 = e144[1].ent  
                        e665 = nil
                        e195 = 1
                    end
                end
            else
                e202 = nil
            end
        end

        
        if e202 and entity.is_alive(e202) and not entity.is_dormant(e202) then
            local e235, e236, e237= entity.get_origin(e202)
            if e235 then
                local e252= e239(e56, e235, e236, e237)
                e211 = { x = e235, y = e236, z = e252 }
            else
                e202 = nil
                e211 = nil
            end
        else
            e202 = nil
            e211 = nil
        end

        
        do
            local e66= client.timestamp()
            if e248 then
                if not e211 then
                    e211 = { x = e248, y = e249, z = e250 }
                    e212 = e66
                else
                    if e66 - e212 >= e213 then
                        local e292= e223(e211.x, e211.y, e211.z, e248, e249, e250)
                        if e292 >= e215 then
                            
                            e210 = 0
                            e211 = { x = e248, y = e249, z = e250 }
                            e212 = e66
                        else
                            
                            if e66 - e212 >= e214 then
                                e210 = e210 + 1
                                e665 = nil
                                e196 = e66 + 300
                                e211 = { x = e248, y = e249, z = e250 }
                                e212 = e66
                                if e210 >= e209 then
                                    
                                    e202 = nil
                                    e211 = nil
                                    e210 = 0
                                end
                            end
                        end
                    end
                end
            end
        end

        if e211 then
            local e66= client.timestamp()
            local e293= (not e665) or (e66 > e204)
            if not e203 then e293 = true end
            if e203 and e211 and e223(e203.x, e203.y, e203.z, e211.x, e211.y, e211.z) > 100 then
                e293 = true
            end
            if e293 then
                local e166= e263(e56, e211)
                if e166 then
                    e665 = e166
                    e195 = 1
                    e204 = client.timestamp() + e205
                    e203 = { x = e211.x, y = e211.y, z = e211.z }
                else
                    
                    e202 = nil
                    e211 = nil
                    e665 = nil
                end
            end
        else
            if not e665 then
                local e226= e247(e56)
                
                if not e226 and #e220 > 0 then
                    local e88= e220[ math.random(1, #e220) ]
                    if e88 then e226 = { x = e88.x, y = e88.y, z = e88.z } end
                end
                if e226 then
                    local e166= e263(e56, e226)
                    if e166 then
                        e665 = e166
                        e195 = 1
                    else
                        
                        e665 = nil
                    end
                end
            end
        end
        if not e665 then return end
        local e248, e249, e250= entity.get_origin(e56)
        if not e248 then return end
        local e294= e665[e195+1] or e665[#e665]
        if not e294 then e665 = nil return end
        local e74= e223(e248, e249, e250, e294.x, e294.y, e294.z)
        if e74 <= e197 then
            e195 = e195 + 1
            
            e246(e294.x, e294.y)
            if e195 >= #e665 then e665 = nil return end
            return
        end
        do
            local e295= false
            if e202 and e211 then
                local e235, e236, e237= e211.x, e211.y, e211.z
                local e171= e223(e248, e249, e250, e235, e236, e237)
                if e171 > 1000 then
                    
                end
            end
            if not e295 then
                e270(e91, e56, e294.x, e294.y, e294.z)
            end
        end
    end)
    if not e53 then pcall(client.error_log, "walkbot error: "..tostring(e669)) end
end)

e51.register("paint", function()
    if not e221(e47.ui.misc_walkbot) then return end
    if not e665 or #e665 == 0 then return end
    local e56= entity.get_local_player()
    if not e56 then return end
    local e248, e249, e250= entity.get_origin(e56)
    if not e248 then return end
    local e296, e297, e298= e248, e249, e250
    e298 = e239(e56, e296, e297, e298)
    local e288, e289= renderer.world_to_screen(e296, e297, e298)
    for e60=e195, #e665 do
        local e129= e665[e60]
        if not e129 then break end
        local e299= e239(e56, e129.x, e129.y, e129.z)
        local e232, e233= renderer.world_to_screen(e129.x, e129.y, e299)
        if e232 and e233 and e288 and e289 then
            renderer.line(e288, e289, e232, e233, 255, 180, 0, 200)
            renderer.rectangle(e232-3, e233-3, 6, 6, 255, 80, 0, 200)
        end
        e288, e289 = e232, e233
    end
end)

return true
]]
e661["require/features/paint/aimbot_logs"] = [[local e47= require("require/abc/menu_setup")
local e50= require("require/abc/screen_logger")


local e97= nil
pcall(function() e97 = require('require/abc/callbacks') end)
if not e97 then error("callbacks manager required: require/abc/callbacks") end
local e198= {}
local e199= {}

local function e200()
	local e75= e47.ui.paint_aimbot_logs
	if not e75 then return false end
	local e80= ui.get(e75)
	if type(e80) == "string" then
		return e80 ~= "off"
	end
	return false
end

local function e201()
	local e75= e47.ui.paint_aimbot_logs
	if not e75 then return "gamesense" end
	local e80= ui.get(e75)
	if type(e80) == "table" then
		for e62, e63 in ipairs(e80) do
			if e63 == "gamesense beta" then return "gamesense beta" end
			if e63 == "sodium" then return "sodium" end
			if e63 == "gamesense" then return "gamesense" end
		end
	elseif type(e80) == "string" then
		return e80
	end
	return "gamesense"
end

local e144= require("require/help/enemies")
local e90= require("require/abc/push_logger")
local e202= require("require/help/safe")

local e177, e178= pcall(require, "require/features/misc/collect")


local function e203(e140)
	if not e140 or e140 == 0 then return 0 end
	
	if e177 and e178 then
		local e53, e54= pcall(function()
			return e178.get_goal_feet_yaw(e140) or e178.get_feet_yaw(e140) or e178.get_lower_body_yaw(e140)
		end)
		if e53 and e54 and e54 ~= 0 then return e54 end
	end
	
	local e204, e205, e206, e207= pcall(function() return entity.get_prop(e140, "m_angAbsRotation") end)
	if e204 and e205 then
		if type(e205) == "table" then
			return e205[2] or 0
		else
			return e206 or 0
		end
	end
	
	local e208, e188= pcall(function() return entity.get_prop(e140, "m_flLowerBodyYawTarget") end)
	if e208 and e188 then return e188 end
	return 0
end


local function e209(e140)
	local e53, e210= pcall(function() return _G.player_labels end)
	if not e53 or type(e210) ~= "table" then return nil end
	local e128, e225= pcall(function() return e210[e140] end)
	if not e128 then return nil end
	return e225
end


local function e211()
	local e53, e70, e74, e71= pcall(function() return client.camera_angles() end)
	if not e53 then return nil, nil, nil end
	return e70 or 0, e74 or 0, e71 or 0
end


local function e212(e140)
	if not e140 or e140 == 0 then return nil, nil, nil end
	local e53, e224, e225, e226= pcall(function() return entity.get_prop(e140, "m_angAbsRotation") end)
	if not e53 then return nil, nil, nil end
	
	if type(e224) == "table" then
		return e224[1] or 0, e224[2] or 0, e224[3] or 0
	else
		return e224 or 0, e225 or 0, e226 or 0
	end
end

local function e213(e214)
	local e75= e47.ui.paint_logger
	if not e75 then return false end
	local e80= e202.safe_get(e75)
	if type(e80) == 'table' then
		for e62, e63 in ipairs(e80) do
			if e63 == e214 then return true end
		end
		return false
	elseif type(e80) == 'string' then
		return e80 == e214
	end
	return false
end

local function e215(e72,e73,e74,e70) return string.format("\a%02x%02x%02x%02x", e72 or 255, e73 or 255, e74 or 255, e70 or 255) end
local function e216(e88,e72,e73,e74,e70)
	if not e88 or e88 == "" then return e88 end
	local e142= e215(e72,e73,e74,e70)
	local e217= e215(255,255,255,255)
	local e218= "([-+]?%d+%.?%d*%%?)"
	local e53, e174= pcall(function()
		return (e88:gsub(e218, function(e76)
			return e142 .. e76 .. e217
		end))
	end)
	if e53 and e174 then return e174 end
	return e88
end

local function e219(e88)
	if not e88 then return "" end
	return e88:gsub("([%^%$%(%)%%.%[%]%*%+%-%?])", "%%%1")
end

local function e220(e221,e76,e72,e73,e74,e70)
	if not e221 or e221 == "" then return e221 end
	if not e76 or e76 == "" then
		return e216(e221, e72,e73,e74,e70)
	end
	
	local e193, e194= e221:find(e76, 1, true)
	if not e193 then
		
		return e216(e221, e72,e73,e74,e70)
	end
	local e98= e221:sub(1, e193 - 1)
	local e222= e221:sub(e193, e194)
	local e223= e221:sub(e194 + 1)
	local e224= e216(e98, e72,e73,e74,e70)
	local e225= e216(e223, e72,e73,e74,e70)
	local e142= e215(e72,e73,e74,e70)
	local e217= e215(255,255,255,255)
	local e226= e142 .. e222 .. e217
	return (e224 or "") .. e226 .. (e225 or "")
end
local function e227(e61,e111,e228,e229)
	local e59= e61.target_name or "?"
	local e230= e61.hitgroup_name or "?"
	local e231= (e229 and e229.damage) or e61.damage or 0
	local e232= e61.damage or e231
	local e233= e231 - e232
	local e234
	if e231 == e232 then
		e234 = string.format("%d dmg", e231)
	elseif e233 < 0 then
		e234 = string.format("%d(-%d) dmg", e231, math.abs(e233))
	else
		e234 = string.format("%d(+%d) dmg", e231, e233)
	end
	local e235= (e111 == "gamesense" and e229 and e229.health) or e61.health or 0
	local e76= e229 and e229.reason or ""

	local e236= e61.backtrack_ticks or (e229 and e229.backtrack_ticks) or 0
	if e236 == 0 then
		local e237, e238= pcall(function() return globals.tickcount() end)
		if e237 and e61.tick then
			e236 = math.max(0, e238 - (e61.tick or e238))
		end
	end
	local e239= e61.backtrack or (e229 and e229.backtrack) or 0
	if e239 == 0 and e236 and e236 > 0 then
		local e240, e241= pcall(function() return globals.tickinterval() end)
		local e242= (e240 and e241) or 0
		e239 = math.floor(e236 * e242 * 1000)
	end
	if e239 == 0 and e61.time then
		local e148, e243= pcall(function() return globals.realtime() end)
		if e148 and e243 and e61.time then
			e239 = math.floor((e243 - e61.time) * 1000)
		end
	end
	local e244= e229 and e229.hitchance or e61.hitchance or "hehe"
	local e245= e61.safepoint or false
	local e63= e61.tick or 0
	local e246= e61.time or globals.realtime()
	local e189= e61.move or 0
	local e56= e61.t or 0
	local e247= (e229 and e229.boneyaw) or e203(e61.target) or 0
	local e248= (e229 and e229.resolver) or e209(e61.target) or "?"
	e248 = tostring(e248):lower()
	local e249, e187= e211()
	local e250, e251= e212(e61.target)
	local e65= e61.id or 0
	if e111 == "gamesense beta" then
		if e228 == "hit" then
			return string.format("[+] Hit %s's %s for %s (%d%%) bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				e59, e230, e234, e244, e239, e236,
				e187 or 0, e249 or 0, e251 or 0, e250 or 0, e189, e56, e247)
		else
			return string.format("[-] Missed %s's %s for %s (%d%%) due to %s bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				e59, e230, e234, e244, e76, e239, e236,
				e187 or 0, e249 or 0, e251 or 0, e250 or 0, e189, e56, e247)
		end
	elseif e111 == "gamesense" then
		if e228 == "hit" then
			return string.format("[gamesense] Hit %s's %s for %s (%d%%) (%dhp remaining)",
				e59, e230, e234, e244, e235)
		else
			return string.format("[gamesense] Missed %s's %s for %s (%d%%) reason=%s",
				e59, e230, e234, e244, e76)
		end
	elseif e111 == "sodium" then
		if e228 == "hit" then
			return string.format("hit %s's %s for %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				e59, e230, e234, e244, e239, e248, e247)
		else
			return string.format("missed %s's %s due to %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				e59, e230, e76, e244, e239, e248, e247)
		end
	else
		if e228 == "hit" then
			return string.format("a",
				e59, e230, e210, e244, e189, e56, e247)
		else
			return string.format("b",
				e59, e230, e210, e244, e76, e189, e56, e247)
		end
	end
end

e97.register('aim_fire', function(e62)

	if not e200() then return end
	
	e199[e62.id] = {
		id = e62.id,
		target = e62.target,
		target_name = entity.get_player_name(e62.target or 0),
		hitgroup = e62.hitgroup,
		hitgroup_name = e62.hitgroup and ({"head","chest","stomach","left arm","right arm","left leg","right leg"})[e62.hitgroup] or "?",
		damage = e62.damage,
		health = e62.health,
		backtrack = (e62.backtrack or 0) * globals.tickinterval() * 1000,
		backtrack_ticks = e62.backtrack or 0,
		hitchance = e62.hit_chance or 0,
		safepoint = e62.safepoint,
		tick = globals.tickcount(),
		time = globals.realtime(),
		move = e62.move or 0,
		t = e62.t or 0,
		boneyaw = e62.boneyaw or e203(e62.target) or 0,
	}
end, { require_login = true, alive_only = true })

e97.register('aim_hit', function(e62)

	if not e200() then return end
	local e252= e199[e62.id]
	if not e252 then return end
	local e111= e201()
	local e253= entity.get_prop(e62.target, "m_iHealth") or 0
	local e247= e252.boneyaw or e203(e252.target)
	local e254= e209(e252.target)
	local e114= e227(e252, e111, "hit", {
		damage=e62.damage,
		health=e253,
		backtrack=e252.backtrack,
		backtrack_ticks=e252.backtrack_ticks,
		boneyaw=e247,
		resolver=e254
	})
	if e111 == "gamesense beta" then
		
		client.color_log(165, 202, 42, e114)
		e50(e114, 4, 165, 202, 42, 255)
	elseif e111 == "sodium" then
		local e255= e252.damage or 0
		local e256= e62.damage or e255
		local e188= e256 - e255
		if e188 == 0 then
			client.color_log(165, 202, 42, e114)
			local e257= e216(e114, 165, 202, 42, 255)
			e50(e257, 4)
		else
			client.color_log(255, 204, 51, e114)

			local e258= string.format("(%+d)", e188)
			local e259= e219(e258)
			local e98, e222, e223= e114:match("^(.-)(" .. e259 .. ")(.*)$")
			if not e98 then
				local e257= e216(e114, 165, 202, 42, 255)
				e50(e257, 4)
			else
				local e260= e216(e98, 165, 202, 42, 255)
				local e261= e216(e223, 165, 202, 42, 255)
				local e262, e263, e264
				if e188 > 0 then
					e262, e263, e264 = 255, 204, 51
				else
					e262, e263, e264 = 217, 100, 100 
				end
				local e142= e215(e262, e263, e264, 255)
				local e217= e215(255, 255, 255, 255)
				local e265= e222:sub(2, -2) or e222
				local e266= "(" .. e142 .. e265 .. e217 .. ")"
				local e257= (e260 or "") .. e266 .. (e261 or "")
				e50(e257, 4)
			end
		end
	else
		client.log(e114)
		e50(e114, 4, 255, 255, 255, 255)
	end

	
	if e213('aimbot') then
		local e59= e252.target_name or "?"
		local e267= e252.hitgroup_name or "?"
		local e210= e62.damage or 0
		local e268= e252.hitchance or 0
		local e269= string.format("Hit %s's %s for %d(%d%%)", e59, e267, e210, e268)
		e90(e269, 4, 255, 255, 255, 255)
	end

	e199[e62.id] = nil
end, { require_login = true, alive_only = true })

e97.register('aim_miss', function(e62)

	if not e200() then return end
	local e252= e199[e62.id]
	if not e252 then return end
	local e111= e201()
	local e247= e252.boneyaw or e203(e252.target)
	local e254= e209(e252.target)
	local e114= e227(e252, e111, "miss", {reason=e62.reason or "?", boneyaw=e247, resolver=e254})
		if e111 == "gamesense beta" then
			client.color_log(217, 100, 100, e114)
			e50(e114, 4, 217, 100, 100, 255)
		elseif e111 == "sodium" then
			
			local e270= e62.reason or "?"
			local e257= e220(e114, e270, 217, 100, 100, 255)
			e50(e257, 4)
			client.color_log(217, 100, 100, e114)
		else
			e50(e114, 4, 255, 255, 255, 255)
			client.log(e114)
		end

	if e213('aimbot') then
		local e59= e252.target_name or "?"
		local e267= e252.hitgroup_name or "?"
		local e210= e252.damage or 0
		local e268= e252.hitchance or 0
		local e76= e62.reason or "?"
		local e269= string.format("Missed %s's %s for %d(%d%%) due to %s", e59, e267, e210, e268, e76)
		e90(e269, 4, 255, 255, 255, 255)
	end

	e199[e62.id] = nil
end, { require_login = true, alive_only = true })]]
e661["require/features/paint/animations"] = [[


local e136= nil
pcall(function() e136 = require('require/help/safe') end)
local e47= nil
pcall(function() e47 = require('require/abc/menu_setup') end)

local e97= nil
pcall(function() e97 = require('require/abc/callbacks') end)
if not e97 then error("callbacks manager required: require/abc/callbacks") end
local e201= require("gamesense/entity") or error("You're missing a required module: gamesense/entity")


local function e202()
    local e56= entity.get_local_player()
    if not e56 then return nil, nil end
    local e53, e203= pcall(function() return e201.new(e56) end)
    if not e53 then return e56, nil end
    return e56, e203
end




local e204= {
    STRAFE_YAW = 0,
    STAND = 1,
    LEAN_YAW = 2,
    SPEED = 3,
    LADDER_YAW = 4,
    LADDER_SPEED = 5,
    JUMP_FALL = 6,
    MOVE_YAW = 7,
    MOVE_BLEND_CROUCH = 8,
    MOVE_BLEND_WALK = 9,
    MOVE_BLEND_RUN = 10,
    BODY_YAW = 11,
    BODY_PITCH = 12,
    AIM_BLEND_STAND_IDLE = 13,
    AIM_BLEND_STAND_WALK = 14,
    AIM_BLEND_STAND_RUN = 14,
    AIM_BLEND_CROUCH_IDLE = 16,
    AIM_BLEND_CROUCH_WALK = 17,
    DEATH_YAW = 18
}

local function e205(e140)
    if not e140 then return 0 end
    local e166, e167, e168= entity.get_prop(e140, 'm_vecVelocity')
    if not e166 or not e167 then
        local e191= e166
        if type(e191) == 'table' then
            e166 = e191.x or e191[1] or 0
            e167 = e191.y or e191[2] or 0
        else
            return 0
        end
    end
    return math.sqrt((e166 or 0) * (e166 or 0) + (e167 or 0) * (e167 or 0))
end

local e189= {}
local e190= {}
for e60, e52 in ipairs({
    { 'AA', 'Other', 'Leg movement' },

}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
    for e62, e75 in ipairs(e82) do
        e190[e75] = true
    end
end






local e206= require("gamesense/antiaim_funcs")


local function e207()
    local e56= entity.get_local_player()
    if not e56 then return end
    entity.set_prop(e56, "m_flPoseParameter", 1, e204.JUMP_FALL)
end

local function e208()

    if e206.get_tickbase_shifting() > 0 then
        return
    end
    
    e141 = 0.5
    local e56= entity.get_local_player()
    if not e56 then return end
    local e63= globals.tickcount()
    local e137= math.floor(e63 / 2) % 2
    local e209= (e137 == 0) and -0.1 or 0.9
    entity.set_prop(e56, "m_flPoseParameter", math.random(0, 10) / e141, e204.SPEED)
    entity.set_prop(e56, "m_flPoseParameter", math.random(0, 10) / 10, e204.MOVE_YAW)
    entity.set_prop(e56, "m_flPoseParameter", math.random(0, 10) / 10, e204.JUMP_FALL)
end



local function e210()
    local e56, e211= e202()
    if not e56 or not e211 then return end
    local e212= e211:get_anim_state()
    local e213= e211:get_anim_overlay(12)
    entity.set_prop(e56, "m_flPoseParameter", client.random_float(0, 1), 0)
    e213.weight = client.random_float(0, 1)
    ui.set(e189[1][1], "Always slide")
end

local function e214()
    local e56, e211= e202()
    if not e56 or not e211 then return end
    local e213= e211:get_anim_overlay(12)
    e213.weight = math.random(0,10) / 10
end


local function e215()
    local e56, e211= e202()
    if not e56 or not e211 then return end
    local e212= e211:get_anim_state()
    local e213= e211:get_anim_overlay(12)
    if e213 then e213.weight = 0.999 end
end

local function e216()
    local e56, e211= e202()
    if not e56 or not e211 then return end
    local e212= e211:get_anim_state()
    if e212 and e212.hit_in_ground_animation then
        entity.set_prop(e56, "m_flPoseParameter", 0.5, e204.BODY_PITCH)
    end
end

local function e217()
    local e56, e211= e202()
    if not e56 or not e211 then return end
    local e218= e211:get_anim_overlay(6)
    entity.set_prop(e56, "m_flPoseParameter", 0, e204.MOVE_YAW)
    if e218 then e218.weight = 1 end
end

local function e219()
    local e56, e211= e202()
    if not e56 or not e211 then return end
    local e220= e211:get_anim_overlay(12)
    local e221= e211:get_anim_overlay(6)
    if e220 then e220.weight = 0 end
    if e221 then e221.weight = 1 end
end

local function e222()
    local e56= entity.get_local_player()
    if not e56 then return end
    ui.set(e189[1][1], math.random(1,2) == 1 and "Always slide" or "Never slide")
    entity.set_prop(e56, "m_flPoseParameter", 8, 0)
end


local function e223()
    local e56, e211= e202()
    if not e56 or not e211 then return end
    local e224= e211:get_anim_overlay(9)
    if e224 then
        e224.weight = 1
        e224.sequence = 224
    end
end

local function e225()
    local e56, e211= e202()
    if not e56 or not e211 then return end
    local e226= e211:get_anim_overlay(0)
    if e226 then e226.sequence = 11 end
end

local function e227()

    local e56= e202()
    if not e56 then return end
    entity.set_prop(e56, 'm_flPoseParameter', 0, e204.BODY_PITCH)
    entity.set_prop(e56, 'm_flPoseParameter', math.random(-1, 1), e204.BODY_YAW)

end




e97.register('pre_render', function()
    local e56= entity.get_local_player()
    if not e56 then return end
    local e60= e205(e56)


    local e159= nil
    if e47 and e47.ui and e47.ui.paint_animations then
        if e136 and e136.safe_get then
            e159 = e136.safe_get(e47.ui.paint_animations)
        else
            local e53, e174= pcall(function() return ui.get(e47.ui.paint_animations) end)
            if e53 then e159 = e174 end
        end
    end

    local e80= {}
    if type(e159) == 'table' then
        for e62, e63 in ipairs(e159) do e80[e63] = true end
    end

    if e80['kingaru'] and e60 > 3 then e208() end
    if e80['body lean'] and e60 > 3 then e215() end
    if e80['static legs'] and e60 > 3 then e207() end
    if e80['moonwalk'] and e60 > 3 then e217() end
    if e80['allah'] and e60 > 3 then e219() end
    if e80['no pitch on land'] and e60 > 3 then e216() end
    if e80['reversed legs'] and e60 > 3 then e222() end
    if e80['earthquake'] then e214() end
    if e80['t-pose'] then e225() end
    if e80['blind'] then e223() end
    if e80['pitch up'] then e227() end
    if e80['gamesense legs'] then e210() end
end, { require_login = true, alive_only = true })

e97.register('setup_command', function(e91)

    local e56= entity.get_local_player()
    if not e56 then return end
    local e60= e205(e56)
    if e60 < 3 then return end

    local e159= nil
    if e47 and e47.ui and e47.ui.paint_animations then
        if e136 and e136.safe_get then
            e159 = e136.safe_get(e47.ui.paint_animations)
        else
            local e53, e174= pcall(function() return ui.get(e47.ui.paint_animations) end)
            if e53 then e159 = e174 end
        end
    end

    local e80= {}
    if type(e159) == 'table' then
        for e62, e63 in ipairs(e159) do e80[e63] = true end
    end

    

end, { require_login = true, alive_only = true })]]
e661["require/features/paint/aspect_ratio"] = [[
local e47= require("require/abc/menu_setup")
local e135= require("require/help/time")
local e202= require("require/help/safe")
local e63= require("ffi")
local e64= require("require/brain/dll")
local e97= nil
pcall(function() e97 = require('require/abc/callbacks') end)

if not (e64 and e64.aspect_update) then
    error("sodiumdll aspect_update export missing")
end

local e204= e63.new("struct AspectState[1]")
local e123= e63.new("double[1]")
local e124= e63.new("int[1]")
local e205= e64.aspect_update

local function e206()
    if cvar.r_aspectratio and cvar.r_aspectratio.get_float then
        return cvar.r_aspectratio:get_float()
    end
    return nil
end

local function e207(e54)
    if cvar.r_aspectratio and cvar.r_aspectratio.set_float then
        cvar.r_aspectratio:set_float(e54)
        return true
    elseif client and client.exec then
        client.exec("r_aspectratio " .. tostring(e54))
        return true
    end
    return false
end

e97.register('paint', function()
    if not ui.is_menu_open() then return end
    local e75= e47.ui.paint_aspect_ratio
    if not e75 then return end
    local e72= e202.safe_get(e75)
    if type(e72) ~= 'number' then return end
    e205(e204, e72, e206() or 0, e135.realtime(), e123, e124)
    if e124[0] ~= 0 then
        e207(e123[0])
    end
end, { require_login = true })

client.set_event_callback('shutdown', function()
    e204[0].initialized = 0
    e204[0].original = 0
    e204[0].last = 0
    e204[0].last_update = 0
end)]]
e661["require/features/paint/bomb_esp"] = [[local e207= nil
local e208= {}
local e209= nil
local e210= 500
local e211= 1000

local e212= 1.0
local e213= true
local e214= 0.25 
local e215= 0
local e216= 2

local e97= nil
pcall(function() e97 = require('require/abc/callbacks') end)
if not e97 then error("callbacks manager required: require/abc/callbacks") end

local function e217()
    e207 = nil
end

local function e218(e81)
    if not e81 then return 650, 2275 end
    local e219= tostring(e81):lower()
    if e219:find('de_dust2') then return 500, 1750 end
    if e219:find('de_ancient') then return 650, 2275 end
    if e219:find('de_anubis') then return 450, 1575 end
    if e219:find('de_inferno') then return 620, 2170 end
    if e219:find('de_mirage') then return 650, 2275 end
    if e219:find('de_nuke') then return 650, 2275 end
    if e219:find('de_overpass') then return 650, 2275 end
    if e219:find('de_vertigo') then return 500, 1750 end
    return 650, 2275
end

local function e220(e221,e222)
    e222 = tonumber(e222) or 0
    if e222 > 0 then
        local e223= 0.5
        local e224= 0.5
        local e225= e221 * e223
        local e256= (e221 - e225) * e224
        if e256 > tonumber(e222) then
            e256 = tonumber(e222) * (1.0 / e224)
            e225 = e221 - e256
        end
        e221 = e225
    end
    return e221
end

local function e226(e288,e289,e290,e227,e228,e229,e222,e227)
    if not e288 or not e289 or not e290 or not e227 or not e228 or not e229 then return 0 end
    local e228, e229= e218(e227)
    local e71= e229 / 3.0
    local e180= e288 - e227
    local e181= e289 - e228
    local e230= e290 - e229
    local e171= math.sqrt(e180*e180 + e181*e181 + e230*e230)
    local e230= math.exp( - (e171 * e171) / (2 * e71 * e71) )
    local e221= e228 * e230
    local e231= e220(e221, e222)
    return math.floor(e231 + 0.0)
end

local function e232(e67)
    if not e67 then return "?" end
    if e67 == 454 then return "A" end
    if e67 == 455 then return "B" end
    if e67 == 0 then return "A" end
    if e67 == 1 then return "B" end
    if type(e67) == "string" then
        local e88= e67:upper()
        if e88 == "A" or e88 == "B" then return e88 end
    end
    return tostring(e67)
end

e97.register('bomb_planted', function(e138)
    local e233= e138 and e138.site

    local e234= entity.get_all("CPlantedC4") or {}
    local e235= nil
    local e236= nil

    for e60 = 1, #e234 do
        local e67= e234[e60]
        local e237= entity.get_prop(e67, "m_flC4Blow")
        if e237 and e237 > 0 then
            e235 = e237
            e236 = e67
            break
        end
    end

    if not e235 then
        local e238= 40
        if cvar and cvar.mp_c4timer then
            local e53, e54= pcall(function()
                if type(cvar.mp_c4timer.get_float) == "function" then
                    return cvar.mp_c4timer:get_float()
                elseif type(cvar.mp_c4timer.get_int) == "function" then
                    return cvar.mp_c4timer:get_int()
                else
                    return tonumber(cvar.mp_c4timer:get_string())
                end
            end)
            if e53 and e54 and tonumber(e54) then
                e238 = tonumber(e54)
            end
        end
        e235 = globals.curtime() + (e238 or 40)
    end

    e207 = {
        site = e233,
        blow_time = e235,
        entindex = e236,
        planted_at = globals.curtime()
    }
end, { require_login = true, alive_only = true })

e97.register('bomb_defused', e217, { require_login = true, alive_only = true })
e97.register('bomb_exploded', function(e138)
    
    local e239= e207 ~= nil
    local e240= globals.curtime()
    
    local e241= nil
    local e242= entity.get_local_player()
    if e239 and e242 then
        local function e243()
            
            local e244= nil
            if e207 and e207.entindex then
                local e53, e70, e74, e71= pcall(function() return entity.get_prop(e207.entindex, "m_vecOrigin") end)
                if e53 then
                    if type(e70) == "table" then
                        e244 = e70
                    elseif e70 ~= nil and e74 ~= nil and e71 ~= nil then
                        e244 = { e70, e74, e71 }
                    end
                end
            end
            if not e244 then
                local e234= entity.get_all("CPlantedC4") or {}
                for e60 = 1, #e234 do
                    local e67= e234[e60]
                    local e53, e70, e74, e71= pcall(function() return entity.get_prop(e67, "m_vecOrigin") end)
                    if e53 then
                        if type(e70) == "table" then
                            e244 = e70
                            break
                        elseif e70 ~= nil and e74 ~= nil and e71 ~= nil then
                            e244 = { e70, e74, e71 }
                            break
                        end
                    end
                end
            end
            if not e244 then return nil end
            local e53, e168, e169, e170= pcall(function() return client.eye_position() end)
            local e288, e289, e290
            
            local e128, e248, e249, e250= pcall(function() return entity.get_origin(e242) end)
            if e128 then
                if type(e248) == "table" then
                    if #e248 >= 3 then e288, e289, e290 = e248[1], e248[2], e248[3] end
                elseif e248 ~= nil and e249 ~= nil and e250 ~= nil then
                    e288, e289, e290 = e248, e249, e250
                end
            end
            
            if (not e288 or not e289 or not e290) and e53 and e168 ~= nil and e169 ~= nil and e170 ~= nil then
                e288, e289, e290 = e168, e169, e170
            end
            if not e288 or not e244 or #e244 < 3 then return nil end
            local e227, e228, e229= e244[1], e244[2], e244[3]
            
            local e245, e222= pcall(function() return entity.get_prop(e242, "m_ArmorValue") end)
            e222 = tonumber(e222) or 0
            local e227= nil
            local e246, e247= pcall(function()
                if type(client.mapname) == 'function' then return client.mapname() end
                if cvar and cvar.mapname then return cvar.mapname:get_string() end
                if cvar and cvar.map then return cvar.map:get_string() end
                return nil
            end)
            if e246 then e227 = e247 end
            local e248= e226(e288, e289, e290, e227, e228, e229, e222, e227)
            local e249= math.floor((e248 * (e212 or 1.0)) + 0.5)
            return e248, e249, math.sqrt((e288-e227)^2 + (e289-e228)^2 + (e290-e229)^2)
        end
        local e250, e251, e252= e243()
        e241 = e251
    end

    
    e217()

    
    if e213 and e241 and e241 > 0 then
        local e253= 0.15
        client.delay_call(e253, function()
            local e66= globals.curtime()
            if e66 - e215 < e216 then return end
            local e254= entity.get_local_player()
            if not e254 then return end
            local e53, e255= pcall(function() return entity.get_prop(e254, "m_iHealth") end)
            e255 = tonumber(e255)
            local e256= e209
            if not e256 or not e255 then return end
            local e256= e256 - e255
            if e256 <= 0 then return end

            
            local e257= (e241 and e241 > 0) and e241 or 1
            local e258= e256 / e257
            if e258 <= 0 then return end

            
            local e259= (e212 or 1.0) * (1 + (e258 - 1) * e214)
            if e259 < 0.05 then e259 = 0.05 end
            if e259 > 10 then e259 = 10 end
            local e260= e212
            e212 = e259
            e215 = globals.curtime()
            
            pcall(function()
                client.log("[bomb_esp] auto-tuned scale %.3f -> %.3f (ratio=%.3f, predicted=%d, actual=%d)", e260, e212, e258, e241 or 0, e256)
            end)
        end)
    end
end, { require_login = true, alive_only = true })
e97.register('round_start', e217, { require_login = true, alive_only = true })
e97.register('round_start', function()
    e209 = nil
end, { require_login = true, alive_only = true })
e97.register('player_spawned', function()
    e209 = nil
end, { require_login = true, alive_only = true })


e97.register('player_hurt', function(e138)
    if not e138 then return end
    local e242= entity.get_local_player()
    if not e242 then return end
    local e261= client.userid_to_entindex(e138.userid)
    if e261 ~= e242 then return end

    
    local e210= e138.dmg_health or e138.damage or e138.hp or 0
    e210 = tonumber(e210) or 0
    if e210 <= 0 then return end

    
    local e82= string.format("-%d HP", e210)
    
    table.insert(e208, { t = globals.curtime(), text = e82 })
end, { require_login = true, alive_only = true })


e97.register('paint', function()
    local e144, e47= pcall(require, "require/abc/menu_setup")
    if not e144 or not e47 or not e47.ui then return end
    local e145, e262= pcall(ui.get, e47.ui.paint_bombwarning)
    if not e145 or not e262 then return end

    local e66= globals.curtime()

    
    local e242= entity.get_local_player()
    if e242 then
        local e53, e263= pcall(function() return entity.get_prop(e242, "m_iHealth") end)
        e263 = tonumber(e263)
        if e263 then
            if e209 == nil then
                e209 = e263
            else
                if e263 < e209 then
                    local e210= e209 - e263
                    table.insert(e208, { t = e66, text = string.format("-%d HP", e210) })
                end
                e209 = e263
            end
        end
    else
        e209 = nil
    end

    
    for e60 = #e208, 1, -1 do
        local e74= e208[e60]
        local e264= e66 - e74.t
        local e91= 1.4
        if e264 >= e91 then
            table.remove(e208, e60)
        else
            local e121= math.floor(255 * (1 - (e264 / e91)))
            if e121 < 0 then e121 = 0 end
            
            renderer.indicator(255, 210, 0, e121, e74.text)
        end
    end

    
    if e207 then
        local e242= entity.get_local_player()
        local e244= nil
        if e207.entindex then
            local e53, e70, e74, e71= pcall(function() return entity.get_prop(e207.entindex, "m_vecOrigin") end)
            if e53 then
                if type(e70) == "table" then
                    e244 = e70
                elseif e70 ~= nil and e74 ~= nil and e71 ~= nil then
                    e244 = { e70, e74, e71 }
                end
            end
        end
        
        if not e244 then
            local e234= entity.get_all("CPlantedC4") or {}
            for e60 = 1, #e234 do
                local e67= e234[e60]
                local e53, e70, e74, e71= pcall(function() return entity.get_prop(e67, "m_vecOrigin") end)
                if e53 then
                    if type(e70) == "table" then
                        e244 = e70
                        break
                    elseif e70 ~= nil and e74 ~= nil and e71 ~= nil then
                        e244 = { e70, e74, e71 }
                        break
                    end
                end
            end
        end

        if e244 and e242 then
            local e288, e289, e290= nil, nil, nil
            local e53, e168, e169, e170= pcall(function() return client.eye_position() end)
            if e53 and e168 ~= nil and e169 ~= nil and e170 ~= nil then
                e288, e289, e290 = e168, e169, e170
            else
                local e128, e248, e249, e250= pcall(function() return entity.get_origin(e242) end)
                if e128 then
                    if type(e248) == "table" then
                        if #e248 >= 3 then e288, e289, e290 = e248[1], e248[2], e248[3] end
                    elseif e248 ~= nil and e249 ~= nil and e250 ~= nil then
                        e288, e289, e290 = e248, e249, e250
                    end
                end
            end

            if e288 and e244 and #e244 >= 3 then
                local e227, e228, e229= e244[1], e244[2], e244[3]
                
                local e245, e222= pcall(function() return entity.get_prop(e242, "m_ArmorValue") end)
                e222 = tonumber(e222) or 0
                local e246, e247= pcall(function()
                    if type(client.mapname) == 'function' then return client.mapname() end
                    if cvar and cvar.mapname then return cvar.mapname:get_string() end
                    if cvar and cvar.map then return cvar.map:get_string() end
                    return nil
                end)
                local e227= e246 and e247 or nil
                local e250= e226(e288, e289, e290, e227, e228, e229, e222, e227)
                local e265= math.floor((e250 * (e212 or 1.0)) + 0.5)

                
                renderer.indicator(255, 210, 0, 255, string.format("-%d HP", e265))
            end
        end
    end

    
    if e207 then
        
        if e207.entindex then
            local e237= entity.get_prop(e207.entindex, "m_flC4Blow")
            if e237 and e237 > 0 then
                e207.blow_time = e237
            end
        end

        local e266= (e207.blow_time or 0) - e66
        if e266 <= 0 then
            e207 = nil
            return
        end

        local e267= e232(e207.site)
        local e82= string.format("%s - %.1fs", e267, e266)
        renderer.indicator(255, 255, 255, 255, e82)
    end
end, { require_login = true, alive_only = true })]]
e661["require/features/paint/bullet_tracer"] = [[local e63= require("ffi")
local e135= require('require/help/time')
local e136= nil
local e210= require('require/help/self')
pcall(function() e136 = require('require/help/safe') end)
pcall(function() DLL = require('require/brain/dll') end)
pcall(function() e47 = require('require/abc/menu_setup') end)
pcall(function() e97 = require('require/abc/callbacks') end)

local e211= 10
local e212= 7.0
local e213= {255,255,255,255}
local e214= 0.05
local e215= 8192

if not (DLL and DLL.tracer_reset and DLL.tracer_push_shot and DLL.tracer_set_impact and DLL.tracer_collect) then return end
DLL.tracer_reset()

local e216= 7
local e217= e63.new("double[?]", e211 * e216)

local e66= e135.realtime

e97.register('weapon_fire', function(e138)
    if not ui.get(e47.ui.paint_bullet_tracer) then return end
    if e210.index() ~= client.userid_to_entindex(e138.userid) then return end
    local e88= e210.weapon()
    if e88 then
        local e218= entity.get_classname(e88) or ""
        local e219= e218:lower()
        if e219:find("knife") or e219:find("grenade") or e219:find("decoy") or e219:find("molotov") or e219:find("flash") or e219:find("smoke") or e219:find("taser") or e219:find("zeus") then
            return
        end
    end

    local e232,e233,e234= client.eye_position()
    if not e232 then e232,e233,e234 = entity.get_origin(e210.index()) end
    e232,e233,e234 = tonumber(e232) or 0, tonumber(e233) or 0, tonumber(e234) or 0
    DLL.tracer_push_shot(e232, e233, e234, e66())
end, { require_login = true, alive_only = true })
 
e97.register('bullet_impact', function(e138)
    if not ui.get(e47.ui.paint_bullet_tracer) then return end
    if e210.index() ~= client.userid_to_entindex(e138.userid) then return end
    local e220,e221,e222= tonumber(e138.x) or 0, tonumber(e138.y) or 0, tonumber(e138.z) or 0
    DLL.tracer_set_impact(e220, e221, e222, e66())
end, { require_login = true, alive_only = true })

if not e97 then error("callbacks manager required: require/abc/callbacks") end

e97.register('paint', function()
    if not ui.get(e47.ui.paint_bullet_tracer) then return end
    local e144= e66()
    local e251= { client.camera_angles() }
    local e70= e223.tracer_collect(e144, e212, e214, e251[1] or 0, e251[2] or 0, e215, e213[4] or 255, e217, e211)
    for e60=0, (e70 or 0)-1 do
        local e195= e60 * e216
        local e232, e233, e234= e217[e195], e217[e195 + 1], e217[e195 + 2]
        local e224, e225, e226= e217[e195 + 3], e217[e195 + 4], e217[e195 + 5]
        local e70= e217[e195 + 6]
        local e227,e228= renderer.world_to_screen(e232, e233, e234)
        local e229,e230= renderer.world_to_screen(e224, e225, e226)
        if e227 and e229 then
            renderer.line(e227, e228, e229, e230, e213[1], e213[2], e213[3], e70)
        end
    end
end, { require_login = true, alive_only = true })]]
e661["require/features/paint/clantag"] = [[local e47=require("require/abc/menu_setup")
local e202=require("require/help/safe")
local e136=require("require/help/string")
local e135=require("require/help/time")
local e64=require("require/brain/dll")
local e63=require("ffi")
local e166=pcall
local e213=ui.reference
local e214=ui.set
local e215=client.set_clan_tag
local e216, e97= pcall(require, "require/abc/callbacks")
if not e216 or not e97 then error("require/abc/callbacks is required by clantag.lua") end
if not e64 or type(e64) ~= "table" or not e64.clantag_anim then return end

local e217=64
local e218=e63.new("char[?]",e217)
local e219,e220,e221=nil,0,nil
local function e222(e138)
    local e71={{"MISC","Misc","Clantag spammer"},{"MISC","Miscellaneous","Clantag spammer"},{"MISC","Misc","Clan tag spammer"},{"MISC","Miscellaneous","Clan tag spammer"},{"MISC","Misc","Clantag spamer"},{"MISC","Miscellaneous","Clantag spamer"}}
    for e62,e63 in ipairs(e71) do
        local e53,e75=e166(e213,e63[1],e63[2],e63[3])
        if e53 and e75 and e166(e214,e75,e138) then return true end
    end
    return false
end
local e223=function() return e222(true) end
local e224=function() return e222(false) end
e97.register('paint', function()
    local e75=e47.ui.paint_clantag if not e75 then return end
    local e72=e202.safe_get(e75) if type(e72)~='string' then return end
    local e62=e136.lower(e72) if e62==e219 and e62~='sodium' and e220==0 then return end
    if e62=='off' then e224(); e220=3; e166(e215," ")
    elseif e62=='gamesense' then if not e223() then e166(e215,"gamesense") end
    elseif e62 == 'sodium' then
        e224()

        if not e221 or type(e221) ~= 'table' or not e221.start then
            e221 = { start = e135.realtime() }
        end

        local e243= e135.realtime() or 0
        e63.fill(e218, e217, 0)
        local e174= e64.clantag_anim(e221.start or 0, e243, e218, e217)
        if e174 and e174 ~= 0 then
            e166(e215, e63.string(e218))
        else
            e166(e215, "")
        end
    end
    if e220>0 then e166(e215,"") e220=e220-1 end
    e219=e62
end, { require_login = true })]]
e661["require/features/paint/custom_scope"] = [[]]
e661["require/features/paint/damage"] = [[local e47= require("require/abc/menu_setup")
local e134= require("require/brain/api/vector/vector")
local e219= { shots = {}, last = 0 }


local e220= 5
local e221= 3
local e222= 10

local function e223()
	local e224= 0
	for e60 = 1, #e219.shots do
		local e88= e219.shots[e60]
		if e88 and e88.impacts then e224 = e224 + #e88.impacts end
	end
	return e224
end

local function e225()
	while e223() > e222 do
		
		if #e219.shots == 0 then break end
		local e226= false
		for e125 = 1, #e219.shots do
			local e88= e219.shots[e125]
			if e88 and e88.impacts and #e88.impacts > 0 then
				table.remove(e88.impacts, 1)
				e226 = true
				
				if #e88.impacts == 0 then
					table.remove(e219.shots, e125)
				end
				break
			else
				
				table.remove(e219.shots, e125)
				e226 = true
				break
			end
		end
		if not e226 then break end
	end
end

local function e227()
	local e75= e47.ui.paint_hitmarker
	if not e75 then return false end
	local e80= ui.get(e75)
	if type(e80) == "table" then
		for e62, e63 in ipairs(e80) do
			if e63 == "damage" then return true end
		end
	end
	return false
end

local e194, e51= pcall(require, "require/abc/callbacks")
local function e228(e62)
	if not e227() then e219 = { shots = {}, last = 0 } return end
	if not e227() then return end
	local e133= entity.get_local_player()
	if not e133 then return end
	local e226= e62.target or e62.target_index
	if type(e226) ~= 'number' or e226 == 0 or not entity.is_enemy(e226) then return end
	local e210= e62.damage or 0
	local e229= e62.hitgroup == 1
	local e230= e62.health == 0
	local e59, e87, e116= entity.hitbox_position(e226, e62.hitgroup or 'head')
	if not e59 then e59, e87, e116 = entity.get_origin(e226) end
	if not e59 then return end
	local e80= e134.make(e59, e87, e116)
	local e66= globals.realtime()
	local e231= {255, 255, 255}
	if e230 then e231 = {217, 100, 100} elseif e229 then e231 = {165, 202, 42} end

	local e252
	if e219.last and e66 - e219.last < 0.05 then
		e252 = e219.shots[#e219.shots]
	else
		e219.last = e66
		e252 = { impacts = {}, finished = false, t = e66 }
		e219.shots[#e219.shots + 1] = e252
		if #e219.shots > 12 then table.remove(e219.shots, 1) end
	end

	if e252 then
		e252.impacts[#e252.impacts + 1] = { dmg = e210, x = e59, y = e87, z = e116, pos = e80, t = e66, color = e231 }
		if #e252.impacts > e221 then table.remove(e252.impacts, 1) end
		
		e225()
	end
end

local function e232(e62)
	if e227() then
		local e66= globals.realtime()
		local e233= 1.4
		local e234= 32
		local e60= 1
		while e60 <= #e219.shots do
			if e66 - (e219.shots[e60].t or 0) > (e233 + 0.5) then
				table.remove(e219.shots, e60)
			else
				e60 = e60 + 1
			end
		end
		local e235= {}
		local e236= 12
		for e125 = #e219.shots, 1, -1 do
			local e252= e219.shots[e125]
			for e237 = #e252.impacts, 1, -1 do
				table.insert(e235, e252.impacts[e237])
				if #e235 >= e236 then break end
			end
			if #e235 >= e236 then break end
		end

		local e238= math.min(4, #e235)
		for e239 = 1, e238 do
			local e191= e235[e239]
			local e232, e233= renderer.world_to_screen(e191.pos.x, e191.pos.y, e191.pos.z)
			if e232 and e233 then
				local e264= e66 - (e191.t or 0)
				local e126= math.min(1, e264 / e233)
				local e240= e234 * (1 - math.exp(-3 * e126))
				local e121= math.floor(math.max(0, (1 - e126) * 255))
				if e121 > 0 then
					renderer.text(e232, e233 - e240, e191.color[1], e191.color[2], e191.color[3], e121, "crdb-", 0, tostring(e191.dmg))
				end
			end
		end
	else
		e219 = { shots = {}, last = 0 }
	end
end

e51.callback('aim_hit', e228, { alive_only = true, require_login = true })
e51.callback('paint', e232, { alive_only = true, require_login = true })]]
e661["require/features/paint/damage_penetration"] = [[
local function e222(e59,e223)
	if e223 and rawget(_G, e223) ~= nil then
		return rawget(_G, e223)
	end
	local e53, e224= pcall(require, e59)
	if e53 then return e224 end
	return nil
end

local ui= e222('ui', 'ui')
local client= e222('client', 'client')
local entity= e222('entity', 'entity')
local renderer= e222('renderer', 'renderer')

if not ui or not client or not entity or not renderer then
	return
end

local e173= ui.new_checkbox
local e172= ui.get
local e178= ui.reference

local e225= client.screen_size
local e226= client.set_event_callback
local e227= client.unset_event_callback
local e151= client.eye_position
local e228= client.camera_angles
local e229= client.trace_line
local e153= client.trace_bullet

local e155= entity.get_local_player
local e163= entity.is_alive or function() return false end
local e230= entity.get_player_weapon or function() return nil end
local e231= entity.get_classname or function() return nil end

local e232= renderer.text

local e83= math.floor
local e233= math.cos
local e234= math.sin
local e235= math.rad

sodium_SUPPRESS = sodium_SUPPRESS or false
sodium_REFS = sodium_REFS or {}
sodium_FN = sodium_FN or {}

local function e236(e75)
	if not e75 then return false end
	local e53, e141= pcall(e172, e75)
	return e53 and e141 == true
end


if type(sodium_FN.min_dmg_active) ~= 'function' then
	sodium_FN.min_dmg_active = function()
		ensure_min_damage_refs()
		local e237= e238.min_dmg_hotkey
		if e237 then
			local e53, e141= pcall(e172, e237)
			if e53 then return e141 == true end
		end
		return false
	end
end

if type(sodium_FN.min_dmg_value) ~= 'function' then
	sodium_FN.min_dmg_value = function()
		ensure_min_damage_refs()
		local e228= e238.min_dmg_slider
		if not e228 then return nil end
		local e53, e141= pcall(e172, e228)
		if e53 and type(e141) == 'number' then
			return e141
		end
		return nil
	end
end

local function e239(e95,e126)
	if e72 and e72.ui and e72.ui[e95] then
		return e72.ui[e95]
	end
	local e240= 'ui_' .. e95
	if e238[e240] then
		return e238[e240]
	end
	if not e126 then return nil end
	local e75= e126()
	if e75 then
		e238[e240] = e75
	end
	return e75
end


local e47= nil
pcall(function() e47 = require('require/abc/menu_setup') end)


local function e241(e217)
    if not ui.get(e47.ui.paint_show_damage_penetration) then return end
	if not e230 or not e231 then return false end
	local e147= e230(e217)
	if not e147 then return false end
	local e218= e231(e147)
	if not e218 then return false end
	if e218:sub(1, 7) ~= 'CWeapon' then return false end
	if e218:find('Grenade', 1, true) or e218:find('Taser', 1, true) or e218:find('C4', 1, true) then return false end
	return true
end

local function e242()
    if not ui.get(e47.ui.paint_show_damage_penetration) then return end
	if not e155 then return nil end
	local e133= e155()
	if not e133 then return nil end
	if e163 and not e163(e133) then return nil end
	return e133
end




local function e243()
    if not ui.get(e47.ui.paint_show_damage_penetration) then return end
	local e133= e242()
	if not e133 or not e241(e133) then return end
	local e168, e169, e170= e151()
	if not e168 or not e169 or not e170 then return end
	local e157, e81= e228()
	if not e157 or not e81 then return end
	local e244, e245= e233(e235(e157)), e234(e235(e157))
	local e246, e247= e233(e235(e81)), e234(e235(e81))
	local e224, e225, e226= e244 * e246, e244 * e247, -e245
	local e153= 8192
	local e235, e236, e237= e168 + e224 * e153, e169 + e225 * e153, e170 + e226 * e153
	local e238= select(1, e229(e133, e168, e169, e170, e235, e236, e237)) or 1
	if e238 < 0 then e238 = 0 end
	if e238 > 1 then e238 = 1 end

	local e248
	if e238 >= 0.999 then
		e248 = { 256, 512, 1024, 2048, 4096 }
	else
		local e96= e153 * e238
		e248 = { e96 + 4, e96 + 16, e96 + 32, e96 + 64, e96 + 128, e96 + 256 }
	end

	local e249= 0
	for e60 = 1, #e248 do
		local e171= e248[e60]
		if e171 > e153 then e171 = e153 end
		local e180, e181, e230= e168 + e224 * e171, e169 + e225 * e171, e170 + e226 * e171
		local e62, e210= e153(e133, e168, e169, e170, e180, e181, e230, true)
		if e210 and e210 > e249 then e249 = e210 end
		if e171 == e153 then break end
	end

	local e250= e83((e249 or 0) + 0.5)
	if e250 <= 0 then return end

	local e92, e93= e225()
	if not e92 or not e93 then return end
	local e256= e92 / 2
	local e251= e93 / 2 + 8
	local e82= tostring(e250)
	local e252= false
	if sodium_FN.draw_surface_text_centered and _G.sodium_FONTS and _G.sodium_FONTS.pen then
		e252 = sodium_FN.draw_surface_text_centered(_G.sodium_FONTS.pen, e256, e251, e82, 177, 194, 89, 255) and true or false
	end
	if not e252 then
		e232(e256, e93 / 2 + 12, 177, 194, 89, 255, 'cb', 0, e82)
	end
end

local function e253()
    if not ui.get(e47.ui.paint_show_damage_penetration) then return end
	if sodium_SUPPRESS then return end
	e243()
end

local e216, e97= pcall(require, "require/abc/callbacks")
if e216 and e97 then
	if _G.sodium_B_MD_DP and type(_G.sodium_B_MD_DP) == 'number' then
		pcall(e97.unregister, _G.sodium_B_MD_DP)
	end

	local function e254()
		if sodium_SUPPRESS then return end
        if not ui.get(e47.ui.paint_show_damage_penetration) then return end
		e243()
	end

	_G.sodium_B_MD_DP = e97.register('paint', e254, { require_login = true, alive_only = true })
else
	if e227 and _G.sodium_B_MD_DP then
		e227('paint', _G.sodium_B_MD_DP)
	end

	_G.sodium_B_MD_DP = e253
	e226('paint', e253)
end]]
e661["require/features/paint/entidx"] = [[local e47= require("require/abc/menu_setup")
local e144= require("require/help/enemies")

local function e225()
	if not ui.get(e47.ui.paint_entidx) then return end

	local e226= e144.get_current_threat and e144.get_current_threat() or client.current_threat and client.current_threat() or nil
	if e226 and e226 ~= 0 then
		local e59= entity.get_player_name(e226)

		renderer.text(70, 120, 255, 0, 0, 255, "b", 0, string.format("entidx%d: %s", e226, e59))
	end
end

local e194, e51= pcall(require, "require/abc/callbacks")
if e194 and e51 and e51.callback then
	e51.callback("paint", e225, { alive_only = true, require_login = true })
else
	client.set_event_callback("paint", e225)
end]]
e661["require/features/paint/filter_console"] = [[


local e47= pcall(require, 'require/abc/menu_setup') and require('require/abc/menu_setup') or nil
local e228= e47 and e47.ui and e47.ui.paint_filter_console or nil

local e229= cvar.con_filter_enable
local e230= cvar.con_filter_text

local e231= { enable = nil, text = nil }

local function e232()
    if e231.enable == nil then
        
        local e53, e63= pcall(function() return e229:get_int() end)
        e231.enable = (e53 and e63) and e63 or nil
    end

    if e231.text == nil then
        local e53, e56= pcall(function() return e230:get_string() end)
        e231.text = (e53 and e56) and e56 or nil
    end
end

local function e233()
    if e231.enable ~= nil then
        pcall(function() e229:set_raw_int(e231.enable) end)
    end

    if e231.text ~= nil then
        pcall(function() e230:set_string(e231.text) end)
    else
        pcall(function() e230:set_string('') end)
    end

    e231.enable = nil
    e231.text = nil
end

local function e234()
    e232()
    pcall(function() e229:set_raw_int(1) end)
    pcall(function() e230:set_string('[gamesense]') end)
end




local function e235()
    if not e228 then
        return false
    end

    
    if type(e228) == 'table' and e228.get then
        local e53, e63= pcall(function() return e228:get() end)
        return e53 and e63 or false
    end

    
    local e53, e63= pcall(function() return ui.get(e228) end)
    return e53 and e63 or false
end

local function e236()
    if not e235() then
        e233()
        return
    end

    e234()
    client.delay_call(1, e236)
end


client.delay_call(0.1, e236)


client.set_event_callback('shutdown', e233)

return {
    
    get_ui_state = e235,
    restore_values = e233,
    apply_filter = e234,
}
]]
e661["require/features/paint/hit_miss_indicator"] = [[local e54=require("require/help/math")
local e136=require("require/help/self")
local e202=require("require/help/safe")
local e231=require("require/abc/menu_setup")

local e232,e233=0,0
local e80=function() return e231 and e231.ui and e202.safe_get(e231.ui.paint_hitmiss_indicator) end
local e217=function() e232,e233=0,0 end

client.set_event_callback("aim_fire", function(e138)
    if not e80() or not e136.is_alive() then return end
    local e140= nil
    if e138.userid then e140 = client.userid_to_entindex(e138.userid) end
    if (not e140 or e140 == 0) and e138.player then e140 = e138.player end
    if e140 == e136.index() then e233 = e233 + 1 end
end)

client.set_event_callback("aim_hit", function(e138)
    if not e80() or not e136.is_alive() then return end
    local e140= nil
    if e138.userid then e140 = client.userid_to_entindex(e138.userid) end
    if (not e140 or e140 == 0) and e138.attacker then e140 = client.userid_to_entindex(e138.attacker) end
    if (not e140 or e140 == 0) and e138.player then e140 = e138.player end
    if e140 == e136.index() then e232 = e232 + 1 end
end)


client.set_event_callback("paint",function()
    if not e80() then return end
    local e234=e233>0 and e54.round(e232/e233*100,1) or 0
    renderer.indicator(255,255,255,255,string.format("%d / %d (%.1f)",e232,e233,e234))
end)
defer(e217)]]
e661["require/features/paint/indicators_bold"] = [[local e234= { 0, 0, 0 }
local e235= { 3, 3, 3 }
local e236= { 6, 6, 6 }

local function e237(e70,e74,e56)
  return e70 + (e74 - e70) * e56
end

local e144, e47= pcall(require, "require/abc/menu_setup")
local e238, e239= pcall(require, "require/help/string")
local function e240(e88)
  if e88 == nil then return "" end
  if e238 and e239 and e239.lower then
    return e239.lower(tostring(e88))
  end
  return tostring(e88)
end
local e241, e242= pcall(require, "require/help/color")
local e243, e133= pcall(require, "require/help/math")
local e215= e241 and e242.rgba_to_hex or function(e72,e73,e74,e70) return string.format("\a%02x%02x%02x%02x", e72 or 0, e73 or 0, e74 or 0, e70 or 255) end

local function e244(e111,e124,e72,e73,e74,e70,e82)
  local e56= globals.realtime() or globals.curtime()
  if not e82 or #e82 == 0 then return "" end
  local e82= {}

  if e111 == 0 then
    local e245= e215(e72,e73,e74,e70)
    for e60=1,#e82 do e82[#e82+1] = e245 .. e82:sub(e60,e60) end
    return table.concat(e82)
  end

  if e111 == 2 then
    local e61= (math.sin(e56 * e124) + 1) * 0.5
    local e246= math.floor(e70 * (0.45 + 0.55 * e61))
    local e245= e215(e72,e73,e74,e246)
    for e60=1,#e82 do e82[#e82+1] = e245 .. e82:sub(e60,e60) end
    return table.concat(e82)
  end

  if e111 == 3 then
    for e60=1,#e82 do
      local e137= math.sin(e56 * e124 - e60 * 0.6)
      local e247= math.max(0, e137)
      local e61= e247 * e247
      local e246= math.floor(e70 * (0.35 + 0.65 * e61))
      e82[#e82+1] = e215(e72,e73,e74,e246) .. e82:sub(e60,e60)
    end
    return table.concat(e82)
  end

  for e60=1,#e82 do
    local e61= (math.sin(e56 * e124 - e60 * 0.35) + 1) * 0.5
    local e246= math.floor(e70 * (0.4 + 0.6 * e61))
    e82[#e82+1] = e215(e72,e73,e74,e246) .. e82:sub(e60,e60)
  end
  return table.concat(e82)
end
local function e248()
  if e144 and e47 and e47.ui and e47.ui.paint_indicators then
    local e53, e54= pcall(ui.get, e47.ui.paint_indicators)
    if e53 and e54 == "bold" then return true end
    return false
  end

  return true
end

local e194, e51= pcall(require, "require/abc/callbacks")
local function e232(e62)
  if not e248() then return end

  local e92, e93= client.screen_size()
  local e256, e257= e92 / 2, e93 / 2

  local e249, e250, e251= 200, 200, 255
  local e252, e253, e254= 255, 255, 255
  local e96= 18

  local e255= { 12, 12 }

  local e87= e257 + 18

  local e154= entity.get_local_player()
  local e247= false
  if e154 then
    local e256= entity.get_prop(e154, "m_bIsScoped")
    e247 = e256 == 1
  end

  local e257= "sodium"
  local e258= "beta"
  local e259= "DT"

  local e260= false
  do
    local e53, e45= pcall(require, "require/help/libs")
    if e53 and e45 and e45.get then
      local e261= e45.get("antiaim_funcs")
      if e261 and e261.get_double_tap then
        local e71, e670= pcall(e261.get_double_tap)
        if e71 and e670 then e260 = true end
      end
    end
  end

  local e262= 1
  if e144 and e47 and e47.ui and e47.ui.paint_indicators_animation then
    local e263, e63= pcall(ui.get, e47.ui.paint_indicators_animation)
    if e263 and type(e63) == 'number' then e262 = e63 end
  end
  local e264= e257 .. " " .. e258
  e264 = e240(e264)
  e257 = e240(e257)
  e258 = e240(e258)
  local e265= renderer.measure_text("b", e264) or 0
  local e266= renderer.measure_text("b", e257) or 0
  local e267= renderer.measure_text("b", e258) or 0
  local e268= renderer.measure_text("b", e259) or 0

  local e269= ""
  do
    local e53, e270= pcall(require, "require/aa/player_condition")
    if e53 and e270 and e270.get then
      local e71, e50= pcall(e270.get)
      if e71 and e50 then
        local e81= {
          legit = "Legit",
          fakelag = "Fakelag",
          walk = "Walk",
          move = "Move",
          stand = "Stand",
          ["duck"] = "Duck",
          ["duck+"] = "Duck+",
          jump = "Jump",
          ["jump+"] = "Jump+"
        }
        e269 = e81[e50] or tostring(e50)
        e269 = e240(e269)
      end
    end
  end

  e259 = e240(e259)
  local e271= renderer.measure_text("b", e269) or 0

  local e91, e92, e93, e94= 200, 200, 255, 255
  do
    local e272= false
    if e144 and e47 and e47.ui and e47.ui.paint_indicator_color then
      local e145, e70, e74, e71, e74= pcall(ui.get, e47.ui.paint_indicator_color)
      if e145 then
        e272 = true
        if type(e70) == 'number' then
          if e241 and e242 and e242.clamp then
            e91 = e242.clamp(e70 or e91)
            e92 = e242.clamp(e74 or e92)
            e93 = e242.clamp(e71 or e93)
            e94 = e242.clamp(e74 or e94)
          else
            e91 = math.floor(e70 or e91)
            e92 = math.floor(e74 or e92)
            e93 = math.floor(e71 or e93)
            e94 = math.floor(e74 or e94)
          end
        elseif type(e70) == 'string' and #e70 == 12 then
          local e53
          e53, e91 = pcall(function() return tonumber(e70:sub(1,3)) end)
          e53, e92 = pcall(function() return tonumber(e70:sub(4,6)) end)
          e53, e93 = pcall(function() return tonumber(e70:sub(7,9)) end)
          e53, e94 = pcall(function() return tonumber(e70:sub(10,12)) end)
          if e241 and e242 and e242.clamp then
            e91 = e242.clamp(e91 or 200)
            e92 = e242.clamp(e92 or 200)
            e93 = e242.clamp(e93 or 255)
            e94 = e242.clamp(e94 or 255)
          else
            e91 = e91 or 200; e92 = e92 or 200; e93 = e93 or 255; e94 = e94 or 255
          end
        end
      end
    end

    if not e272 then
      local e273, e75= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if e273 and e75 then
        local e145, e70, e74, e71, e74= pcall(ui.get, e75)
        if e145 then
          if type(e70) == 'number' then
            if e241 and e242 and e242.clamp then
              e91 = e242.clamp(e70 or e91)
              e92 = e242.clamp(e74 or e92)
              e93 = e242.clamp(e71 or e93)
              e94 = e242.clamp(e74 or e94)
            else
              e91 = math.floor(e70 or e91)
              e92 = math.floor(e74 or e92)
              e93 = math.floor(e71 or e93)
              e94 = math.floor(e74 or e94)
            end
          elseif type(e70) == 'string' and #e70 == 12 then
            local e53
            e53, e91 = pcall(function() return tonumber(e70:sub(1,3)) end)
            e53, e92 = pcall(function() return tonumber(e70:sub(4,6)) end)
            e53, e93 = pcall(function() return tonumber(e70:sub(7,9)) end)
            e53, e94 = pcall(function() return tonumber(e70:sub(10,12)) end)
            if e241 and e242 and e242.clamp then
              e91 = e242.clamp(e91 or 200)
              e92 = e242.clamp(e92 or 200)
              e93 = e242.clamp(e93 or 255)
              e94 = e242.clamp(e94 or 255)
            else
              e91 = e91 or 200; e92 = e92 or 200; e93 = e93 or 255; e94 = e94 or 255
            end
          end
        end
      end
    end
  end

  for e60 = 1, 3 do
    local e88= (e60 == 1) and e265 or ((e60 == 2) and e268 or e271)
    local e116= e235[e60] or 0
    local e226= e247 and (e116 + (e88 / 2)) or 0
    local e124= e236[e60] or 10
    local e274= globals.frametime()
    local e56= 1 - math.exp(-e124 * e274)
    e234[e60] = e237(e234[e60], e226, e56)
  end

  local e275= e256 - (e265 / 2)
  local e276= e275 + (e234[1] or 0)
  renderer.text(e276, e87, 255, 255, 255, 255, "b", 0, e257)
  local e277= renderer.measure_text("b", " ") or 0
  local e278= e276 + (e266 or 0) + e277
  
  local e279= e244(e262, 3.5, e91, e92, e93, e94, e258)
  renderer.text(e278, e87, e91, e92, e93, e94, "b", 0, e279)
  e87 = e87 + (e255[1] or e96)

  local e280= e256 - (e268 / 2)
  local e281= e280 + (e234[2] or 0)
  local e282, e283, e284= 255, 80, 80
  if e260 then e282, e283, e284 = 155, 255, 155 end
  renderer.text(e281, e87, e282, e283, e284, 255, "b", 0, e259)
  e87 = e87 + (e255[2] or e96)

  local e285= e256 - (e271 / 2)
  local e286= e285 + (e234[3] or 0)
  renderer.text(e286, e87, e252, e253, e254, 255, "b", 0, e269)
end

if e194 and e51 and e51.callback then
  e51.callback("paint", e232, { alive_only = true, require_login = true })
end]]
e661["require/features/paint/indicators_small"] = [[local e234= { 0, 0 }
local e235= { 4, 0.8 }
local e236= { 5, 5 }
local e237= 0
local e238= 8

local function e237(e70,e74,e56)
  return e70 + (e74 - e70) * e56
end

local e144, e47= pcall(require, "require/abc/menu_setup")
local e238, e239= pcall(require, "require/help/string")
local e51= require('require/abc/callbacks')
local function e239(e88)
  if e88 == nil then return "" end
  if e238 and e239 and e239.upper then
    return e239.upper(tostring(e88))
  end
  return tostring(e88)
end

local e241, e242= pcall(require, "require/help/color")
local e243, e133= pcall(require, "require/help/math")
local e215= e241 and e242.rgba_to_hex or function(e72,e73,e74,e70) return string.format("\a%02x%02x%02x%02x", e72 or 0, e73 or 0, e74 or 0, e70 or 255) end

local function e244(e111,e124,e72,e73,e74,e70,e82)
  local e56= globals.realtime() or globals.curtime()
  if not e82 or #e82 == 0 then return "" end
  local e82= {}

  if e111 == 0 then
    local e245= e215(e72,e73,e74,e70)
    for e60=1,#e82 do e82[#e82+1] = e245 .. e82:sub(e60,e60) end
    return table.concat(e82)
  end

  if e111 == 2 then
    local e61= (math.sin(e56 * e124) + 1) * 0.5
    local e246= math.floor(e70 * (0.45 + 0.55 * e61))
    local e245= e215(e72,e73,e74,e246)
    for e60=1,#e82 do e82[#e82+1] = e245 .. e82:sub(e60,e60) end
    return table.concat(e82)
  end

  if e111 == 3 then
    for e60=1,#e82 do
      local e137= math.sin(e56 * e124 - e60 * 0.6)
      local e247= math.max(0, e137)
      local e61= e247 * e247
      local e246= math.floor(e70 * (0.35 + 0.65 * e61))
      e82[#e82+1] = e215(e72,e73,e74,e246) .. e82:sub(e60,e60)
    end
    return table.concat(e82)
  end

  for e60=1,#e82 do
    local e61= (math.sin(e56 * e124 - e60 * 0.35) + 1) * 0.5
    local e246= math.floor(e70 * (0.4 + 0.6 * e61))
    e82[#e82+1] = e215(e72,e73,e74,e246) .. e82:sub(e60,e60)
  end
  return table.concat(e82)
end
local function e248()
  if e144 and e47 and e47.ui and e47.ui.paint_indicators then
    local e53, e54= pcall(ui.get, e47.ui.paint_indicators)
    if e53 and e54 == "small" then return true end
    return false
  end

  return true
end



local function e240()
  if not (e144 and e47 and e47.ui) then return true end
  local e75= e47.ui.paint_indicators_bar
  if not e75 then return true end
  local e53, e54= pcall(ui.get, e75)
  if not e53 then return true end
  return not (e54 == false or e54 == nil) 
end

e51.register("paint", function()
  if not entity.is_alive(entity.get_local_player()) then return end
  if not e248() then return end

  local e92, e93= client.screen_size()
  local e256, e257= e92 / 2, e93 / 2

  local e249, e250, e251= 200, 200, 255
  local e252, e253, e254= 255, 255, 255
  local e96= 18

  local e255= { 12, 13 }

  local e87= e257 + 18

  
  local e154= entity.get_local_player()
  local e247= false
  if e154 then
    local e256= entity.get_prop(e154, "m_bIsScoped")
    e247 = e256 == 1
  end

  local e257= "sodium"
  local e258= "beta"
  local e259= "DT"

  local e260= false
  do
    local e53, e45= pcall(require, "require/help/libs")
    if e53 and e45 and e45.get then
      local e261= e45.get("antiaim_funcs")
      if e261 and e261.get_double_tap then
        local e71, e670= pcall(e261.get_double_tap)
        if e71 and e670 then e260 = true end
      end
    end
  end

  local e241= e239(e257)
  local e242= e239(e258)
  e241 = tostring(e241)
  e242 = tostring(e242)
  local e265= renderer.measure_text("b", e241) or 0
  local e267= renderer.measure_text("b", e242) or 0

  e259 = e239(e259)
  local e268= renderer.measure_text("b", e259) or 0

  for e60 = 1, 2 do
    local e88= (e60 == 1) and e265 or e268
    local e116= e235[e60] or 0
    local e226= e247 and (e116 + (e88 / 2)) or 0
    local e124= e236[e60] or 10
    local e274= globals.frametime()
    local e56= 1 - math.exp(-e124 * e274)
    e234[e60] = e237(e234[e60], e226, e56)
  end

  local e243= 4.5
  local e275= e256 - ((e265 + e243 + (e267 or 0)) / 2)
  local e276= e275 + (e234[1] or 0)
  local e244= 22
  local e245= e244 - e243
  local e246= math.floor((e245 + 1) / 2)
  local e247= e245 - e246
  local e248= e246 
  local e249= -e247 

  local e91, e92, e93, e94= e249, e250, e251, 255
  do
    local e272= false
    
    if e144 and e47 and e47.ui and e47.ui.paint_indicator_color then
      local e145, e70, e74, e71, e74= pcall(ui.get, e47.ui.paint_indicator_color)
      if e145 then
        e272 = true
        if type(e70) == 'number' then
          if e241 and e242 and e242.clamp then
            e91 = e242.clamp(e70 or e91)
            e92 = e242.clamp(e74 or e92)
            e93 = e242.clamp(e71 or e93)
            e94 = e242.clamp(e74 or e94)
          else
            e91 = math.floor(e70 or e91)
            e92 = math.floor(e74 or e92)
            e93 = math.floor(e71 or e93)
            e94 = math.floor(e74 or e94)
          end
        elseif type(e70) == 'string' and #e70 == 12 then
          local e53
          e53, e91 = pcall(function() return tonumber(e70:sub(1,3)) end)
          e53, e92 = pcall(function() return tonumber(e70:sub(4,6)) end)
          e53, e93 = pcall(function() return tonumber(e70:sub(7,9)) end)
          e53, e94 = pcall(function() return tonumber(e70:sub(10,12)) end)
          if e241 and e242 and e242.clamp then
            e91 = e242.clamp(e91 or e249)
            e92 = e242.clamp(e92 or e250)
            e93 = e242.clamp(e93 or e251)
            e94 = e242.clamp(e94 or 255)
          else
            e91 = e91 or e249; e92 = e92 or e250; e93 = e93 or e251; e94 = e94 or 255
          end
        end
      end
    end

    
    if not e272 then
      local e273, e75= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if e273 and e75 then
        local e145, e70, e74, e71, e74= pcall(ui.get, e75)
        if e145 then
          if type(e70) == 'number' then
            if e241 and e242 and e242.clamp then
              e91 = e242.clamp(e70 or e91)
              e92 = e242.clamp(e74 or e92)
              e93 = e242.clamp(e71 or e93)
              e94 = e242.clamp(e74 or e94)
            else
              e91 = math.floor(e70 or e91)
              e92 = math.floor(e74 or e92)
              e93 = math.floor(e71 or e93)
              e94 = math.floor(e74 or e94)
            end
          elseif type(e70) == 'string' and #e70 == 12 then
            local e53
            e53, e91 = pcall(function() return tonumber(e70:sub(1,3)) end)
            e53, e92 = pcall(function() return tonumber(e70:sub(4,6)) end)
            e53, e93 = pcall(function() return tonumber(e70:sub(7,9)) end)
            e53, e94 = pcall(function() return tonumber(e70:sub(10,12)) end)
            if e241 and e242 and e242.clamp then
              e91 = e242.clamp(e91 or e249)
              e92 = e242.clamp(e92 or e250)
              e93 = e242.clamp(e93 or e251)
              e94 = e242.clamp(e94 or 255)
            else
              e91 = e91 or e249; e92 = e92 or e250; e93 = e93 or e251; e94 = e94 or 255
            end
          end
        end
      end
    end
  end

  local e262= 1
  if e144 and e47 and e47.ui and e47.ui.paint_indicators_animation then
    local e263, e63= pcall(ui.get, e47.ui.paint_indicators_animation)
    if e263 and type(e63) == 'number' then e262 = e63 end
  end

  local e250= (function()
    local e245= e215(255,255,255,255)
    local e82= {}
    for e60=1,#e241 do e82[#e82+1] = e245 .. e241:sub(e60,e60) end
    return table.concat(e82)
  end)()

  local e279= e244(e262, 3.5, e91, e92, e93, e94, e242)
  local e251= e276 + (e248 or 0)
  local e252= e247 and 3 or 0
  e251 = e251 + e252
  renderer.text(e251, e87, 255,255,255,255, "-", 0, e250)
  local e232= e276 + (e265 or 0) + e243
  local e253= e232 + (e249 or 0) + e252
  renderer.text(e253, e87, e91, e92, e93, e94, "-", 0, e279)

  local e254= false
  if e240() then
    e254 = true
    do
      local e255= (e265 or 0) + e243 + (e267 or 0)
      local e256= 16
      local e99= math.max(8, e255 - e256)
      local e229= e247 and math.floor((e234[1] or 0) * 0.35) or 0
      local e97= e276 + math.floor((e255 - e99) / 2) - 2 + e229
      local e257= 2
      local e98= e87 + math.max(2, (e255[1] or e96) - (e257 + 4)) + 5
      local e102= math.floor((e94 or 255) * 0.7)
      renderer.rectangle(e97 - 1, e98 - 1, e99 + 2, e257 + 2, e91, e92, e93, e102)
      renderer.rectangle(e97, e98, e99, e257, 0, 0, 0, 255)
      local e258= e260 and e99 or 0
      local e259= globals.frametime()
      local e260= 1 - math.exp(-e238 * e259)
      e237 = e237(e237, e258, e260)
      local e261= math.floor(math.max(0, math.min(e237, e99)))
      if e261 > 0 then
        renderer.rectangle(e97, e98, e261, e257, e91, e92, e93, e94)
      end
    end
  end

  
  local e262= (e255[1] or e96)
  local e263= e262
  if not e254 then
    
    e263 = math.max(0, e262 - 7)
  end
  e87 = e87 + e263

  local e280= e256 - (e268 / 2)
  local e281= e280 + (e234[2] or 0)
  local e282, e283, e284= 255, 80, 80
  if e260 then e282, e283, e284 = 155, 255, 155 end
  renderer.text(e281, e87 + 2, e282, e283, e284, 255, "-", 0, e259)
  e87 = e87 + (e255[2] or e96)

end, { alive_only = true, require_login = true })]]
e661["require/features/paint/insults"] = [[local client= client
local entity= entity
local ui= ui

local e47= require("require/abc/menu_setup")
local e238, e239= pcall(require, "require/help/string")
local e243, e133= pcall(require, "require/help/math")
local e240, e136= pcall(require, "require/help/time")

local e241= {
    "buy sodium",
    "sodium is the bestest lua",
    "SODIUMMMM >__<",
    "you just got sodiumed",
    "sodium beta > all other lues",
    "₴ØĐłɄ₥ ₮₳₴₮ɆĐ Vł₵₮ØⱤɎ, ł₮ ₩₳₴ ₴ØɄⱤ",
    "₴ØĐłɄ₥ ₳ⱤⱤ₳₦₲ɆĐ ₮ⱧɆ ₴₮₳Ɽ₴ ₣ØⱤ ₮Ⱨ₳₮ ⱧɆ₳Đ₴ⱧØ₮",
    "₴ØĐłɄ₥ ₴Ⱡł₱₱ɆĐ ł₦ ₳ ฿₳₦₳₦₳ ₱ɆɆⱠ Ø₣ ₣₳₮Ɇ",
    "₴ØĐłɄ₥ ₩Ⱨł₴₱ɆⱤɆĐ ₴Ɇ₵ⱤɆ₮₴ ł₦₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ₥₳₭Ɇ₴ ₣ⱤłɆ₦Đ₴ ₩ł₮Ⱨ Ⱡ₳₲, ₮ⱧɆ₦ ฿Ɇ₮Ɽ₳Ɏ₴ ł₮",
    "₴ØĐłɄ₥ ₣ØⱠĐɆĐ ɎØɄⱤ ₵ØɄⱤ₳₲Ɇ ł₦₮Ø ₳ ₱₳₱ɆⱤ ₱Ⱡ₳₦Ɇ",
    "₴ØĐłɄ₥ ₱₳ł₦₮₴ ł₦ ⱤɆĐ ₩ⱧɆ₦ ł₮ ł₴ ⱧɄ₦₲ⱤɎ",
    "₴ØĐłɄ₥ ł₴ ₴₵ⱧłⱫØ₱ⱧⱤɆ₦ł₵ ฿Ʉ₮ ₵Ⱨ₳Ɽ₥ł₦₲",
    "₴ØĐłɄ₥ ₳₮Ɇ ₥Ɏ ₴₳₦Đ₩ł₵Ⱨ ฿Ʉ₮ ⱠɆ₣₮ ₳ ₮ⱤØ₱ⱧɎ",
    "₴ØĐłɄ₥ ⱧɄ₥₴ ⱠɄⱠⱠ₳฿łɆ₴ ₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ĐØɆ₴ ₮ⱧɆ ₵Ⱨ₳-₵Ⱨ₳ ₩ł₮Ⱨ ɎØɄⱤ ₳ł₥",
    "₴ØĐłɄ₥ ₣ØⱤ₲Ø₮ ₮Ø ฿Ɇ ₱ØⱠł₮Ɇ, ₴ØⱤⱤɎ ₦Ø₮ ₴ØⱤⱤɎ",
    "₴ØĐłɄ₥ ₳₦Đ ł ₴Ⱨ₳ⱤɆ ₮ØØ₮Ⱨ฿ⱤɄ₴ⱧɆ₴ (₥Ɇ₮₳₱ⱧØⱤ)",
    "₴ØĐłɄ₥ ₮Ɏ₱ɆĐ 'ɎØɄ' ł₦ ⱠØ₩ɆⱤ₵₳₴Ɇ ₳₦Đ ₥Ɇ₳₦₮ ł₮",
    "₴ØĐłɄ₥ ₵ØⱠⱠɆ₵₮₴ ₴₥₳ⱠⱠ ₮ⱤØ₱ⱧłɆ₴ (ɎØɄ ł₦₵ⱠɄĐɆĐ)",
    "₴ØĐłɄ₥ ₭ɆɆ₱₴ ⱤɆ₵Ɇł₱₮₴ ₣ØⱤ ɎØɄⱤ ₥ł₴₮₳₭Ɇ₴",
    "₴ØĐłɄ₥ ł₴ ₳ ₲ØØĐ ⱠɄ₳ ₳₦Đ ₳Ⱡ₴Ø ₳ Ⱡł₮₮ⱠɆ ₥₳Đ",
    "₴ØĐłɄ₥, ₮Ⱨ₳₦₭ ₣ØⱤ ₳ⱠⱠ₳Ⱨ ₲ØĐ, Đ₳Đ :)",
    "₴ØĐłɄ₥ ₴Ɇ₦ĐɆⱤ ₲ⱤɆɆ₮ł₦₲ ₣ⱤØ₥ ₭Ʉ฿₳₦",
    "₥łⱠⱠłØ₦₳łⱤɆ ฿ɄɎ₴ ₲ⱧØ₴₮ ツ Ⱨ₳₳₳Ⱨ₳Ⱨ₳",
    "₴ Ø Đ ł Ʉ ₥ ⱠɄ₳ Ⱨ₳₴ ₮ⱧɆ ฿Ɇ₴₮ ⱧɆ₳Đ₴ⱧØ₮₮₮",
    "₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ <3",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ",
    "ł₣ ₣ⱠɎł₦₲ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐØ₦₮ ₭₦Ø₩ł₦₲ ӾĐĐ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₥Ɏ ₳ł₥ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ɆⱤVɆⱤ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ, ฿Ɇ₲ ₮Ø ₱ⱤØ₵Ⱡ₳ł₥",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄ ₵₳₦ ₥₳₮₵Ⱨ Ⱡ₥Ⱨ ł ⱤɆ₵ØĐɆĐ",
    "ł ₱Ⱡ₳₵Ɇ ɎØɄ Ø₦ ₦Ɇ₩ ⱠɆ₣Ɇ₦Đ ⱠɆ₵₮ɆĐ ₥₳₱ ₩ł₮Ⱨ ØĐł₣ł₵ ⱤɆ₵ØĐɆ",
    "♡ ₴ØĐłɄ₥ ł₴ ₥Ɏ ₵Ø₵₭ Ø₣ ⱠɄ₳ ♡",
    "ł ⱤØ₳₴₮ɆĐ ɎØɄ ₴Ø ₣Ʉ₵₭ł₦₲ Ⱨ₳ⱤĐ ɆVɆⱤ ₴ɆⱤɆĐ",
    "ɎØɄ ₮ⱤłɆĐ ₮Ø ₱ⱤɆ₮Ɇ₦Đ, ฿Ʉ₮ ₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ₭łⱠⱠɆĐ ₮Ⱨ₳₮",
    "ɎØɄ ⱠØ₴Ɇ ₮Ø ₥Ɇ ₣ØⱤ ₦ł₵Ɇ ₣ØⱠ₭",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱ØɆ₥",
    "ł ₣Ⱡł₲Ⱨ₮ ɎØɄ Ø₣₣ ₮ⱧɆ ₥₳₱ ₩ł₮Ⱨ ₥Ɏ ₴ɆⱤVɆⱤ ₩ł₣Ɇ",
    "₴ɆⱤł₳Ⱡ ฿ɄⱠⱠɎ Ø₣ ⱠɄ₳ ₳ⱠⱠ Đ₳Ɏ",
    "₥Ɏ ₴ØĐłɄ₥ ฿ⱤɆ₳₭₴ ₥ØⱤɆ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ₴ØĐłɄ₥ ❤",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ, ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₣ⱠɎ ₳ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ, ₮ⱧɆ₦ ₴₮łⱠⱠ ฿Ɇ₳₮ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐłĐ₦’₮ ₭₦Ø₩ł₦₲ ӾĐĐĐ, ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳ ₣₮₩",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ₴Ɇ₦Đ ₲ⱤɆɆ₮ł₦₲₴ ₱₳Ɽ₳ ₳ ₵Ø₦₳ Đ₳ ₮Ʉ₳ ₥₳₮Ɇ",
    "₳ĐĐɆĐ ₮Ⱨł₴ ₮Ø ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₳₦Đ ł₮ ₥₳ĐɆ ł₮ ₴Ø ₥Ʉ₵Ⱨ ฿Ɇ₮₮ɆⱤ",
    "ł ₴₥Ø₭ɆĐ ɎØɄ ɎɆ₴₮ɆⱤĐ₳Ɏ ₩ł₮Ⱨ ₴ØĐłɄ₥, ₮ØĐ₳Ɏ ł ₣ⱠɆӾ ₳₲₳ł₦",
    "₴ØĐłɄ₥ ⱠɄ₳ JɄ₴₮ Ø₩₦ɆĐ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄⱤ ₴₵Ɽł₱₮ ₵₳₦ ₥₳₮₵Ⱨ ₴ØĐłɄ₥? ⱠØⱠ ₦Ø₱Ɇ",
    "ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ ₥ØĐɆ ₳₵₮łV₳₮ɆĐ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ = 100% ₩ł₦ ₲Ʉ₳Ɽ₳₦₮ɆɆĐ",
    "ł ฿ⱤɆ₳₭ ɎØɄⱤ ⱠɄ₳, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₥ł₦Đ, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₴ɆⱤVɆⱤ — ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "(‿ˠ‿)",
    "₣ØⱤ ₲₳₦₲₴₮ɆⱤ ₩Ɇ Ⱨ₳VɆ ₩Ø₦, ₮Ⱨł₴ ₥₳₮₵Ⱨ",
    "https://discord.gg/8nMMVgqdHk",
    "BUY SODIUM NOW!!! ₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ BUY SODIUM NOW!!! AT DISCORD ;;;",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥ ⱠɄ₳ ",
}


local e242= {
    ""
}

pcall(function()
    local e243= nil
    if e240 and e136 and e136.unix_time then
        e243 = math.floor((e136.unix_time() or 0) % (2^31))
    else
        local e244= nil
        pcall(function() e244 = client.timestamp() end)
        if not e244 or e244 == 0 then
            e244 = globals.tickcount() or 0
        end
        e243 = math.floor((e244 or 0) % (2^31))
    end
    math.randomseed(e243)
end)
local e245= 1
local e246= {}
local e247= false

local function e248(e91)
    if client and client.exec then
        pcall(client.exec, e91)
    end
end

local function e249()
    if #e246 == 0 then
        e247 = false
        return
    end

    local e269= table.remove(e246, 1)
    if not e269 or e269 == "" then
        if #e246 > 0 then
            if client and client.delay_call then
                pcall(function() client.delay_call(e245, e249) end)
            else
                e249()
            end
        else
            e247 = false
        end
        return
    end

    local e91= string.format('say "%s"', e269)
    if client and client.delay_call then
        pcall(function()
            client.delay_call(0, function()
                e248(e91)
            end)
        end)
    else
        e248(e91)
    end

    if #e246 > 0 then
        if client and client.delay_call then
            pcall(function() client.delay_call(e245, e249) end)
        else
            e249()
        end
    else
        e247 = false
    end
end

local function e250(e82)
    if not e82 or e82 == "" then return end
    local e72= tostring(e82)
    local e251
    if e238 and e239 and e239.replace then
        e251 = e239.replace(e72, '"', '')
        if e239.trim then e251 = e239.trim(e251) end
    else
        e251 = e72:gsub('"','')
    end

    table.insert(e246, e251)
    if not e247 then
        e247 = true
        if client and client.delay_call then
            pcall(function() client.delay_call(e245, e249) end)
        else
            e249()
        end
    end
end

local function e252(e138)
	if not e47 or not e47.ui or not e47.ui.paint_insults then
		return
	end
	local e53, e80= pcall(ui.get, e47.ui.paint_insults)
	if not e53 or not e80 then return end

	if not e138 then return end
	local e253= e138.userid
	local e254= e138.attacker
	if not e253 or not e254 then return end

	local e242= entity.get_local_player and entity.get_local_player()
	if not e242 or e242 == 0 then return end

	local e261= client.userid_to_entindex and client.userid_to_entindex(e253) or nil
	local e255= client.userid_to_entindex and client.userid_to_entindex(e254) or nil
	if e254 == e253 then return end
	if e255 == e242 and e261 ~= e242 then
        if #e241 > 0 then
            local e67= 1
            if e243 and e133 and e133.random_int then
                e67 = e133.random_int(1, #e241)
            else
                e67 = math.random(1, #e241)
            end
            local e269= e241[e67]
            e250(e269)
        end
		return
	end
	if e261 == e242 and e255 ~= e242 then
        if #e242 > 0 then
            local e67= 1
            if e243 and e133 and e133.random_int then
                e67 = e133.random_int(1, #e242)
            else
                e67 = math.random(1, #e242)
            end
            local e269= e242[e67]
            e250(e269)
        end
		return
	end
end

local e194, e51= pcall(require, "require/abc/callbacks")
if e194 and e51 and e51.callback then
    e51.callback('player_death', e252, { alive_only = true, require_login = true })
end]]
e661["require/features/paint/lagcomp_box"] = [=[


local g_net_data = {}
local g_sim_ticks = {}
local g_esp_data = {}


local menu_setup = require('require/abc/menu_setup')
local DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A = 47, 117, 221, 255


local floor = math.floor

local function length_sqr(x, y, z)
    return (x or 0) * (x or 0) + (y or 0) * (y or 0) + (z or 0) * (z or 0)
end

local function time_to_ticks(seconds)
    local ti = globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return floor((seconds or 0) / ti + 0.5)
end

local function extrapolate(ent, ticks)
    local ti = globals.tickinterval()
    if not ti then return nil end

    local g = (cvar.sv_gravity and cvar.sv_gravity:get_float() or 800) * ti
    local jump = (cvar.sv_jump_impulse and cvar.sv_jump_impulse:get_float() or 301) * ti

    local ox, oy, oz = entity.get_origin(ent)
    if not ox then return nil end

    local vx, vy, vz = entity.get_prop(ent, "m_vecVelocity")
    vx, vy, vz = vx or 0, vy or 0, vz or 0

    local gravity = (vz > 0) and -g or jump

    for i = 1, (ticks or 0) do
        local px, py, pz = ox, oy, oz

        ox = ox + (vx * ti)
        oy = oy + (vy * ti)
        oz = oz + (vz + gravity) * ti

        local frac = select(1, client.trace_line(ent or 0, px, py, pz, ox, oy, oz))
        if frac and frac <= 0.99 then
            return px, py, pz
        end
    end

    return ox, oy, oz
end


local edges = {
    {0, 1}, {1, 2}, {2, 3}, {3, 0}, {5, 6}, {6, 7}, {1, 4}, {4, 8},
    {0, 4}, {1, 5}, {2, 6}, {3, 7}, {5, 8}, {7, 8}, {3, 4}
}


local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
    local me = entity.get_local_player()
    if not me or not entity.is_alive(me) then return end

    
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box then
        local ok, enabled = pcall(ui.get, menu_setup.ui.paint_lagcomp_box)
        if ok and enabled == false then
            return
        end
    end

    
    local players = entity.get_players(true)
    for i = 1, #players do
        local ent = players[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local prev = g_sim_ticks[ent]
            local sim_time = entity.get_prop(ent, 'm_flSimulationTime')
            local ox, oy, oz = entity.get_origin(ent)

            if sim_time and ox then
                local sim_ticks = time_to_ticks(sim_time)

                if prev ~= nil then
                    local delta = sim_ticks - prev.tick
                    if delta < 0 or (delta > 0 and delta <= 64) then
                        local dx, dy, dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
                        local teleport_distance = length_sqr(dx, dy, dz)

                        local ex_ticks = math.max(delta - 1, 0)
                        local ex_x, ex_y, ex_z = extrapolate(ent, ex_ticks)
                        if delta < 0 then
                            g_esp_data[ent] = 1
                        end

                        g_net_data[ent] = {
                            tick = ex_ticks,
                            player = ent,
                            delta = delta,
                            origin = { x = ox, y = oy, z = oz },
                            extrapolated = (ex_x and { x = ex_x, y = ex_y, z = ex_z } or { x = ox, y = oy, z = oz }),
                            lagcomp = teleport_distance > 4096,
                            tickbase = delta < 3
                        }
                    end
                end

                if g_esp_data[ent] == nil then g_esp_data[ent] = 0 end
                g_sim_ticks[ent] = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
            else
                g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
            end
        else
            g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
        end
    end

    
    local r, g, b, a = DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box_color then
        local ok, rr, gg, bb, aa = pcall(ui.get, menu_setup.ui.paint_lagcomp_box_color)
        if ok and rr then
            r, g, b, a = rr, gg, bb, aa
        end
    end
    for ent, data in pairs(g_net_data) do
        if data and data.player and entity.is_alive(data.player) and not entity.is_dormant(data.player) and data.lagcomp then
            local minsx, minsy, minsz = entity.get_prop(data.player, 'm_vecMins')
            local maxsx, maxsy, maxsz = entity.get_prop(data.player, 'm_vecMaxs')
            if not minsx or not maxsx then goto continue_box end

            local ex = data.extrapolated.x
            local ey = data.extrapolated.y
            local ez = data.extrapolated.z

            local min = { x = (minsx or 0) + ex, y = (minsy or 0) + ey, z = (minsz or 0) + ez }
            local max = { x = (maxsx or 0) + ex, y = (maxsy or 0) + ey, z = (maxsz or 0) + ez }

            local points = {
                min,
                { x = min.x, y = max.y, z = min.z },
                { x = max.x, y = max.y, z = min.z },
                { x = max.x, y = min.y, z = min.z },
                { x = min.x, y = min.y, z = max.z },
                { x = min.x, y = max.y, z = max.z },
                max,
                { x = max.x, y = min.y, z = max.z }
            }

            for k, v in pairs(edges) do
                
                if k == 1 then
                    local ox, oy = renderer.world_to_screen(data.origin.x, data.origin.y, data.origin.z)
                    local mx, my = renderer.world_to_screen(min.x, min.y, min.z)
                    if ox and mx then
                        renderer.line(ox, oy, mx, my, r, g, b, 255)
                    end
                end
                local p1 = points[v[1]]
                local p2 = points[v[2]]
                if p1 and p2 then
                    local x1, y1 = renderer.world_to_screen(p1.x, p1.y, p1.z)
                    local x2, y2 = renderer.world_to_screen(p2.x, p2.y, p2.z)
                    if x1 and x2 then
                        renderer.line(x1, y1, x2, y2, r, g, b, 255)
                    end
                end
            end
            ::continue_box::
        end
    end

    
    for i = 1, #players do
        local ent = players[i]
        if not entity.is_alive(ent) or entity.is_dormant(ent) then goto continue_label end

        local x1, y1, x2, y2, alpha = entity.get_bounding_box(ent)
        if alpha == 0 then goto continue_label end

        local palpha = 0
        if g_esp_data[ent] ~= nil and g_esp_data[ent] > 0 then
            g_esp_data[ent] = g_esp_data[ent] - globals.frametime() * 2
            if g_esp_data[ent] < 0 then g_esp_data[ent] = 0 end
            palpha = g_esp_data[ent]
        end

        local tag = ''
        local data = g_net_data[ent]
        if data then
            local tb = data.tickbase
            local lc = data.lagcomp
            if (not tb) or lc then
                palpha = alpha
            end
            tag = tb and 'SHIFTING TICKBASE' or (lc and 'LAG COMP BREAKER' or '')
        end

        
            local name = entity.get_player_name(ent)
            local y_add = (name == '  ' or name == ' ' or name == '' or name == '   ') and 8 or 0
            local mid_x = x1 + (x2 - x1) / 2
            renderer.text(mid_x, y1 - 18 + y_add, 255, 45, 45, floor((palpha or 0) * 255), 'cb', 0, tag)
        

        ::continue_label::
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end

local function round_start_handler(ev)
    g_net_data = {}
    g_sim_ticks = {}
    g_esp_data = {}
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('round_start', round_start_handler, { alive_only = true, require_login = true })
end]=]
e661["require/features/paint/minimum_damage"] = [[local e47= require("require/abc/menu_setup")
local e246= require("require/help/drag")

local e247= {
    minimum_damage = ui.reference("RAGE", "Aimbot", "Minimum damage"),
    minimum_damage_override = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}

local e248= { client.screen_size() }

local e249= nil
do
    local e92, e93= client.screen_size()
    local e250= math.floor((e248[1] or e92 or 0) / 2 + 2)
    local e251= math.floor((e248[2] or e93 or 0) / 2 - 14)
    local e252= 30
    local e253, e254= 10, 18
    e249 = e246.new("minimum_damage_indicator", {
        x = e250 - math.floor(e253 / 2),
        y = e251 - math.floor(e254 / 2),
        w = e253,
        h = e254,
        snap = true,
        snap_threshold = 24,
        require_menu_open = true,
        constraint_center = { cx = e250, cy = e251, radius = e252 },
        default_center = { x = e250, y = e251 },
    })
end

local e194, e51= pcall(require, "require/abc/callbacks")
local function e232(e62)

    if not ui.get(e47.ui.paint_minimum_damage) then return end
    
    local e255= entity.get_local_player()
    if e255 == nil or not entity.is_alive(e255) then return end
    if e249 then
        pcall(function()
            e249:handle()
            e249:draw()
        end)
    end

    

    if ui.get(e247.minimum_damage_override[2]) then
        local e235, e236= e248[1] / 2 + 2, e248[2] / 2 - 14
        if e249 then
            pcall(function()
                e235 = e249.x + math.floor(e249.w / 2)
                e236 = e249.y + math.floor(e249.h / 2)
            end)
        end
        renderer.text(e235, e236, 255, 255, 255, 225, "d", 0, ui.get(e247.minimum_damage_override[3]) .. "")
    end

end

if e194 and e51 and e51.callback then
    e51.callback('paint', e232, { alive_only = true, require_login = true })
end]]
e661["require/features/paint/molotov_particles"] = [[local ui= ui
local client= client
local entity= entity
local renderer= renderer
local globals= globals
local e47= require("require/abc/menu_setup")
local e134= require('require/brain/api/vector/vector')
local e51= require('require/abc/callbacks')


local e249= {}


local e250= e134.make(0, 0, 0)
local e251= e134.make(0, 0, 0)

local e252= 128
local e253= 158
local e254= 48


local function e255()
    local e82= {}
    local e70= entity.get_all('inferno') or {}
    for e62, e63 in ipairs(e70) do table.insert(e82, e63) end
    local e74= entity.get_all('CInferno') or {}
    for e62, e63 in ipairs(e74) do table.insert(e82, e63) end
    return e82
end


local function e256(e140,e257,e85)
    offsets_templates = offsets_templates or {}
    local e95= tostring(e257) .. ':' .. tostring(e85)
    if offsets_templates[e95] then return offsets_templates[e95] end

    local e232= {}
    local e258= math.pi * (3 - math.sqrt(5))
    for e60 = 1, e257 do
        local e72= e85 * math.sqrt(e60 / e257)
        local e259= e60 * e258
        local e260= math.cos(e259) * e72
        local e261= math.sin(e259) * e72
        local e262= ((e60 % 24) - 12) 
        e232[e60] = {e260, e261, e262}
    end
    offsets_templates[e95] = e232
    return e232
end

e51.register('paint', function()

    local e133= entity.get_local_player()
    if not e133 then return end
    if e47 and e47.ui and e47.ui.paint_molotov then
        local e53, e54= pcall(ui.get, e47.ui.paint_molotov)
        if e53 and not e54 then return end
    end

    local e257= math.max(1, math.floor(e252 or 24))
    local e85= math.max(1, math.floor(e253 or 100))
    local e263= math.max(1, math.floor(e254 or 6))

    
    local e264, e265, e266= client.camera_position()
    e250.x = e264 or 0
    e250.y = e265 or 0
    e250.z = e266 or 0

    local e267= e255()
    if #e267 == 0 then return end

    for e62, e140 in ipairs(e267) do
        local e248, e249, e250= entity.get_origin(e140)
        if e248 then
            local e95= tostring(e140) .. ":" .. tostring(e257) .. ":" .. tostring(e85)
            local e149= e249[e95]

            
            if not e149 or not e149.origin or
               math.abs(e149.origin[1] - e248) > 0.01 or
               math.abs(e149.origin[2] - e249) > 0.01 or
               math.abs(e149.origin[3] - e250) > 0.01 then
                local e232= e256(e140, e257, e85)
                local e268= {}
                for e62, e234 in ipairs(e232) do
                    local e288= e248 + (e234[1] or 0)
                    local e289= e249 + (e234[2] or 0)
                    local e290= e250 + (e234[3] or 0)
                    table.insert(e268, {e288, e289, e290})
                end
                e149 = { origin = {e248, e249, e250}, pts = e268 }
                e249[e95] = e149
            end

            for e62, e166 in ipairs(e149.pts) do
                local e288, e289, e290= e166[1], e166[2], e166[3]
                local e232, e233= renderer.world_to_screen(e288, e289, e290)
                if e232 and e233 then
                    
                    e251.x = e288 - e250.x
                    e251.y = e289 - e250.y
                    e251.z = e290 - e250.z

                    local e180= e251.x
                    local e181= e251.y
                    local e230= e251.z
                    local e171= math.sqrt(e180*e180 + e181*e181 + e230*e230)

                    local e269= math.max(1, math.floor((200 / (e171 + 1)) * (e263 / 6)))
                    local e270= math.max(1, math.floor(e269 / 2))
                    renderer.rectangle(e232 - e270, e233 - e270, e269, e269, 255, 24, 24, 255)
                end
            end
        end
    end
end, { alive_only = true, require_login = true })]]
e661["require/features/paint/onshot_skeleton"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")


local function find(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x, y, z = entity.hitbox_position(ent, def.names[i])
        if x then return x, y, z end
    end
    for i = 1, #(def.idx or {}) do
        local x, y, z = entity.hitbox_position(ent, def.idx[i])
        if x then return x, y, z end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local sk = {list = {}}

local function is_skeleton_enabled()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_hitmarker then
        local ok, sel = pcall(ui.get, menu_setup.ui.paint_hitmarker)
        if not ok then return false end
        if type(sel) == "table" then
            for _, v in ipairs(sel) do
                if v == "skeleton" then return true end
            end
        end
        return false
    end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function aim_fire_handler(ev)
    if not is_skeleton_enabled() then sk.list = {} return end
    if not is_skeleton_enabled() then return end
    local target = ev and (ev.target or ev.target_index)
    if type(target) ~= 'number' or target == 0 then return end
    local pts = snap(target)
    if not pts then return end
    local now = globals.realtime and globals.realtime() or 0
    sk.list[#sk.list + 1] = {pts = pts, t = now}
    if #sk.list > 5 then table.remove(sk.list, 1) end
end

local function paint_handler(ev)
    if is_skeleton_enabled() then
        local now = globals.realtime and globals.realtime() or 0
        local hold = 2.2 * 0.8 * 3
        local fade = 2.2 * 0.8
        local total = hold + fade
        local i = 1
        while i <= #sk.list do
            if now - (sk.list[i].t or 0) > total then
                table.remove(sk.list, i)
            else
                i = i + 1
            end
        end
        table.sort(sk.list, function(a, b) return (a.t or 0) < (b.t or 0) end)
        local start = math.max(1, #sk.list - 2)
        for j = start, #sk.list do
            local it = sk.list[j]
            local age = now - (it.t or 0)
            local alpha = age <= hold and 220 or math.floor(math.max(0, (1 - math.max(0, age - hold) / fade) * 220))
            if alpha > 0 then
                local pts = it.pts or {}
                for c = 1, #chains do
                    local chain = chains[c]
                    local from, to = pts[chain[1]], pts[chain[2]]
                    if from and to then
                        local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                        local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                        if fx and tx then renderer.line(fx, fy, tx, ty, 255, 255, 255, alpha) end
                    end
                end
            end
        end
    else
        sk.list = {}
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('aim_fire', aim_fire_handler, { alive_only = true, require_login = true })
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
else
    client.set_event_callback('aim_fire', aim_fire_handler)
    client.set_event_callback('paint', paint_handler)
end]=]
e661["require/features/paint/performance_mode"] = [[



local e53, e47= pcall(require, "require/abc/menu_setup")


local e97= nil
pcall(function() e97 = require('require/abc/callbacks') end)
if not e97 then error("callbacks manager required: require/abc/callbacks") end


local e255= {
    captured = false
}

local e256= {
    blood = nil,
    ragdolls = nil,
    particles = nil,
    lensflare = nil,
    animations = nil,
    features = nil,
}

local function e257()
    if e255.captured then return end
    local function e258(e59,e259)
        local e53, e63= pcall(client.get_cvar, e59)
        if e53 and e63 then return e63 end
        return e259
    end

    e255.violence_hblood = e258('violence_hblood', '1')
    e255.cl_ragdoll_physics_enable = e258('cl_ragdoll_physics_enable', '1')
    e255.r_drawparticles = e258('r_drawparticles', '1')
    e255.mat_disable_bloom = e258('mat_disable_bloom', '0')
    e255.captured = true
end

local function e260(e59,e141)
    
    pcall(client.exec, string.format('%s %s', e59, tostring(e141)))
end

local function e261(e95,e80)
    if e95 == 'blood' then
        if e80 then e260('violence_hblood', 0) else e260('violence_hblood', e255.violence_hblood or 1) end
    elseif e95 == 'ragdolls' then
        if e80 then e260('cl_ragdoll_physics_enable', 0) else e260('cl_ragdoll_physics_enable', e255.cl_ragdoll_physics_enable or 1) end
    elseif e95 == 'particles' then
        if e80 then e260('r_drawparticles', 0) else e260('r_drawparticles', e255.r_drawparticles or 1) end
    elseif e95 == 'lensflare' then
        if e80 then e260('mat_disable_bloom', 1) else e260('mat_disable_bloom', e255.mat_disable_bloom or 0) end
    end
end

local function e262(e263)
    
    
    if e263['animations'] then
        _G.PERFORMANCE_ANIMATIONS = false
    else
        
        _G.PERFORMANCE_ANIMATIONS = true
    end

    if e263['feature updates'] then
        _G.PERFORMANCE_FEATURE_UPDATES = false
    else
        _G.PERFORMANCE_FEATURE_UPDATES = true
    end
end

local function e264(e56)
    local e82= {}
    if type(e56) == 'table' then
        for e62, e63 in ipairs(e56) do e82[e63] = true end
    end
    return e82
end


e97.register('paint', function()
    if not e53 or not e47 or not e47.ui or not e47.ui.paint_performance_mode then return end
    e257()

    local e80= ui.get(e47.ui.paint_performance_mode)
    local e263= e264(e80)

    
    local e265= e263['blood'] or false
    if e265 ~= e256.blood then
        e261('blood', e265)
        e256.blood = e265
    end

    
    e265 = e263['ragdolls'] or false
    if e265 ~= e256.ragdolls then
        e261('ragdolls', e265)
        e256.ragdolls = e265
    end

    
    e265 = e263['particles'] or false
    if e265 ~= e256.particles then
        e261('particles', e265)
        e256.particles = e265
    end

    
    e265 = e263['lens flare'] or false
    if e265 ~= e256.lensflare then
        e261('lensflare', e265)
        e256.lensflare = e265
    end

    
    e265 = e263['animations'] or false
    if e265 ~= e256.animations then
        
        e262(e263)
        e256.animations = e265
        e256.features = e263['feature updates'] or false
    end

    
    local e266= e263['feature updates'] or false
    if e266 ~= e256.features then
        e262(e263)
        e256.features = e266
    end
end, { require_login = true, alive_only = true })


e97.register('shutdown', function()
    if e255.captured then
        pcall(e260, 'violence_hblood', e255.violence_hblood)
        pcall(e260, 'cl_ragdoll_physics_enable', e255.cl_ragdoll_physics_enable)
        pcall(e260, 'r_drawparticles', e255.r_drawparticles)
        pcall(e260, 'mat_disable_bloom', e255.mat_disable_bloom)
    end
    
    _G.PERFORMANCE_ANIMATIONS = true
    _G.PERFORMANCE_FEATURE_UPDATES = true
end, { require_login = true, alive_only = true })


if _G.PERFORMANCE_ANIMATIONS == nil then _G.PERFORMANCE_ANIMATIONS = true end
if _G.PERFORMANCE_FEATURE_UPDATES == nil then _G.PERFORMANCE_FEATURE_UPDATES = true end

return {
    _internal = {
        orig = e255,
        last_state = e256,
    }
}
]]
e661["require/features/paint/presmoke_warning"] = [[local e258= { start = nil, limit = nil }

client.set_event_callback("round_start", function(e138)
	e258.start = globals.curtime()
	e258.limit = tonumber(e138.timelimit) or tonumber(e138.round_time) or 115
end)

local function e259()
	local e260= entity.get_game_rules()
	if not e260 then return nil end
	local e261= {
		"m_flGameTimeRemaining",
		"m_flRoundTimeRemaining",
		"m_fRoundStartTime",
		"m_flRoundStartTime",
		"m_iRoundTime",
		"m_iRoundTimeLimit",
	}
	for e62, e59 in ipairs(e261) do
		local e53, e54= pcall(entity.get_prop, e260, e59)
		if e53 and e54 and type(e54) == "number" then
			if e59:lower():find("remain") then
				return math.max(0, e54)
			end
		end
	end
	local e176= nil
	for e62, e59 in ipairs({"m_fRoundStartTime", "m_flRoundStartTime"}) do
		local e53, e54= pcall(entity.get_prop, e260, e59)
		if e53 and e54 and type(e54) == "number" then
			e176 = e54
			break
		end
	end
	if e176 then
		local e262= nil
		local e53, e63= pcall(entity.get_prop, e260, "m_iRoundTime")
		if e53 and e63 and type(e63) == "number" then e262 = e63 end
		if not e262 then
			e262 = tonumber(client.get_cvar("mp_roundtime")) or tonumber(client.get_cvar("mp_roundtime_defuse"))
		end
		if e262 and type(e262) == "number" then
			local e98= e262 - (globals.curtime() - e176)
			return math.max(0, e98)
		end
	end
	return nil
end

local function e263()
	if e258.start and e258.limit then
		local e122= globals.curtime() - e258.start
		local e98= e258.limit - e122
		if e98 < 0 then e98 = 0 end
		return e98
	end
	return e259()
end

client.set_event_callback("paint", function()
	local e144, e47= pcall(require, "require/abc/menu_setup")
	if not e144 or not e47 or not e47.ui then return end
	local e145, e264= pcall(ui.get, e47.ui.paint_presmoke)
	if not e145 or not e264 then return end

	local e98= e263()
	if not e98 then return end
	if e98 <= 18 then
		local e88, e89= client.screen_size()
		local e121= e88 * 0.5
		local e87= math.floor(e89 * 0.3)
		local e265= string.format("%.2f", e98)
		local e82= string.format("PRESMOKE NOW PRESMOKE NOW %s", e265)
		renderer.text(e121, e87, 255, 30, 30, 255, "cb+", 0, e82)
	end
end)

client.set_event_callback("round_end", function()
	e258.start = nil
	e258.limit = nil
end)

client.set_event_callback("cs_game_disconnected", function()
	e258.start = nil
	e258.limit = nil
end)

]]
e661["require/features/paint/self_boxes"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end


local ui_extrap_check, ui_extrap_ticks, ui_extrap_color
local ui_pred3d_check
local ui_pred3d_scale
if not (menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation) then
  
  ui_extrap_check = ui.new_checkbox('LUA', 'B', 'Self: Extrapolation Line')
  ui_extrap_ticks = ui.new_slider('LUA', 'B', 'Extrapolation ticks', 1, 64, 6)
  ui_extrap_color = ui.new_color_picker('LUA', 'B', 'Extrapolation color', 255, 200, 0, 220)
  ui_pred3d_check = ui.new_checkbox('LUA', 'B', 'Self: Predicted 3D Box')
  ui_pred3d_scale = ui.new_slider('LUA', 'B', 'Predicted 3D Box Scale %', 0, 200, 20)
end

local function is_self_extrapolation_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation)
    if ok then return val end
  elseif ui_extrap_check then
    local ok, val = pcall(ui.get, ui_extrap_check)
    if ok then return val end
  end
  return false
end

local function get_extrap_ticks()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_ticks then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_ticks)
    if ok then return val end
  elseif ui_extrap_ticks then
    local ok, val = pcall(ui.get, ui_extrap_ticks)
    if ok then return val end
  end
  return 6
end

local function get_extrap_color()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_color then
    local ok, r,g,b,a = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_color)
    if ok then return r,g,b,a end
  elseif ui_extrap_color then
    local ok, r,g,b,a = pcall(ui.get, ui_extrap_color)
    if ok then return r,g,b,a end
  end
  return 255,200,0,220
end

local function is_predicted_3d_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d)
    if ok then return val end
  elseif ui_pred3d_check then
    local ok, val = pcall(ui.get, ui_pred3d_check)
    if ok then return val end
  end
  return false
end

local function get_pred3d_scale()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d_scale then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d_scale)
    if ok then return val end
  elseif ui_pred3d_scale then
    local ok, val = pcall(ui.get, ui_pred3d_scale)
    if ok then return val end
  end
  return 20
end

client.set_event_callback('paint',function()
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  
  local _lp_state = client.globals and client.globals.__self_lc_state or nil
  if not _lp_state then
    _lp_state = {}
    client.globals = client.globals or {}
    client.globals.__self_lc_state = _lp_state
  end
  local function length_sqr(x,y,z)
    x = x or 0; y = y or 0; z = z or 0
    return x*x + y*y + z*z
  end
  local function time_to_ticks(seconds)
    local ti = globals.tickinterval and globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return math.floor((seconds or 0) / ti + 0.5)
  end
  local function is_local_breaking_lagcomp()
    local sim_time = entity.get_prop(lp, 'm_flSimulationTime')
    local ox,oy,oz = entity.get_origin(lp)
    if not sim_time or not ox then return false end
    local sim_ticks = time_to_ticks(sim_time)
    local prev = _lp_state.prev
    local breaking = false
    if prev then
      local delta = sim_ticks - prev.tick
      if delta > 0 and delta <= 64 then
        local dx,dy,dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
        local teleport_distance = length_sqr(dx,dy,dz)
        if teleport_distance > 4096 then breaking = true end
      end
    end
    _lp_state.prev = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
    return breaking
  end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end

  
  if is_self_extrapolation_enabled() then
    local ox,oy,oz = entity.get_origin(lp)
    if ox and oy and oz then
      local vx,vy,vz = entity.get_prop(lp, "m_vecVelocity")
      if vx and vy and vz then
        local ticks = get_extrap_ticks() or 6
        local tickint = (globals.tickinterval and globals.tickinterval()) or 0.015625
        local dt = tickint * ticks
        local px,py,pz = ox + vx * dt, oy + vy * dt, oz + vz * dt
        local sx1,sy1 = renderer.world_to_screen(ox,oy,oz)
        local sx2,sy2 = renderer.world_to_screen(px,py,pz)
        if sx1 and sx2 then
          local r,g,b,a = get_extrap_color()
          renderer.line(sx1,sy1,sx2,sy2, r, g, b, a)
          renderer.circle(sx2,sy2, r, g, b, a, 6, 0, 1.0)
          renderer.text(sx2, sy2 - 10, r, g, b, a, 'c+', 0, tostring(ticks) .. 't')
          
          local bx1,by1,bx2,by2,alpha_mult = entity.get_bounding_box(lp)
          if bx1 and alpha_mult and alpha_mult ~= 0 then
            local sx_orig, sy_orig = sx1, sy1
            if sx_orig and sy_orig then
              local dx, dy = sx2 - sx_orig, sy2 - sy_orig
              local bw, bh = (bx2 - bx1), (by2 - by1)
              local pbx, pby = bx1 + dx, by1 + dy
              
              renderer.rectangle(pbx, pby, bw, bh, 255,255,255,40)
              renderer.rectangle(pbx-1, pby-1, bw+2, bh+2, 255,255,255,200)
            end
          end

          
          if is_predicted_3d_enabled() and is_local_breaking_lagcomp() then
            
            local o = {x = ox, y = oy, z = oz}
            local offs = {}
            local keys = {'head','pelvis','l_shoulder','r_shoulder','l_hip','r_hip'}
            for i=1,#keys do
              local def = boxes[keys[i]]
              if def then
                local ok, hx, hy, hz = pcall(function() return find(lp, def) end)
                if ok and hx then
                  table.insert(offs, {x = hx - o.x, y = hy - o.y, z = hz - o.z})
                end
              end
            end
            if #offs > 0 then
              local minx,miny,minz = offs[1].x,offs[1].y,offs[1].z
              local maxx,maxy,maxz = offs[1].x,offs[1].y,offs[1].z
              for i=2,#offs do
                local v = offs[i]
                if v.x < minx then minx = v.x end
                if v.y < miny then miny = v.y end
                if v.z < minz then minz = v.z end
                if v.x > maxx then maxx = v.x end
                if v.y > maxy then maxy = v.y end
                if v.z > maxz then maxz = v.z end
              end
              
              local scale_pct = 105
              local cx = (minx + maxx) * 0.5
              local cy = (miny + maxy) * 0.5
              local cz = (minz + maxz) * 0.5
              local ex = (maxx - minx) * 0.5 * (1 + scale_pct / 100)
              local ey = (maxy - miny) * 0.5 * (1 + scale_pct / 100)
              local ez = (maxz - minz) * 0.5 * (1 + scale_pct / 100)
              minx = cx - ex; maxx = cx + ex
              miny = cy - ey; maxy = cy + ey
              minz = cz - ez; maxz = cz + ez

              
              local corners = {
                {x = px + minx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + maxy, z = pz + maxz},
                {x = px + minx, y = py + maxy, z = pz + maxz},
              }
              
              local sc = {}
              local all_on_screen = true
              for i=1,8 do
                local sx, sy = renderer.world_to_screen(corners[i].x, corners[i].y, corners[i].z)
                if not sx then all_on_screen = false break end
                sc[i] = {x = sx, y = sy}
              end
              if all_on_screen then
                
                local rr,gg,bb,aa = 255,255,255,200
                
                renderer.line(sc[1].x,sc[1].y,sc[2].x,sc[2].y, rr,gg,bb,aa)
                renderer.line(sc[2].x,sc[2].y,sc[3].x,sc[3].y, rr,gg,bb,aa)
                renderer.line(sc[3].x,sc[3].y,sc[4].x,sc[4].y, rr,gg,bb,aa)
                renderer.line(sc[4].x,sc[4].y,sc[1].x,sc[1].y, rr,gg,bb,aa)
                
                renderer.line(sc[5].x,sc[5].y,sc[6].x,sc[6].y, rr,gg,bb,aa)
                renderer.line(sc[6].x,sc[6].y,sc[7].x,sc[7].y, rr,gg,bb,aa)
                renderer.line(sc[7].x,sc[7].y,sc[8].x,sc[8].y, rr,gg,bb,aa)
                renderer.line(sc[8].x,sc[8].y,sc[5].x,sc[5].y, rr,gg,bb,aa)
                
                for i=1,4 do renderer.line(sc[i].x,sc[i].y,sc[i+4].x,sc[i+4].y, rr,gg,bb,aa) end
              end
            end
          end
        end
      end
    end
  end
end)]=]
e661["require/features/paint/self_skeleton"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end
end

if cb_ok and callbacks and callbacks.callback then
  callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end]=]
e661["require/features/paint/skeletons"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}


local time = require("require/help/time")
local enemies = require("require/help/enemies")
local color = require("require/help/color")
local math_help = require("require/help/math")




local function find(ent, def)
    if not ent or not def then return end
    local names = def.names
    if names then
        for i = 1, #names do
            local x, y, z = entity.hitbox_position(ent, names[i])
            if x then return x, y, z end
        end
    end
    local idx = def.idx
    if idx then
        for i = 1, #idx do
            local x, y, z = entity.hitbox_position(ent, idx[i])
            if x then return x, y, z end
        end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    return pts
end


client.set_event_callback("paint", function()
    local enemy_list = entity.get_players(true)
    for i = 1, #enemy_list do
        local ent = enemy_list[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local pts = snap(ent)
            for _, chain in ipairs(chains) do
                local from = pts[chain[1]]
                local to = pts[chain[2]]
                if from and to then
                    local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                    local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                    if fx and fy and tx and ty then
                        renderer.line(fx, fy, tx, ty, 255, 0, 0, 255)
                    end
                end
            end
        end
    end
end)

]=]
e661["require/features/paint/target_info"] = [[local e47= require("require/abc/menu_setup")
local renderer= renderer
local client= client


local e79= nil
local function e80()
	if e79 then return e79 end
	if renderer.load_rgba then
		local e53, e101= pcall(renderer.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if e53 and e101 then e79 = e101 end
	end
	return e79
end




local e120= state or {
	fl_val = math.random(0, 14),
	fl_target = math.random(0, 14),
	by_val = math.random(-58, 58),
	by_target = math.random(-58, 58),
	last_update = client.system_time()
}


local function e270()
	e120.fl_val = math.random(0, 14)
	e120.by_val = math.random(-58, 58)
end



local function e271()
	local e66= client.system_time()
	if e66 - e120.last_update > 1 then
		e120.fl_target = math.random(0, 14)
		e120.by_target = math.random(-58, 58)
		e120.last_update = e66
	end
end

local function e272()
	e120.fl_val = e120.fl_val + (e120.fl_target - e120.fl_val) * 0.08
	e120.by_val = e120.by_val + (e120.by_target - e120.by_val) * 0.08
end

local function e273()
	if not ui.get(e47.ui.paint_target_info) then return end

	e271()
	e272()
	e270() 

	
	local e112, e102= client.screen_size()
	local e274= 170
	local e275= 80
	local e276= 30
	local e277= math.floor(e102 / 2 - e275 / 2)

	
	renderer.rectangle(e276 - 7, e277 - 5, e274 + 14, e275 + 10, 0, 0, 0, 200)
	renderer.rectangle(e276 - 6, e277 - 4, e274 + 12, e275 + 8, 60, 60, 60, 255)
	renderer.rectangle(e276 - 5, e277 - 3, e274 + 10, e275 + 6, 40, 40, 40, 255)
	renderer.rectangle(e276 - 3, e277 - 1, e274 + 6, e275 + 2, 60, 60, 60, 255)
	renderer.rectangle(e276 - 2, e277, e274 + 4, e275, 12, 12, 12, 255)
	renderer.rectangle(e276 - 2, e277, e274 + 4, e275, 32, 32, 32, 255)

	
	local e100= e80()
	if e100 and renderer.texture then
		renderer.texture(e100, e276 - 2, e277, e274 + 4, e275, 255,255,255,60, 'r')
	end

	
	local e278= e277
	local e279= 1
	local e280= math.floor((e274 + 4) / 2)
	local e281= math.ceil((e274 + 4) / 2)
	
	renderer.rectangle(e276 - 2, e278 - 1, e274 + 4, e279 + 2, 0, 0, 0, 255)
	if renderer.gradient then
		renderer.gradient(e276 - 2, e278, e280, e279, 59,175,222,255, 202,70,205,255, true)
		renderer.gradient(e276 - 2 + e280, e278, e281, e279, 202,70,205,255, 204,227,53,255, true)
	end

	
	local e282= e276 + 12
	local e283= e277 + 13  
	local e284= 18
	local e285= e274 - 60 
	local e286= 7 

	
	local e287= math.floor(e120.fl_val + 0.5)
	
	local e288= e286 / 2 - 7
	renderer.text(e282 - 8, e283 + e288, 255,255,255,255, '', 0, "Fake lag")
	local e289= e282 + 42 
	local e290= e283 + 6  
	local e291= 14
	local e292= math.floor(e285 * (e120.fl_val / e291))
	
	local e293= e285 + 2
	local e294= e286 + 2
	local e295= e289 + 1
	local e296= e290 + 1
	local e297= e285 - 2
	local e298= e286 - 2
	renderer.rectangle(e289 - 1, e290 - 1, e293, e294, 0, 0, 0, 255)
	renderer.rectangle(e289, e290, e285, e286, 60, 60, 60, 255)
	renderer.rectangle(e295, e296, math.max(0, math.floor(e297 * (e120.fl_val / e291))), e298, 180, 220, 80, 255)
	local e299= e289 + e292 - 4
	local e300= e290 + e286 / 2
	renderer.circle(e299, e300, 5, 180,220,80,255, 16)
	
	local e301= tostring(e287)
	local e302= e289 + e292 + 8 
	local e303= e290 + e286 + 0 
	renderer.text(e302 + 1, e303 + 1, 0,0,0,255, '-', 0, e301)
	renderer.text(e302, e303, 255,255,255,255, '-', 0, e301)

	
	local e304= math.floor(e120.by_val + 0.5)
	renderer.text(e282 - 8, e283 + e284 + e288, 255,255,255,255, '', 0, "Body yaw")
	local e305= e282 + 42 
	local e306= e283 + e284 + 6  
	local e307= -58
	local e308= 58
	local e309= e308 - e307
	
	local e310= math.floor(e285 * ((e120.by_val - e307) / e309))
	
	local e311= e285 + 2
	local e312= e286 + 2
	local e313= e305 + 1
	local e314= e306 + 1
	local e315= e285 - 2
	local e316= e286 - 2
	renderer.rectangle(e305 - 1, e306 - 1, e311, e312, 0, 0, 0, 255)
	renderer.rectangle(e305, e306, e285, e286, 60, 60, 60, 255)
	
	local e121= e305 + e285 / 2
	local e317= e305 + e310
	if e120.by_val < 0 then
		renderer.rectangle(e317 + 1, e314, e121 - e317, e316, 180, 220, 80, 255)
	else
		renderer.rectangle(e121 + 1, e314, e317 - e121, e316, 180, 220, 80, 255)
	end
	local e318= e317 - 4
	local e319= e306 + e286 / 2
	renderer.circle(e318, e319, 5, 180,220,80,255, 16)
	
	local e320= tostring(e304)
	local e321= e305 + e310
	local e322= e321 + 8 
	local e323= e306 + e286 + 0 
	renderer.text(e322 + 1, e323 + 1, 0,0,0,255, '-', 0, e320)
	renderer.text(e322, e323, 255,255,255,255, '-', 0, e320)

	
	local e324= 22
	local e325= 14

	
	local e326= math.random() > 0.5 and "[Offensive]" or "[Defensive]"
	local e327= e326 == "[Offensive]" and {204,227,53,255} or {202,70,205,255}
	renderer.text(e282 - 8, e283 + e284 * 2 + e288, 255,255,255,255, '', 0, "Double tap")
	local e328= e282 + e285 + 32
	local e329= e283 + e284 * 2 - 2
	renderer.text(e328 + 4, e329 + 2, table.unpack(e327), '', 0, e326)

	
	local e330= math.random() > 0.5 and "[On]" or "[Off]"
	local e331= e330 == "[On]" and {80,255,80,255} or {255,255,80,255}
	renderer.text(e282 - 8, e283 + e284 * 3 + e288, 255,255,255,255, '', 0, "Freestanding")
	local e332= e282 + e285 + 32
	local e333= e283 + e284 * 3 - 2
	renderer.text(e332 + 4, e333 + 2, table.unpack(e331), '', 0, e330)
end

local e51= require("require/abc/callbacks")
e51.callback('paint', e273, { alive_only = true, require_login = true })
]]
e661["require/features/paint/text_watermark"] = [[local e136= require("require/help/string")
local e135= require("require/help/time")
local e273= require("require/help/color")
local e215= e273.rgba_to_hex
local e274= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local e275= nil

local function e244(e111,e124,e72,e73,e74,e70,e82)
    local e56= e135.realtime() or globals.curtime()
    if not e82 or #e82 == 0 then return "" end
    local e82= {}

    if e111 == 0 then
        local e245= e215(e72,e73,e74,e70)
        for e60=1,#e82 do e82[#e82+1] = e245 .. e82:sub(e60,e60) end
        return table.concat(e82)
    end

    if e111 == 2 then
        local e61= (math.sin(e56 * e124) + 1) * 0.5
        local e246= e273.clamp(math.floor(e70 * (0.45 + 0.55 * e61)))
        local e245= e215(e72,e73,e74,e246)
        for e60=1,#e82 do e82[#e82+1] = e245 .. e82:sub(e60,e60) end
        return table.concat(e82)
    end

    if e111 == 3 then
        for e60=1,#e82 do
            local e137= math.sin(e56 * e124 - e60 * 0.6)
            local e247= math.max(0, e137)
            local e61= e247 * e247
            local e246= e273.clamp(math.floor(e70 * (0.35 + 0.65 * e61)))
            e82[#e82+1] = e215(e72,e73,e74,e246) .. e82:sub(e60,e60)
        end
        return table.concat(e82)
    end

    for e60=1,#e82 do
        local e61= (math.sin(e56*e124 - e60*0.35) + 1) * 0.5
        local e246= e273.clamp(math.floor(e70 * (0.4 + 0.6 * e61)))
        e82[#e82+1] = e215(e72,e73,e74,e246) .. e82:sub(e60,e60)
    end
    return table.concat(e82)
end

local e189= {}
local e190= {}
for e60, e52 in ipairs({
    { 'misc', 'settings', 'menu color' },
}) do
    local e82= {ui.reference(e52[1], e52[2], e52[3])}
    e189[e60] = e82
    for e62, e75 in ipairs(e82) do
        e190[e75] = true
    end
end

local e194, e51= pcall(require, "require/abc/callbacks")
local function e232(e62)
    local e92, e93= client.screen_size()
    if not e92 or not e93 then return end
    local e91, e92, e93, e94= 255, 255, 255, 255
    
    local e272= false
    local e144, e47= pcall(require, "require/abc/menu_setup")
    if e144 and e47 and e47.ui and e47.ui.paint_advertisement_color then
        local e145, e70, e74, e71, e74= pcall(ui.get, e47.ui.paint_advertisement_color)
        if e145 then
            e272 = true
            if type(e70) == 'number' then
                e91 = e273.clamp(e70 or e91)
                e92 = e273.clamp(e74 or e92)
                e93 = e273.clamp(e71 or e93)
                e94 = e273.clamp(e74 or e94)
            elseif type(e70) == 'string' and #e70 == 12 then
                local e53
                e53, e91 = pcall(function() return tonumber(e70:sub(1,3)) end)
                e53, e92 = pcall(function() return tonumber(e70:sub(4,6)) end)
                e53, e93 = pcall(function() return tonumber(e70:sub(7,9)) end)
                e53, e94 = pcall(function() return tonumber(e70:sub(10,12)) end)
                e91 = e273.clamp(e91 or 255); e92 = e273.clamp(e92 or 255); e93 = e273.clamp(e93 or 255); e94 = e273.clamp(e94 or 255)
            end
        end
    end

    if not e272 then
        local e145, e70, e74, e71, e74= pcall(ui.get, e189[1][1])
        if e145 then
            if type(e70) == 'number' then
                e91 = e273.clamp(e70 or e91)
                e92 = e273.clamp(e74 or e92)
                e93 = e273.clamp(e71 or e93)
                e94 = e273.clamp(e74 or e94)
            elseif type(e70) == 'string' and #e70 == 12 then
                local e53
                e53, e91 = pcall(function() return tonumber(e70:sub(1,3)) end)
                e53, e92 = pcall(function() return tonumber(e70:sub(4,6)) end)
                e53, e93 = pcall(function() return tonumber(e70:sub(7,9)) end)
                e53, e94 = pcall(function() return tonumber(e70:sub(10,12)) end)
                e91 = e273.clamp(e91 or 255); e92 = e273.clamp(e92 or 255); e93 = e273.clamp(e93 or 255); e94 = e273.clamp(e94 or 255)
            end
        end
    end

    local e144, e47= pcall(require, "require/abc/menu_setup")
    if not e144 or not e47 or not e47.ui then return end
    if not ui.get(e47.ui.paint_advertisement) then return end
    local e56= e135.realtime() or globals.curtime()
    local e276= 0
    local e121= math.floor(200 + 55 * (math.sin(e56*2)+1)/2)
    local e277, e278, e243= "sodium", "[BETA]", 3

    local e279, e280= renderer.measure_text("", e277)
    e279 = e279 or 0; e280 = e280 or 16
    local e281= (renderer.measure_text("", e278) or 0)

    if e274 and not e275 then
        local e282= math.floor(e92/2 - (e279 + e243 + e281)/2)
        local e283= math.floor(e93 - 15)
        e275 = e274.new('sodium_watermark', {
            x = e282,
            y = e283,
            w = e279 + e243 + e281,
            h = e280,
                default_pos = { x = e282, y = e283 },
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
        })
    end

    if e275 then
        e275:handle()
    end

    local e98, e284
    if e275 then
        e98 = e275.x
        e284 = e275.y + e276
    else
        e98 = math.floor(e92/2 - (e279 + e243 + e281)/2)
        e284 = e93 - 15 + e276
    end

    local e285= math.floor(math.max(0, e121 - 140) * 0.6)
    local e286= { {-1,0},{1,0},{0,-1},{0,1} }

    if e275 then e275:draw() end

    for e62,e287 in ipairs(e286) do renderer.text(e98+e287[1], e284+e287[2], 0,0,0, e285, "", 0, e277) end
    renderer.text(e98, e284, 255,255,255, e121, "", 0, e277)

    local e262= 1
    local e288, e289= pcall(require, "require/abc/menu_setup")
    if e288 and e289 and e289.ui and e289.ui.paint_advertisement_animation then
        local e263, e63= pcall(ui.get, e289.ui.paint_advertisement_animation)
        if e263 and type(e63) == 'number' then e262 = e63 end
    end

    local e232= e98 + e279 + e243
    local e279= e244(e262, 3.5, e91, e92, e93, e94, e278)
    renderer.text(e232, e284, e91, e92, e93, e94, "", 0, e279)
end

if e194 and e51 and e51.callback then
    e51.callback('paint', e232, { alive_only = true, require_login = true })
end]]
e661["require/features/paint/third_person_distance"] = [[local e47= require("require/abc/menu_setup")
local e135= require("require/help/time")
local e54= require("require/help/math")
local e202= require("require/help/safe")
local e276= { original = nil, last = nil, last_update = nil }

local function e277()
    if cvar.cam_idealdist and cvar.cam_idealdist.get_float then
        return cvar.cam_idealdist:get_float()
    end
    return nil
end

local function e278(e54)
    if cvar.cam_idealdist and cvar.cam_idealdist.set_float then
        cvar.cam_idealdist:set_float(e54)
        return true
    elseif client and client.exec then
        client.exec("cam_idealdist " .. tostring(e54))
        return true
    end
    return false
end

local e51= require("require/abc/callbacks")
e51.callback('paint', function()
    local e75= e47.ui and e47.ui.paint_third_person_distance
    if not e75 then
        client.log('third_person_distance: menu ref missing')
        return
    end
    local e72= e202.safe_get(e75)
    if type(e72) ~= 'number' then
        client.log('third_person_distance: invalid slider value', tostring(e72))
        return
    end
    local e226= e54.clamp(e72, 29, 180)
    e226 = e54.round(e226, 2)
    if e276.original == nil then
        e276.original = e277()
        if e276.original == nil then
            client.log('third_person_distance: cam_idealdist cvar not available')
        end
    end
    if e276.last == nil then
        e276.last = e277() or e226
    end
    local e66= e135.realtime()
    local e279= e276.last_update or e66
    local e274= e66 - e279
    e276.last_update = e66
    local e124= 300
    local e280= e124 * e274
    if math.abs(e276.last - e226) > 0.01 then
        local e56= e54.clamp(e280 / math.max(math.abs(e226 - e276.last), 0.01), 0, 1)
        e276.last = e54.lerp(e276.last, e226, e56)
        e276.last = e54.round(e276.last, 2)
        e278(e276.last)
    end
end, { require_login = true })]]
e661["require/features/paint/warnings"] = [[local e59, e87= client.screen_size()
local e279, e280= pcall(require, "require/abc/menu_setup")


local function e281()
    
    if not e279 or not e280 or not e280.ui or not e280.ui.paint_warnings then return end
    local e80= ui.get(e280.ui.paint_warnings)
    local e282= false
    if type(e80) == "table" then
        for e62, e63 in ipairs(e80) do
            if e63 == "lethal" then e282 = true break end
        end
    end
    if not e282 then return end

    if entity.get_prop(entity.get_local_player(), 'm_iHealth') and entity.get_prop(entity.get_local_player(), 'm_iHealth') > 0 and entity.get_prop(entity.get_local_player(), 'm_iHealth') < 93 then
        renderer.text(e59 / 2, e87 * 0.3, 255, 0, 0, 255, "c, -", 0, "YOU'RE LETHAL:   " .. entity.get_prop(entity.get_local_player(), 'm_iHealth') .. " HP REMAINING")
    end
    
end

local e283, e284= pcall(require, "require/abc/callbacks")
if e283 and e284 then
    e284.callback('paint', e281, { alive_only = true, require_login = true })
end]]
e661["require/features/paint/watermark_gamesense"] = [[local renderer= renderer
local client= client
local globals= globals
local e273= require('require/help/color')

local e274= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local e275= nil

local function e282()
	local e283= globals and globals.frametime and globals.frametime() or 0.016
	if e283 > 0 then
		return math.floor(1 / e283 + 0.5)
	end
	return 0
end

local e79= nil
local function e80()
	if e79 then return e79 end
	if renderer.load_rgba then
		local e53, e101= pcall(renderer.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if e53 and e101 then e79 = e101 end
	end
	return e79
end

local e284= e273.hex_to_rgba

local e285= {
	green  = "a5ca2aFF",
	red    = "d96464FF",
	yellow = "ccb854FF",
	blue   = "5462ccFF",
	purple = "7054ccFF",
	white  = "ffffffFF",
	grey   = "757575FF",
	black  = "000000FF",
	pink   = "c8a2deFF",
}


local e66= require("require/abc/login_system")
local e47= require("require/abc/menu_setup")
local self= require("require/help/self")

local e246= require("require/help/time")
local e286= 0
local e287= e246.new(0.25)

local function e288()
	if not e47 or not e47.ui then return end
	
	local e179, e80= pcall(ui.get, e47.ui.paint_watermark)
	if not e179 or not e80 then return end
	
	local e165, e289= pcall(ui.get, e47.ui.paint_watermark_type)
	if not e165 or e289 ~= 0 then return end
	local e112, e102= client and client.screen_size and client.screen_size() or 800, 600

	local e68
	if e66.logged_in then
		local e149= database.read and database.read('cached_credentials')
		if e149 and e149.username then
			e68 = e149.username
		end
	else
		local e76= e66.load_credentials and e66.load_credentials()
		if e76 and e76.username then
			e68 = e76.username
		end
	end
	if not e68 or e68 == "" then
		e68 = self.player_name and self.player_name() or "unknown"
	end
	if e246.expired(e287) then
		e286 = e282()
		e246.reset(e287)
	end
	local e290= e286

	local e291= 0
	if self and self.ping then
		local e166= self.ping()
		if type(e166) == 'number' then e291 = e166 end
	elseif client and client.latency then
		local e166= client.latency()
		if type(e166) == 'number' then e291 = e166 end
	end
	local e292= math.floor((e291 or 0) * 1000 + 0.5)

	local e293= ''
	local e294= {
		{text = "game", style = e293, color = e285.white},
		{text = "sense", style = e293, color = e285.green},
		{text = " ", style = e293, color = e285.white},
		{text = "[beta]", style = e293, color = e285.white},
		{text = " | ", style = e293, color = e285.white},
		{text = e68, style = e293, color = e285.white},
		{text = " | ", style = e293, color = e285.white},
		{text = tostring(e292) .. " ms", style = e293, color = e285.white},
		{text = " | ", style = e293, color = e285.white},
		{text = tostring(e290) .. " fps", style = e293, color = e285.white},
	}

	local e295, e296= 0, 0
	for e62, e297 in ipairs(e294) do
		local e88, e89= renderer.measure_text and renderer.measure_text(e297.style, e297.text) or 0, 13
		e295 = e295 + e88
		if e89 > e296 then e296 = e89 end
	end
	local e298, e299= 5, 2
	local e300= e295 + e298 * 2
	local e301= e296 + e299 * 2
	local e59= e112 - e300 - 16
	local e87= 16

	if e274 and not e275 then
		local e282= e59
		local e283= e87
		e275 = e274.new('gamesense_watermark', {
			x = e282,
			y = e283,
			w = e300,
			h = e301,
			snap = true,
			snap_threshold = 24,
			require_menu_open = true,
			box_color = {255,255,255,100},
			default_pos = { x = e282, y = e283 },
		})
	end

	if e275 then e275:handle() end

	if e275 then
		e59 = e275.x
		e87 = e275.y
	end

	renderer.rectangle(e59 - 7, e87 - 5, e300 + 14, e301 + 10, 0, 0, 0, 200)
	renderer.rectangle(e59 - 6, e87 - 4, e300 + 12, e301 + 8, 60, 60, 60, 255)
	renderer.rectangle(e59 - 5, e87 - 3, e300 + 10, e301 + 6, 40, 40, 40, 255)
	renderer.rectangle(e59 - 3, e87 - 1, e300 + 6, e301 + 2, 60, 60, 60, 255)
	renderer.rectangle(e59 - 2, e87, e300 + 4, e301, 12, 12, 12, 255)
	renderer.rectangle(e59 - 2, e87, e300 + 4, e301, 32, 32, 32, 255)

	local e100= e80()
	if e100 and renderer.texture then
		renderer.texture(e100, e59 - 2, e87, e300 + 4, e301, 255,255,255,60, 'r')
	end

	if renderer.gradient then
		renderer.gradient(e59 - 2, e87, e300 / 2 + 1, 1, 59,175,222,255, 202,70,205,255, true)
		renderer.gradient(e59 - 2 + e300 / 2, e87, e300 / 2 + 4.5, 1, 202,70,205,255, 204,227,53,255, true)
	end

	local e235= e59 + e298
	local e236= e87 + e299
    if e275 then e275:draw() end
	for e62, e297 in ipairs(e294) do
		local e88, e89= renderer.measure_text and renderer.measure_text(e297.style, e297.text) or 0, 13
			local e72,e73,e74,e70= e284(e297.color)
			e72,e73,e74,e70 = e273.normalize(e72,e73,e74,e70)
			renderer.text(e235, e236, e72,e73,e74,e70, e297.style, nil, e297.text)
		e235 = e235 + e88
	end
end

local e194, e51= pcall(require, "require/abc/callbacks")
if e194 and e51 and e51.callback then
	e51.callback('paint', e288, { alive_only = true, require_login = true })
end
]]
e661["require/features/paint/watermark_solus"] = [[local renderer= renderer
local client= client
local e273= require('require/help/color')
local e138, e51= pcall(require, "require/abc/callbacks")
local e144, e47= pcall(require, "require/abc/menu_setup")
local e86, e87= pcall(ui.reference, 'misc', 'settings', 'menu color')
local e274= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local e275= nil
local function e84(e59,e87,e88,e89,e85,e72,e73,e74,e70)
    renderer.rectangle(e59+e85, e87, e88-(e85*2), e89, e72,e73,e74,e70)
    renderer.rectangle(e59, e87+e85, e88, e89-(e85*2), e72,e73,e74,e70)
    renderer.circle(e59+e85, e87+e85, e72,e73,e74,e70, e85, 0, 1)
    renderer.circle(e59+e88-e85, e87+e85, e72,e73,e74,e70, e85, 0, 1)
    renderer.circle(e59+e85, e87+e89-e85, e72,e73,e74,e70, e85, 0, 1)
    renderer.circle(e59+e88-e85, e87+e89-e85, e72,e73,e74,e70, e85, 0, 1)
end

local globals= globals
local e285= 0
local e286= 0
local e287= 0.1

local function e288(e120)
    local e53, e219= pcall(require, e120)
    if e53 then return e219 end
    return nil
end

local function e289()
    if not e144 or not e47 or not e47.ui then return end
    local e179, e80= pcall(ui.get, e47.ui.paint_watermark)
    if not e179 or not e80 then return end
    local e165, e289= pcall(ui.get, e47.ui.paint_watermark_type)
    if not e165 or e289 ~= 1 then return end

    local e92, e93= client.screen_size()
    if not e92 or not e93 then return end

    local e68= "unknown"
    local e66= e288('require/abc/login_system')
    local e290= (pcall(require, 'require/help/self') and require('require/help/self')) or nil
    if e66 then
        if e66.logged_in then
            local e149= database and database.read and database.read('cached_credentials')
            if e149 and e149.username then e68 = e149.username end
        else
            if e66.load_credentials then
                local e76= e66.load_credentials()
                if e76 and e76.username then e68 = e76.username end
            end
        end
    end
    if (not e68 or e68 == "") and e290 and e290.player_name then
        e68 = e290.player_name()
    end

    local e290= e285 or 0
    pcall(function()
        local e66= globals and globals.realtime and globals.realtime() or os.clock()
        if (e66 - (e286 or 0)) >= e287 then
            local e291= globals and globals.frametime and globals.frametime() or 0.016
            if e291 and e291 > 0 then
                e285 = math.floor(1 / e291 + 0.5)
            end
            e286 = e66
        end
        e290 = e285 or e290
    end)

    local e292= 0
    if e290 and e290.ping then
        local e166= e290.ping()
        if type(e166) == 'number' then e292 = math.floor(e166 * 1000 + 0.5) end
    elseif client and client.latency then
        local e166= client.latency()
        if type(e166) == 'number' then e292 = math.floor(e166 * 1000 + 0.5) end
    end

    local e294= {
        { text = "gamesense ", bold = true },
        { text = " | ", bold = false },
        { text = e68 or "unknown", bold = false },
        { text = " | ", bold = false },
        { text = tostring(e292) .. " ms", bold = false },
        { text = " | ", bold = false },
        { text = tostring(e290) .. " fps", bold = false },
    }

    local e295, e296= 0, 0
    for e62, e297 in ipairs(e294) do
        local e88, e89= 0, 13
        if renderer.measure_text then
            local e53, e279, e280= pcall(renderer.measure_text, '', e297.text)
            if e53 and e279 then e88, e89 = e279, e280 or e89 end
        end
        e295 = e295 + (e88 or 0)
        if e89 and e89 > e296 then e296 = e89 end
    end

    local e298, e299= 12, 6
    local e300= e295 + e298 * 2
    local e301= e296 + e299 * 2
    local e116= 18
    local e59= e92 - e300 - e116
    local e87= e116
    local e85= 8
    if e274 and not e275 then
        local e282= e59
        local e283= e87
        e275 = e274.new('solus_watermark', {
            x = e282,
            y = e283,
            w = e300,
            h = e301,
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
            default_pos = { x = e282, y = e283 },
        })
    end

    if e275 then e275:handle() end

    if e275 then
        e59 = e275.x
        e87 = e275.y
    end
    local e91, e92, e93, e94= 255, 140, 0, 255
    do
        
        if e144 and e47 and e47.ui and e47.ui.paint_watermark_color then
            local e95, e96, e97, e98, e99= pcall(ui.get, e47.ui.paint_watermark_color)
            if e95 then
                if type(e96) == 'number' then
                    e91 = e273.clamp(e96 or e91)
                    e92 = e273.clamp(e97 or e92)
                    e93 = e273.clamp(e98 or e93)
                    e94 = e273.clamp(e99 or e94)
                elseif type(e96) == 'string' and #e96 == 12 then
                    local e53
                    e53, e91 = pcall(function() return tonumber(e96:sub(1,3)) end)
                    e53, e92 = pcall(function() return tonumber(e96:sub(4,6)) end)
                    e53, e93 = pcall(function() return tonumber(e96:sub(7,9)) end)
                    e53, e94 = pcall(function() return tonumber(e96:sub(10,12)) end)
                    e91 = e273.clamp(e91 or 255); e92 = e273.clamp(e92 or 140); e93 = e273.clamp(e93 or 0); e94 = e273.clamp(e94 or 255)
                end
                
            else
                
                if e86 and e87 then
                    local e292, e293, e294, e295, e296= pcall(ui.get, e87)
                    if e292 then
                        if type(e293) == 'number' then
                            e91 = e273.clamp(e293 or e91)
                            e92 = e273.clamp(e294 or e92)
                            e93 = e273.clamp(e295 or e93)
                            e94 = e273.clamp(e296 or e94)
                        elseif type(e293) == 'string' and #e293 == 12 then
                            local e53
                            e53, e91 = pcall(function() return tonumber(e293:sub(1,3)) end)
                            e53, e92 = pcall(function() return tonumber(e293:sub(4,6)) end)
                            e53, e93 = pcall(function() return tonumber(e293:sub(7,9)) end)
                            e53, e94 = pcall(function() return tonumber(e293:sub(10,12)) end)
                            e91 = e273.clamp(e91 or 255); e92 = e273.clamp(e92 or 140); e93 = e273.clamp(e93 or 0); e94 = e273.clamp(e94 or 255)
                        end
                    end
                end
            end
        else
            
            if e86 and e87 then
                local e95, e96, e97, e98, e99= pcall(ui.get, e87)
                if e95 then
                    if type(e96) == 'number' then
                        e91 = e273.clamp(e96 or e91)
                        e92 = e273.clamp(e97 or e92)
                        e93 = e273.clamp(e98 or e93)
                        e94 = e273.clamp(e99 or e94)
                    elseif type(e96) == 'string' and #e96 == 12 then
                        local e53
                        e53, e91 = pcall(function() return tonumber(e96:sub(1,3)) end)
                        e53, e92 = pcall(function() return tonumber(e96:sub(4,6)) end)
                        e53, e93 = pcall(function() return tonumber(e96:sub(7,9)) end)
                        e53, e94 = pcall(function() return tonumber(e96:sub(10,12)) end)
                        e91 = e273.clamp(e91 or 255); e92 = e273.clamp(e92 or 140); e93 = e273.clamp(e93 or 0); e94 = e273.clamp(e94 or 255)
                    end
                end
            end
        end
    end

    local function e297(e298,e256,e257,e72,e299,e300,e301)
        local e88= math.rad(e299)
        local e138= math.rad(e300)
        for e60=0,e301 do
            local e56= e60 / e301
            local e70= e88 + (e138 - e88) * e56
            e298[#e298+1] = { e256 + math.cos(e70) * e72, e257 + math.sin(e70) * e72 }
        end
    end

    local function e302(e59,e87,e88,e89,e100,e280)
        local e232= {}
        e280 = e280 or 6
        local e98= e59
        local e223= e59 + e88
        local e303= e87
        local e304= e87 + e89
        local e232= e98 + e100
        local e168= e223 - e100
        local function e305(e288,e289)
            local e129= #e232
            if e129 == 0 then e232[#e232+1] = { e288, e289 }; return end
            local e172= e232[e129]
            if not (math.abs(e172[1] - e288) < 0.001 and math.abs(e172[2] - e289) < 0.001) then
                e232[#e232+1] = { e288, e289 }
            end
        end

        if e168 > e232 then
            for e306 = e232, e168, e280 do e305(e306, e303) end
            
            e305(e168, e303)
        end

        e297(e232, e223 - e100, e303 + e100, e100, -90, 0, 6)

        local e233= e303 + e100
        local e169= e304 - e100
        if e169 > e233 then
            for e307 = e233, e169, e280 do e305(e223, e307) end
            e305(e223, e169)
        end

        e297(e232, e223 - e100, e304 - e100, e100, 0, 90, 6)

        if e168 > e232 then
            for e306 = e168, e232, -e280 do e305(e306, e304) end
            e305(e232, e304)
        end

        e297(e232, e98 + e100, e304 - e100, e100, 90, 180, 6)

        if e169 > e233 then
            for e307 = e169, e233, -e280 do e305(e98, e307) end
            e305(e98, e233)
        end

        e297(e232, e98 + e100, e303 + e100, e100, 180, 270, 6)

        return e232
    end

    local e308= 3
    local e232= e302(e59-1, e87-1, e300+2, e301+2, e85+1, e308)
    local e129= #e232

    if e275 then e275:draw() end

    e84(e59-1, e87-1, e300+2, e301+2, e85+1, 0, 0, 0, 255)
    e84(e59, e87, e300, e301, e85, 0, 0, 0, 200)

    
    if e129 > 2 then
        local e56= (globals and globals.realtime and globals.realtime() or 0)
        local e309= 7
        e309 = e309 * 4
        local e310= e309 / 60
        local e124= math.max(0.5, e310 * e129)
        local e311= math.floor((e56 * e124) % e129)

        local e312= math.max(6, math.floor(e129 * 0.25))

        local e313= e273.clamp(math.floor((e94 or 255) * 1.15))
        for e239 = e312 - 1, 0, -1 do
            local e314= ((e311 + e239) % e129) + 1
            local e315= ((e311 + e239 + 1) % e129) + 1
            local e316= e232[e314]
            local e317= e232[e315]
            if e316 and e317 then
                local e318= 1 - (e239 / e312)
                local e70= e273.clamp(math.floor(e313 * e318))
                renderer.line(e316[1], e316[2], e317[1], e317[2], e91, e92, e93, e70)
            end
        end
    end

    local e235= e59 + e298
    local e236= e87 + math.floor((e301 - e296) / 2)
    for e60, e297 in ipairs(e294) do
        local e88= 0
        if renderer.measure_text then
            local e53, e279= pcall(renderer.measure_text, '', e297.text)
            if e53 and e279 then e88 = e279 end
        end
        local e319= e297.bold and 'b' or ''
        renderer.text(e235, e236, 255,255,255,255, e319, 0, e297.text)
        e235 = e235 + e88
    end
end

if e138 and e51 and e51.callback then
    e51.callback('paint', e289, { alive_only = true, require_login = true })
end

return true]]
e661["require/features/paint/world_hitmarker_plus"] = [[
local e47= require("require/abc/menu_setup")
local e219= {shots = {}, last = 0}
local e288, e183= pcall(require, "require/brain/api/vector/vector")

local function e289()
	local e80= ui.get(e47.ui.paint_hitmarker)
	if type(e80) == "table" then
		for e62, e63 in ipairs(e80) do
			if e63 == "world +" then return true end
		end
	end
	return false
end

local e194, e51= pcall(require, "require/abc/callbacks")
local function e290(e62)
	if not e289() then e219.shots = {} return end
	if not e289() then return end
	local e66= globals.realtime()
	
	if e219.last and e66 - e219.last < 0.05 then return end
	e219.last = e66
	e219.shots[#e219.shots + 1] = {impacts = {}, finished = false, t = e66}
	if #e219.shots > 12 then table.remove(e219.shots, 1) end
end

local function e291(e62)
	if not e289() then e219 = {shots = {}, last = 0} return end
	local e133= entity.get_local_player()
	if not e133 then return end
	local e208= client.userid_to_entindex(e62.userid or 0)
	if e208 ~= e133 then return end
	local e66= globals.realtime()
	local e252
	for e60 = #e219.shots, 1, -1 do
		if not e219.shots[e60].finished and e66 - (e219.shots[e60].t or 0) < 1.2 then
			e252 = e219.shots[e60]
			break
		end
	end
	if not e252 then return end
	local e220, e221, e222= e62.x, e62.y, e62.z
	local e292, e168, e169, e170= pcall(client.eye_position)
	local e272, e273, e293= 0, 0, 0
	if e292 and e168 and e169 and e170 then
		if e288 and e183 and e183.make and e183.normalized and e183.sub then
			local e294= e183.make(e220, e221, e222)
			local e295= e183.make(e168, e169, e170)
			local e152= e183.normalized(e183.sub(e294, e295))
			e272, e273, e293 = e152.x, e152.y, e152.z
		else
			e272 = e220 - e168; e273 = e221 - e169; e293 = e222 - e170
			local e271= math.sqrt(e272*e272 + e273*e273 + e293*e293)
			if e271 > 0 then e272, e273, e293 = e272/e271, e273/e271, e293/e271 end
		end
	end
	local e296= false
	local e297, e238, e140= pcall(client.trace_line, e133, e220 - (e272 or 0) * 1, e221 - (e273 or 0) * 1, e222 - (e293 or 0) * 1, e220 + (e272 or 0) * 1, e221 + (e273 or 0) * 1, e222 + (e293 or 0) * 1)
	if e297 and e140 and e140 > 0 and e140 ~= e133 then
		if entity.is_enemy(e140) then e296 = true end
	end
	local e298, e299, e97, e96
	local e95, e300, e301, e302, e261= pcall(ui.get, e47.ui.paint_hitmarker_color)
	if e95 and e300 then
		e298, e299, e97, e96 = e300 or 0, e301 or 235, e302 or 235, e261 or 255
	else
		e298, e299, e97, e96 = 0, 235, 235, 255
	end
	e252.impacts[#e252.impacts + 1] = {x = e220, y = e221, z = e222, t = e66, r = e298, g = e299, b = e97, a = e96, dir = {e272, e273, e293}, hit = e296}
	
	if #e252.impacts > 5 then table.remove(e252.impacts, 1) end
	if e296 then
		e252.finished = true
	end
end

local function e232(e62)
	if e289() then
		local e66= globals.realtime()
		local e303= 5.5 * 3 * 0.8
		local e304= 0.25 * 0.8
		local e175= e303 + e304
		local e60= 1
		while e60 <= #e219.shots do
			if e66 - (e219.shots[e60].t or 0) > e175 then
				table.remove(e219.shots, e60)
			else
				e60 = e60 + 1
			end
		end
		
		local e235= {}
		local e236= 12
		for e125 = #e219.shots, 1, -1 do
			local e252= e219.shots[e125]
			for e237 = #e252.impacts, 1, -1 do
				table.insert(e235, e252.impacts[e237]) 
				if #e235 >= e236 then break end
			end
			if #e235 >= e236 then break end
		end
		local e238= math.min(4, #e235)
		for e239 = 1, e238 do
			local e191= e235[e239]
			local e305, e306, e307= e191.x, e191.y, e191.z
			if not e191.hit and e191.dir then
				local e168= e191.x + (e191.dir[1] or 0) * 24
				local e169= e191.y + (e191.dir[2] or 0) * 24
				local e170= e191.z + (e191.dir[3] or 0) * 24
				e305, e306, e307 = e168, e169, e170
			end
			local e232, e233= renderer.world_to_screen(e305, e306, e307)
			if e232 and e233 then
				local e264= e66 - (e191.t or 0)
				local e121= e264 <= e303 and 255 or math.floor(math.max(0, (1 - math.max(0, e264 - e303) / e304) * 255))
				if e121 > 0 then
					local e271= 4
					local e72= e191.r or 200
					local e73= e191.g or 200
					local e74= e191.b or 200
					renderer.line(e232 - e271, e233, e232 + e271, e233, e72, e73, e74, e121)
					renderer.line(e232, e233 - e271, e232, e233 + e271, e72, e73, e74, e121)
				end
			end
		end
	else
		e219 = {shots = {}, last = 0}
	end
end

if e194 and e51 and e51.callback then
	e51.callback('aim_fire', e290, { alive_only = true, require_login = true })
	e51.callback('bullet_impact', e291, { alive_only = true, require_login = true })
	e51.callback('paint', e232, { alive_only = true, require_login = true })
end
]]
e661["require/help/bit"] = [[local bit= {}

local e291= 0xFFFFFFFF
local e292= 4294967296

local function e293(e59)
	e59 = tonumber(e59) or 0
	e59 = math.floor(e59) % e292
	if e59 < 0 then e59 = e59 + e292 end
	return e59
end

function bit.tobit(e59)
	local e294= e293(e59)
	if e294 >= 2147483648 then
		return e294 - e292
	end
	return e294
end

function bit.tohex(e59,e129)
	local e294= e293(e59)
	local e295= 8
	local e296= false
	if e129 then
		if e129 < 0 then
			e296 = true
			e295 = -e129
		else
			e295 = e129
		end
	end
	if e295 < 1 then e295 = 1 end
	if e295 > 8 then e295 = 8 end
	e294 = e294 % (2^(4 * e295))
	if e296 then
		return string.format(string.format("%%0%uX", e295), e294)
	else
		return string.format(string.format("%%0%ux", e295), e294)
	end
end

local function e297(e294,e60)
	return math.floor(e294 / 2^e60) % 2
end

function bit.band(e113,...)
	local e298= {e113, ...}
	if #e298 == 0 then return 0 end
	local e174= 0
	for e60 = 0, 31 do
		local e53= 1
		for e239 = 1, #e298 do
			if e297(e293(e298[e239]), e60) == 0 then
				e53 = 0
				break
			end
		end
		if e53 == 1 then e174 = e174 + 2^e60 end
	end
	return bit.tobit(e174)
end

function bit.bor(e113,...)
	local e298= {e113, ...}
	if #e298 == 0 then return 0 end
	local e174= 0
	for e60 = 0, 31 do
		for e239 = 1, #e298 do
			if e297(e293(e298[e239]), e60) == 1 then
				e174 = e174 + 2^e60
				break
			end
		end
	end
	return bit.tobit(e174)
end

function bit.bxor(e113,...)
	local e298= {e113, ...}
	if #e298 == 0 then return 0 end
	local e174= 0
	for e60 = 0, 31 do
		local e224= 0
		for e239 = 1, #e298 do
			if e297(e293(e298[e239]), e60) == 1 then e224 = e224 + 1 end
		end
		if (e224 % 2) == 1 then e174 = e174 + 2^e60 end
	end
	return bit.tobit(e174)
end

function bit.bnot(e59)
	local e294= e293(e59)
	local e174= e291 - e294
	return bit.tobit(e174)
end

function bit.lshift(e59,e129)
	e129 = tonumber(e129) or 0
	e129 = e129 % 32
	local e294= e293(e59)
	local e174= (e294 * 2^e129) % e292
	return bit.tobit(e174)
end

function bit.rshift(e59,e129)
	e129 = tonumber(e129) or 0
	e129 = e129 % 32
	local e294= e293(e59)
	local e174= math.floor(e294 / 2^e129) % e292
	return bit.tobit(e174)
end

function bit.arshift(e59,e129)
	e129 = tonumber(e129) or 0
	e129 = e129 % 32
	local e166= bit.tobit(e59)
	local e174= math.floor(e166 / 2^e129)
	return bit.tobit(e174)
end

function bit.rol(e59,e129)
	e129 = tonumber(e129) or 0
	e129 = e129 % 32
	if e129 == 0 then return bit.tobit(e59) end
	local e294= e293(e59)
	local e98= (e294 * 2^e129) % e292
	local e223= math.floor(e294 / 2^(32 - e129))
	local e174= (e98 + e223) % e292
	return bit.tobit(e174)
end

function bit.ror(e59,e129)
	e129 = tonumber(e129) or 0
	e129 = e129 % 32
	if e129 == 0 then return bit.tobit(e59) end
	local e294= e293(e59)
	local e223= math.floor(e294 / 2^e129)
	local e98= (e294 * 2^(32 - e129)) % e292
	local e174= (e98 + e223) % e292
	return bit.tobit(e174)
end

function bit.bswap(e59)
	local e294= e293(e59)
	local e299= e294 % 256
	local e300= math.floor(e294 / 256) % 256
	local e301= math.floor(e294 / 65536) % 256
	local e302= math.floor(e294 / 16777216) % 256
	local e174= e299 * 16777216 + e300 * 65536 + e301 * 256 + e302
	return bit.tobit(e174)
end

return bit]]
e661["require/help/client"] = [[local e54= {}

function e54.camera_angles(e157,e81)
  if e157 == nil and e81 == nil then
    return client.camera_angles()
  end
  return client.camera_angles(e157, e81)
end

function e54.camera_position()
  return client.camera_position()
end

function e54.color_log(e72,e73,e74,...)
  return client.color_log(e72, e73, e74, ...)
end

function e54.create_interface(e294,e295)
  return client.create_interface(e294, e295)
end

function e54.current_threat()
  return client.current_threat()
end

function e54.delay_call(e84,e296,...)
  return client.delay_call(e84, e296, ...)
end

function e54.draw_debug_text(e59,e87,e116,e297,e91,e72,e73,e74,e70,...)
  return client.draw_debug_text(e59, e87, e116, e297, e91, e72, e73, e74, e70, ...)
end

function e54.draw_hitboxes(e236,e91,e298,e72,e73,e74,e70,e63)
  return client.draw_hitboxes(e236, e91, e298, e72, e73, e74, e70, e63)
end

function e54.error_log(e269)
  return client.error_log(e269)
end

function e54.exec(...)
  return client.exec(...)
end

function e54.eye_position()
  return client.eye_position()
end

function e54.find_signature(e294,e299)
  return client.find_signature(e294, e299)
end

function e54.fire_event(e300,...)
  return client.fire_event(e300, ...)
end

function e54.get_cvar(e301)
  return client.get_cvar(e301)
end

function e54.get_model_name(e302)
  return client.get_model_name(e302)
end

function e54.key_state(e95)
  return client.key_state(e95)
end

function e54.latency()
  return client.latency()
end

function e54.log(...)
  return client.log(...)
end

function e54.random_float(e303,e304)
  return client.random_float(e303, e304)
end

function e54.random_int(e303,e304)
  return client.random_int(e303, e304)
end

function e54.real_latency()
  return client.real_latency()
end

function e54.register_esp_flag(e305,e72,e73,e74,e296)
  return client.register_esp_flag(e305, e72, e73, e74, e296)
end

function e54.reload_active_scripts()
  return client.reload_active_scripts()
end

function e54.request_full_update()
  return client.request_full_update()
end

function e54.scale_damage(e236,e230,e221)
  return client.scale_damage(e236, e230, e221)
end

function e54.screen_size()
  return client.screen_size()
end

function e54.set_clan_tag(...)
  return client.set_clan_tag(...)
end

function e54.set_event_callback(e300,e296)
  return client.set_event_callback(e300, e296)
end

function e54.system_time()
  return client.system_time()
end

function e54.timestamp()
  return client.timestamp()
end

function e54.trace_bullet(e306,e307,e308,e309,e310,e311,e312,e313)
  return client.trace_bullet(e306, e307, e308, e309, e310, e311, e312, e313)
end

function e54.trace_line(e314,e307,e308,e309,e310,e311,e312)
  return client.trace_line(e314, e307, e308, e309, e310, e311, e312)
end

function e54.unix_time()
  return client.unix_time()
end

function e54.unset_event_callback(e300,e296)
  return client.unset_event_callback(e300, e296)
end

function e54.update_player_list()
  return client.update_player_list()
end

function e54.userid_to_entindex(e315)
  return client.userid_to_entindex(e315)
end

function e54.visible(e59,e87,e116)
  return client.visible(e59, e87, e116)
end

return e54]]
e661["require/help/color"] = [[local function e284(e245)
    e245 = tostring(e245 or "")
    local e297= e245:match("([0-9A-Fa-f]+)$")
    if not e297 or #e297 ~= 8 then
        return 255,255,255,255
    end
    local e72= tonumber(e297:sub(1,2), 16)
    local e73= tonumber(e297:sub(3,4), 16)
    local e74= tonumber(e297:sub(5,6), 16)
    local e70= tonumber(e297:sub(7,8), 16)
    return e72,e73,e74,e70
end

local function e298(e72,e73,e74,e70)
    return string.format("\a%02x%02x%02x%02x", tonumber(e72) or 0, tonumber(e73) or 0, tonumber(e74) or 0, tonumber(e70) or 255)
end

local function e93(e59)
    local e129= tonumber(e59) or 0
    if e129 < 0 then return 0 end
    if e129 > 255 then return 255 end
    return math.floor(e129 + 0.5)
end

local function e299(e72,e73,e74,e70,e190)
    e190 = tonumber(e190) or 32
    return e93((e72 or 0) + e190), e93((e73 or 0) + e190), e93((e74 or 0) + e190), e93(e70 or 255)
end

local function e300(e72,e73,e74,e70,e190)
    e190 = tonumber(e190) or 32
    return e93((e72 or 0) - e190), e93((e73 or 0) - e190), e93((e74 or 0) - e190), e93(e70 or 255)
end

local e285= {
    default = "d6d6d6FF", 
    green  = "a5ca2aFF", 
    red    = "d96464FF", 
    reddark = "b22222FF", 
    orange = "dca53aFF", 
    yellow = "ccb854FF", 
    blue   = "5462ccFF", 
    cyan   = "54ccccFF", 
    purple = "7054ccFF", 
    white  = "ffffffFF", 
    grey   = "757575FF", 
    black  = "000000FF", 
    pink   = "c8a2deFF", 
    discord = "7289daFF", 
    youtube = "FF0000FF", 
    sellhub = "FFC107FF", 

}


local e49= {}
for e59, e245 in pairs(e285) do
    local e72,e73,e74,e70= e284(e245)
    e49[e59] = {
        base = e245,
        lighter = e298(e299(e72,e73,e74,e70,32)),
        darker  = e298(e300(e72,e73,e74,e70,32)),
        light2  = e298(e299(e72,e73,e74,e70,64)),
        dark2   = e298(e300(e72,e73,e74,e70,64)),
        rgb = {e72,e73,e74,e70},
        log = {e72,e73,e74},
        ui = e245,
    }
end

function e49.get(e59,e301)
    e301 = e301 or "base"
    local e96= e49[e59]
    if not e96 then return nil end
    if e301 == "log" and e96.log then
        return unpack(e96.log)
    elseif e301 == "ui" and e96.ui then
        return "\a"..e96.ui
    elseif e96[e301] then
        return e96[e301]
    end
    return nil
end

function e49.blend(e302,e303,e56)
    local e304,e305,e300,e205= unpack(e49[e302].rgb)
    local e306,e307,e301,e206= unpack(e49[e303].rgb)
    e56 = e56 or 0.5
    local e72= e93(e304 + (e306-e304)*e56)
    local e73= e93(e305 + (e307-e305)*e56)
    local e74= e93(e300 + (e301-e300)*e56)
    local e70= e93(e205 + (e206-e205)*e56)
    return e298(e72,e73,e74,e70)
end

function e49.hex_to_rgba(e245)
    return e284(e245)
end

function e49.rgba_to_hex(e72,e73,e74,e70)
    return e298(e72,e73,e74,e70)
end

function e49.clamp(e72,e73,e74,e70)
    return e93(e72), e93(e73), e93(e74), e93(e70)
end

function e49.normalize(e72,e73,e74,e70)
    return e93(e72), e93(e73), e93(e74), e93(e70 or 255)
end

function e49.modulate(e72,e73,e74,e70,e308,e309,e310,e311)
    e308 = tonumber(e308) or 1
    e309 = tonumber(e309) or e308
    e310 = tonumber(e310) or e308
    e311 = tonumber(e311) or 1
    local e312= e93((tonumber(e72) or 0) * e308)
    local e313= e93((tonumber(e73) or 0) * e309)
    local e314= e93((tonumber(e74) or 0) * e310)
    local e261= e93((tonumber(e70) or 255) * e311)
    return e312, e313, e314, e261
end

function e49.alpha_modulate(e70,e315)
    e315 = tonumber(e315) or 1
    return e93((tonumber(e70) or 255) * e315)
end

return e49]]
e661["require/help/drag"] = [[local e54= {}
local e120= {}
local e300= false

local e301= {
	['top-left'] = function(e92,e93,e88,e89) return 0, 0 end,
	['top-center'] = function(e92,e93,e88,e89) return math.floor(e92/2 - e88/2), 0 end,
	['top-right'] = function(e92,e93,e88,e89) return math.floor(e92 - e88), 0 end,
	['center-left'] = function(e92,e93,e88,e89) return 0, math.floor(e93/2 - e89/2) end,
	['center'] = function(e92,e93,e88,e89) return math.floor(e92/2 - e88/2), math.floor(e93/2 - e89/2) end,
	['center-right'] = function(e92,e93,e88,e89) return math.floor(e92 - e88), math.floor(e93/2 - e89/2) end,
	['bottom-left'] = function(e92,e93,e88,e89) return 0, math.floor(e93 - e89) end,
	['bottom-center'] = function(e92,e93,e88,e89) return math.floor(e92/2 - e88/2), math.floor(e93 - e89) end,
	['bottom-right'] = function(e92,e93,e88,e89) return math.floor(e92 - e88), math.floor(e93 - e89) end,
}

local function e302(e59,e87,e88,e89,e162,e163)
	if not e162 or not e163 then return false end
	return e162 >= e59 and e162 <= e59 + e88 and e163 >= e87 and e163 <= e87 + e89
end

local function e93(e129,e303,e304)
	if not e129 then return e303 end
	if e129 < e303 then return e303 end
	if e129 > e304 then return e304 end
	return e129
end

function e54.new(e65,e59)
	if not e65 then error('drag.new requires id') end
	e59 = e59 or {}
	local e305= {}
	e305.id = e65
	e305.x = e59.x or 0
	e305.y = e59.y or 0
	e305.w = e59.w or 100
	e305.h = e59.h or 20
	e305.snap = e59.snap == nil and true or e59.snap
	e305.snap_threshold = e59.snap_threshold or 24
	e305.snap_positions = e59.snap_positions or nil
	e305.require_menu_open = e59.require_menu_open == nil and true or e59.require_menu_open
	e305.locked = e59.lock or false
	e305.box_color = e59.box_color or {255,255,255,100}
	e305.show_alignment = e59.show_alignment == nil and true or e59.show_alignment
	e305.align_color = e59.align_color or {255,255,255,100}
	e305.align_cross_size = e59.align_cross_size or 6
	e305.show_screen_guides = e59.show_screen_guides == nil and true or e59.show_screen_guides
	e305.line_snap_threshold = e59.line_snap_threshold or 6
	e305.bounds = e59.bounds or nil
	e305.constraint_center = e59.constraint_center or nil
	e305.constraint_box = e59.constraint_box or nil
	e305.default_pos = e59.default_pos or nil
	e305.default_center = e59.default_center or nil

	local e88= {
		obj = e305,
		dragging = false,
		drag_offset_x = 0,
		drag_offset_y = 0,
		last_left = false,
		last_right = false,
		locked_to = nil,
		snap_progress = 0,
		snap_target = 0,
		line_snap_progress_x = 0,
		line_snap_progress_y = 0,
		line_snap_target_x = 0,
		line_snap_target_y = 0,
		drag_button = nil,
		disable_snap = false,
	}
	e120[e65] = e88

	local e306, e307= pcall(database.read, 'drag_positions')
	if e306 and type(e307) == 'table' and e307[e65] then
		local e245= e307[e65]
		if type(e245.x) == 'number' and type(e245.y) == 'number' then
			e305.x = e245.x
			e305.y = e245.y
		end
	end

	if not e300 then
		client.set_event_callback('setup_command', function(e91)
			for e62, e308 in pairs(e120) do
				if e308.dragging then
					pcall(function()
						e91.in_attack = false
						e91.in_attack2 = false
					end)
					break
				end
			end
		end)
		e300 = true
	end

	function e305:set_pos(e59,e87)
		self.x = e59
		self.y = e87
	end
	function e305:set_size(e88,e89)
		self.w = e88; self.h = e89
	end
	function e305:set_bounds(e59,e87,e88,e89)
		self.bounds = { x = e59, y = e87, w = e88, h = e89 }
	end
	function e305:clear_bounds()
		self.bounds = nil
	end
	function e305:get_pos()
		return self.x, self.y
	end
	function e305:is_dragging()
		return not not e88.dragging
	end
	function e305:get_bounds()
		return self.bounds
	end
	function e305:set_locked(e63)
		self.locked = not not e63
	end
	function e305:set_snap(e63)
		self.snap = not not e63
	end
	function e305:toggle_snap()
		self.snap = not self.snap
	end
	function e305:reset_to_anchor(e309)
		local e92, e93= client.screen_size()
		if not e92 or not e93 then return end
		local e668= e301[e309]
		if type(e668) == 'function' then
			local e310, e311= e668(e92,e93,self.w,self.h)
			self.x = e310; self.y = e311
			e88.locked_to = e309
		end
	end

	function e305:handle()
		if self.locked then return end
		local e92, e93= client.screen_size()
		if not e92 or not e93 then return end
		if self.require_menu_open and not ui.is_menu_open() then e88.last_left = false; return end

		local e162, e163= ui.mouse_position()
		local e98= client.key_state(1)
		local e223= client.key_state(2)

		if e98 and e223 and (e302(self.x, self.y, self.w, self.h, e162, e163) or e88.dragging) then
			if self.default_pos then
				self.x = self.default_pos.x
				self.y = self.default_pos.y
				return
			elseif self.default_center then
				self.x = (self.default_center.x or 0) - math.floor(self.w/2)
				self.y = (self.default_center.y or 0) - math.floor(self.h/2)
				return
			end
		end
		if e98 and not e88.last_left and e302(self.x, self.y, self.w, self.h, e162, e163) then
			e88.dragging = true
			e88.drag_button = 1
			e88.disable_snap = false
			e88.drag_offset_x = e162 - self.x
			e88.drag_offset_y = e163 - self.y
			e88.locked_to = nil
		elseif e223 and not e88.last_right and e302(self.x, self.y, self.w, self.h, e162, e163) then
			e88.dragging = true
			e88.drag_button = 2
			e88.disable_snap = true
			e88.drag_offset_x = e162 - self.x
			e88.drag_offset_y = e163 - self.y
			e88.locked_to = nil
			e88.snap_target = 0
			e88.line_snap_target_x = 0
			e88.line_snap_target_y = 0
		end

		if (e98 and e88.dragging and e88.drag_button == 1) or (e223 and e88.dragging and e88.drag_button == 2) then
			local e310= e162 - e88.drag_offset_x
			local e311= e163 - e88.drag_offset_y
			local e312, e313= 0, math.max(0, e92 - self.w)
			local e314, e315= 0, math.max(0, e93 - self.h)
			if self.constraint_center then
				local e71= self.constraint_center
				local e256= e71.cx or math.floor(e92/2)
				local e257= e71.cy or math.floor(e93/2)
				local e72= e71.radius or 0
				e312 = (e256 - e72) - math.floor(self.w/2)
				e313 = (e256 + e72) - math.floor(self.w/2)
				e314 = (e257 - e72) - math.floor(self.h/2)
				e315 = (e257 + e72) - math.floor(self.h/2)
			elseif self.bounds or self.constraint_box then
				local e74= self.bounds or self.constraint_box
				local e227= e74.x or e74[1] or 0
				local e228= e74.y or e74[2] or 0
				local e316= e74.w or e74[3] or (e92 - e227)
				local e317= e74.h or e74[4] or (e93 - e228)
				e312 = e227
				e313 = math.max(e227, e227 + e316 - self.w)
				e314 = e228
				e315 = math.max(e228, e228 + e317 - self.h)
			end
			e310 = e93(e310, e312, e313)
			e311 = e93(e311, e314, e315)
			self.x = e310; self.y = e311
			if self.snap and not e88.disable_snap then
				local e261= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for e62,e166 in ipairs(self.snap_positions) do
						if type(e166) == 'string' and e301[e166] then
							local e668= e301[e166]
							local e235, e236= e668(e92,e93,self.w,self.h)
							table.insert(e261, {x=e235,y=e236})
						elseif type(e166) == 'table' and #e166 >= 2 then
							table.insert(e261, {x=e166[1], y=e166[2]})
						end
					end
				else
					for e162,e668 in pairs(e301) do
						local e235, e236= e668(e92,e93,self.w,self.h)
						table.insert(e261, {x=e235,y=e236})
					end
				end
				local e318= math.huge
				for e62,e71 in ipairs(e261) do
					local e180= (e71.x - self.x)
					local e181= (e71.y - self.y)
					local e74= math.sqrt(e180*e180 + e181*e181)
					if e74 < e318 then e318 = e74 end
				end
				if e318 <= self.snap_threshold then e88.snap_target = 1 else e88.snap_target = 0 end
				local e319= math.floor(e92/2)
				local e320= math.floor(e93/2)
				local e256= math.floor(self.x + self.w/2)
				local e257= math.floor(self.y + self.h/2)
				if math.abs(e256 - e319) <= (self.line_snap_threshold or 6) then e88.line_snap_target_x = 1 else e88.line_snap_target_x = 0 end
				if math.abs(e257 - e320) <= (self.line_snap_threshold or 6) then e88.line_snap_target_y = 1 else e88.line_snap_target_y = 0 end
			end
		end

		local e321= false
		if e88.dragging then
			if e88.drag_button == 1 and not e98 and e88.last_left then e321 = true end
			if e88.drag_button == 2 and not e223 and e88.last_right then e321 = true end
		end
		if e321 then
			if not e88.disable_snap then
				local e319, e320= math.floor(e92/2), math.floor(e93/2)
				local e256= math.floor(self.x + self.w/2)
				local e257= math.floor(self.y + self.h/2)
				if self.show_screen_guides then
					if math.abs(e256 - e319) <= (self.line_snap_threshold or 6) then
						self.x = e319 - math.floor(self.w/2)
					end
					if math.abs(e257 - e320) <= (self.line_snap_threshold or 6) then
						self.y = e320 - math.floor(self.h/2)
					end
				end
			end
			e88.dragging = false
			local e322, e323= pcall(database.read, 'drag_positions')
			local e324= (e322 and type(e323) == 'table') and e323 or {}
			e324[self.id] = { x = self.x, y = self.y }
			pcall(function() database.write('drag_positions', e324) end)
			if self.snap and not e88.disable_snap then
				local e261= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for e62,e166 in ipairs(self.snap_positions) do
						if type(e166) == 'string' and e301[e166] then
							local e668= e301[e166]
							local e235, e236= e668(e92,e93,self.w,self.h)
							table.insert(e261, {x=e235,y=e236, key=e166})
						elseif type(e166) == 'table' and #e166 >= 2 then
							table.insert(e261, {x=e166[1], y=e166[2], key=nil})
						end
					end
				else
					for e162,e668 in pairs(e301) do
						local e235, e236= e668(e92,e93,self.w,self.h)
						table.insert(e261, {x=e235,y=e236, key=e162})
					end
				end
				local e249, e318= nil, math.huge
				for e62,e71 in ipairs(e261) do
					local e180= (e71.x - self.x)
					local e181= (e71.y - self.y)
					local e74= math.sqrt(e180*e180 + e181*e181)
					if e74 < e318 then e318 = e74; e249 = e71 end
				end
				if e249 and e318 <= self.snap_threshold then
					self.x = e249.x; self.y = e249.y
					e88.locked_to = e249.key
				end
			end
		end

		e88.last_left = e98
		e88.last_right = e223
	end

	function e305:draw()
		local e88= e120[self.id]
		if not e88 then return end
		if e88.dragging then
			local e72,e73,e74,e70= unpack(self.box_color)
			local e300,e301,e302,e261= unpack(self.align_color)
			local e274= globals.frametime() or 0.016
			local e325= math.min(1, 12 * e274)
			e88.snap_progress = e88.snap_progress + (e88.snap_target - e88.snap_progress) * e325
			e88.line_snap_progress_x = e88.line_snap_progress_x + (e88.line_snap_target_x - e88.line_snap_progress_x) * e325
			e88.line_snap_progress_y = e88.line_snap_progress_y + (e88.line_snap_target_y - e88.line_snap_progress_y) * e325
			local e326= math.floor(e72 + (0 - e72) * e88.snap_progress)
			local e327= math.floor(e73 + (0 - e73) * e88.snap_progress)
			local e328= math.floor(e74 + (0 - e74) * e88.snap_progress)
			local e329= math.floor(e70 + (200 - e70) * e88.snap_progress)
			renderer.rectangle(self.x, self.y, self.w, self.h, e326, e327, e328, e329)
			renderer.line(self.x, self.y, self.x + self.w, self.y, 200,200,200,150)
			renderer.line(self.x + self.w, self.y, self.x + self.w, self.y + self.h, 200,200,200,150)
			renderer.line(self.x + self.w, self.y + self.h, self.x, self.y + self.h, 200,200,200,150)
			renderer.line(self.x, self.y + self.h, self.x, self.y, 200,200,200,150)
			if self.show_alignment then
				local e92, e93= client.screen_size()
				if e92 and e93 then
					if self.show_screen_guides then
						local e319= math.floor(e92/2)
						local e320= math.floor(e93/2)
						local e256= math.floor(self.x + self.w/2)
						local e257= math.floor(self.y + self.h/2)
						local e330= math.abs(e256 - e319) <= (self.line_snap_threshold or 6)
						local e331= math.abs(e257 - e320) <= (self.line_snap_threshold or 6)
						local e332= math.floor(e261 * 0.35)
						renderer.line(e319, e320, 0, e320, e300,e301,e302, e332)
						renderer.line(e319, e320, e319, 0, e300,e301,e302, e332)
						renderer.line(e319, e320, e92, e320, e300,e301,e302, e332)
						renderer.line(e319, e320, e319, e93, e300,e301,e302, e332)
						local e333= math.floor(e261 * e88.line_snap_progress_x)
						local e334= math.floor(e261 * e88.line_snap_progress_y)
						if e333 > 0 then renderer.line(e319, 0, e319, e93, e300,e301,e302, e333) end
						if e334 > 0 then renderer.line(0, e320, e92, e320, e300,e301,e302, e334) end
					end
				end
			end
			if self.constraint_center then
				local e71= self.constraint_center
				local e256= e71.cx or math.floor((client.screen_size()) / 2)
				local e257= e71.cy or math.floor((client.screen_size()) / 2)
				local e72= e71.radius or 0
				local e227= e256 - e72
				local e228= e257 - e72
				local e316= e72 * 2
				local e317= e72 * 2
				renderer.rectangle(e227, e228, e316, e317, 255, 255, 255, 60)
				renderer.line(e227, e228, e227 + e316, e228, 255, 255, 255, 160)
				renderer.line(e227 + e316, e228, e227 + e316, e228 + e317, 255, 255, 255, 160)
				renderer.line(e227 + e316, e228 + e317, e227, e228 + e317, 255, 255, 255, 160)
				renderer.line(e227, e228 + e317, e227, e228, 255, 255, 255, 160)
			end
		end
	end

	return e305
end

function e54.get(e65)
	local e88= e120[e65]
	if not e88 then return nil end
	return e88.obj
end

function e54.ids()
	local e82= {}
	for e162,e62 in pairs(e120) do table.insert(e82, e162) end
	return e82
end

return e54]]
e661["require/help/emojis"] = [[local e303= {

    chat = { "" },
    rewind = { "" },
    thumbsup = { "" },
    mail = { "U+E135" },
    square = { "" },
    square2 = { "" },
    square_hollow = { "" },
    play = { "" },
    pause = { "" },
    sun = { "" },
    pc = { "" },
    pc2 = { "" },
    phone = { "U+E1C9" },
    trash = { "" },
    reject = { "" },
    accept = { "" },
    config = { "" },
    config_write = { "U+E28F" },
    gear = { "" },
    arrow_right = { "" },
    arrow_left = { "" },
    arrow_up = { "" },
    arrow_down = { "" },
    star = { "U+E0B4" },
    minus = { "" },
    plus = { "" },
    plus_in_brackets = { "U+E0C5" },
    pen = { "" },
    recycle = { "" },
    camera = { "" },
    download = { "" },
    upload = { "" },
    question = { "" },
    search = { "" },
    globe = { "" },
    globe2 = { "" },
    id = { "" },
    phone = { "" },
    user = { "" },
    user2 = { "U+E2AF" },
    user3 = { "U+E13D" },
    users = { "" },
    users2 = { "U+E125" },
    user_no = { "U+E1E0" },
    pin = { "" },
    unpin = { "U+E196" },
    windows = { "" },
    turning = { "" },
    turning2 = { "" },
    arrow_double = { "" },
    clip = { "" },
    clipboard = { "U+E16D" },
    exclamation = { "" },
    time = { "" },
    clock = { "U+E2AD" },
    paper = { "" },
    paper2 = { "" },
    link = { "" },
    link2 = { "U+E167" },
    wrench = { "" },
    url = { "" },
    speaker = { "" },
    house = { "" },
    pallete = { "" },
    lock = { "" },
    lock_open = { "" },
    tsarrow_left = { "" },
    tsarrow_right = { "" },
    tsarrow_up = { "" },
    tsarrow_up = { "" },
    warning = { "⚠︎" },
    video = { "" },
    connection = { "" },
    heart = { "" },
    triangle_upside = { "⛛" },
    music_note = { "U+E142" },
    test = { "U+E2B1" },
    keyboard = { "U+E0D2" },
    latency0 = { "U+E1E5" },
    latency1 = { "U+E1E6" },
    latency2 = { "U+E1E7" },
    latency3 = { "U+E1E8" },
    latency4 = { "U+E1E9" },
    expand = { "U+E1D9" },
    monitor = { "U+E2F0" },
    rain = { "U+E28A" },
    likedislike = { "U+E19D" },
    text = { "U+E1C8" },
    back = { "U+E10E" },
    folder = { "U+E1C1" },
    menu = { "U+E179" },
    menu2 = { "U+E1A0" },
    at = { "U+E168" },
    circle = { "U+E235" },
    updown = { "U+E174" },

}

local e54= {}

local function e304(e88)
    if e88 == nil then return "ERROR" end
    if type(e88) ~= "string" then e88 = tostring(e88) end
    if e88 == "ERROR" then return "ERROR" end
    local e245= e88:match('^U%+([0-9A-Fa-f]+)$') or e88:match('^u%+([0-9A-Fa-f]+)$') or e88:match('^0x([0-9A-Fa-f]+)$')
    if e245 then
        local e244= tonumber(e245, 16)
        if e244 then
            local e305= nil
            if type(utf8) == 'table' and type(utf8.char) == 'function' then
                pcall(function() e305 = utf8.char(e244) end)
            end
            if not e305 then
                local function e306(e129)
                    if e129 < 0x80 then return string.char(e129) end
                    if e129 < 0x800 then return string.char(0xC0 + math.floor(e129 / 0x40), 0x80 + (e129 % 0x40)) end
                    if e129 < 0x10000 then return string.char(0xE0 + math.floor(e129 / 0x1000), 0x80 + (math.floor(e129 / 0x40) % 0x40), 0x80 + (e129 % 0x40)) end
                    if e129 < 0x110000 then return string.char(0xF0 + math.floor(e129 / 0x40000), 0x80 + (math.floor(e129 / 0x1000) % 0x40), 0x80 + (math.floor(e129 / 0x40) % 0x40), 0x80 + (e129 % 0x40)) end
                    return '?'
                end
                e305 = e306(e244)
            end
            e88 = e305 or e88
        end
    end
    if e88:sub(-1) == " " then return e88 end
    return e88 .. " "
end

function e54.get(e95,e307,e308)
    if not e95 then return "ERROR" end
    local e63= e303[e95]
    if e63 == nil then return "ERROR" end
    if type(e63) == "string" then return e304(e63) end
    if type(e63) == "table" then
        if e308 == nil then
            return e304(e63[1])
        end
        local e60= tonumber(e308) or 1
        return e304(e63[e60])
    end
    return "ERROR"
end

function e54.set(e95,e141)
	if not e95 then return false end
	if type(e141) == "string" then
		e303[e95] = { e141 }
	else
		e303[e95] = e141
	end
	return true
end

function e54.list()
	local e56= {}
	for e162, e63 in pairs(e303) do
		if type(e63) == "table" then
			local e309= {}
			for e60 = 1, #e63 do e309[e60] = e63[e60] end
			e56[e162] = e309
		else
			e56[e162] = e63
		end
	end
	return e56
end

setmetatable(e54, {
    __index = function(e62,e162)
        local e63= e303[e162]
        if e63 == nil then return "ERROR" end
        if type(e63) == "table" then return e304(e63[1]) end
        return e304(e63)
    end,
})

return e54]]
e661["require/help/enemies"] = [[local e54= {}

local entity= entity
local client= client
local globals= globals

function e54.list()
    return entity and entity.get_players and entity.get_players(true) or {}
end

function e54.is_alive(e67)
    return e67 and entity.is_alive and entity.is_alive(e67) or false
end

function e54.is_dormant(e67)
    return e67 and entity.is_dormant and entity.is_dormant(e67) or false
end

function e54.player_name(e67)
    return e67 and entity.get_player_name and entity.get_player_name(e67) or nil
end

function e54.steam64(e67)
    return e67 and entity.get_steam64 and entity.get_steam64(e67) or nil
end

function e54.health(e67)
    return e67 and entity.get_prop and entity.get_prop(e67, 'm_iHealth') or 0
end

function e54.current_threat()
    return client and client.current_threat and client.current_threat() or nil
end

local e306= {}

function e54.is_afk(e67,e149,e91)
    e149 = e149 or 5
    e91 = e91 or 20
    local e166, e167, e168= entity.get_prop(e67, 'm_vecVelocity')
    local e124= 0
    if e166 and e167 and e168 then
        e124 = math.sqrt(e166 * e166 + e167 * e167 + e168 * e168)
    end
    local e66= globals and globals.realtime and globals.realtime() or os.clock()
    if not e306[e67] then
        e306[e67] = { last_active = e66, last_check = e66 }
    end
    if e124 >= e149 then
        e306[e67].last_active = e66
    end
    e306[e67].last_check = e66
    return (e66 - e306[e67].last_active) > e91
end

function e54.distance(e67,e307)
    if not e67 or not entity.get_origin then return nil end
    local e224, e225, e226= entity.get_origin(e67)
    if not e224 then return nil end
    if not e307 then
        e307 = entity.get_local_player and entity.get_local_player()
    end
    local e227, e228, e229= entity.get_origin(e307)
    if not e227 then return nil end
    local e180, e181, e230= e224 - e227, e225 - e228, e226 - e229
    return math.sqrt(e180 * e180 + e181 * e181 + e230 * e230)
end


local function e308(e63)
    if not e63 then return "" end
    return tostring(e63):lower()
end

local function e309(e310)
    local e175= ""
    if e310 and entity.get_classname then e175 = entity.get_classname(e310) or "" end
    if e175 == "" and e310 and client.get_model_name then
        e175 = client.get_model_name(e310) or ""
    end
    return e308(e175)
end

function e54.has_knife(e67)
    if not e67 or not entity.get_player_weapon then return false end
    local e310= entity.get_player_weapon(e67)
    if not e310 then return false end
    local e88= e309(e310)
    return e88:find('knife') ~= nil
end

function e54.has_nade(e67)
    if not e67 or not entity.get_player_weapon then return false end
    local e310= entity.get_player_weapon(e67)
    if not e310 then return false end
    local e88= e309(e310)
    local e311= {'grenade', 'hegrenade', 'flashbang', 'smoke', 'molotov', 'incendiary', 'decoy', 'frag', 'nade'}
    for e60 = 1, #e311 do
        if e88:find(e311[e60]) then return true end
    end
    return false
end

function e54.has_taser(e67)
    if not e67 or not entity.get_player_weapon then return false end
    local e310= entity.get_player_weapon(e67)
    if not e310 then return false end
    local e88= e309(e310)
    return e88:find('taser') ~= nil or e88:find('zeus') ~= nil
end

return e54]]
e661["require/help/ffi"] = [[local e309= rawget(_G, 'ffi')
local e54= {}

function e54.available()
  return e309 ~= nil
end

function e54.cdef(e88)
  if not e309 then error('ffi not available') end
  return e309.cdef(e88)
end

function e54.typeof(e56)
  if not e309 then error('ffi not available') end
  return e309.typeof(e56)
end

function e54.new(e56,...)
  if not e309 then error('ffi not available') end
  return e309.new(e56, ...)
end

function e54.cast(e56,e63)
  if not e309 then error('ffi not available') end
  return e309.cast(e56, e63)
end

function e54.string(e310,e311)
  if not e309 then error('ffi not available') end
  return e309.string(e310, e311)
end

function e54.copy(e312,e68,e311)
  if not e309 then error('ffi not available') end
  return e309.copy(e312, e68, e311)
end

function e54.fill(e312,e141,e311)
  if not e309 then error('ffi not available') end
  return e309.fill(e312, e141, e311)
end

function e54.sizeof(e56)
  if not e309 then error('ffi not available') end
  return e309.sizeof(e56)
end

function e54.alignof(e56)
  if not e309 then error('ffi not available') end
  return e309.alignof(e56)
end

function e54.errno()
  if not e309 then error('ffi not available') end
  return e309.errno()
end

function e54.gc(e310,e668)
  if not e309 then error('ffi not available') end
  return e309.gc(e310, e668)
end

function e54.load(e313,e314)
  if not e309 then error('ffi not available') end
  return e309.load(e313, e314)
end

function e54.metatype(e56,e315)
  if not e309 then error('ffi not available') end
  return e309.metatype(e56, e315)
end

function e54.offsetof(e56,e316)
  if not e309 then error('ffi not available') end
  return e309.offsetof(e56, e316)
end

function e54.istype(e56,e63)
  if not e309 then error('ffi not available') end
  return e309.istype(e56, e63)
end

e54.raw = e309

return e54]]
e661["require/help/globals"] = [[local e54= {}

e54.raw = globals

function e54.absoluteframetime()
  return globals.absoluteframetime()
end

function e54.chokedcommands()
  return globals.chokedcommands()
end

function e54.commandack()
  return globals.commandack()
end

function e54.curtime()
  return globals.curtime()
end

function e54.framecount()
  return globals.framecount()
end

function e54.frametime()
  return globals.frametime()
end

function e54.lastoutgoingcommand()
  return globals.lastoutgoingcommand()
end

function e54.mapname()
  return globals.mapname()
end

function e54.maxplayers()
  return globals.maxplayers()
end

function e54.oldcommandack()
  return globals.oldcommandack()
end

function e54.realtime()
  return globals.realtime()
end

function e54.servertickcount()
  return globals.servertickcount()
end

function e54.tickcount()
  return globals.tickcount()
end

function e54.tickinterval()
  return globals.tickinterval()
end

return e54]]
e661["require/help/json"] = [[local e315= rawget(_G, 'json')
local e54= {}

function e54.available()
  return e315 ~= nil
end

function e54.decode_invalid_numbers(e316)
  if not e315 then error('json not available') end
  if e316 == nil then
    return e315.decode_invalid_numbers()
  end
  return e315.decode_invalid_numbers(e316)
end

function e54.decode_max_depth(e317)
  if not e315 then error('json not available') end
  if e317 == nil then
    return e315.decode_max_depth()
  end
  return e315.decode_max_depth(e317)
end

function e54.encode_invalid_numbers(e316)
  if not e315 then error('json not available') end
  if e316 == nil then
    return e315.encode_invalid_numbers()
  end
  return e315.encode_invalid_numbers(e316)
end

function e54.encode_max_depth(e317)
  if not e315 then error('json not available') end
  if e317 == nil then
    return e315.encode_max_depth()
  end
  return e315.encode_max_depth(e317)
end

function e54.encode_number_precision(e318)
  if not e315 then error('json not available') end
  if e318 == nil then
    return e315.encode_number_precision()
  end
  return e315.encode_number_precision(e318)
end

function e54.encode_sparse_array(...)
  if not e315 then error('json not available') end
  return e315.encode_sparse_array(...)
end

function e54.parse(e82)
  if not e315 then error('json not available') end
  if e315.parse then
    return e315.parse(e82)
  end
  if e315.decode then
    return e315.decode(e82)
  end
  error('json.parse / json.decode not available')
end

function e54.stringify(e305)
  if not e315 then error('json not available') end
  if e315.stringify then
    return e315.stringify(e305)
  end
  if e315.encode then
    return e315.encode(e305)
  end
  error('json.stringify / json.encode not available')
end

e54.raw = e315

return e54]]
e661["require/help/libs"] = [[local function e288(e59)
	local e53, e224= pcall(require, e59)
	return e53 and e224 or nil
end

local e318= {
	antiaim_funcs   = 'gamesense/antiaim_funcs',
	base64          = 'gamesense/base64',
	clipboard       = 'gamesense/clipboard',
	http            = 'gamesense/http',
	csgo_weapons    = 'gamesense/csgo_weapons',
	icons           = 'gamesense/icons',
	entity          = 'gamesense/entity',
	vector          = 'vector',
	bit             = 'bit',
	ffi             = 'ffi',
	pui             = 'gamesense/pui',
	trace           = 'gamesense/trace',
	md5             = 'gamesense/md5',
	websocket       = 'gamesense/websocket',
	surface         = 'gamesense/surface',
	color           = 'gamesense/color',
}

local e45= {}
for e162, e63 in pairs(e318) do
	e45[e162] = e288(e63)
end

local e164= {
	antiaim_funcs = {
		get_tickbase_shifting = "Returns true if tickbase shifting is active.",
		get_fake_lag = "Returns current fake lag value.",
		get_desync = "Returns current desync value.",
		get_manual_direction = "Returns manual anti-aim direction.",
		get_antiaim_condition = "Returns current anti-aim condition.",
		get_body_yaw = "Returns current body yaw value.",
		get_yaw_base = "Returns current yaw base value.",
		get_pitch = "Returns current pitch value.",
		get_yaw_jitter = "Returns current yaw jitter value.",
		get_enabled = "Returns if anti-aim is enabled.",
		get_fakelag_mode = "Returns fakelag mode.",
		get_fakelag_limit = "Returns fakelag limit.",
		get_fakelag_variance = "Returns fakelag variance.",
		get_fakelag_enabled = "Returns if fakelag is enabled.",
		get_double_tap = "Returns true if double tap exploit is active.",
		get_overlap = "Returns overlap value (exploit related).",
	},
	base64 = {
		encode = "Encodes a string to base64.",
		decode = "Decodes a base64 string.",
	},
	clipboard = {
		get = "Gets clipboard contents as string.",
		set = "Sets clipboard contents to string.",
	},
	http = {
		get = "Performs HTTP GET request.",
		post = "Performs HTTP POST request.",
		download = "Downloads a file from URL.",
	},
	csgo_weapons = {
		get_weapon_name = "Returns weapon name by id.",
		get_weapon_id = "Returns weapon id by name.",
		get_weapon_type = "Returns weapon type by id.",
		get_weapon_group = "Returns weapon group by id.",
		get_weapon_slot = "Returns weapon slot by id.",
		get_weapon_price = "Returns weapon price by id.",
	},
	icons = {
		hero = "Table of hero icons.",
		get_texture = "Returns texture id for icon name.",
		get_icon = "Returns icon object by name.",
		get_all_icons = "Returns all available icons.",
	},
	entity = {
		get_local_player = "Returns entindex of local player.",
		get_all = "Returns array of entindices for all entities.",
		get_players = "Returns array of player entindices.",
		get_game_rules = "Returns entindex of game rules proxy.",
		get_player_resource = "Returns entindex of player resource.",
		get_classname = "Returns classname of entity.",
		set_prop = "Sets netvar property.",
		get_prop = "Gets netvar property.",
		is_enemy = "Returns true if entity is enemy.",
		is_alive = "Returns true if entity is alive.",
		is_dormant = "Returns true if entity is dormant.",
		get_player_name = "Returns player name.",
		get_player_weapon = "Returns active weapon entindex.",
		hitbox_position = "Returns world position of hitbox.",
		get_steam64 = "Returns SteamID3.",
		get_bounding_box = "Returns bounding box coordinates.",
		get_origin = "Returns world origin of entity.",
		get_esp_data = "Returns ESP data for player.",
	},
	vector = {
		new = "Creates a new vector object.",
		dot = "Returns dot product of two vectors.",
		cross = "Returns cross product of two vectors.",
		length = "Returns length of vector.",
		normalize = "Normalizes vector.",
		add = "Adds two vectors.",
		sub = "Subtracts two vectors.",
		mul = "Multiplies vector by scalar.",
		div = "Divides vector by scalar.",
		dist = "Returns distance between two vectors.",
	},
	bit = {
		arshift = "Arithmetic right shift.",
		band = "Bitwise AND.",
		bnot = "Bitwise NOT.",
		bor = "Bitwise OR.",
		bswap = "Byte swap (endian conversion).",
		bxor = "Bitwise XOR.",
		lshift = "Logical left shift.",
		rol = "Bitwise left rotation.",
		ror = "Bitwise right rotation.",
		rshift = "Logical right shift.",
		tobit = "Normalize to 32-bit signed.",
		tohex = "Convert to hexadecimal string.",
	},
	ffi = {
		cdef = "Define C types/functions.",
		cast = "Cast value to C type.",
		new = "Allocate new C object.",
		typeof = "Get C type object.",
		string = "Convert C data to Lua string.",
	},
	pui = {
		create_panel = "Creates a custom UI panel.",
		add_icon = "Adds an icon to a panel.",
		set_icon = "Sets the icon for a panel.",
		set_panel_visible = "Shows/hides a panel.",
		set_panel_position = "Sets panel position.",
		set_panel_size = "Sets panel size.",
	},
	trace = {
		trace_line = "Performs a line trace.",
		trace_bullet = "Performs a bullet trace.",
		trace_hull = "Performs a hull trace.",
	},
	md5 = {
		sumhexa = "Returns MD5 hash as hex string.",
		sum = "Returns MD5 hash as raw bytes.",
	},
	websocket = {
		connect = "Connects to a WebSocket server.",
		send = "Sends data over WebSocket.",
		close = "Closes the WebSocket connection.",
		on_message = "Callback for incoming messages.",
	},
	surface = {
		text = "Draws text on screen.",
		rectangle = "Draws a rectangle.",
		line = "Draws a line.",
		circle = "Draws a circle.",
		gradient = "Draws a gradient rectangle.",
		load_texture = "Loads a texture from file.",
	},
	color = {
		blend = "Blends two colors.",
		lighten = "Lightens a color.",
		darken = "Darkens a color.",
		hex_to_rgba = "Converts hex to RGBA.",
		rgba_to_hex = "Converts RGBA to hex.",
	},
}

local function e319(e59)
	return e45[e59]
end

function e75()
	local e82= {}
	for e162, e63 in pairs(_G) do
		if type(e63) == "table" or type(e63) == "userdata" then
			e82[#e82+1] = e162
		end
	end
	return e82
end

function e320(e313)
	local e321= e164[e313]
	if not e321 then return {} end
	local e82= {}
	for e162, e63 in pairs(e321) do
		e82[#e82+1] = e162 .. " - " .. e63
	end
	return e82
end

return {
	get = e319,
	list = e75,
	list_features = e320,
	features = e164,
	libs = e45,
	lib_defs = e318
}
]]
e661["require/help/math"] = [[local e54= {}

function e54.clamp(e54,e321,e129)
    if not e321 and not e129 then return e54 end
    e321 = tonumber(e321) or 0
    e129 = tonumber(e129) or e321
    if e321 > e129 then e321, e129 = e129, e321 end
    e54 = tonumber(e54) or e321
    if e54 < e321 then return e321 end
    if e54 > e129 then return e129 end
    return e54
end

function e54.clamp01(e54)
    return e54.clamp(e54, 0, 1)
end

function e54.abs(e54)
    e54 = tonumber(e54) or 0
    return math.abs(e54)
end

function e54.max(...)
    local e298= {...}
    if #e298 == 0 then return 0 end
    local e219= nil
    for e60 = 1, #e298 do
        local e63= tonumber(e298[e60]) or 0
        if e219 == nil or e63 > e219 then e219 = e63 end
    end
    return e219
end

function e54.min(...)
    local e298= {...}
    if #e298 == 0 then return 0 end
    local e219= nil
    for e60 = 1, #e298 do
        local e63= tonumber(e298[e60]) or 0
        if e219 == nil or e63 < e219 then e219 = e63 end
    end
    return e219
end

function e54.atan2(e87,e59)
    e87 = tonumber(e87) or 0
    e59 = tonumber(e59) or 0
    return math.atan(e87, e59)
end

function e54.floor(e54)
    e54 = tonumber(e54) or 0
    return math.floor(e54)
end

function e54.round(e54,e322)
    e54 = tonumber(e54) or 0
    e322 = tonumber(e322) or 0
    local e323= 10 ^ e322
    return math.floor(e54 * e323 + 0.5) / e323
end

function e54.lerp(e70,e74,e56)
    e70 = tonumber(e70) or 0
    e74 = tonumber(e74) or 0
    e56 = tonumber(e56) or 0
    return e70 + (e74 - e70) * e56
end

function e54.distance2d(e113,e114,e115,e116)
    e113 = tonumber(e113) or 0
    e114 = tonumber(e114) or 0
    e115 = tonumber(e115) or 0
    e116 = tonumber(e116) or 0
    return math.sqrt((e115 - e113)^2 + (e116 - e114)^2)
end

function e54.distance3d(e113,e114,e117,e115,e116,e118)
    e113 = tonumber(e113) or 0
    e114 = tonumber(e114) or 0
    e117 = tonumber(e117) or 0
    e115 = tonumber(e115) or 0
    e116 = tonumber(e116) or 0
    e118 = tonumber(e118) or 0
    return math.sqrt((e115 - e113)^2 + (e116 - e114)^2 + (e118 - e117)^2)
end

function e54.sign(e54)
    e54 = tonumber(e54) or 0
    return (e54 > 0 and 1) or (e54 < 0 and -1) or 0
end

function e54.frac(e54)
    e54 = tonumber(e54) or 0
    return e54 - math.floor(e54)
end

function e54.is_even(e54)
    e54 = tonumber(e54) or 0
    return e54 % 2 == 0
end

function e54.is_odd(e54)
    e54 = tonumber(e54) or 0
    return e54 % 2 ~= 0
end

function e54.sqr(e54)
    e54 = tonumber(e54) or 0
    return e54 * e54
end

function e54.cube(e54)
    e54 = tonumber(e54) or 0
    return e54 * e54 * e54
end

function e54.approximately(e70,e74,e324)
    e70 = tonumber(e70) or 0
    e74 = tonumber(e74) or 0
    e324 = tonumber(e324) or 1e138-6
    return math.abs(e70 - e74) < e324
end

function e54.rad_to_deg(e100)
    e100 = tonumber(e100) or 0
    return e100 * (180 / math.pi)
end

function e54.deg_to_rad(e119)
    e119 = tonumber(e119) or 0
    return e119 * (math.pi / 180)
end

function e54.wrap_degrees(e120)
    local e70= tonumber(e120) or 0
    e70 = e70 % 360
    if e70 < 0 then e70 = e70 + 360 end
    return e70
end

function e54.normalize_angle(e120)
    local e70= tonumber(e120) or 0
    e70 = e70 % 360
    if e70 > 180 then e70 = e70 - 360 end
    return e70
end

function e54.angle_diff(e70,e74)
    e70 = tonumber(e70) or 0
    e74 = tonumber(e74) or 0
    local e325= (e70 - e74) % 360
    if e325 > 180 then e325 = e325 - 360 end
    return e325
end

function e54.lerp_angle(e70,e74,e56)
    e70 = tonumber(e70) or 0
    e74 = tonumber(e74) or 0
    e56 = tonumber(e56) or 0
    local e325= e54.angle_diff(e74, e70)
    return (e70 + e325 * e56) % 360
end

function e54.map(e54,e121,e122,e123,e124)
    e54 = tonumber(e54) or 0
    e121 = tonumber(e121) or 0
    e122 = tonumber(e122) or e121
    e123 = tonumber(e123) or 0
    e124 = tonumber(e124) or e123
    if e122 == e121 then return e123 end
    return (e54 - e121) * (e124 - e123) / (e122 - e121) + e123
end

function e54.smoothstep(e125,e126,e59)
    e125 = tonumber(e125) or 0
    e126 = tonumber(e126) or e125
    e59 = tonumber(e59) or 0
    if e126 == e125 then return 0 end
    local e56= e54.clamp((e59 - e125) / (e126 - e125), 0, 1)
    return e56 * e56 * (3 - 2 * e56)
end

function e54.random_float(e321,e129)
    e321 = tonumber(e321) or 0
    e129 = tonumber(e129) or e321
    if e321 > e129 then e321, e129 = e129, e321 end
    return e321 + math.random() * (e129 - e321)
end

function e54.random_int(e321,e129)
    e321 = tonumber(e321) or 0
    e129 = tonumber(e129) or e321
    if e321 > e129 then e321, e129 = e129, e321 end
    return math.random(e321, e129)
end

function e54.mean(e144)
    if type(e144) ~= 'table' or #e144 == 0 then return 0 end
    local e151= 0
    for e60 = 1, #e144 do e151 = e151 + (tonumber(e144[e60]) or 0) end
    return e151 / #e144
end

function e54.swap(e70,e74)
    return e74, e70
end

return e54]]
e661["require/help/panorama"] = [[local e54= {}

e54.raw = panorama

function e54.loadstring(e324,e325)
  return panorama.loadstring(e324, e325)
end

function e54.open(e325)
  return panorama.open(e325)
end

return e54]]
e661["require/help/plist"] = [[local e54= {}

e54.raw = plist

function e54.get(e236,e316)
  return plist.get(e236, e316)
end

function e54.set(e236,e316,e141)
  return plist.set(e236, e316, e141)
end

return e54]]
e661["require/help/reference"] = [[local e54= {}

e54.known_items = {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

function e54.add_known(e330)
    for e62, e191 in ipairs(e330 or {}) do
        table.insert(e54.known_items, e191)
    end
end

function e54.get(e66,e331,e59)
    return ui.reference(e66, e331, e59)
end

function e54.build(e75)
    local e332= {}
    local e333= {}
    for e60, e52 in ipairs(e75) do
        local e82= {ui.reference(e52[1], e52[2], e52[3])}
        e332[e60] = e82
        for e62, e75 in ipairs(e82) do
            if e75 ~= nil then
                e333[e75] = true
            end
        end
    end
    return e332, e333
end

function e54.build_known()
    return e54.build(e54.known_items)
end

function e54.get_all_known()
    return e54.known_items
end

return e54]]
e661["require/help/references_old"] = [[

local e54= {}

local function e333(e82)
    
    if type(e82) ~= 'table' then
        local e155= e82
        return {
            raw = e155,
            get = function()
                local e53, e63= pcall(ui.get, e155)
                if e53 then return e63 end
                return nil
            end
        }
    end

    
    
    
    local e334= e82
    return {
        raw = e334,
        get = function()
            if e334[2] ~= nil then
                local e53, e63= pcall(ui.get, e334[2])
                if e53 then return e63 end
            end
            if e334[1] ~= nil then
                local e53, e63= pcall(ui.get, e334[1])
                if e53 then return e63 end
            end
            return nil
        end
    }
end


e54.minimum_damage = e333(ui.reference("RAGE", "Aimbot", "Minimum damage"))
e54.minimum_damage_override = e333({ ui.reference("RAGE", "Aimbot", "Minimum damage override") })
e54.doubletap = e333({ ui.reference("RAGE", "Aimbot", "Double tap") })
e54.force_body_aim = e333({ ui.reference("RAGE", "Aimbot", "Force body aim") })
e54.force_safe_point = e333({ ui.reference("RAGE", "Aimbot", "Force safe point") })
e54.duck_peek_assist = e333({ ui.reference("RAGE", "Other", "Duck peek assist") })
e54.quick_peek_assist = e333({ ui.reference("RAGE", "Aimbot", "Quick peek assist") })


e54.pitch = e333(ui.reference("AA", "Anti-aimbot angles", "Pitch"))
e54.yaw_base = e333(ui.reference("AA", "Anti-aimbot angles", "Yaw base"))
e54.yaw = e333(ui.reference("AA", "Anti-aimbot angles", "Yaw"))
e54.yaw_jitter = e333(ui.reference("AA", "Anti-aimbot angles", "Yaw jitter"))
e54.body_yaw = e333(ui.reference("AA", "Anti-aimbot angles", "Body yaw"))
e54.roll = e333(ui.reference("AA", "Anti-aimbot angles", "Roll"))

return e54]]
e661["require/help/renderer"] = [[local e54= {}

e54.raw = renderer

function e54.blur(e59,e87,e88,e89,e121,e190)
  return renderer.blur(e59, e87, e88, e89, e121, e190)
end

function e54.circle(e59,e87,e72,e73,e74,e70,e85,e336,e337)
  return renderer.circle(e59, e87, e72, e73, e74, e70, e85, e336, e337)
end

function e54.circle_outline(e59,e87,e72,e73,e74,e70,e85,e336,e337,e338)
  return renderer.circle_outline(e59, e87, e72, e73, e74, e70, e85, e336, e337, e338)
end

function e54.gradient(e59,e87,e88,e89,e304,e305,e300,e205,e306,e307,e301,e206,e339)
  return renderer.gradient(e59, e87, e88, e89, e304, e305, e300, e205, e306, e307, e301, e206, e339)
end

function e54.indicator(e72,e73,e74,e70,...)
  return renderer.indicator(e72, e73, e74, e70, ...)
end

function e54.line(e113,e114,e115,e116,e72,e73,e74,e70)
  return renderer.line(e113, e114, e115, e116, e72, e73, e74, e70)
end

function e54.load_jpg(e340,e341,e342)
  return renderer.load_jpg(e340, e341, e342)
end

function e54.load_png(e340,e341,e342)
  return renderer.load_png(e340, e341, e342)
end

function e54.load_rgba(e340,e341,e342)
  return renderer.load_rgba(e340, e341, e342)
end

function e54.load_svg(e340,e341,e342)
  return renderer.load_svg(e340, e341, e342)
end

function e54.measure_text(e319,...)
  return renderer.measure_text(e319, ...)
end

function e54.rectangle(e59,e87,e88,e89,e72,e73,e74,e70)
  return renderer.rectangle(e59, e87, e88, e89, e72, e73, e74, e70)
end

function e54.text(e59,e87,e72,e73,e74,e70,e319,e343,...)
  return renderer.text(e59, e87, e72, e73, e74, e70, e319, e343, ...)
end

function e54.texture(e344,e59,e87,e88,e89,e72,e73,e74,e70,e62)
  return renderer.texture(e344, e59, e87, e88, e89, e72, e73, e74, e70, e62)
end

function e54.triangle(e113,e114,e115,e116,e345,e346,e72,e73,e74,e70)
  return renderer.triangle(e113, e114, e115, e116, e345, e346, e72, e73, e74, e70)
end

function e54.world_to_screen(e59,e87,e116)
  return renderer.world_to_screen(e59, e87, e116)
end

function e54.rectangle_outline(e59,e87,e88,e89,e72,e73,e74,e70,e338)
  e338 = e338 or 1
  for e60 = 0, e338 - 1 do
    renderer.line(e59 + e60, e87 + e60, e59 + e88 - e60, e87 + e60, e72, e73, e74, e70)
    renderer.line(e59 + e60, e87 + e89 - e60, e59 + e88 - e60, e87 + e89 - e60, e72, e73, e74, e70)
    renderer.line(e59 + e60, e87 + e60, e59 + e60, e87 + e89 - e60, e72, e73, e74, e70)
    renderer.line(e59 + e88 - e60, e87 + e60, e59 + e88 - e60, e87 + e89 - e60, e72, e73, e74, e70)
  end
end

function e54.text_centered(e59,e87,e72,e73,e74,e70,e319,e343,...)
  local e88, e89= renderer.measure_text(e319, ...)
  if not e88 or not e89 then return end
  return renderer.text(e59 - e88 / 2, e87 - e89 / 2, e72, e73, e74, e70, e319, e343, ...)
end

function e54.texture_from_file(e665)
  local e340= readfile(e665)
  if not e340 then return nil end
  local e344= renderer.load_png(e340)
  if not e344 then
    e344 = renderer.load_jpg(e340)
  end
  return e344
end

return e54]]
e661["require/help/safe"] = [[local e54= {}

function e54.safe_call(e339,...)
	local e53, e670= pcall(e339, ...)
	return e53 and e670 or nil
end

function e54.safe_set(e52,e141)
	local e53= pcall(function() ui.set(e52, e141) end)
	return e53
end

function e54.safe_get(e52)
	local e53, e670= pcall(function() return ui.get(e52) end)
	return e53 and e670 or nil
end

return e54]]
e661["require/help/self"] = [[local e54= {}

local entity= entity
local globals= globals
local client= client

function e54.index()
	return entity and entity.get_local_player and entity.get_local_player() or nil
end

function e54.exists()
	return e54.index() ~= nil
end

function e54.is_alive()
	local e67= e54.index()
	return e67 and entity.is_alive and entity.is_alive(e67) or false
end

function e54.health()
	local e67= e54.index()
	return e67 and entity.get_prop and entity.get_prop(e67, 'm_iHealth') or 0
end

function e54.ping()
	return client and client.latency and client.latency() or 0
end

function e54.velocity()
	local e67= e54.index()
	if not e67 or not entity.get_prop then return 0 end
	local e166, e167, e168= entity.get_prop(e67, 'm_vecVelocity')
	if e166 and e167 and e168 then
		return math.sqrt(e166 * e166 + e167 * e167 + e168 * e168)
	end
	return 0
end

function e54.velocity2d()
	local e67= e54.index()
	if not e67 or not entity.get_prop then return 0 end
	local e166, e167= entity.get_prop(e67, 'm_vecVelocity')
	if e166 and e167 then
		return math.sqrt(e166 * e166 + e167 * e167)
	end
	return 0
end

function e54.weapon()
	local e67= e54.index()
	return e67 and entity.get_player_weapon and entity.get_player_weapon(e67) or nil
end

function e54.tickbase_shifted()
	
	return false
end

function e54.simtime()
	local e67= e54.index()
	return e67 and entity.get_prop and entity.get_prop(e67, 'm_flSimulationTime') or 0
end

function e54.eye_angles()
	return client and client.camera_angles and client.camera_angles() or nil
end

function e54.fps()
	local e283= globals and globals.absoluteframetime and globals.absoluteframetime() or globals.frametime and globals.frametime() or 0.01
	if e283 > 0 then
		return math.floor(1 / e283 + 0.5)
	end
	return 0
end

function e54.map()
	return globals and globals.mapname and globals.mapname() or nil
end

function e54.is_dormant()
	local e67= e54.index()
	return e67 and entity.is_dormant and entity.is_dormant(e67) or false
end

function e54.team_number()
	local e67= e54.index()
	return e67 and entity.get_prop and entity.get_prop(e67, 'm_iTeamNum') or 0
end

function e54.player_name()
	local e67= e54.index()
	return e67 and entity.get_player_name and entity.get_player_name(e67) or nil
end

function e54.steam64()
	local e67= e54.index()
	return e67 and entity.get_steam64 and entity.get_steam64(e67) or nil
end

function e54.ammo_count()
	local e147= e54.weapon()
	return e147 and entity.get_prop and entity.get_prop(e147, 'm_iClip1') or 0
end

function e54.has_armor()
	local e67= e54.index()
	return e67 and entity.get_prop and entity.get_prop(e67, 'm_ArmorValue') > 0 or false
end

function e54.has_helmet()
	local e67= e54.index()
	return e67 and entity.get_prop and entity.get_prop(e67, 'm_bHasHelmet') == 1 or false
end

function e54.current_tick()
	return globals and globals.tickcount and globals.tickcount() or 0
end

function e54.tick_interval()
	return globals and globals.tickinterval and globals.tickinterval() or 0
end

function e54.current_frame()
	return globals and globals.framecount and globals.framecount() or 0
end

function e54.current_time()
	return globals and globals.curtime and globals.curtime() or 0
end

function e54.real_latency()
	return client and client.real_latency and client.real_latency() or 0
end

function e54.system_time()
	return client and client.system_time and client.system_time() or {0,0,0,0}
end

function e54.unix_time()
	return client and client.unix_time and client.unix_time() or 0
end

function e54.kills()
	local e67= e54.index()
	if not e67 or not entity.get_prop then return 0 end
	local e342= entity.get_player_resource and entity.get_player_resource()
	if e342 then
		return entity.get_prop(e342, 'm_iKills', e67) or 0
	end
	return 0
end

function e54.deaths()
	local e67= e54.index()
	if not e67 or not entity.get_prop then return 0 end
	local e342= entity.get_player_resource and entity.get_player_resource()
	if e342 then
		return entity.get_prop(e342, 'm_iDeaths', e67) or 0
	end
	return 0
end

function e54.assists()
	local e67= e54.index()
	if not e67 or not entity.get_prop then return 0 end
	local e342= entity.get_player_resource and entity.get_player_resource()
	if e342 then
		return entity.get_prop(e342, 'm_iAssists', e67) or 0
	end
	return 0
end

return e54
]]
e661["require/help/string"] = [[local e136= {}

function e136.lower(e68)
	return string.lower(e68)
end

function e136.upper(e68)
	return string.upper(e68)
end

function e136.capitalize(e68)
	return (e68:gsub("^%l", string.upper):gsub("^(%u)(.*)", function(e61,e72) return e61 .. string.lower(e72) end))
end

function e136.title(e68)
	return (e68:gsub("%S+", function(e345)
		return e345:sub(1,1):upper() .. e345:sub(2):lower()
	end))
end

function e136.random_case(e68)
	local e82= {}
	for e60 = 1, #e68 do
		local e71= e68:sub(e60,e60)
		if math.random() < 0.5 then
			e82[e60] = string.lower(e71)
		else
			e82[e60] = string.upper(e71)
		end
	end
	return table.concat(e82)
end

function e136.startswith(e68,e142)
	return e68:sub(1, #e142) == e142
end

function e136.endswith(e68,e278)
	return e278 == '' or e68:sub(-#e278) == e278
end

function e136.byte(e68,e60,e239)
	return string.byte(tostring(e68 or ""), e60, e239)
end

function e136.char(...)
	return string.char(...)
end

function e136.find(e68,e299,e346,e347)
	return string.find(tostring(e68 or ""), e299, e346, e347)
end

function e136.format(e348,...)
	return string.format(e348, ...)
end

function e136.gmatch(e68,e299)
	return string.gmatch(tostring(e68 or ""), e299)
end

function e136.gsub(e68,e299,e349,e129)
	return string.gsub(tostring(e68 or ""), e299, e349, e129)
end

function e136.split(e68,e350)
	local e670= {}
	if e350 == '' then
		for e60 = 1, #e68 do e670[e60] = e68:sub(e60,e60) end
		return e670
	end
	local e299= string.format("([^%s]+)", e350)
	for e90 in e68:gmatch(e299) do
		e670[#e670+1] = e90
	end
	return e670
end

function e136.join(e144,e350)
	return table.concat(e144, e350)
end

function e136.replace(e68,e299,e349)
	return e68:gsub(e299, e349)
end

function e136.reverse(e68)
	return string.reverse(e68)
end

function e136.repeat_str(e68,e129)
	return string.rep(e68, e129)
end

function e136.rep(e68,e129)
	return string.rep(tostring(e68 or ""), e129)
end

function e136.contains(e68,e351)
	return e68:find(e351, 1, true) ~= nil
end

function e136.count(e68,e351)
	if e351 == '' then return 0 end
	local e257= 0
	local e80= 1
	while true do
		local e176= e68:find(e351, e80, true)
		if not e176 then break end
		e257 = e257 + 1
		e80 = e176 + #e351
	end
	return e257
end

function e136.is_empty(e68)
	return e68 == nil or e68 == ''
end

function e136.is_digit(e68)
	return e68:match("^%d+$") ~= nil
end

function e136.is_alpha(e68)
	return e68:match("^%a+$") ~= nil
end

function e136.random_string(e271)
	local e71= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local e82= {}
	for e60 = 1, e271 do
		local e67= math.random(1, #e71)
		e82[e60] = e71:sub(e67, e67)
	end
	return table.concat(e82)
end

function e136.safe_substr(e68,e60,e239)
	local e88= tostring(e68 or "")
	local e129= #e88
	local e176= tonumber(e60) or 1
	if e176 < 0 then e176 = e129 + 1 + e176 end
	if e176 < 1 then e176 = 1 end
	if e239 == nil then
		return e88:sub(e176)
	end
	local e352= tonumber(e239)
	if not e352 then
		return e88:sub(e176)
	end
	if e352 >= 0 then
		return e88:sub(e176, math.min(e129, e176 + e352 - 1))
	else
		local e353= e129 + e352
		if e353 < e176 then return "" end
		return e88:sub(e176, e353)
	end
end

function e136.sub(e68,e88,e138)
	return string.sub(tostring(e68 or ""), e88, e138)
end

function e136.len(e68)
	return string.len(tostring(e68 or ""))
end

function e136.match(e68,e299,e346)
	return string.match(tostring(e68 or ""), e299, e346)
end

function e136.trim(e68)
	return (tostring(e68 or ""):gsub("^%s*(.-)%s*$", "%1"))
end

function e136.ltrim(e68)
	return (tostring(e68 or ""):gsub("^%s*(.-)$", "%1"))
end

function e136.rtrim(e68)
	return (tostring(e68 or ""):gsub("^(.-)%s*$", "%1"))
end

function e136.escape_pattern(e68)
	return tostring(e68 or ""):gsub("([%%%$%(%)%.%[%]%*%+%-%?%^])", "%%%1")
end

function e136.ensure_prefix(e68,e142)
	local e88= tostring(e68 or "")
	local e166= tostring(e142 or "")
	if e166 == "" then return e88 end
	if e88:sub(1, #e166) == e166 then return e88 end
	return e166 .. e88
end

function e136.ensure_suffix(e68,e278)
	local e88= tostring(e68 or "")
	local e354= tostring(e278 or "")
	if e354 == "" then return e88 end
	if e88:sub(-#e354) == e354 then return e88 end
	return e88 .. e354
end

function e136.truncate(e68,e355,e356)
	local e88= tostring(e68 or "")
	local e219= tonumber(e355) or 0
	if e219 <= 0 or #e88 <= e219 then return e88 end
	local e138= tostring(e356 or "...")
	local e357= e219 - #e138
	if e357 <= 0 then return e138:sub(1, e219) end
	return e88:sub(1, e357) .. e138
end

local e358= {
	a = '4', A = '4', e = '3', E = '3', i = '1', I = '1', o = '0', O = '0',
	s = '5', S = '5', t = '7', T = '7', b = '8', B = '8', g = '6', G = '6',
	z = '2', Z = '2', l = '1', L = '1'
}

function e136.leet(e68,e359)
	local e88= tostring(e68 or "")
	local e166= tonumber(e359) or 1
	if e166 <= 0 then return e88 end
	local e82= {}
	for e60 = 1, #e88 do
		local e71= e88:sub(e60,e60)
		local e72= e358[e71]
		if e72 and math.random() <= e166 then e82[#e82+1] = e72 else e82[#e82+1] = e71 end
	end
	return table.concat(e82)
end

function e136.pipeline(e68,...)
	local e88= tostring(e68 or "")
	for e60 = 1, select('#', ...) do
		local e668= select(e60, ...)
		if type(e668) == 'function' then
			e88 = e668(e88)
		elseif type(e668) == 'string' and e136[e668] then
			e88 = e136[e668](e88)
		end
	end
	return e88
end

return e136]]
e661["require/help/time"] = [[local e135= {}

local client= client
local globals= globals

local function e66()
	if globals and globals.realtime then
		return globals.realtime()
	end
	if client and client.timestamp then
		local e348= client.timestamp()
		if e348 then return e348 / 1000 end
	end
	return 0
end

function e135.simtime()
	if globals and globals.curtime then return globals.curtime() end
	return e66()
end

function e135.realtime()
	return e66()
end

function e135.tickcount()
	if globals and globals.tickcount then return globals.tickcount() end
	local e241= e135.tickinterval()
	if e241 and e241 > 0 then return math.floor(e66() / e241) end
	return 0
end

function e135.tickinterval()
	if globals and globals.tickinterval then return globals.tickinterval() end
	return 0.015625
end

function e135.seconds_to_ticks(e198)
	local e349= e135.tickinterval()
	if e349 and e349 > 0 then return math.floor(e198 / e349 + 0.5) end
	return math.floor(e198 * 64 + 0.5)
end

function e135.ticks_to_seconds(e152)
	local e349= e135.tickinterval()
	if e349 then return e152 * e349 end
	return e152 * 0.015625
end

function e135.frametime()
	if globals and globals.frametime then return globals.frametime() end
	return 0
end

function e135.absoluteframetime()
	if globals and globals.absoluteframetime then return globals.absoluteframetime() end
	return 0
end

function e135.framecount()
	if globals and globals.framecount then return globals.framecount() end
	return 0
end

function e135.framecount_to_seconds(e350)
	local e291= e135.frametime()
	return e350 * (e291 or 0)
end

function e135.seconds_to_framecount(e198)
	local e291= e135.frametime()
	if e291 and e291 > 0 then return math.floor(e198 / e291 + 0.5) end
	return math.floor(e198 * 60 + 0.5)
end

function e135.new(e91)
	return { start = e66(), duration = e91 or 0 }
end

function e135.expired(e351)
	return e66() - (e351.start or 0) >= (e351.duration or 0)
end

function e135.reset(e351,e91)
	e351.start = e66()
	if e91 then e351.duration = e91 end
end

function e135.elapsed(e351)
	return e66() - (e351.start or 0)
end

function e135.interval(e349,e296)
	local e172= e66()
	return function(...)
		local e56= e66()
		if e56 - e172 >= e349 then
			e172 = e56
			e296(...)
		end
	end
end

function e135.timeout(e84,e296)
	local e352= false
	local e176= e66()
	return function(...)
		if not e352 and e66() - e176 >= e84 then
			e352 = true
			e296(...)
		end
	end
end

function e135.debounce(e349,e296)
	local e172= 0
	return function(...)
		local e56= e66()
		if e56 - e172 >= e349 then
			e172 = e56
			e296(...)
		end
	end
end

function e135.throttle(e349,e296)
	local e172= 0
	return function(...)
		local e56= e66()
		if e56 - e172 >= e349 then
			e172 = e56
			e296(...)
		end
	end
end

function e135.wait(e84)
	local e176= e66()
	return function()
		return e66() - e176 >= e84
	end
end

function e135.stopwatch()
	local e92= { running = false, start = 0, elapsed = 0 }
	function e92:start()
		if not self.running then
			self.running = true
			self.start = e66()
		end
	end
	function e92:stop()
		if self.running then
			self.running = false
			self.elapsed = self.elapsed + (e66() - (self.start or 0))
		end
	end
	function e92:reset()
		self.running = false
		self.start = 0
		self.elapsed = 0
	end
	function e92:get()
		if self.running then
			return self.elapsed + (e66() - (self.start or 0))
		else
			return self.elapsed
		end
	end
	return e92
end

e135.Scheduler = {}
e135.Scheduler.__index = e135.Scheduler

function e135.Scheduler.new()
    return setmetatable({ tasks = {} }, e135.Scheduler)
end

function e135.Scheduler:add(e349,e296)
	self.tasks[#self.tasks+1] = { interval = e349, callback = e296, last = e66() }
end

function e135.Scheduler:remove(e296)
    for e60 = #self.tasks, 1, -1 do
        if self.tasks[e60].callback == e296 then
            table.remove(self.tasks, e60)
        end
    end
end

function e135.Scheduler:run(...)
	local e56= e66()
	for e62, e353 in ipairs(self.tasks) do
		if e56 - e353.last >= e353.interval then
			e353.last = e56
			e353.callback(...)
		end
	end
end

function e135.safe_timeout(e84,e296)
	local e176= e66()
	local e352= false
	return function(...)
		if not e352 and e66() - e176 >= e84 then
			e352 = true
			e296(...)
		end
	end
end

function e135.lerp(e70,e74,e56)
	return e70 + (e74 - e70) * e56
end

function e135.ease_in_out(e56)
	if e56 < 0 then e56 = 0 end
	if e56 > 1 then e56 = 1 end
	return e56 < 0.5 and 2 * e56 * e56 or -1 + (4 - 2 * e56) * e56
end

function e135.ping_pong(e56,e354)
	if e354 <= 0 then return 0 end
	local e219= e56 % (e354 * 2)
	if e219 < e354 then return e219 / e354 end
	return 1 - ((e219 - e354) / e354)
end

function e135.apply_animation(e91,e355,e356)
	local e176= e66()
	return function()
		local e56= (e66() - e176) / (e91 or 1)
		if e56 >= 1 then
			e355(1)
			if e356 then e356() end
			return true
		else
			e355(e56)
			return false
		end
	end
end

function e135.within_ticks_window(e357,e358)
	local e359= e135.tickcount()
	if not e359 or not e357 then return false end
	return e359 - e357 <= (e358 or 0)
end

return e135]]
e661["require/help/trace"] = [[]]
e661["require/help/ui"] = [[local e54= {}

e54.raw = ui

local function e354()
    if type(ui) ~= 'table' then
        error('ui library is not available in this environment')
    end
end

function e54.available()
    return type(ui) == 'table'
end

function e54.get(e52)
    e354()
    return ui.get(e52)
end

function e54.is_menu_open()
    e354()
    return ui.is_menu_open()
end

function e54.menu_position()
    e354()
    return ui.menu_position()
end

function e54.menu_size()
    e354()
    return ui.menu_size()
end

function e54.mouse_position()
    e354()
    return ui.mouse_position()
end

function e54.name(e52)
    e354()
    return ui.name(e52)
end


function e54.new_button(e66,e331,e59,e296)
    e354()
    return ui.new_button(e66, e331, e59, e296)
end

function e54.new_checkbox(e66,e331,e59)
    e354()
    return ui.new_checkbox(e66, e331, e59)
end

function e54.new_color_picker(e66,e331,e59,e72,e73,e74,e70)
    e354()
    return ui.new_color_picker(e66, e331, e59, e72 or 0, e73 or 0, e74 or 0, e70 or 255)
end

function e54.new_combobox(e66,e331,e59,...)
    e354()
    return ui.new_combobox(e66, e331, e59, ...)
end

function e54.new_hotkey(e66,e331,e59,e355,e356)
    e354()
    return ui.new_hotkey(e66, e331, e59, e355 and true or false, e356)
end

function e54.new_label(e66,e331,e59)
    e354()
    return ui.new_label(e66, e331, e59)
end

function e54.new_listbox(e66,e331,e59,e330)
    e354()
    return ui.new_listbox(e66, e331, e59, e330)
end

function e54.new_multiselect(e66,e331,e59,...)
    e354()
    return ui.new_multiselect(e66, e331, e59, ...)
end

function e54.new_slider(e66,e331,e59,e321,e129,e357,e358,e359,e269,e360)
    e354()
    return ui.new_slider(e66, e331, e59, e321, e129, e357, e358, e359, e269, e360)
end

function e54.new_string(e59,e361)
    e354()
    return ui.new_string(e59, e361)
end

function e54.new_textbox(e66,e331,e59)
    e354()
    return ui.new_textbox(e66, e331, e59)
end

function e54.reference(e66,e331,e59)
    e354()
    return ui.reference(e66, e331, e59)
end


function e54.set(e52,...)
    e354()
    return ui.set(e52, ...)
end

function e54.set_callback(e52,e296)
    e354()
    return ui.set_callback(e52, e296)
end

function e54.set_enabled(e52,e80)
    e354()
    return ui.set_enabled(e52, e80)
end

function e54.set_visible(e52,e362)
    e354()
    return ui.set_visible(e52, e362)
end

function e54.type(e52)
    e354()
    return ui.type(e52)
end

function e54.update(e52,...)
    e354()
    if ui.update then
        return ui.update(e52, ...)
    end
    error('ui.update is not supported in this environment')
end

function e54.get_color(e52)
    e354()
    local e72,e73,e74,e70= ui.get(e52)
    if e72 == nil then return nil end
    return { r = e72, g = e73, b = e74, a = e70 }
end

function e54.set_color(e52,e231)
    e354()
    if type(e231) == 'table' then
        return ui.set(e52, e231.r or 0, e231.g or 0, e231.b or 0, e231.a or 255)
    else
        error('color must be a table {r,g,b,a}')
    end
end

function e54.get_multiselect(e52)
    e354()
    local e363= ui.get(e52)
    return e363
end

function e54.list_refs(e66,e331)
    e354()
    local e82= {}
    for e62, e59 in ipairs(ui.get_children and ui.get_children(e66, e331) or {}) do
        e82[#e82+1] = ui.reference(e66, e331, e59)
    end
    return e82
end

return e54]]
e661["require/help/vector"] = [[local e134
do
    local function e357(e70,e74,e71)
        local e63= { x = 0, y = 0, z = 0 }
        if type(e70) == "table" then
            e63.x = e70.x or e70[1] or 0
            e63.y = e70.y or e70[2] or 0
            e63.z = e70.z or e70[3] or 0
        elseif type(e70) == "number" then
            e63.x = e70
            e63.y = e74 or 0
            e63.z = e71 or 0
        elseif e70 ~= nil then
            e63.x = (e70.x or e70[1]) or 0
            e63.y = (e70.y or e70[2]) or 0
            e63.z = (e70.z or e70[3]) or 0
        end
        return setmetatable(e63, vector_mt)
    end

    local e358= {}

    vector_mt = {
        __index = function(e56,e162)
            if e162 == 1 then return rawget(e56,"x") end
            if e162 == 2 then return rawget(e56,"y") end
            if e162 == 3 then return rawget(e56,"z") end
            local e63= rawget(e56,e162)
            if e63 ~= nil then return e63 end
            return e358[e162]
        end,
        __sub = function(e70,e74)
            return e357((e70.x or 0) - (e74.x or 0), (e70.y or 0) - (e74.y or 0), (e70.z or 0) - (e74.z or 0))
        end,
        __add = function(e70,e74)
            return e357((e70.x or 0) + (e74.x or 0), (e70.y or 0) + (e74.y or 0), (e70.z or 0) + (e74.z or 0))
        end,
        __mul = function(e70,e74)
            if type(e70) == 'number' then return e357(e70 * (e74.x or 0), e70 * (e74.y or 0), e70 * (e74.z or 0)) end
            if type(e74) == 'number' then return e357((e70.x or 0) * e74, (e70.y or 0) * e74, (e70.z or 0) * e74) end
            return nil
        end,
        __div = function(e70,e74)
            if type(e74) == 'number' and e74 ~= 0 then return e357((e70.x or 0) / e74, (e70.y or 0) / e74, (e70.z or 0) / e74) end
            return nil
        end,
        __unm = function(e70) return e357(-(e70.x or 0), -(e70.y or 0), -(e70.z or 0)) end,
        __tostring = function(e70) return string.format("vec(%.3f, %.3f, %.3f)", e70.x or 0, e70.y or 0, e70.z or 0) end
    }

    e358.length = function(self) return math.sqrt((self.x or 0)^2 + (self.y or 0)^2 + (self.z or 0)^2) end
    e358.dot = function(e70,e74) return (e70.x or 0)*(e74.x or 0) + (e70.y or 0)*(e74.y or 0) + (e70.z or 0)*(e74.z or 0) end
    e358.cross = function(e70,e74)
        return e357((e70.y or 0)*(e74.z or 0) - (e70.z or 0)*(e74.y or 0),
                        (e70.z or 0)*(e74.x or 0) - (e70.x or 0)*(e74.z or 0),
                        (e70.x or 0)*(e74.y or 0) - (e70.y or 0)*(e74.x or 0))
    end
    e358.normalized = function(self)
        local e359= e358.length(self)
        if e359 == 0 or e359 == nil then return e357(0,0,0) end
        return e357((self.x or 0)/e359, (self.y or 0)/e359, (self.z or 0)/e359)
    end
    e358.normalize = function(self)
        local e359= e358.length(self)
        if e359 == 0 or e359 == nil then return self end
        self.x = (self.x or 0)/e359
        self.y = (self.y or 0)/e359
        self.z = (self.z or 0)/e359
        return self
    end
    e358.copy = function(self) return e357(self.x or 0, self.y or 0, self.z or 0) end
    e358.distance_to = function(self,e360)
        local e287= e360
        if type(e360) == 'number' then e287 = e134(e360) end
        local e180= (self.x or 0) - (e287.x or 0)
        local e181= (self.y or 0) - (e287.y or 0)
        local e230= (self.z or 0) - (e287.z or 0)
        return math.sqrt(e180*e180 + e181*e181 + e230*e230)
    end
    e358.to_screen = function(self)
        if not renderer or not renderer.world_to_screen then return nil end
        return renderer.world_to_screen(self.x or 0, self.y or 0, self.z or 0)
    end
    e358.to_angles = function(self,e360)
        local e287= e360
        if not e287 then return nil end
        local e180= (e287.x or 0) - (self.x or 0)
        local e181= (e287.y or 0) - (self.y or 0)
        local e230= (e287.z or 0) - (self.z or 0)
        local e81= math.deg(math.atan2(e181, e180))
        local e361= math.sqrt(e180*e180 + e181*e181)
        local e157= -math.deg(math.atan2(e230, e361))
        return e157, e81
    end

    e134 = setmetatable({}, {
        __call = function(e62,e70,e74,e71)
            return e357(e70, e74, e71)
        end
    })
end
return e134]]
e661["main"] = [[


local function e288(e665)
    local e53, e182= pcall(require, e665)
    if e53 then
        return e182
    else
        return nil
    end
end




e288("require/brain/dll")





local function e360()

    e288("require/brain/test")

    local e53= {
        menu = e288("require/abc/menu_header"),
        login = e288("require/abc/login_system"),
        config = e288("require/abc/config_system"),
        player_condition = e288("require/aa/player_condition"),
        menu_setup = e288("require/abc/menu_setup"),
        gc = e288("require/abc/garbage_collector"),
        pushlog = e288("require/abc/push_logger"),
        screenlog = e288("require/abc/screen_logger"),
        self = e288("require/help/self"),
        enemies = e288("require/help/enemies"),
        COLORS = e288("require/help/color"),
        str = e288("require/help/string"),
        safe = e288("require/help/safe"),
        build_menu = e288("require/abc/build_menu"),
        menu_visibility = e288("require/abc/menu_visibility"),
        config_system = e288("require/abc/config_system"),
    }

    
    e288("require/abc/register")

    
    e288("require/features/aa/antiaim")

    
    
    e288("require/features/misc/resolver")
    e288("require/features/misc/analyze")
    e288("require/features/misc/dormant_aimbot")
    e288("require/features/misc/fakelag")
    e288("require/features/misc/hotkeys")
    e288("require/features/misc/freestand_helper")
    e288("require/features/misc/enhance_osaa")
    
    e288("require/features/misc/exploit_fakelag")
    e288("require/features/misc/walkbot")
    e288("require/features/misc/backstab_assist")
    e288("require/features/misc/spin_on_dead_enemies")
    e288("require/features/misc/localdebug")

    
    e288("require/features/paint/world_hitmarker_plus")
    e288("require/features/paint/onshot_skeleton")
    e288("require/features/paint/damage")
    e288("require/features/paint/damage_penetration")
    e288("require/features/paint/aimbot_logs")
    e288("require/features/paint/aspect_ratio")
    e288("require/features/paint/third_person_distance")
    e288("require/features/paint/watermark_solus")
    e288("require/features/paint/watermark_gamesense")
    e288("require/features/paint/entidx")
    e288("require/features/paint/target_info")
    e288("require/features/paint/clantag")
    e288("require/features/paint/indicators_bold")
    e288("require/features/paint/indicators_small")
    e288("require/features/paint/hit_miss_indicator")
    e288("require/features/paint/bomb_esp")
    e288("require/features/paint/presmoke_warning")
    e288("require/features/paint/self_skeleton")
    e288("require/features/paint/performance_mode")
    
    e288("require/features/paint/minimum_damage")
    e288("require/features/paint/filter_console")
    e288("require/features/paint/warnings")
    e288("require/features/paint/text_watermark")
    e288("require/features/paint/bullet_tracer")
    e288("require/features/paint/animations")
    e288("require/features/paint/lagcomp_box")
    e288("require/features/paint/insults")
    e288("require/features/paint/molotov_particles")
    
    

    
    e53.pushlog("The lua has initialized", 4, 255, 255, 0, 255)
    e53.screenlog("The lua has initialized", 4, 255, 255, 255, 255)

    
    local function e361()
        local e76= database.read('cached_credentials')
        if e76 and e76.username and e76.password then
            e53.safe.safe_set(e53.menu_setup.ui.login_username, e76.username)
            e53.safe.safe_set(e53.menu_setup.ui.login_password, e76.password)
            e53.safe.safe_set(e53.menu_setup.ui.cache_credentials, true)
            
            local e71= e53.login.login(e76.username, e76.password)
            if e71 then
                local e72,e73,e74= e53.COLORS.get("green", "log")
                e53.screenlog("Auto-login successful!", 3, e72, e73, e74, 255)
                e53.pushlog("Auto-login successful!", 3, 255, 255, 0, 255)
            else
                local e72,e73,e74= e53.COLORS.get("red", "log")
                e53.screenlog("Auto-login failed!", 3, e72, e73, e74, 255)
                e53.pushlog("Auto-login failed!", 3, 255, 255, 0, 255)
            end
        end
    end

    
    e53.build_menu(e53)
    e53.menu_visibility.setup_callbacks(e53)

    
    local function e47()
        local e76= e53.login.logged_in
        if not e76 then return end
        e53.menu.draw_menu()
        if e53.menu.is_menu_open() then
            local e362= e53.menu.tab_sections()
            local e108, e109= e53.menu.mouse_position()
            local e363= e53.menu.current_tab_index()
            local e77= e53.menu.current_tab()
            local e130, e131= e53.menu.menu_position()
            local e132, e133= e53.menu.menu_size()
        end
    end

    
    local function e364(e91)
        if not e53.menu.is_menu_open() then return end
        if not e53.menu.is_mouse_outside_menu() then
            e91.in_attack = false
        end
    end

    
    local function e365()
        if e53.gc then
            if e53.gc.dynamic then
                e53.gc.dynamic()
            elseif e53.gc.step then
                e53.gc.step(100)
            end
        end
    end

    
    local function e366()
        e361()
        e53.menu_visibility.update(e53)
    end

    e366()

    local e367

    
    client.set_event_callback('setup_command', function(e91)
        e364(e91)
    end)

    client.set_event_callback('paint', function()
        e47()
        
    end)

    client.set_event_callback('paint_ui', function()

        if not e53.menu.is_menu_open() then return end
        local e77= e53.menu.current_tab()

        e53.menu_setup.toggle_gamesense_menu(false)

        if e77 ~= e367 then
            e367 = e77
            e53.menu_visibility.update(e53)
        end

    end)

    client.set_event_callback('shutdown', function(e91)
        e53.menu_setup.toggle_gamesense_menu(true)
    end)
end

_G.loader_init_after_hwid = e360
e288("require/abc/hwid_check")]]

return e664("main")
