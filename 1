
local e981= {}
local e982= {}
local e983= require

local function e984(e985)
    if e982[e985] then
        return e982[e985]
    end

    local e986= e981[e985]
    if not e986 then
        return e983(e985)
    end
    local e987= {}
    setmetatable(e987, { __index = _G })
    e987.require = e984

    local e988, e989
    if type(setfenv) == "function" then
        e988, err = load(e986, e985)
        if not e988 then
            error("Failed to load module: " .. e985 .. " (" .. tostring(e989) .. ")")
        end
        setfenv(e988, e987)
    else
        e988, err = load(e986, e985, nil, e987)
        if not e988 then
            error("Failed to load module: " .. e985 .. " (" .. tostring(e989) .. ")")
        end
    end

    local e990= e988()
    e982[e985] = e990 or true
    return e982[e985]
end

e981["require/aa/player_condition"] = [[
local e365= require("require/help/libs")
local e366= e365.get("antiaim_funcs")
local e367= e365.get("entity") or e367
local e368= e365.get("bit") or e368
local e369= require('require/abc/menu_setup')
local e370= { last_air = false, last_tick = 0, last_cond = nil }

local function e371(e372)
    if e372 == 'global' then return true end
    if not e369 or not e369.ui then return true end
    local e373= 'enable_' .. e372
    local e374= e369.ui[e373]
    if not e374 then
        return true
    end
    local e375, e376= pcall(ui.get, e374)
    return e375 and e376 == true
end


local function e377()
    local e378= e367.get_local_player()
    if not e378 or not e367.is_alive(e378) then
        return nil
    end
    
    if client.key_state(0x45) then
        if e371('legit') then return "legit" end
    end

    local e379= false
    if e366 and e366.get_double_tap then
        e379 = e366.get_double_tap()
    else
        e379 = true
    end

    if e379 == false then
        if e371('fakelag') then return "fakelag" end
    end

    if misc_gs_hotkey_slowmotion and ui.get(misc_gs_hotkey_slowmotion) == true then
        if e371('walk') then return "walk" end
    end
    
    if client.key_state(0x10) then
        local e380, e381= e367.get_prop(e378, 'm_vecVelocity')
        local e382= math.sqrt((e380 or 0)^2 + (e381 or 0)^2)
        if e382 >= 20 and e382 <= 140 then
            if e371('walk') then return "walk" end
        end
    end

    local e380, e381= e367.get_prop(e378, 'm_vecVelocity')
    local e382= math.sqrt((e380 or 0)^2 + (e381 or 0)^2)
    local e383= e367.get_prop(e378, 'm_flDuckAmount') > 0.5
    local e384= e368.band(e367.get_prop(e378, 'm_fFlags') or 0, 1) == 1
    local e385= globals.tickcount()

    if not e384 then
        if e383 then
            e370.last_air = true
            e370.last_tick = e385
            e370.last_cond = "jump+"
            if e371('jump+') then return "jump+" end
        else
            e370.last_air = true
            e370.last_tick = e385
            e370.last_cond = "jump"
            if e371('jump') then return "jump" end
        end
    else
        if e370.last_air and (e385 - e370.last_tick <= 2) then
            if e370.last_cond and e371(e370.last_cond) then
                return e370.last_cond
            end
        end
        e370.last_air = false
        e370.last_cond = nil
    end

    if e383 then
        if e382 >= 2 then
            if e371('duck+') then return "duck+" end
        else
            if e371('duck') then return "duck" end
        end
    else
        if e382 >= 2 then
            if e371('move') then return "move" end
        else
            if e371('stand') then return "stand" end
        end
    end

    return "global"
end

return {
    get = e377
}]]
e981["require/abc/build_menu"] = [[tab = {
    "RAGE",
    "AA",
    "LEGIT",
    "VISUALS",
    "MISC",
    "PLIST",
    "CONFIG",
    "LUA"
}

cont = {
    {
        "Aimbot",
        "Other"
    },
    {
        "Anti-aimbot angles",
        "Fake lag",
        "Other"
    },
    {},
    {
        "Player ESP",
        "Other ESP",
        "Colored models",
        "Effects"
    },
    {},
    {},
    {},
    {
        "A",
        "B",
    }
}

local e368= {
    "global",
    "stand",
    "move",
    "duck",
    "duck+",
    "jump",
    "jump+",
    "walk",
    "fakelag",
    "legit",
}

local e369= require("require/abc/menu_setup")
local e370= require("require/help/color")
local e371= require("require/abc/screen_logger")
local e372= require("require/help/emojis")

local function e373(e374)
    local e375= 'inDGnidgdisgndsin'

    local function e376()
        local e377= database.read(e375)
        return type(e377) == 'table' and e377 or {}
    end

    local function e378(e377)
        database.write(e375, e377)
    end

    local function e379(e377,e380)
        for i = 1, #e377 do if e377[i] == e380 then return i end end
        return nil
    end

    local function e381()
        if not (e374 and e374.menu_setup and e374.menu_setup.ui and e374.menu_setup.ui.paint_logger) then
            return false
        end
        local e382, e383= pcall(ui.get, e374.menu_setup.ui.paint_logger)
        if not e382 or not e383 then return false end
        if type(e383) == 'table' then
            for _, v in ipairs(e383) do
                if tostring(v) == 'config' then return true end
            end
            return false
        else
            return tostring(e383) == 'config'
        end
    end

    local function e384(e385)
        local e386= e376()
        if #e386 == 0 then e386 = {'(empty)'} end
            if e369.ui.cfg_listbox then
                pcall(ui.set_visible, e369.ui.cfg_listbox, false)
            end
            e369.ui.cfg_listbox = e369.register_ui(
                ui.new_listbox(tab[2], cont[2][1], 'Configs', e386),
                { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
            )
        if e385 then
            local e387= e379(e386, e385)
            if e387 then ui.set(e369.ui.cfg_listbox, e387-1) end
        end
    end
 
    
    
    
    e369.ui.cache_credentials = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("pin") .. e370.get("default", "ui") .. 'Cache credentials'),
        { requires_login = false, key = 'cache_credentials', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e369.ui.login_username = e369.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Username', 'username'),
        { requires_login = false, key = 'login_username', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    e369.ui.login_password = e369.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Password', 'password'),
        { requires_login = false, key = 'login_password', tab = 'AA', visible = true, config_type = 'textbox' }
    )
    e369.ui.login_howto_header = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], e370.get("grey", "ui") .. '───────[ ' .. e370.get("white", "ui") .. 'How to ' .. e370.get("green", "ui") .. 'log in' .. e370.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'login_howto_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.login_console_register = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], e370.get("grey", "ui") .. '1. In console -> "register ' .. e370.get("green", "ui") .. 'user' .. e370.get("grey", "ui") .. ' ' .. e370.get("red", "ui") .. 'pass' .. e370.get("grey", "ui") .. ' ' .. e370.get("blue", "ui") .. 'code' .. e370.get("grey", "ui") .. '"'),
        { requires_login = false, key = 'login_console_register', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.login_menu_credentials = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], e370.get("grey", "ui") .. '2. Write password & username in the menu.'),
        { requires_login = false, key = 'login_menu_credentials', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.login_press_login = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], e370.get("grey", "ui") .. '3. Press log in and enjoy ' .. e370.get("green", "ui") .. 'premium features' .. e370.get("grey", "ui") .. '.'),
        { requires_login = false, key = 'login_press_login', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.login_spacer1 = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer1', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.reset_header = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], e370.get("grey", "ui") .. '───────[ ' .. e370.get("white", "ui") .. 'How to ' .. e370.get("yellow", "ui") .. 'reset pass' .. e370.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'reset_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.reset_step1 = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], e370.get("grey", "ui") .. '1. Write username -> press reset.'),
        { requires_login = false, key = 'reset_step1', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.reset_step2 = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], e370.get("grey", "ui") .. '2. Login with your oldest password.'),
        { requires_login = false, key = 'reset_step2', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.login_spacer2 = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], ' '),
        { requires_login = false, key = 'login_spacer2', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.support_header = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], e370.get("grey", "ui") .. '───────[ ' .. e370.get("red", "ui") .. 'Support & Other' .. e370.get("grey", "ui") .. ' ]───────'),
        { requires_login = false, key = 'support_header', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.support_discord = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], e370.get("grey", "ui") .. '1. Join the ' .. e370.get("discord", "ui") .. 'discord ' .. e370.get("grey", "ui") .. 'for support.'),
        { requires_login = false, key = 'support_discord', tab = 'AA', visible = true, config_type = 'label' }
    )

    e369.ui.login_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("lock_open") .. e370.get("default", "ui") .. 'Login', function()
            local e388= e374.safe.safe_get(e369.ui.login_username)
            local e389= e374.safe.safe_get(e369.ui.login_password)
            local e390= e374.safe.safe_get(e369.ui.cache_credentials)
            if e388 ~= '' and e389 ~= '' then
                local e391= e374.login.login(e388, e389)
                if e391 then
                    e374.pushlog("Welcome back, " .. e374.str.capitalize(e388) .. ". You logged in successfully.", 3, 75, 145, 55, 255)
                    if e390 then
                        database.write('cached_credentials', { username = e388, password = e389 })
                    else
                        database.write('cached_credentials', nil)
                    end
                    local e392,e393,e394= e370.get("green", "log")
                    e374.screenlog("Login successful!", 4, e392, e393, e394, 255)
                else
                    local e392,e393,e394= e370.get("red", "log")
                    e374.screenlog("Login failed!", 4, e392, e393, e394, 255)
                end
            end
                if e374.menu_visibility and e374.menu_visibility.update then
                    e374.menu_visibility.update(e374)
                end
        end),
        { requires_login = false, key = 'login_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    e369.ui.logout_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][3], e370.get("red", "ui") .. e372.get("lock") .. e370.get("default", "ui") .. 'Logout', function()
            e374.login.logout()
            local e392,e393,e394= e370.get("red", "log")
            e374.screenlog("Logged out!", 4, e392, e393, e394, 255)
                if e374.menu_visibility and e374.menu_visibility.update then
                    e374.menu_visibility.update(e374)
                end
        end),
        { requires_login = true, key = 'logout_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e369.ui.reset_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][1], e370.get("yellow", "ui") .. e372.get("warning") .. e370.get("default", "ui") .. 'Reset', function()
            local e388= e374.safe.safe_get(e369.ui.login_username)
            e374.login.reset_password(e388)
            local e392,e393,e394= e370.get("yellow", "log")
            e374.screenlog("Password reset.", 4, e392, e393, e394, 255)
            e374.pushlog("Password reset for user: " .. e388, 5, 255, 255, 0, 255)
                if e374.menu_visibility and e374.menu_visibility.update then
                    e374.menu_visibility.update(e374)
                end
        end),
        { requires_login = true, key = 'reset_button', tab = 'AA', visible = true, config_type = 'button' }
    )

    e369.ui.discord_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][3], e370.get("discord", "ui") .. e372.get("chat") .. e370.get("default", "ui") .. 'Discord', function()
            local e395= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            e374.safe.safe_set(e395, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://discord.gg/a2bFbVWWg9')
        end),
        { requires_login = true, key = 'discord_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    e369.ui.youtube_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][3], e370.get("youtube", "ui") .. e372.get("play") .. e370.get("default", "ui") .. 'YouTube', function()
            local e395= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            e374.safe.safe_set(e395, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://www.youtube.com/@vile-gs/videos')
        end),
        { requires_login = true, key = 'youtube_button', tab = 'AA', visible = true, config_type = 'button' }
    )
    e369.ui.sellhub_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][3], e370.get("sellhub", "ui") .. e372.get("folder") .. e370.get("default", "ui") .. 'Sellhub', function()
            local e395= ui.reference('CONFIG', 'Lua', 'Allow scripts to open links')
            e374.safe.safe_set(e395, true)
            panorama.open('CSGOHud').SteamOverlayAPI.OpenExternalBrowserURL('https://sodium.sellhub.cx/#products-list')
        end),
        { requires_login = true, key = 'sellhub_button', tab = 'AA', visible = true, config_type = 'button' }
    )


    
    
    
    e369.ui.condition_label = e369.register_ui(
        ui.new_label(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("menu") .. e370.get("default", "ui") .. 'Condition', unpack(e368)),
        { requires_login = true, key = 'condition_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.condition = e369.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nCondition', unpack(e368)),
        { requires_login = true, key = 'condition', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e369.ui.condition_label2 = e369.register_ui(
        ui.new_label(tab[2], cont[2][1], '\ncondition label'),
        { requires_login = true, key = 'condition_label2', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.misc_resolver = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("wrench") .. e370.get("default", "ui") .. 'Resolver'),
        { requires_login = true, key = 'misc_resolver', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e369.ui.misc_ragebot = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("arrow_double") .. e370.get("default", "ui") .. 'Ragebot'),
        { requires_login = true, key = 'misc_ragebot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e369.ui.misc_dormantaimbot = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("time") .. e370.get("default", "ui") .. 'Dormant aimbot'),
        { requires_login = true, key = 'misc_dormantaimbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e369.ui.misc_dormantaimbot_key = e369.register_ui(
        ui.new_hotkey(tab[2], cont[2][1], '\ndormant aimbot key', true),
        { requires_login = true, key = 'misc_dormantaimbot_key', tab = 'MISC', visible = true, config_type = 'hotkey' }
    )
    e369.ui.misc_dormantaimbot_value = e369.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\ndormant aimbot value', 60, 100, 0, true, '%'),
        { requires_login = true, key = 'misc_dormantaimbot_value', tab = 'MISC', visible = true, config_type = 'slider' }
    )
    e369.ui.misc_exploit_fakelag = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("latency3") .. e370.get("default", "ui") .. 'Limit exploit fakelag'),
        { requires_login = true, key = 'misc_exploit_fakelag', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e369.ui.misc_walkbot = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("arrow_up") .. e370.get("default", "ui") .. 'Walkbot'),
        { requires_login = true, key = 'misc_walkbot', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e369.ui.misc_backstab = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("triangle_upside") .. e370.get("default", "ui") .. 'Backstab Assist'),
        { requires_login = true, key = 'misc_backstab', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e369.ui.misc_spindead = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("turning2") .. e370.get("default", "ui") .. 'Spin on dead enemies'),
        { requires_login = true, key = 'misc_spindead', tab = 'MISC', visible = true, config_type = 'checkbox' }
    )
    e369.ui.aa_gskey_freestandh = e369.register_ui(
        ui.new_label(tab[2], cont[2][3], e370.get("green", "ui") .. e372.get("turning2") .. e370.get("default", "ui") .. 'Freestand'),
        { requires_login = false, key = 'aa_gskey_freestandh', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.aa_gskey_freestand = e369.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'freestand', true),
        { requires_login = true, key = 'aa_gskey_freestand', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    e369.ui.aa_gskey_slowmotionh = e369.register_ui(
        ui.new_label(tab[2], cont[2][3], e370.get("green", "ui") .. e372.get("gear") .. e370.get("default", "ui") .. 'Slowmotion'),
        { requires_login = false, key = 'aa_gskey_slowmotionh', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.aa_gskey_slowmotion = e369.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'slowmotion', true),
        { requires_login = true, key = 'aa_gskey_slowmotion', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    e369.ui.aa_gskey_edgeyawh = e369.register_ui(
        ui.new_label(tab[2], cont[2][3], e370.get("green", "ui") .. e372.get("recycle") .. e370.get("default", "ui") .. 'Edge Yaw'),
        { requires_login = false, key = 'aa_gskey_edgeyawh', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.aa_gskey_edgeyaw = e369.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'edge yaw', true),
        { requires_login = true, key = 'aa_gskey_edgeyaw', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    e369.ui.aa_gskey_onshoth = e369.register_ui(
        ui.new_label(tab[2], cont[2][3], e370.get("green", "ui") .. e372.get("arrow_double") .. e370.get("default", "ui") .. 'On-shot aa'),
        { requires_login = false, key = 'aa_gskey_onshoth', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.aa_gskey_onshot = e369.register_ui(
        ui.new_hotkey(tab[2], cont[2][3], 'on-shot aa', true),
        { requires_login = true, key = 'aa_gskey_onshot', tab = 'AA', visible = true, config_type = 'hotkey' }
    )
    
    for _, cond in ipairs(e368) do
        local e396= 'enable_' .. cond
        e369.ui[e396] = e369.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("accept") .. e370.get("default", "ui") .. 'Enable ' .. cond),
            { requires_login = true, key = e396, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        e369.ui['pitch_' .. cond] = e369.register_ui(
            ui.new_combobox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("triangle_upside") .. e370.get("default", "ui") .. 'Pitch', 'off', 'up', 'down', 'minimal', 'ideal'),
            { requires_login = true, key = 'pitch_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e369.ui['yaw_base_' .. cond] = e369.register_ui(
            ui.new_combobox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("recycle") .. e370.get("default", "ui") .. 'Yaw Base', 'target', 'view', 'threat', 'distance', 'smart'),
            { requires_login = true, key = 'yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e369.ui['yaw_' .. cond] = e369.register_ui(
            ui.new_combobox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("turning2") .. e370.get("default", "ui") .. 'Yaw', 'off', 'spin', '180', '3way', 'ideal'),
            { requires_login = true, key = 'yaw_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e369.ui['label1_' .. cond] = e369.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label1_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        e369.ui['body_yaw_base_' .. cond] = e369.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Base', -90, 90, 0, true, '°'),
            { requires_login = true, key = 'body_yaw_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e369.ui['body_yaw_left_' .. cond] = e369.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Left', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_left_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e369.ui['body_yaw_right_' .. cond] = e369.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw - Right', -90, 90, 0, true, '°', 1, {
                [0] = 'back', [-90] = 'left', [90] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_right_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e369.ui['randomize_yaw_' .. cond] = e369.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Randomize Yaw', 0, 30, 0, true, '%', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'randomize_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e369.ui['label2_' .. cond] = e369.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label2_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        e369.ui['yaw_jitter_' .. cond] = e369.register_ui(
            ui.new_combobox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("turning") .. e370.get("default", "ui") .. 'Yaw Jitter', 'off', 'center', 'skitter'),
            { requires_login = true, key = 'yaw_jitter_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e369.ui['yaw_jitter_base_' .. cond] = e369.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Yaw Jitter - Base', 0, 120, 0, true, '°', 1, {
                [0] = 'disabled'
            }),
            { requires_login = true, key = 'yaw_jitter_base_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e369.ui['body_yaw_mode_' .. cond] = e369.register_ui(
            ui.new_combobox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("gear") .. e370.get("default", "ui") .. 'Body Yaw Mode', 'off', 'static', 'opposite', 'jitter'),
            { requires_login = true, key = 'body_yaw_mode_' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e369.ui['static_body_yaw_' .. cond] = e369.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Static Body Yaw', -58, 58, 0, true, '°'),
            { requires_login = true, key = 'static_body_yaw_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e369.ui['body_yaw_value_' .. cond] = e369.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Body Yaw Value', 1, 3, 2, true, '', 2, {
                [1] = 'left', [2] = 'back', [3] = 'right'
            }),
            { requires_login = true, key = 'body_yaw_value_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e369.ui['delay_' .. cond] = e369.register_ui(
            ui.new_slider(tab[2], cont[2][1], 'Delay', 0, 17, 1, true, 't', 1, {
                [0] = 'jitter'
            }),
            { requires_login = true, key = 'delay_' .. cond, tab = 'AA', visible = true, config_type = 'slider' }
        )
        e369.ui['label3_' .. cond] = e369.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n '),
            { requires_login = true, key = 'label3_' .. cond, tab = 'AA', visible = true, config_type = 'label' }
        )
        e369.ui['fifty_fifty_' .. cond] = e369.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("question") .. e370.get("default", "ui") .. '50/50'),
            { requires_login = true, key = 'fifty_fifty_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        e369.ui['only_flip_on_0_choke_' .. cond] = e369.register_ui(
            ui.new_checkbox(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("time") .. e370.get("default", "ui") .. 'Only Flip on 0 Choke'),
            { requires_login = true, key = 'only_flip_on_0_choke_' .. cond, tab = 'AA', visible = true, config_type = 'checkbox' }
        )
        e369.ui['aa_label_space' .. cond] = e369.register_ui(
            ui.new_label(tab[2], cont[2][1], '\n abc'),
            { requires_login = true, key = 'aa_label_space', tab = 'AA', visible = true, config_type = 'label' }
        )
        e369.ui['aa_label_combo' .. cond] = e369.register_ui(
            ui.new_label(tab[2], cont[2][1], 'Send state -> state'),
            { requires_login = true, key = 'aa_label_combo', tab = 'AA', visible = true, config_type = 'label' }
        )
        e369.ui['send_combo' .. cond] = e369.register_ui(
            ui.new_combobox(tab[2], cont[2][1], '\n', unpack(e368)),
            { requires_login = true, key = 'send_combo' .. cond, tab = 'AA', visible = true, config_type = 'combobox' }
        )
        e369.ui['send_button' .. cond] = e369.register_ui(
            ui.new_button(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("upload") .. e370.get("default", "ui") .. 'Send', function() end),
            { requires_login = true, key = 'send_button', tab = 'AA', visible = true, config_type = 'button' }
        )

    end


    
    
    
    e369.ui.fakelag_mode = e369.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("gear") .. e370.get("default", "ui") .. 'Mode', 'defensive', 'stealer', 'fakelag', 'settings'),
        { requires_login = true, key = 'fakelag_mode', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e369.ui.fakelag_defensive = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("turning2") .. e370.get("default", "ui") .. 'Defensive'),
        { requires_login = true, key = 'fakelag_defensive', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e369.ui.fakelag_force = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("exclamation") .. e370.get("default", "ui") .. 'Force'),
        { requires_login = true, key = 'fakelag_force', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e369.ui.fakelag_fakedef = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("globe") .. e370.get("default", "ui") .. 'Unmatched.gg'),
        { requires_login = true, key = 'fakelag_fakedef', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e369.ui.fakelag_force_on = e369.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("clip") .. e370.get("default", "ui") .. 'Force whilst', 'peek', 'reload', 'shot', 'damaged'),
        { requires_login = true, key = 'fakelag_force_on', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    
    
    
    e369.ui.cfg_load_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("arrow_double") .. e370.get("default", "ui") .. 'Load', function()
            local e386= e376()
            local e387= ui.get(e369.ui.cfg_listbox)
            local e397= e386[(e387 or 0) + 1]
            local e398= ui.get(e369.ui.cfg_input_box)
            local e380= (e397 and e397 ~= '(empty)' and e397 ~= '') and e397 or e398

            if e380 and e380 ~= '' and e380 ~= '(empty)' then
                local e399= require("require/abc/config_system")
                local function e400()
                    if not e369.ui.cfg_selection then return nil end
                    local e382, e401= pcall(ui.get, e369.ui.cfg_selection)
                    if not e382 or not e401 or type(e401) ~= 'table' or #e401 == 0 then return nil end
                    local e402= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local e403= {}
                    for _, v in ipairs(e401) do
                        local e377= e402[tostring(v)]
                        if e377 then e403[#e403+1] = e377 end
                    end
                    if #e403 == 0 then return nil end
                    return e403
                end
                local e404= e400()
                e399.load(e380, e404)
                e374.screenlog('[Config] Loaded config: ' .. e380, 4, 120, 180, 255, 255)
                if e374 and e374.pushlog and e381() then
                    e374.pushlog('Loaded config: ' .. e380, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for load.')
                if e374 and e374.pushlog and e381() then
                    e374.pushlog('No config name selected for load.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_load_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e369.ui.cfg_save_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("config") .. e370.get("default", "ui") .. 'Save', function()
            local e386= e376()
            local e387= ui.get(e369.ui.cfg_listbox)
            local e397= e386[(e387 or 0) + 1]
            local e398= ui.get(e369.ui.cfg_input_box)
            local e380= (e397 and e397 ~= '(empty)' and e397 ~= '') and e397 or e398

            if e380 and e380 ~= '' then
                local e399= require("require/abc/config_system")
                local function e400()
                    if not e369.ui.cfg_selection then return nil end
                    local e382, e401= pcall(ui.get, e369.ui.cfg_selection)
                    if not e382 or not e401 or type(e401) ~= 'table' or #e401 == 0 then return nil end
                    local e402= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local e403= {}
                    for _, v in ipairs(e401) do
                        local e377= e402[tostring(v)]
                        if e377 then e403[#e403+1] = e377 end
                    end
                    if #e403 == 0 then return nil end
                    return e403
                end
                local e404= e400()
                e399.save(e380, e404)
                local e386= e376()
                if not e379(e386, e380) then
                    e386[#e386+1] = e380
                    e378(e386)
                end
                e384(e380)
                e374.screenlog('[Config] Saved config: ' .. e380, 4, 120, 180, 255, 255)
                if e374 and e374.pushlog and e381() then
                    e374.pushlog('Saved config: ' .. e380, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name provided for save.')
                if e374 and e374.pushlog and e381() then
                    e374.pushlog('No config name provided for save.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_save_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e369.ui.cfg_create_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("plus") .. e370.get("default", "ui") .. 'Create', function()
            local e398= ui.get(e369.ui.cfg_input_box)
            if not e398 or e398 == '' then
                client.error_log('[Config] No config name provided for create.')
                if e374 and e374.pushlog and e381() then
                    e374.pushlog('No config name provided for create.', 4, 255, 255, 255, 255)
                end
                return
            end

            local e386= e376()
            if e379(e386, e398) then
                client.error_log('[Config] Config with that name already exists: ' .. e398)
                if e374 and e374.pushlog and e381() then
                    e374.pushlog('Config already exists: ' .. e398, 4, 255, 255, 255, 255)
                end
                return
            end

            local e399= require("require/abc/config_system")
            local function e400()
                if not e369.ui.cfg_selection then return nil end
                local e382, e401= pcall(ui.get, e369.ui.cfg_selection)
                if not e382 or not e401 or type(e401) ~= 'table' or #e401 == 0 then return nil end
                local e402= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local e403= {}
                for _, v in ipairs(e401) do
                    local e377= e402[tostring(v)]
                    if e377 then e403[#e403+1] = e377 end
                end
                if #e403 == 0 then return nil end
                return e403
            end
            local e404= e400()
            e399.save(e398, e404)
            e386[#e386+1] = e398
            e378(e386)
            e384(e398)
            e374.screenlog('[Config] Created config: ' .. e398, 4, 120, 180, 255, 255)
            if e374 and e374.pushlog and e381() then
                e374.pushlog('Created config: ' .. e398, 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_create_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e369.ui.cfg_delete_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][1], e370.get("red", "ui") .. e372.get("trash") .. e370.get("default", "ui") .. 'Delete', function()
            local e386= e376()
            local e387= ui.get(e369.ui.cfg_listbox)
            local e397= e386[(e387 or 0) + 1]
            local e398= ui.get(e369.ui.cfg_input_box)
            local e380= (e397 and e397 ~= '(empty)' and e397 ~= '') and e397 or e398

            if e380 and e380 ~= '' and e380 ~= '(empty)' then
                local e399= require("require/abc/config_system")
                e399.delete(e380)
                local e386= e376()
                local e387= e379(e386, e380)
                if e387 then
                    table.remove(e386, e387)
                    e378(e386)
                end
                e384()
                e374.screenlog('[Config] Deleted config: ' .. e380, 4, 255, 80, 80, 255)
                if e374 and e374.pushlog and e381() then
                    e374.pushlog('Deleted config: ' .. e380, 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config name selected for delete.')
                if e374 and e374.pushlog and e381() then
                    e374.pushlog('No config name selected for delete.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_delete_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e369.ui.cfg_refresh_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("turning") .. e370.get("default", "ui") ..'Refresh', function()
            e384()
            e374.screenlog('[Config] Refreshed config list.', 4, 120, 180, 255, 255)
            if e374 and e374.pushlog and e381() then
                e374.pushlog('Refreshed config list.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_refresh_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    
    local e399= require("require/abc/config_system")
    local e405, e406= pcall(require, 'gamesense/clipboard')
    local e407= e406
    if not e405 or not e407 then
        e407 = {
            set = function(e408) end,
            get = function() return '' end,
        }
    end


    e369.ui.cfg_export_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("upload") .. e370.get("default", "ui") .. 'Export', function()
            local function e400()
                if not e369.ui.cfg_selection then return nil end
                local e382, e401= pcall(ui.get, e369.ui.cfg_selection)
                if not e382 or not e401 or type(e401) ~= 'table' or #e401 == 0 then return nil end
                local e402= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                local e403= {}
                for e408, v in ipairs(e401) do
                    local e377= e402[tostring(v)]
                    if e377 then e403[#e403+1] = e377 end
                end
                if #e403 == 0 then return nil end
                return e403
            end
            local e404= e400()
            local e409= e399.build(e404)
            e407.set(e409)
            client.log('[Config] Exported config string:')
            client.log(e409)
            e374.screenlog('[Config] Exported config string to clipboard and console.', 4, 120, 180, 255, 255)
            if e374 and e374.pushlog and e381() then
                e374.pushlog('Exported config string to clipboard.', 4, 255, 255, 255, 255)
            end
        end),
        { requires_login = true, key = 'cfg_export_button', tab = 'CFG', visible = true, config_type = 'button' }
    )

    e369.ui.cfg_import_button = e369.register_ui(
        ui.new_button(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("download") .. e370.get("default", "ui") .. 'Import', function()
            local e410= e407.get()
            if e410 and e410 ~= '' then
                local function e400()
                    if not e369.ui.cfg_selection then return nil end
                    local e382, e401= pcall(ui.get, e369.ui.cfg_selection)
                    if not e382 or not e401 or type(e401) ~= 'table' or #e401 == 0 then return nil end
                    local e402= { antiaim = 'AA', paint = 'PAINT', misc = 'MISC' }
                    local e403= {}
                    for e408, v in ipairs(e401) do
                        local e377= e402[tostring(v)]
                        if e377 then e403[#e403+1] = e377 end
                    end
                    if #e403 == 0 then return nil end
                    return e403
                end
                local e404= e400()
                e399.apply(e410, e404)
                e374.screenlog('[Config] Imported config string from clipboard.', 4, 120, 180, 255, 255)
                if e374 and e374.pushlog and e381() then
                    e374.pushlog('Imported config string from clipboard.', 4, 255, 255, 255, 255)
                end
            else
                client.error_log('[Config] No config string found in clipboard.')
                if e374 and e374.pushlog and e381() then
                    e374.pushlog('No config string found in clipboard for import.', 4, 255, 255, 255, 255)
                end
            end
        end),
        { requires_login = true, key = 'cfg_import_button', tab = 'CFG', visible = true, config_type = 'button' }
    )
    e369.ui.cfg_selection = e369.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\n selection', 'antiaim', 'paint', 'misc'),
        { requires_login = true, key = 'cfg_selection', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    e369.ui.cfg_input_box = e369.register_ui(
        ui.new_textbox(tab[2], cont[2][1], 'Config name'),
        { requires_login = true, key = 'cfg_input_box', tab = 'CFG', visible = true, config_type = 'textbox' }
    )
    e369.ui.cfg_listbox = e369.register_ui(
        ui.new_listbox(tab[2], cont[2][1], 'Configs', {}),
        { requires_login = true, key = 'cfg_listbox', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    e384()

    e369.ui.cfg_cloud_apply = e369.register_ui(
        ui.new_button(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("globe") .. e370.get("default", "ui") .. ' Apply cloud', function()
            local e382, e401= pcall(ui.get, e369.ui.cfg_cloud)
            if not e382 then
                client.log('cfg_cloud_apply: failed to read selection')
                return
            end

            local e411= { 'Reset', 'Defensive', 'Unmatched', 'Community' }
            local e380= nil

            if type(e401) == 'number' then
                local e387= e401 + 1
                e380 = e411[e387]
            elseif type(e401) == 'table' then
                if #e401 > 0 and type(e401[1]) == 'number' then
                    e380 = e411[e401[1] + 1]
                else
                    e380 = tostring(e401[1])
                end
            else
                e380 = tostring(e401)
            end

            if not e380 or e380 == '' then
                client.log('cfg_cloud_apply: no selection')
                return
            end

            local e412, e413= pcall(require, 'require/abc/config_cloud')
            if not e412 or not e413 then
                client.log('cfg_cloud_apply: failed to load config_cloud module')
                return
            end

            local e414= e413[e380]
            if not e414 then
                client.log('cfg_cloud_apply: no cloud config string for', tostring(e380))
                return
            end

            local e415, e399= pcall(require, 'require/abc/config_system')
            if not e415 or not e399 or not e399.apply then
                client.log('cfg_cloud_apply: config_system.apply not available')
                return
            end

            e399.apply(e414)
            client.log('cfg_cloud_apply: applied cloud config', tostring(e380))
        end),
        { requires_login = true, key = 'cfg_cloud_apply', tab = 'AA', visible = true, config_type = 'button' }
    )

    e369.ui.cfg_cloud = e369.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'Cloud', { e370.get("red", "ui") .. 'Reset', e370.get("reddark", "ui") .. 'Defensive', e370.get("yellow", "ui") .. 'Unmatched', e370.get("grey", "ui") .. 'Community'}),
        { requires_login = true, key = 'cfg_cloud', tab = 'CFG', visible = true, config_type = 'listbox' }
    )
    e369.ui.fakelag_stealer = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("download") .. e370.get("default", "ui") .. 'Stealer' .. e370.get("blue", "ui") .. ' [BETA]' ),
        { requires_login = true, key = 'fakelag_stealer', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e369.ui.fakelag_stealer_type = e369.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("gear") .. e370.get("default", "ui") .. 'Type', 'mimic', 'import'),
        { requires_login = true, key = 'fakelag_stealer_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e369.ui.fakelag_stealer_target = e369.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("id") .. e370.get("default", "ui") .. 'Target', 'threat', 'closest', 'random', 'best kdas'),
        { requires_login = true, key = 'fakelag_stealer_target', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e369.ui.fakelag_stealer_list = e369.register_ui(
        ui.new_listbox(tab[2], cont[2][2], 'target list', {'-'}),
        { requires_login = true, key = 'fakelag_stealer_list', tab = 'AA', visible = true, config_type = 'listbox' }
    )
    e369.ui.fakelag_stealer_refresh = e369.register_ui(
        ui.new_button(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("refresh") .. e370.get("default", "ui") .. 'Refresh', function() end),
        { requires_login = true, key = 'fakelag_stealer_refresh', tab = 'AA', visible = true, config_type = 'button' }
    )
    e369.ui.fakelag_stealer_steal = e369.register_ui(
        ui.new_button(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("clip") .. e370.get("default", "ui") .. 'Steal', function() end),
        { requires_login = true, key = 'fakelag_stealer_steal', tab = 'AA', visible = true, config_type = 'button' }
    )
    e369.ui.fakelag_fakelag = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("latency3") .. e370.get("default", "ui") .. 'Fakelag'),
        { requires_login = true, key = 'fakelag_fakelag', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e369.ui.fakelag_fakelag_type = e369.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("gear") .. e370.get("default", "ui") .. 'Type', 'gamesense', 'sodium'),
        { requires_login = true, key = 'fakelag_fakelag_type', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e369.ui.fakelag_fakelag_amount = e369.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("plus") .. e370.get("default", "ui") .. 'Amount', 'dynamic', 'maximum', 'fluctuate'),
        { requires_login = true, key = 'fakelag_fakelag_amount', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e369.ui.fakelag_fakelag_variance = e369.register_ui(
        ui.new_slider(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("recycle") .. e370.get("default", "ui") .. 'Variance', 0, 100, 0, true, '%'),
        { requires_login = true, key = 'fakelag_fakelag_variance', tab = 'AA', visible = true, config_type = 'slider' }
    )
    e369.ui.fakelag_fakelag_limit = e369.register_ui(
        ui.new_slider(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("lock") .. e370.get("default", "ui") .. 'Limit', 1, 15, 1, true, 't'),
        { requires_login = true, key = 'fakelag_fakelag_limit', tab = 'AA', visible = true, config_type = 'slider' }
    )
    e369.ui.fakelag_fakelag_type2 = e369.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("config") .. e370.get("default", "ui") .. 'Preset', 'jitter', 'max'),
        { requires_login = true, key = 'fakelag_fakelag_type2', tab = 'AA', visible = true, config_type = 'combobox' }
    )
    e369.ui.fakelag_settings_freestanding = e369.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("turning2") .. e370.get("default", "ui") .. 'Freestanding options', 'static', 'zero pitch', 'defensive', 'side flip', 'pitch flip'),
        { requires_login = true, key = 'fakelag_settings_freestanding', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    e369.ui.fakelag_settings_enhance_onshot = e369.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("arrow_double") .. e370.get("default", "ui") .. 'Enhance on-shot aa', 'defensive', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_enhance_onshot', tab = 'AA', visible = true, config_type = 'multiselect' }
    )
    e369.ui.fakelag_settings_antibrute = e369.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("exclamation") .. e370.get("default", "ui") .. 'Antibrute', 'defensive', 'flip', 'roll', 'jitter'),
        { requires_login = true, key = 'fakelag_settings_antibrute', tab = 'AA', visible = true, config_type = 'multiselect' }
    )

    e369.ui.fakelag_settings_roll_checkbox = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][2], '\nuse roll'),
        { requires_login = true, key = 'fakelag_settings_roll_checkbox', tab = 'AA', visible = true, config_type = 'checkbox' }
    )
    e369.ui.fakelag_settings_roll_label = e369.register_ui(
        ui.new_label(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("recycle") .. e370.get("default", "ui") .. 'Roll'),
        { requires_login = false, key = 'label_roll', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.fakelag_settings_roll = e369.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nroll', 0, 45, 0, true, '°'),
        { requires_login = true, key = 'fakelag_settings_roll', tab = 'AA', visible = true, config_type = 'slider' }
    )
    e369.ui.fakelag_settings_side = e369.register_ui(
        ui.new_slider(tab[2], cont[2][2], '\nside', 1, 3, 1, true, '', 1, {
            [1] = 'left', [2] = 'swap', [3] = 'right'
        }),
        { requires_login = true, key = 'fakelag_settings_side', tab = 'AA', visible = true, config_type = 'slider' }
    )

    
    
    
    e369.ui.paint_advertisement = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nadvertisement', true),
        { requires_login = true, key = 'paint_advertisement', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_advertisement_animation = e369.register_ui(
        ui.new_slider(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("speaker") .. e370.get("default", "ui") .. 'Advertisement', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_advertisement_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    e369.ui.paint_advertisement_color = e369.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'rizz546456', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_advertisement_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e369.ui.paint_watermark = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\nwatermark'),
        { requires_login = true, key = 'paint_watermark', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_watermark_type = e369.register_ui(
        ui.new_slider(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("text") .. e370.get("default", "ui") .. 'Watermark', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_watermark_type', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    e369.ui.paint_watermark_color = e369.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'sigma9745', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_watermark_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e369.ui.label_space2 = e369.register_ui(
        ui.new_label(tab[2], cont[2][1], '\n abc'),
        { requires_login = false, key = 'label_space2', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.label_space3 = e369.register_ui(
        ui.new_label(tab[2], cont[2][1], e370.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space3', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.paint_entidx = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'entidx'),
        { requires_login = true, key = 'paint_entidx', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_target_info = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'target info'),
        { requires_login = true, key = 'paint_target_info', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_filter_console = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'filter console'),
        { requires_login = true, key = 'paint_filter_console', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_minimum_damage = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'minimum damage'),
        { requires_login = true, key = 'paint_minimum_damage', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_show_damage_penetration = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'show damage penetration'),
        { requires_login = true, key = 'paint_show_damage_penetration', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_hitmiss_indicator = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'hit/miss indicator'),
        { requires_login = true, key = 'paint_hitmiss_indicator', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_self_skeleton = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'self skeleton'),
        { requires_login = true, key = 'paint_self_skeleton', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_bullet_tracer = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'bullet tracer'),
        { requires_login = true, key = 'paint_bullet_tracer', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_lagcomp_box = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lagcomp box'),
        { requires_login = true, key = 'paint_lagcomp_box', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_lagcomp_box_color = e369.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], 'lagcomp box color', 47, 117, 221, 255),
        { requires_login = true, key = 'paint_lagcomp_box_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e369.ui.paint_presmoke = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'presmoke warning'),
        { requires_login = true, key = 'paint_presmoke', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_bombwarning = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'c4 warning'),
        { requires_login = true, key = 'paint_bombwarning', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_insults = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'insults'),
        { requires_login = true, key = 'paint_insults', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_rainbow_esp = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'rainbow esp'),
        { requires_login = true, key = 'paint_rainbow_esp', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_molotov = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'molotov particles'),
        { requires_login = true, key = 'paint_molotov', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_lag_record = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], 'lag record'),
        { requires_login = true, key = 'paint_lag_record', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.label_space4 = e369.register_ui(
        ui.new_label(tab[2], cont[2][1], e370.get("grey", "ui") .. '────────────────────────────────'),
        { requires_login = false, key = 'label_space4', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.paint_clantag = e369.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("id") .. e370.get("default", "ui") .. 'Clantag', 'off', 'gamesense', 'sodium'),
        { requires_login = true, key = 'paint_clantag', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    e369.ui.paint_aimbot_logs = e369.register_ui(
        ui.new_combobox(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("clipboard") .. e370.get("default", "ui") .. 'Aimbot logs', 'off', 'gamesense', 'gamesense beta', 'sodium'),
        { requires_login = true, key = 'paint_aimbot_logs', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    e369.ui.label_space1 = e369.register_ui(
        ui.new_label(tab[2], cont[2][1], '\nextra space'),
        { requires_login = false, key = 'label_space1', tab = 'AA', visible = true, config_type = 'label' }
    )
    
    e369.ui.paint_indicators_enable = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n enable'),
        { requires_login = true, key = 'paint_indicators_enable', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_indicators_label = e369.register_ui(
        ui.new_label(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("pallete") .. e370.get("default", "ui") .. 'Indicators'),
        { requires_login = false, key = 'paint_indicators_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.paint_indicators = e369.register_ui(
        ui.new_combobox(tab[2], cont[2][1], '\nIndicators', 'off', 'small', 'bold'),
        { requires_login = true, key = 'paint_indicators', tab = 'PAINT', visible = true, config_type = 'combobox' }
    )
    e369.ui.paint_indicator_color = e369.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_indicator_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e369.ui.paint_indicators_bar = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n bar'),
        { requires_login = true, key = 'paint_indicators_bar', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_indicators_animation = e369.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 3, 0, true, '', 1, {
            [0] = 'static', [1] = 'fading', [2] = 'breathing', [3] = 'bounce'
        }),
        { requires_login = true, key = 'paint_indicators_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    e369.ui.paint_logger_checkbox = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][1], '\n abc'),
        { requires_login = true, key = 'paint_logger_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_logger_label = e369.register_ui(
        ui.new_label(tab[2], cont[2][1], e370.get("green", "ui") .. e372.get("pen") .. e370.get("default", "ui") .. 'Logger'),
        { requires_login = false, key = 'paint_logger_label', tab = 'AA', visible = true, config_type = 'label' }
    )
    e369.ui.paint_logger = e369.register_ui(
        ui.new_multiselect(tab[2], cont[2][1], '\nLogger', 'aimbot', 'config', 'anti-aim', 'other'),
        { requires_login = true, key = 'paint_logger', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    e369.ui.paint_logger_color = e369.register_ui(
        ui.new_color_picker(tab[2], cont[2][1], '\n abc', 255, 255, 255, 255),
        { requires_login = true, key = 'paint_logger_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e369.ui.paint_logger_animation = e369.register_ui(
        ui.new_slider(tab[2], cont[2][1], '\nanimation style', 0, 1, 0, true, '', 1, {
            [0] = 'gamesense', [1] = 'modern'
        }),
        { requires_login = true, key = 'paint_logger_animation', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    e369.ui.paint_hitmarker = e369.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("reject") .. e370.get("default", "ui") .. 'Hitmarkers', 'world +', 'skeleton', 'damage'),
        { requires_login = true, key = 'paint_hitmarker', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    e369.ui.paint_hitmarker_color = e369.register_ui(
        ui.new_color_picker(tab[2], cont[2][2], '\n + color', 0, 225, 225, 255),
        { requires_login = true, key = 'paint_hitmarker_color', tab = 'PAINT', visible = true, config_type = 'color' }
    )
    e369.ui.paint_warnings = e369.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("warning") .. e370.get("default", "ui") .. 'Warnings', 'lethal', 'cant fire', 'low bullets'),
        { requires_login = true, key = 'paint_warnings', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    e369.ui.paint_performance_mode = e369.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("latency4") .. e370.get("default", "ui") .. 'Performance mode', 'blood', 'ragdolls', 'particles', 'lens flare', 'animations', 'feature updates'),
        { requires_login = true, key = 'paint_performance_mode', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    e369.ui.paint_animations = e369.register_ui(
        ui.new_multiselect(tab[2], cont[2][2], e370.get("green", "ui") .. e372.get("turning2") .. e370.get("default", "ui") .. 'Animations', 'kingaru', 'body lean', 'gamesense legs', 'moonwalk', 'allah', 'static legs', 'no pitch on land', 'reversed legs', 'earthquake', 't-pose', 'blind', 'pitch up'),
        { requires_login = true, key = 'paint_animations', tab = 'PAINT', visible = true, config_type = 'multiselect' }
    )
    e369.ui.paint_aspect_ratio_checkbox = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], e370.get("green", "ui") .. e372.get("expand") .. e370.get("default", "ui") .. 'Aspect ratio'),
        { requires_login = true, key = 'paint_aspect_ratio_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_aspect_ratio = e369.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\naspect ratio', 0, 300, 0, true, '', 0.01, {
            [0] = 'default', [125] = '5:4', [133] = '4:3', [150] = '3:2', [160] = '16:10', [177] = '16:9'
        }),
        { requires_login = true, key = 'paint_aspect_ratio', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    e369.ui.paint_third_person_distance_checkbox = e369.register_ui(
        ui.new_checkbox(tab[2], cont[2][3], e370.get("green", "ui") .. e372.get("camera") .. e370.get("default", "ui") .. 'Third person distance'),
        { requires_login = true, key = 'paint_third_person_distance_checkbox', tab = 'PAINT', visible = true, config_type = 'checkbox' }
    )
    e369.ui.paint_third_person_distance = e369.register_ui(
        ui.new_slider(tab[2], cont[2][3], '\nthird person distance', 30, 166, 150, true, '', 1, {
            [150] = 'default'
        }),
        { requires_login = true, key = 'paint_third_person_distance', tab = 'PAINT', visible = true, config_type = 'slider' }
    )
    
    
    
    
    local e416= {
        checkbox = 'c',
        slider = 's',
        combobox = 'o',
        multiselect = 'm',
    }
    for key, item in pairs(e369.ui) do
        for e408, entry in ipairs(e369.registered_items or {}) do
            if entry.key == key and entry.config_type and e416[entry.config_type] then
                e399.register(key, item, e416[entry.config_type], entry.tab)
            end
        end
    end
end

return e373]]
e981["require/abc/callbacks"] = [[




local e371= {}

local e372= 1
local e373= {}          
local e374= {}      
local e375= {}   

local function e376()
	local e377, e378= pcall(require, "require/abc/login_system")
	if not e377 or not e378 then return false end
	return e378.logged_in == true
end

local function e379(e380)
	if not e380 then return true end
	if e380.menu_only and not (ui and ui.is_menu_open and ui.is_menu_open()) then return false end
	if e380.alive_only then
		local e381= (entity and entity.get_local_player) and entity.get_local_player()
		if not e381 or not entity.is_alive(e381) then return false end
	end
	if e380.require_login then
		if not e376() then return false end
	end
	return true
end

local function e382(e383)
	return function(e384)
		local e385= e374[e383]
		if not e385 then return end
		local e386= {}
		for i=1,#e385 do e386[i] = e385[i] end
		for i=1,#e386 do
			local e387= e386[i]
			local e388= e373[e387]
			if e388 and e388.wrapper then
				local e377, e389= pcall(e388.wrapper, e384)
				if not e377 then
					local e390= nil
					pcall(function()
						e390 = debug.getinfo(e388.user_fn, "Sln")
					end)
					local e391= e390 and e390.short_src or "<unknown>"
					local e392= e390 and (e390.linedefined or -1) or -1
					pcall(client.error_log, string.format("callback[%d] error: %s (source=%s:%d)", e387, tostring(e389), e391, e392))
				end
			end
		end
	end
end



function e371.register(e383,e393,e394,e395,e396)
	if type(e383) ~= 'string' then error('event must be a string') end
	if type(e393) ~= 'function' then error('callback must be a function') end

	local e380= nil
	if type(e394) == 'table' then e380 = e394
	else
		e380 = { menu_only = (e394 == true), alive_only = (e395 == true), require_login = (e396 == true) }
	end

	local e387= e372; e372 = e372 + 1
	local e397= function(e384)
		if e379(e380) then
			return e393(e384)
		end
	end

	e373[e387] = { event = e383, wrapper = e397, user_fn = e393, opts = e380 }
	e374[e383] = e374[e383] or {}
	e374[e383][#e374[e383] + 1] = e387

	
	if not e375[e383] then
		local e398= e382(e383)
		e375[e383] = e398
		pcall(client.set_event_callback, e383, e398)
	end

	return e387
end

function e371.callback(e383,e394,e395,e396,e399)
	if type(e394) == 'function' then
		return e371.register(e383, e394, e395)
	end
	if type(e399) == 'function' then
		local e393= e399
		local e380= { menu_only = (e394 == true), alive_only = (e395 == true), require_login = (e396 == true) }
		return e371.register(e383, e393, e380)
	end
	error('invalid callback signature')
end

function e371.unregister(e387)
	local e388= e373[e387]
	if not e388 then return false end
	local e383= e388.event
	e373[e387] = nil
	local e400= e374[e383]
	if e400 then
		for i=#e400,1,-1 do if e400[i] == e387 then table.remove(e400, i) end end
		if #e400 == 0 then
			e374[e383] = nil
			local e398= e375[e383]
			if e398 then pcall(client.unset_event_callback, e383, e398) end
			e375[e383] = nil
		end
	end
	return true
end

function e371.clear_all()
	for e383, e398 in pairs(e375) do
		pcall(client.unset_event_callback, e383, e398)
	end
	e373 = {}
	e374 = {}
	e375 = {}
end

function e371._list()
	return { regs = e373, by_event = e374 }
end

pcall(function()
	if lua and lua.defer then
		lua.defer(e371.clear_all)
	else
		pcall(client.set_event_callback, 'shutdown', e371.clear_all)
	end
end)

return e371
]]
e981["require/abc/config_cloud"] = [[local e374= {
    Reset = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfbW92ZXx0PW98dj1vZmYKeWF3X2Zha2VsYWd8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wK3x0PXN8dj0wCmZha2VsYWdfc2V0dGluZ3Nfc2lkZXx0PXN8dj0xCnBpdGNoX21vdmV8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbW92ZXx0PXN8dj0wCmZha2VsYWdfZm9yY2Vfb258dD1tfHY9CmZha2VsYWdfZGVmZW5zaXZlfHQ9Y3x2PWZhbHNlCnlhd193YWxrfHQ9b3x2PW9mZgpzdGF0aWNfYm9keV95YXdfZmFrZWxhZ3x0PXN8dj0wCnBpdGNoX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfanVtcHx0PXN8dj0yCmJvZHlfeWF3X21vZGVfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXArfHQ9c3x2PTIKeWF3X2ppdHRlcl9iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfYmFzZV9kdWNrK3x0PW98dj10YXJnZXQKb25seV9mbGlwX29uXzBfY2hva2VfZHVjayt8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PWZhbHNlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9MApib2R5X3lhd19sZWZ0X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19zdGFuZHx0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19nbG9iYWx8dD1zfHY9MApwaXRjaF9kdWNrfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PW9mZgp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRhcmdldApmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9b2ZmCnlhd19qaXR0ZXJfYmFzZV9qdW1wfHQ9c3x2PTAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PQpzZW5kX2NvbWJvanVtcHx0PW98dj1nbG9iYWwKc2VuZF9jb21ib2p1bXArfHQ9b3x2PWdsb2JhbApvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj1mYWxzZQpzdGF0aWNfYm9keV95YXdfbW92ZXx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVjayt8dD1zfHY9MAp5YXdfYmFzZV9nbG9iYWx8dD1vfHY9dGFyZ2V0CmVuYWJsZV9sZWdpdHx0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PQpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9kdWNrK3x0PXN8dj0yCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfdmFsdWVfbGVnaXR8dD1zfHY9Mgpib2R5X3lhd19iYXNlX2Zha2VsYWd8dD1zfHY9MAp5YXdfanVtcCt8dD1vfHY9b2ZmCmRlbGF5X3dhbGt8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdHlwZTJ8dD1vfHY9aml0dGVyCnlhd19sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9zdGFuZHx0PXN8dj0wCmVuYWJsZV9qdW1wK3x0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZmFrZWxhZ3x0PW98dj1nbG9iYWwKeWF3X2ppdHRlcl9iYXNlX2R1Y2t8dD1zfHY9MApmaWZ0eV9maWZ0eV9qdW1wfHQ9Y3x2PWZhbHNlCnBpdGNoX2xlZ2l0fHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfc3RhbmR8dD1zfHY9MAp5YXdfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfanVtcHx0PW98dj1vZmYKYm9keV95YXdfcmlnaHRfZHVja3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVjayt8dD1zfHY9MApib2R5X3lhd19tb2RlX3dhbGt8dD1vfHY9b2ZmCmJvZHlfeWF3X3JpZ2h0X2p1bXArfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10YXJnZXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj1mYWxzZQp5YXdfanVtcHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV93YWxrfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X3N0YW5kfHQ9c3x2PTAKcmFuZG9taXplX3lhd19nbG9iYWx8dD1zfHY9MApmaWZ0eV9maWZ0eV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfbW92ZXx0PW98dj1vZmYKeWF3X2Jhc2VfanVtcCt8dD1vfHY9dGFyZ2V0CnBpdGNoX2R1Y2srfHQ9b3x2PW1pbmltYWwKYm9keV95YXdfbW9kZV9qdW1wK3x0PW98dj1vZmYKc2VuZF9jb21ib2R1Y2t8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfZmFrZWxhZ3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVja3x0PW98dj1vZmYKZmFrZWxhZ19zdGVhbGVyX3RhcmdldHx0PW98dj10aHJlYXQKZmlmdHlfZmlmdHlfZHVjayt8dD1jfHY9ZmFsc2UKb25seV9mbGlwX29uXzBfY2hva2VfanVtcHx0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTAKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0wCmRlbGF5X2R1Y2srfHQ9c3x2PTEKYm9keV95YXdfbW9kZV9sZWdpdHx0PW98dj1vZmYKYm9keV95YXdfdmFsdWVfZHVja3x0PXN8dj0yCmVuYWJsZV9kdWNrfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PW9mZgp5YXdfYmFzZV9zdGFuZHx0PW98dj10YXJnZXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PW9mZgp5YXdfaml0dGVyX3N0YW5kfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2xlZ2l0fHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19iYXNlX2xlZ2l0fHQ9b3x2PXRhcmdldApzdGF0aWNfYm9keV95YXdfd2Fsa3x0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X2Zha2VsYWd8dD1zfHY9MApkZWxheV9kdWNrfHQ9c3x2PTEKZmFrZWxhZ19zZXR0aW5nc19yb2xsfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2xpbWl0fHQ9c3x2PTEKZmFrZWxhZ19mYWtlbGFnX3ZhcmlhbmNlfHQ9c3x2PTAKZmFrZWxhZ19mYWtlbGFnX2Ftb3VudHx0PW98dj1keW5hbWljCmZha2VsYWdfZmFrZWxhZ190eXBlfHQ9b3x2PWdhbWVzZW5zZQpyYW5kb21pemVfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2dsb2JhbHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9nbG9iYWx8dD1zfHY9MApyYW5kb21pemVfeWF3X3dhbGt8dD1zfHY9MApjZmdfc2VsZWN0aW9ufHQ9bXx2PWFudGlhaW0KYm9keV95YXdfdmFsdWVfbW92ZXx0PXN8dj0yCmZpZnR5X2ZpZnR5X21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKb25seV9mbGlwX29uXzBfY2hva2VfbW92ZXx0PWN8dj1mYWxzZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ3x0PWN8dj1mYWxzZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfd2Fsa3x0PWN8dj1mYWxzZQpmaWZ0eV9maWZ0eV9zdGFuZHx0PWN8dj1mYWxzZQpzZW5kX2NvbWJvZHVjayt8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnlhd19qaXR0ZXJfanVtcCt8dD1vfHY9b2ZmCnlhd19iYXNlX2p1bXB8dD1vfHY9dGFyZ2V0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKcGl0Y2hfanVtcCt8dD1vfHY9b2ZmCnlhd19kdWNrfHQ9b3x2PW9mZgpkZWxheV9qdW1wK3x0PXN8dj0xCmRlbGF5X3N0YW5kfHQ9c3x2PTEKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj0wCmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2Jhc2VfZHVja3x0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10YXJnZXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9MApib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgpib2R5X3lhd19sZWZ0X2dsb2JhbHx0PXN8dj0wCmRlbGF5X21vdmV8dD1zfHY9MQpkZWxheV9qdW1wfHQ9c3x2PTEKZW5hYmxlX2p1bXB8dD1jfHY9ZmFsc2UKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PTAKYm9keV95YXdfbGVmdF9qdW1wK3x0PXN8dj0wCnlhd19tb3ZlfHQ9b3x2PW9mZgpib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PWZhbHNlCmZha2VsYWdfZmFrZWRlZnx0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX2dsb2JhbHx0PW98dj1vZmYKZmlmdHlfZmlmdHlfanVtcCt8dD1jfHY9ZmFsc2UKY29uZGl0aW9ufHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9ZmFsc2UKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X21vdmV8dD1zfHY9MApkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PWZhbHNl0000',
    Defensive = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9Mgp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9dHJ1ZQp5YXdfd2Fsa3x0PW98dj0xODAKc3RhdGljX2JvZHlfeWF3X2Zha2VsYWd8dD1zfHY9MApwaXRjaF9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2p1bXB8dD1zfHY9Mgpib2R5X3lhd19tb2RlX3N0YW5kfHQ9b3x2PWppdHRlcgpib2R5X3lhd192YWx1ZV9qdW1wK3x0PXN8dj0yCnlhd19qaXR0ZXJfYmFzZV9mYWtlbGFnfHQ9c3x2PTAKeWF3X2Jhc2VfZHVjayt8dD1vfHY9dGhyZWF0Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2srfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZmFrZWxhZ3x0PW98dj10YXJnZXQKc2VuZF9jb21ib2dsb2JhbHx0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X2p1bXArfHQ9c3x2PTAKYm9keV95YXdfdmFsdWVfd2Fsa3x0PXN8dj0yCmVuYWJsZV93YWxrfHQ9Y3x2PXRydWUKZGVsYXlfbGVnaXR8dD1zfHY9MQp5YXdfc3RhbmR8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVja3x0PXN8dj0wCmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKcGl0Y2hfZHVja3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfZHVjayt8dD1vfHY9aml0dGVyCnlhd19iYXNlX21vdmV8dD1vfHY9dGhyZWF0CmZha2VsYWdfbW9kZXx0PW98dj1zZXR0aW5ncwpwaXRjaF93YWxrfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9iYXNlX2p1bXB8dD1zfHY9MTIwCnNlbmRfY29tYm93YWxrfHQ9b3x2PWdsb2JhbApmYWtlbGFnX3NldHRpbmdzX2ZyZWVzdGFuZGluZ3x0PW18dj1zdGF0aWMJemVybyBwaXRjaAlkZWZlbnNpdmUJc2lkZSBmbGlwCnNlbmRfY29tYm9qdW1wfHQ9b3x2PWdsb2JhbApzZW5kX2NvbWJvanVtcCt8dD1vfHY9Z2xvYmFsCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXArfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9dHJ1ZQpmYWtlbGFnX3NldHRpbmdzX2VuaGFuY2Vfb25zaG90fHQ9bXx2PWRlZmVuc2l2ZQlyb2xsCWppdHRlcgpzdGF0aWNfYm9keV95YXdfanVtcHx0PXN8dj0wCnlhd19qaXR0ZXJfYmFzZV9sZWdpdHx0PXN8dj0wCmJvZHlfeWF3X3JpZ2h0X3dhbGt8dD1zfHY9MjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9MgpzZW5kX2NvbWJvbGVnaXR8dD1vfHY9Z2xvYmFsCmJvZHlfeWF3X2xlZnRfbGVnaXR8dD1zfHY9LTU4Cm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTQKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9MApyYW5kb21pemVfeWF3X2R1Y2srfHQ9c3x2PTAKYm9keV95YXdfbW9kZV93YWxrfHQ9b3x2PXN0YXRpYwpib2R5X3lhd19yaWdodF9qdW1wK3x0PXN8dj0zNwpvbmx5X2ZsaXBfb25fMF9jaG9rZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmZha2VsYWdfc2V0dGluZ3NfYW50aWJydXRlfHQ9bXx2PQp5YXdfYmFzZV93YWxrfHQ9b3x2PXRocmVhdApmYWtlbGFnX3N0ZWFsZXJ8dD1jfHY9ZmFsc2UKZW5hYmxlX3N0YW5kfHQ9Y3x2PXRydWUKeWF3X2p1bXB8dD1vfHY9MTgwCmJvZHlfeWF3X2Jhc2Vfd2Fsa3x0PXN8dj0wCnN0YXRpY19ib2R5X3lhd19zdGFuZHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZ2xvYmFsfHQ9c3x2PTAKZmlmdHlfZmlmdHlfZHVja3x0PWN8dj1mYWxzZQpib2R5X3lhd19tb2RlX21vdmV8dD1vfHY9aml0dGVyCnlhd19iYXNlX2p1bXArfHQ9b3x2PXRocmVhdApwaXRjaF9kdWNrK3x0PW98dj1taW5pbWFsCmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2p1bXB8dD1zfHY9MTgKcmFuZG9taXplX3lhd19mYWtlbGFnfHQ9c3x2PTAKcmFuZG9taXplX3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3N0YW5kfHQ9c3x2PTIKYm9keV95YXdfYmFzZV9qdW1wK3x0PXN8dj0tMwpkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjcKc2VuZF9jb21ib21vdmV8dD1vfHY9Z2xvYmFsCnJhbmRvbWl6ZV95YXdfbW92ZXx0PXN8dj0wCnBpdGNoX2p1bXB8dD1vfHY9ZG93bgp5YXdfYmFzZV9zdGFuZHx0PW98dj10aHJlYXQKeWF3X2ppdHRlcl9mYWtlbGFnfHQ9b3x2PW9mZgpzZW5kX2NvbWJvc3RhbmR8dD1vfHY9Z2xvYmFsCnBpdGNoX3N0YW5kfHQ9b3x2PWRvd24KeWF3X2ppdHRlcl9zdGFuZHx0PW98dj1vZmYKYm9keV95YXdfYmFzZV9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2dsb2JhbHx0PWN8dj1mYWxzZQp5YXdfYmFzZV9sZWdpdHx0PW98dj10aHJlYXQKc3RhdGljX2JvZHlfeWF3X3dhbGt8dD1zfHY9MApib2R5X3lhd19yaWdodF9mYWtlbGFnfHQ9c3x2PTAKZGVsYXlfZHVja3x0PXN8dj01CmZha2VsYWdfc2V0dGluZ3Nfcm9sbHx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19saW1pdHx0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ192YXJpYW5jZXx0PXN8dj0wCmZha2VsYWdfZmFrZWxhZ19hbW91bnR8dD1vfHY9ZHluYW1pYwpmYWtlbGFnX2Zha2VsYWdfdHlwZXx0PW98dj1zb2RpdW0KcmFuZG9taXplX3lhd19qdW1wfHQ9c3x2PTAKeWF3X2ppdHRlcl9nbG9iYWx8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKcmFuZG9taXplX3lhd193YWxrfHQ9c3x2PTAKY2ZnX3NlbGVjdGlvbnx0PW18dj1hbnRpYWltCmJvZHlfeWF3X3ZhbHVlX21vdmV8dD1zfHY9MgpmaWZ0eV9maWZ0eV9tb3ZlfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfYmFzZV9kdWNrK3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX21vdmV8dD1jfHY9dHJ1ZQpmYWtlbGFnX3N0ZWFsZXJfdHlwZXx0PW98dj1taW1pYwpib2R5X3lhd19yaWdodF9zdGFuZHx0PXN8dj0yNApmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQpkZWxheV9mYWtlbGFnfHQ9c3x2PTEKZW5hYmxlX2dsb2JhbHx0PWN8dj1mYWxzZQplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV93YWxrfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCnNlbmRfY29tYm9kdWNrK3x0PW98dj1nbG9iYWwKYm9keV95YXdfcmlnaHRfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9qdW1wK3x0PW98dj1vZmYKeWF3X2Jhc2VfanVtcHx0PW98dj10aHJlYXQKb25seV9mbGlwX29uXzBfY2hva2VfbGVnaXR8dD1jfHY9dHJ1ZQpib2R5X3lhd19tb2RlX2R1Y2t8dD1vfHY9c3RhdGljCnN0YXRpY19ib2R5X3lhd19sZWdpdHx0PXN8dj0wCnBpdGNoX2p1bXArfHQ9b3x2PWRvd24KeWF3X2R1Y2t8dD1vfHY9MTgwCmRlbGF5X2p1bXArfHQ9c3x2PTMKZGVsYXlfc3RhbmR8dD1zfHY9NApmYWtlbGFnX2ZvcmNlfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X3JpZ2h0X2R1Y2srfHQ9c3x2PTQ0CmVuYWJsZV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcHx0PXN8dj0tMTUKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTE0Cnlhd19qaXR0ZXJfYmFzZV9tb3ZlfHQ9c3x2PTAKeWF3X2dsb2JhbHx0PW98dj1vZmYKY2FjaGVfY3JlZGVudGlhbHN8dD1jfHY9dHJ1ZQpyYW5kb21pemVfeWF3X2xlZ2l0fHQ9c3x2PTAKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfcmlnaHRfbGVnaXR8dD1zfHY9NTgKYm9keV95YXdfdmFsdWVfZ2xvYmFsfHQ9c3x2PTIKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApkZWxheV9tb3ZlfHQ9c3x2PTEKZGVsYXlfanVtcHx0PXN8dj0xCmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKYm9keV95YXdfYmFzZV9qdW1wfHQ9c3x2PTQKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCnlhd19qaXR0ZXJfanVtcHx0PW98dj1vZmYKYm9keV95YXdfbGVmdF93YWxrfHQ9c3x2PS0xNgpib2R5X3lhd19sZWZ0X2p1bXArfHQ9c3x2PS05Cnlhd19tb3ZlfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2srfHQ9c3x2PS0xNQpzdGF0aWNfYm9keV95YXdfZHVja3x0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3dhbGt8dD1jfHY9dHJ1ZQpmYWtlbGFnX2Zha2VkZWZ8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9nbG9iYWx8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmNvbmRpdGlvbnx0PW98dj1zdGFuZApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2Vfd2Fsa3x0PXN8dj0wCnlhd19qaXR0ZXJfZHVjayt8dD1vfHY9b2ZmCmJvZHlfeWF3X21vZGVfZmFrZWxhZ3x0PW98dj1vZmYKc3RhdGljX2JvZHlfeWF3X2R1Y2srfHQ9c3x2PTAKeWF3X2ppdHRlcl9sZWdpdHx0PW98dj1vZmYKZW5hYmxlX21vdmV8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX2Jhc2VfZ2xvYmFsfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfbW92ZXx0PXN8dj00MgpkZWxheV9nbG9iYWx8dD1zfHY9MQpmaWZ0eV9maWZ0eV9mYWtlbGFnfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX3N0YW5kfHQ9Y3x2PXRydWU00=',
    Unmatched = 'dj0xCmJvZHlfeWF3X3ZhbHVlX2Zha2VsYWd8dD1zfHY9MgplbmFibGVfZHVjayt8dD1jfHY9dHJ1ZQp5YXdfaml0dGVyX21vdmV8dD1vfHY9b2ZmCnlhd19mYWtlbGFnfHQ9b3x2PW9mZgp5YXdfaml0dGVyX2Jhc2VfanVtcCt8dD1zfHY9MApmYWtlbGFnX3NldHRpbmdzX3NpZGV8dD1zfHY9MQpwaXRjaF9tb3ZlfHQ9b3x2PWRvd24KYm9keV95YXdfYmFzZV9tb3ZlfHQ9c3x2PTAKZmFrZWxhZ19mb3JjZV9vbnx0PW18dj0KZmFrZWxhZ19kZWZlbnNpdmV8dD1jfHY9ZmFsc2UKeWF3X3dhbGt8dD1vfHY9MTgwCnN0YXRpY19ib2R5X3lhd19mYWtlbGFnfHQ9c3x2PTAKcGl0Y2hfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9qdW1wfHQ9c3x2PTIKYm9keV95YXdfbW9kZV9zdGFuZHx0PW98dj1qaXR0ZXIKYm9keV95YXdfdmFsdWVfanVtcCt8dD1zfHY9Mgp5YXdfaml0dGVyX2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19iYXNlX2R1Y2srfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV9kdWNrK3x0PWN8dj10cnVlCnlhd19iYXNlX2Zha2VsYWd8dD1vfHY9dGFyZ2V0CnNlbmRfY29tYm9nbG9iYWx8dD1vfHY9Z2xvYmFsCnN0YXRpY19ib2R5X3lhd19qdW1wK3x0PXN8dj0wCmJvZHlfeWF3X3ZhbHVlX3dhbGt8dD1zfHY9MgplbmFibGVfd2Fsa3x0PWN8dj10cnVlCmRlbGF5X2xlZ2l0fHQ9c3x2PTEKeWF3X3N0YW5kfHQ9b3x2PTE4MApib2R5X3lhd19sZWZ0X2R1Y2t8dD1zfHY9LTM0CmJvZHlfeWF3X2xlZnRfc3RhbmR8dD1zfHY9LTIxCnJhbmRvbWl6ZV95YXdfc3RhbmR8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfZ2xvYmFsfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX3dhbGt8dD1zfHY9MApib2R5X3lhd19tb2RlX2R1Y2srfHQ9b3x2PWppdHRlcgpmYWtlbGFnX21vZGV8dD1vfHY9ZGVmZW5zaXZlCnBpdGNoX3dhbGt8dD1vfHY9ZG93bgp5YXdfaml0dGVyX2Jhc2VfanVtcHx0PXN8dj0xMjAKc2VuZF9jb21ib3dhbGt8dD1vfHY9Z2xvYmFsCmZha2VsYWdfc2V0dGluZ3NfZnJlZXN0YW5kaW5nfHQ9bXx2PXN0YXRpYwlkZWZlbnNpdmUKc2VuZF9jb21ib2p1bXB8dD1vfHY9Z2xvYmFsCnNlbmRfY29tYm9qdW1wK3x0PW98dj1nbG9iYWwKc3RhdGljX2JvZHlfeWF3X21vdmV8dD1zfHY9MApib2R5X3lhd19iYXNlX2R1Y2srfHQ9c3x2PTAKeWF3X2Jhc2VfZ2xvYmFsfHQ9b3x2PXRhcmdldAplbmFibGVfbGVnaXR8dD1jfHY9ZmFsc2UKZmFrZWxhZ19zZXR0aW5nc19lbmhhbmNlX29uc2hvdHx0PW18dj1kZWZlbnNpdmUJcm9sbAlqaXR0ZXIKc3RhdGljX2JvZHlfeWF3X2p1bXB8dD1zfHY9MAp5YXdfaml0dGVyX2Jhc2VfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF93YWxrfHQ9c3x2PTIzCnNlbmRfY29tYm9sZWdpdHx0PW98dj1nbG9iYWwKYm9keV95YXdfbGVmdF9sZWdpdHx0PXN8dj0wCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2R1Y2t8dD1jfHY9dHJ1ZQpib2R5X3lhd192YWx1ZV9sZWdpdHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfZmFrZWxhZ3x0PXN8dj0wCnlhd19qdW1wK3x0PW98dj0xODAKZGVsYXlfd2Fsa3x0PXN8dj0xCmZha2VsYWdfZmFrZWxhZ190eXBlMnx0PW98dj1tYXgKeWF3X2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX3N0YW5kfHQ9c3x2PTIKZW5hYmxlX2p1bXArfHQ9Y3x2PXRydWUKc2VuZF9jb21ib2Zha2VsYWd8dD1vfHY9Z2xvYmFsCnlhd19qaXR0ZXJfYmFzZV9kdWNrfHQ9c3x2PTAKZmlmdHlfZmlmdHlfanVtcHx0PWN8dj1mYWxzZQpwaXRjaF9sZWdpdHx0PW98dj1vZmYKeWF3X2ppdHRlcl9iYXNlX3N0YW5kfHQ9c3x2PTAKeWF3X2R1Y2srfHQ9b3x2PTE4MApib2R5X3lhd19tb2RlX2p1bXB8dD1vfHY9aml0dGVyCmJvZHlfeWF3X3JpZ2h0X2R1Y2t8dD1zfHY9NDQKcmFuZG9taXplX3lhd19kdWNrK3x0PXN8dj0wCmJvZHlfeWF3X21vZGVfd2Fsa3x0PW98dj1zdGF0aWMKYm9keV95YXdfcmlnaHRfanVtcCt8dD1zfHY9NTQKb25seV9mbGlwX29uXzBfY2hva2VfZmFrZWxhZ3x0PWN8dj1mYWxzZQpmYWtlbGFnX3NldHRpbmdzX2FudGlicnV0ZXx0PW18dj0KeWF3X2Jhc2Vfd2Fsa3x0PW98dj10aHJlYXQKZmFrZWxhZ19zdGVhbGVyfHQ9Y3x2PWZhbHNlCmVuYWJsZV9zdGFuZHx0PWN8dj10cnVlCnlhd19qdW1wfHQ9b3x2PTE4MApib2R5X3lhd19iYXNlX3dhbGt8dD1zfHY9MApzdGF0aWNfYm9keV95YXdfc3RhbmR8dD1zfHY9MApyYW5kb21pemVfeWF3X2dsb2JhbHx0PXN8dj0wCmZpZnR5X2ZpZnR5X2R1Y2t8dD1jfHY9ZmFsc2UKYm9keV95YXdfbW9kZV9tb3ZlfHQ9b3x2PWppdHRlcgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9zdGFuZHx0PWN8dj10cnVlCmJvZHlfeWF3X2Jhc2VfanVtcHx0PXN8dj03CmJvZHlfeWF3X21vZGVfanVtcCt8dD1vfHY9aml0dGVyCnNlbmRfY29tYm9kdWNrfHQ9b3x2PWdsb2JhbApib2R5X3lhd19sZWZ0X2Zha2VsYWd8dD1zfHY9MAp5YXdfaml0dGVyX2R1Y2t8dD1vfHY9b2ZmCmZha2VsYWdfc3RlYWxlcl90YXJnZXR8dD1vfHY9dGhyZWF0CmZpZnR5X2ZpZnR5X2R1Y2srfHQ9Y3x2PWZhbHNlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2p1bXB8dD1jfHY9dHJ1ZQpmaWZ0eV9maWZ0eV9sZWdpdHx0PWN8dj1mYWxzZQpib2R5X3lhd19yaWdodF9qdW1wfHQ9c3x2PTI0CnJhbmRvbWl6ZV95YXdfZmFrZWxhZ3x0PXN8dj0wCnJhbmRvbWl6ZV95YXdfanVtcCt8dD1zfHY9MApib2R5X3lhd192YWx1ZV9zdGFuZHx0PXN8dj0yCmJvZHlfeWF3X2Jhc2VfanVtcCt8dD1zfHY9MApkZWxheV9kdWNrK3x0PXN8dj0zCmJvZHlfeWF3X21vZGVfbGVnaXR8dD1vfHY9b2ZmCmJvZHlfeWF3X3ZhbHVlX2R1Y2t8dD1zfHY9MgplbmFibGVfZHVja3x0PWN8dj10cnVlCmJvZHlfeWF3X3JpZ2h0X2dsb2JhbHx0PXN8dj0wCnNlbmRfY29tYm9tb3ZlfHQ9b3x2PWdsb2JhbApyYW5kb21pemVfeWF3X21vdmV8dD1zfHY9MApwaXRjaF9qdW1wfHQ9b3x2PWRvd24KeWF3X2Jhc2Vfc3RhbmR8dD1vfHY9dGhyZWF0Cnlhd19qaXR0ZXJfZmFrZWxhZ3x0PW98dj1vZmYKc2VuZF9jb21ib3N0YW5kfHQ9b3x2PWdsb2JhbApwaXRjaF9zdGFuZHx0PW98dj1kb3duCnlhd19qaXR0ZXJfc3RhbmR8dD1vfHY9b2ZmCmJvZHlfeWF3X2Jhc2VfbGVnaXR8dD1zfHY9MApvbmx5X2ZsaXBfb25fMF9jaG9rZV9nbG9iYWx8dD1jfHY9ZmFsc2UKeWF3X2Jhc2VfbGVnaXR8dD1vfHY9dGFyZ2V0CnN0YXRpY19ib2R5X3lhd193YWxrfHQ9c3x2PTAKYm9keV95YXdfcmlnaHRfZmFrZWxhZ3x0PXN8dj0wCmRlbGF5X2R1Y2t8dD1zfHY9NQpmYWtlbGFnX3NldHRpbmdzX3JvbGx8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfbGltaXR8dD1zfHY9MQpmYWtlbGFnX2Zha2VsYWdfdmFyaWFuY2V8dD1zfHY9MApmYWtlbGFnX2Zha2VsYWdfYW1vdW50fHQ9b3x2PWR5bmFtaWMKZmFrZWxhZ19mYWtlbGFnX3R5cGV8dD1vfHY9c29kaXVtCnlhd19qaXR0ZXJfZ2xvYmFsfHQ9b3x2PW9mZgpib2R5X3lhd19iYXNlX2dsb2JhbHx0PXN8dj0wCnJhbmRvbWl6ZV95YXdfd2Fsa3x0PXN8dj0wCmNmZ19zZWxlY3Rpb258dD1tfHY9YW50aWFpbQpib2R5X3lhd192YWx1ZV9tb3ZlfHQ9c3x2PTIKZmlmdHlfZmlmdHlfbW92ZXx0PWN8dj1mYWxzZQpkZWxheV9tb3ZlfHQ9c3x2PTMKeWF3X2ppdHRlcl9iYXNlX2R1Y2srfHQ9c3x2PTAKcmFuZG9taXplX3lhd19kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX2dsb2JhbHx0PXN8dj0wCmZha2VsYWdfc3RlYWxlcl90eXBlfHQ9b3x2PW1pbWljCmJvZHlfeWF3X3JpZ2h0X3N0YW5kfHQ9c3x2PTQwCnBpdGNoX2R1Y2t8dD1vfHY9ZG93bgpmYWtlbGFnX2Zha2VsYWd8dD1jfHY9dHJ1ZQplbmFibGVfbW92ZXx0PWN8dj10cnVlCmVuYWJsZV9nbG9iYWx8dD1jfHY9ZmFsc2UKYm9keV95YXdfbGVmdF9nbG9iYWx8dD1zfHY9MApib2R5X3lhd19yaWdodF9tb3ZlfHQ9c3x2PTQyCmZpZnR5X2ZpZnR5X3N0YW5kfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfbW92ZXx0PXN8dj0tMjMKYm9keV95YXdfdmFsdWVfZHVjayt8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXArfHQ9b3x2PW9mZgpvbmx5X2ZsaXBfb25fMF9jaG9rZV9qdW1wK3x0PWN8dj10cnVlCm9ubHlfZmxpcF9vbl8wX2Nob2tlX2xlZ2l0fHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZHVja3x0PW98dj1qaXR0ZXIKZGVsYXlfc3RhbmR8dD1zfHY9MQp5YXdfYmFzZV9tb3ZlfHQ9b3x2PXRocmVhdApvbmx5X2ZsaXBfb25fMF9jaG9rZV93YWxrfHQ9Y3x2PXRydWUKc3RhdGljX2JvZHlfeWF3X2xlZ2l0fHQ9c3x2PTAKc3RhdGljX2JvZHlfeWF3X2R1Y2t8dD1zfHY9MApwaXRjaF9qdW1wK3x0PW98dj1kb3duCmRlbGF5X2p1bXArfHQ9c3x2PTUKZmFrZWxhZ19mb3JjZXx0PWN8dj1mYWxzZQplbmFibGVfZmFrZWxhZ3x0PWN8dj1mYWxzZQpvbmx5X2ZsaXBfb25fMF9jaG9rZV9tb3ZlfHQ9Y3x2PXRydWUKeWF3X2Jhc2VfZHVja3x0PW98dj10aHJlYXQKYm9keV95YXdfYmFzZV9kdWNrfHQ9c3x2PTAKeWF3X2ppdHRlcl9iYXNlX21vdmV8dD1zfHY9MAp5YXdfZ2xvYmFsfHQ9b3x2PW9mZgpjYWNoZV9jcmVkZW50aWFsc3x0PWN8dj10cnVlCnJhbmRvbWl6ZV95YXdfbGVnaXR8dD1zfHY9MApib2R5X3lhd19yaWdodF9sZWdpdHx0PXN8dj0wCmRlbGF5X2dsb2JhbHx0PXN8dj0xCmRlbGF5X2p1bXB8dD1zfHY9MQpib2R5X3lhd19sZWZ0X2p1bXB8dD1zfHY9LTIwCnJhbmRvbWl6ZV95YXdfanVtcHx0PXN8dj0wCmJvZHlfeWF3X2xlZnRfd2Fsa3x0PXN8dj0tMTYKZmlmdHlfZmlmdHlfZ2xvYmFsfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X2xlZnRfanVtcCt8dD1zfHY9LTE4Cnlhd19kdWNrfHQ9b3x2PTE4MAp5YXdfYmFzZV9qdW1wK3x0PW98dj10aHJlYXQKeWF3X21vdmV8dD1vfHY9MTgwCmJvZHlfeWF3X2xlZnRfZHVjayt8dD1zfHY9LTE1CmVuYWJsZV9qdW1wfHQ9Y3x2PXRydWUKZmFrZWxhZ19mYWtlZGVmfHQ9Y3x2PWZhbHNlCmZpZnR5X2ZpZnR5X2p1bXArfHQ9Y3x2PWZhbHNlCmJvZHlfeWF3X21vZGVfZ2xvYmFsfHQ9b3x2PW9mZgp5YXdfYmFzZV9qdW1wfHQ9b3x2PXRocmVhdApjb25kaXRpb258dD1vfHY9ZHVjaysKc2VuZF9jb21ib2R1Y2srfHQ9b3x2PWdsb2JhbApwaXRjaF9mYWtlbGFnfHQ9b3x2PW9mZgpib2R5X3lhd19yaWdodF9kdWNrK3x0PXN8dj00NAp5YXdfaml0dGVyX3dhbGt8dD1vfHY9c2tpdHRlcgp5YXdfaml0dGVyX2R1Y2srfHQ9b3x2PW9mZgpib2R5X3lhd19tb2RlX2Zha2VsYWd8dD1vfHY9b2ZmCmRlbGF5X2Zha2VsYWd8dD1zfHY9MQpzdGF0aWNfYm9keV95YXdfZHVjayt8dD1zfHY9MAp5YXdfaml0dGVyX2xlZ2l0fHQ9b3x2PW9mZgpib2R5X3lhd192YWx1ZV9nbG9iYWx8dD1zfHY9Mgp5YXdfaml0dGVyX2p1bXB8dD1vfHY9b2ZmCmZpZnR5X2ZpZnR5X3dhbGt8dD1jfHY9ZmFsc2UKZmlmdHlfZmlmdHlfZmFrZWxhZ3x0PWN8dj1mYWxzZQpwaXRjaF9kdWNrK3x0PW98dj1kb3du0000',
    Community = '',
}
return e374]]
e981["require/abc/config_system"] = [[


local e377='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

local function e378(e379)
    return ((e379:gsub('.', function(e380)
        local e381,e377='',e380:byte()
        for i=8,1,-1 do e381=e381..(e377%2^i-e377%2^(i-1)>0 and '1' or '0') end
        return e381
    end)..'0000'):gsub('%d%d%d%d%d%d', function(e380)
        if (#e380 < 6) then return '' end
        return e377:sub(tonumber(e380,2)+1,tonumber(e380,2)+1)
    end)..({ '', '==', '=' })[#e379%3+1])
end

local function e382(e379)
    e379 = string.gsub(e379, '[^'..b..'=]', '')
    return (e379:gsub('.', function(e380)
        if e380 == '=' then return '' end
        local e381,e383='',(e377:find(e380)-1)
        for i=6,1,-1 do e381=e381..(e383%2^i-e383%2^(i-1)>0 and '1' or '0') end
        return e381
    end):gsub('%d%d%d%d%d%d%d%d', function(e380)
        if (#e380 ~= 8) then return '' end
        local e384=0
        for i=1,8 do e384=e384+(e380:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(e384)
    end))
end





local e385= database

local e386= {}
local e387= {}

local function e388(e389,e390,e391,e392)
    if not e389 or e389 == '' or not e390 or e387[e389] then return end
    e386[#e386+1] = { key = e389, ref = e390, type = e391, tab = e392 }
    e387[e389] = e386[#e386]
end

local function e393(e394)
    local function e395(e396,e394)
        if not e394 or #e394 == 0 then return true end
        if e396 == 'CFG' then return true end
        if not e396 then return true end
        for _, t in ipairs(e394) do if t == e396 then return true end end
        return false
    end

    local e397= { 'v=1' }
    for i = 1, #e386 do
        local e398= e386[i]
        if e395(e398.tab, e394) then
            local e399= e398.type
            local e400= ui.get(e398.ref)
            if e399 == 'c' then
                e397[#e397+1] = e398.key .. '|t=c|v=' .. (e400 and 'true' or 'false')
            elseif e399 == 's' then
                e397[#e397+1] = e398.key .. '|t=s|v=' .. tostring(e400 or 0)
            elseif e399 == 'o' then
                e397[#e397+1] = e398.key .. '|t=o|v=' .. tostring(e400 or '')
            elseif e399 == 'm' then
                if type(e400) == 'table' then
                    e397[#e397+1] = e398.key .. '|t=m|v=' .. table.concat(e400, '\t')
                end
            end
        end
    end
    return e378(table.concat(e397, '\n'))
end

local function e401(e402,e394)
    if not e402 or e402 == '' then return end
    local e403, e404= pcall(e382, e402)
    if not e403 or not e404 or e404 == '' then return end
    local function e395(e396,e394)
        if not e394 or #e394 == 0 then return true end
        if e396 == 'CFG' then return true end
        if not e396 then return true end
        for _, e399 in ipairs(e394) do if e399 == e396 then return true end end
        return false
    end
    for line in e404:gmatch('([^\n]+)') do
        if line ~= 'v=1' then
            local e389, e405, e406= line:match('^(.-)|t=(.)|v=(.*)$')
            if e389 and e405 and e406 then
                local e398= e387[e389]
                if e398 and e398.type == e405 and e395(e398.tab, e394) then
                    if e405 == 'c' then
                        ui.set(e398.ref, vseg == 'true')
                    elseif e405 == 's' then
                        local e407= tonumber(e406)
                        if e407 ~= nil then
                            ui.set(e398.ref, e407)
                        end
                    elseif e405 == 'o' then
                        pcall(ui.set, e398.ref, e406)
                    elseif e405 == 'm' then
                        local e408= {}
                        for token in e406:gmatch('[^\t]+') do e408[#e408+1] = token end
                        ui.set(e398.ref, e408)
                    end
                end
            end
        end
    end
end


local function e409(e410,e394)
    if not e410 or e410 == '' then return end
    local e402= e393(e394)
    e385.write('cfg:' .. e410, e402)
end


local function e411(e410,e394)
    if not e410 or e410 == '' then return end
    local e402= e385.read('cfg:' .. e410)
    if e402 then e401(e402, e394) end
end


local function e412(e410)
    if not e410 or e410 == '' then return end
    e385.write('cfg:' .. e410, nil)
end


local e413= {
    register = e388,
    build = e393,
    apply = e401,
    save = e409,
    load = e411,
    delete = e412,
}

return e413]]
e981["require/abc/garbage_collector"] = [[local e380= {}

local e381= {
    pause = 200,
    stepmul = 600,
    mode = "collect"
}

function e380.tune(e382)
	if type(e382) == "table" then
		if e382.pause then
			collectgarbage("setpause", e382.pause)
			e381.pause = e382.pause
		end
		if e382.stepmul then
			collectgarbage("setstepmul", e382.stepmul)
			e381.stepmul = e382.stepmul
		end
		if e382.mode then
			e381.mode = e382.mode
		end
	end
end

function e380.collect(e383)
	collectgarbage(e383 or e381.mode)
end

function e380.step(e384)
	return collectgarbage("step", e384 or 0)
end

function e380.stop()
	collectgarbage("stop")
end

function e380.restart()
	collectgarbage("restart")
end

function e380.memory()
	return collectgarbage("count")
end

function e380.status()
	return {
		memory = e380.memory(),
		pause = e381.pause,
		stepmul = e381.stepmul,
		mode = e381.mode
	}
end

local e385= 0
function e380.dynamic(e382)
	e382 = type(e382) == "table" and e382 or {}
	local e386= e382.min_interval or 0.6
	local e387= (globals and globals.realtime) and globals.realtime() or (e385 + e386)
	if e387 - e385 < e386 then
		return
	end
	e385 = e387

	local e384= e382.step_size or 20
	local e388= e382.full_threshold_kb or 65536
	local e389= e382.aggressive_threshold_kb or 12288

	local e390, e391= pcall(collectgarbage, "count")
	if not e390 or type(e391) ~= "number" then
		pcall(collectgarbage, "step", e384)
		return
	end

	if e391 >= e388 then
		pcall(collectgarbage, "collect")
		return
	end

	if e391 >= e389 then
		pcall(collectgarbage, "step", e384)
		pcall(collectgarbage, "step", e384)
		return
	end

	pcall(collectgarbage, "step", e384)
end

if lua and lua.defer then
	lua.defer(function()
		e380.collect()
	end)
end

return e380]]
e981["require/abc/hwid_check"] = [[local e383= require("ffi")
local e384= require("require/brain/dll")
local e385= 1
local e386= 1

local function e387()
    return globals.curtime and globals.curtime() or 0
end

local function e388()
    local shared= rawget(_G, "loader_shared")
    if not shared or type(shared) ~= "table" then
    return nil, "missing"
    end
    local e389= tonumber(shared.expires) or 0
    if e387() > e389 then
    return nil, "expired"
    end
    if type(shared.hwids) ~= "table" then
    return nil, "bad_hwids"
    end
    return shared, nil
end

local e390= false

local function e391()
    if not e384 or type(e384) ~= "table" or type(e384.get_hwid) ~= "function" then
        print("invalid hwid")
    return
    end

    local e392
    
    local e393, e394= pcall(e384.get_hwid)
    if e393 and e394 and e394 ~= e383.NULL then
    if type(e394) == "cdata" then
        local e395, e396= pcall(e383.string, e394)
        if e395 then e392 = e396 end
    else
        e392 = tostring(e394)
    end
    end

    if not e392 or e392 == "" then
        print("invalid hwid")
    end

    local shared, e397= e388()
    if not shared then
        print("invalid hwid")
    end

    local e398= shared.hwids
    local e399= false
    for i = 1, #e398 do
    local e400= tostring(e398[i] or "")
    if e400:find(tostring(e392), 1, true) then
        e399 = true
        break
    end
    end


    if e399 then
        local e401= rawget(_G, "loader_init_after_hwid")
        if not e390 and type(e401) == "function" then
        e390 = true
        local e402, e403= pcall(e401)
        if not e402 then
            print("invalid hwid")
        end
        end
    else
        print("invalid hwid")
    end
end

local e404= 0
local function e405()
    e404 = e404 + 1
    local shared= rawget(_G, "loader_shared")
    if shared then
    e391()
    return
    end
    if e404 > e385 then
        print("invalid hwid")
        return
    end

    if type(client.delay_call) == "function" then
        client.delay_call(e386, e405)
    else
        e391()
    end

end


e405()]]
e981["require/abc/login_system"] = [[local e386= {}


local function e387(e388)
	if client.hash_sha256 then
		return client.hash_sha256(e388)
	end
	
	return tostring(e388):reverse()
end


local e389= "acc_" .. "897ntv45ynvttyjt980745nyv0t485vn87t6"

local function e390()
	local e391= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local e392= ""
	for i = 1, 16 do
		local e393= math.random(1, #e391)
		e392 = e392 .. e391:sub(e393, e393)
	end
	return e392
end

function e386.hash_password(e394,e392)
	return e387(e392 .. e394)
end

function e386.verify_password(e394,e395,e392)
	return e386.hash_password(e394, e392) == e395
end

function e386.get_hwid()
	
	return tostring(client.userid_to_entindex(client.userid_to_entindex(1)))
end

function e386.store_credentials(e396,e394)
	local e392= e390()
	local e395= e386.hash_password(e394, e392)
	database.write("login_credentials", { username = e396, hash = e395, salt = e392 })
end

function e386.load_credentials()
	return database.read("login_credentials")
end


function e386.login(e396,e394)
	
	local e397= database.read(e389) or {}
	local e398= e397[e396]
	if e398 and e398.enabled ~= false then
		if e386.verify_password(e394, e398.hash, e398.salt) then
			e386.logged_in = true
			return true
		end
	end
	
	local e399= e386.load_credentials()
	if e399 and e399.username == e396 then
		if e386.verify_password(e394, e399.hash, e399.salt) then
			e386.logged_in = true
			return true
		end
	end
	e386.logged_in = false
	return false
end

function e386.logout()
	e386.logged_in = false
end

function e386.reset_password(e400)
	
	database.write("login_credentials", nil)
end



function e386.is_valid_invite(e401)
	if not e401 or e401 == "" then
		return false, nil
	end
	local e402= database.read(e389 .. ":invites") or {}
	local e403= e402[e401]
	if not e403 then
		return false, nil
	end
	if e403.used then
		return false, e403
	end
	return true, e403
end

function e386.add_account(e396,e394)
	local e392= e390()
	local e395= e386.hash_password(e394, e392)
	local e397= database.read(e389) or {}
	e397[e396] = { hash = e395, salt = e392, role = "user", enabled = true, orig_password = e394 }
	database.write(e389, e397)
end

function e386.register_with_invite(e401,e396,e394)
	if not e401 or e401 == '' then return false, 'no invite provided' end
	local e402= database.read(e389 .. ":invites") or {}
	local e403= e402[e401]
	if not e403 then return false, 'invalid invite' end
	if e403.used then return false, 'invite already used' end

	e386.add_account(e396, e394)

	e403.used = true
	e403.used_by = e396
	e403.redeemed_at = client.unix_time()
	e402[e401] = e403
	database.write(e389 .. ":invites", e402)

	return true
end

function e386.invalidate_invite(e401)
	local e402= database.read(e389 .. ":invites") or {}
	if e402[e401] then
		e402[e401] = nil
		database.write(e389 .. ":invites", e402)
		return true
	end
	return false
end

return e386
]]
e981["require/abc/menu_header"] = [[local e389, e390, e391= 1, 398, 49
local e392= 0.85 
local e393= { "AA", "PAINT", "MISC", "CFG" }
local e394= e393[e389]
local e395= {}
local e396= {
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS1.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS2.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS3.png",
    "C:/Program Files (x86)/Steam/steamapps/common/Counter-Strike Global Offensive/lua/GS4.png"
}
local e397

local e398= {
    size = {
        x = 6,
        y = 6,
        w = 120,
        h = 72, 
    },
    skeet_cur_tab = 8,
}

local function e399()
    local e400= { ui.menu_position() }
    local e401= { ui.mouse_position() }
    if not e400[1] or not e400[2] or not e401[1] or not e401[2] then
        return e398.skeet_cur_tab
    end

    for i = 1, 9 do
        local e402= { e398.size.x, e398.size.y + e398.size.h * (i - 1) }
        if e401[1] >= e400[1] + e402[1]
           and e401[1] <= e400[1] + e398.size.w + e402[1]
           and e401[2] >= e400[2] + e402[2]
           and e401[2] <= e400[2] + e398.size.h + e402[2] then
            return i
        end
    end

    return e398.skeet_cur_tab
end

local function e403()
    if not renderer.load_png or not readfile then return end
    for i, path in ipairs(e396) do
        if not e395[i] then
            local e404= readfile(path)
            if e404 then
                e395[i] = renderer.load_png(e404, e390, e391)
            end
        end
    end
end


local function e405()
    local e406= ui.is_menu_open()
    local e407, e408= ui.menu_position()
    local e409, e410= ui.menu_size()
    e409 = e409-2
    e407 = e407+1
    if e406 and e407 and e408 and e409 and e410 then
        local e411= (e398.skeet_cur_tab == 2)
        local e412= math.floor(90 * e392)
        local e413= math.max(1, math.floor(4 * e392))
        local e414= math.max(1, math.floor(3 * e392))
        local e415= math.max(1, math.floor(2 * e392))
        local e416= math.max(0, math.floor(1 * e392))
        local e417= 0
        local e418= e407 + e413
        local e419= e408 - math.floor(7 * e392) - e412
        local e420= e409 - 2 * e413

        if e411 then
            renderer.rectangle(e418-e413*1.3, e419-8, e420+2*e413*1.5-1, e412+16, 12, 12, 12, 255)
            renderer.rectangle(e418-e414*1.5, e419-7, e420+2*e414*1.5, e412+14, 60, 60, 60, 255)
            renderer.rectangle(e418-e415*1.51, e419-6, e420+2*e415*2, e412+12, 40, 40, 40, 255)
            renderer.rectangle(e418-e416, e419-3, e420+2*e416, e412+6, 60, 60, 60, 255)
            renderer.rectangle(e418-e417, e419-2, e420+2*e417, e412+4, 12, 12, 12, 255)

            local e421= nil
            if renderer.load_rgba then
                local e422, e423= pcall(renderer.load_rgba,
                    string.char(
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                        16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                        20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
                    ), 4, 4)
                if e422 and e423 then e421 = e423 end
            end
            if e421 and renderer.texture then
                renderer.texture(e421, e418-e417, e419-2, e420+2*e417, e412+4, 255,255,255,255, 'r')
            end

            if renderer.gradient then
                renderer.gradient(e418-e417, e419-2, (e420+2*e417)/2+1, 1, 59,175,222,255, 202,70,205,255, true)
                renderer.gradient(e418-e417+(e420+2*e417)/2+1, e419-2, (e420+2*e417)/2-1, 1, 202,70,205,255, 204,227,53,255, true)
            end

            local e424= math.max(1, math.floor(2 * e392))
            local e425= e419 - math.floor(8 * e392)

            local e426= math.max(1, math.floor(5 * e392))
            local e427= 60
            renderer.circle(e418-e413+e426, e425+e424/2, e426, 59,175,222, e427, 16)
            renderer.circle(e418+e420-e413-e417-e426, e425+e424/2, e426, 204,227,53, e427, 16)
        end

        local e428= 4
        local e429= e419 + e412 / 2
        local e430, e431= ui.mouse_position()
        local e432= {}
        local e433= e412
            local e434= math.max(1, math.floor(59 * e392))
            local e435= math.max(1, math.floor(e390 * e392))
            local e436= math.max(1, math.floor(e391 * e392))
            local e437= e428 * e435 + (e428 - 1) * e434
            local e438= math.max(0, e420 * 0.5)
            local e439= e418 + e438 + (e420 - 2 * e438 - e437) / 2
            if e437 > e420 then
                e434 = math.max(0, math.floor((e420 - e428 * e435) / (e428 - 1)))
                e437 = e428 * e435 + (e428 - 1) * e434
                e439 = e418 + (e420 - e437) / 2
            end
        e403()
        local e440= e420 / e428
        for i=1,e428 do
            local e441= e418 + (i-1) * e440
            local e442= e419
            e432[i] = {x=e441, y=e442, w=e440, h=e433}
            if e411 then
                if e389 == i then
                    renderer.rectangle(e441, e442, e440, e433+1, 32,32,32, 85)
                end
                local e443= e441 + e440/2 - e435/2
                local e444= e442 + e433/2 - e436/2
                if e395[i] then
                    renderer.texture(e395[i], e443, e444, e435, e436, 255,255,255,255, "f")
                else
                    renderer.text(e443 + e435/2, e444 + e436/2, 255,255,255,255, '+c', 0, tostring(i))
                end
            end
        end

        local e445= client.key_state(1)
        if e406 and e430 and e431 and ui.is_menu_open() then
            if e445 and not prev_mouse_down then
                for i=1,e428 do
                    local e446= e432[i]
                    if e430 >= e446.x and e430 <= e446.x+e446.w and e431 >= e446.y and e431 <= e446.y+e446.h then
                        e389 = i
                        e394 = e393[e389]
                    end
                end
                local e447= { ui.menu_position() }
                if e447[1] and e447[2] then
                    for si = 1, 9 do
                        local e402= { e398.size.x, e398.size.y + e398.size.h * (si - 1) }
                        if e430 >= e447[1] + e402[1]
                           and e430 <= e447[1] + e398.size.w + e402[1]
                           and e431 >= e447[2] + e402[2]
                           and e431 <= e447[2] + e398.size.h + e402[2] then
                            e398.skeet_cur_tab = si
                            break
                        end
                    end
                end
            end
            prev_mouse_down = e445
        else
            prev_mouse_down = false
        end
        local e448= e399()
        local e449= e398.skeet_cur_tab or 0
        local e450= "Skeet sel: " .. tostring(e449)
        if e448 and e448 ~= e449 then
            e450 = e450 .. "  (hover: " .. tostring(e448) .. ")"
        end
        if e411 then
            if renderer.measure_text then
                pcall(function() renderer.measure_text(nil, e450) end)
            end
            renderer.text(e418 + 6, e419 + e412 + 6, 200,200,200,255, nil, 0, e450)
        end
    end
end

local function e451()
    if not ui.is_menu_open() then return false end
    local e430, e431= ui.mouse_position()
    local e452, e453= ui.menu_position()
    local e454, e455= ui.menu_size()
    local e412= math.floor(90 * e392)
    local e413= math.max(1, math.floor(4 * e392))
    local e418, e419, e420= e452 + e413, e453 - math.floor(7 * e392) - e412, e454 - 2 * e413
    return not (
        e430 >= e452 and e430 <= e452 + e454 and e431 >= e453 and e431 <= e453 + e455
        or e430 >= e418 and e430 <= e418 + e420 and e431 >= e419 and e431 <= e419 + e412
    )
end

return {
    current_tab = function() return e394 end,
    current_tab_index = function() return e389 end,
    tab_names = e393,
    tab_sections = function() return e397 end,
    menu_position = function() return ui.menu_position() end,
    menu_size = function() return ui.menu_size() end,
    is_menu_open = function() return ui.is_menu_open() end,
    mouse_position = function() return ui.mouse_position() end,
    is_mouse_outside_menu = e451,
    draw_menu = e405
}]]
e981["require/abc/menu_setup"] = [[local e392= {
    ui = {},
    registered_items = {},
}

function e392.register_ui(e393,e394)
    
    
    
    if e394 and e394.key then
        for i = #e392.registered_items, 1, -1 do
            local e395= e392.registered_items[i]
            if e395 and e395.key == e394.key then
                
                pcall(function()
                    if e395.item then ui.set_visible(e395.item, false) end
                end)
                table.remove(e392.registered_items, i)
            end
        end
    end

    table.insert(e392.registered_items, {
        item = e393,
        key = e394.key,
        requires_login = e394.requires_login,
        tab = e394.tab,
        visible = e394.visible ~= false,
        config_type = e394.config_type,
        show_condition = e394.show_condition,
    })
    return e393
end

function e392.update_visibility(e396)
    for _, e395 in ipairs(e392.registered_items) do
        local e397= e395.visible
        if e395.requires_login and not e396 then
            e397 = false
        end
        if e395.show_condition then
            e397 = e395.show_condition()
        end
        if e395.item then
            ui.set_visible(e395.item, e397)
        end
    end
end

function e392.save_config()
    local e398= {}
    for _, e395 in ipairs(e392.registered_items) do
        if e395.key and e395.item then
            e398[e395.key] = ui.get(e395.item)
        end
    end
    return e398
end

function e392.load_config(e399)
    for _, e395 in ipairs(e392.registered_items) do
        if e395.key and e395.item and e399[e395.key] ~= nil then
            ui.set(e395.item, e399[e395.key])
        end
    end
end

local e400= {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

local e401= {

    { 'Rage', 'other', 'accuracy boost' },
    { 'Rage', 'other', 'anti-aim correction' },
    { 'rage', 'other', 'automatic fire' },
    { 'Rage', 'other', 'automatic penetration' },
    { 'Rage', 'other', 'silent aim' },
    { 'Rage', 'other', 'remove recoil' },
    { 'Rage', 'other', 'reduce aimstep' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'log misses due to spread' },
    { 'Rage', 'other', 'low fps mitigations ' },
    { 'rage', 'other', 'delay shot' },
    { 'Rage', 'other', 'quick peek assist' },
    { 'Rage', 'other', 'quick peek assist mode' },
    { 'Rage', 'other', 'quick peek assist distance' },
    { 'Rage', 'other', 'reduce aim step' },
    { 'Rage', 'other', 'maximum fov' },
    { 'Rage', 'other', 'low fps mitigations' },
    { 'Rage', 'other', 'duck peek assist' },


}

function e392.toggle_gamesense_menu(e397)
    e392.state = e392.state or {}
    e392.hidden_refs = e392.hidden_refs or {}
    for _, e395 in ipairs(e400) do
        local e402, e403, e404, e405, e406= pcall(ui.reference, e395[1], e395[2], e395[3], e395[4])
        if e402 then
            if e395[1] == 'AA' and e395[2] == 'Anti-aimbot angles' and e395[3] == 'Enabled' then
                e392.state.gs_enabled_ref = e403
                if e403 ~= nil and e397 then
                    if e392.state.gs_enabled_previous ~= nil then
                        ui.set(e403, e392.state.gs_enabled_previous)
                    end
                elseif e403 ~= nil and not e397 then
                    e392.state.gs_enabled_previous = ui.get(e403)
                    ui.set(e403, true)
                end
            end
            local e407= { e403, e404, e405, e406 }
            local e408= {}
            for _, ref in ipairs(e407) do
                if ref ~= nil then
                    ui.set_visible(ref, e397)
                    e408[#e408 + 1] = ref
                end
            end
            if not e397 and #e408 > 0 then
                table.insert(e392.hidden_refs, e408)
            end
        end
    end
    e392.state.gs_hidden = not e397
end

function e392.toggle_rage_menu(e397)
    e392.state = e392.state or {}
    e392.hidden_rage_refs = e392.hidden_rage_refs or {}
    e392.hidden_rage_refs = {} 

    for _, e395 in ipairs(e401) do
        local e402, e403, e404, e405, e406= pcall(ui.reference, e395[1], e395[2], e395[3])
        if e402 then
            local e407= { e403, e404, e405, e406 }
            local e408= {}
            for _, ref in ipairs(e407) do
                if ref ~= nil then
                    pcall(function() ui.set_visible(ref, e397) end)
                    e408[#e408 + 1] = ref
                end
            end
            if not e397 and #e408 > 0 then
                table.insert(e392.hidden_rage_refs, e408)
            end
        end
    end
    e392.state.rage_hidden = not e397
end

return e392]]
e981["require/abc/menu_visibility"] = [[local e395= {
	"global",
	"stand",
	"move",
	"duck",
	"duck+",
	"jump",
	"jump+",
	"walk",
	"fakelag",
	"legit",
}

local e396= require("require/abc/login_system")

local function e397(e398)
	if e398.menu_setup and e398.menu_setup.refresh_cfg_listbox then
		e398.menu_setup.refresh_cfg_listbox()
	end

	if e398 and not e398.login then
		e398.login = e396
	end
	e398.menu_setup.toggle_gamesense_menu(false)
	e398.menu_setup.toggle_rage_menu(true)
	e398.menu_setup.update_visibility(e398.login and e398.login.logged_in)
	local e399= (e398.login and e398.login.logged_in) or false

	local e400= not e399
	local e401= (e398.menu_header and e398.menu_header.current_tab and e398.menu_header.current_tab()) or e398.menu.current_tab()
	 	
	ui.set_visible(e398.menu_setup.ui.login_howto_header, e400)
	ui.set_visible(e398.menu_setup.ui.login_console_register, e400)
	ui.set_visible(e398.menu_setup.ui.login_menu_credentials, e400)
	ui.set_visible(e398.menu_setup.ui.login_press_login, e400)
	ui.set_visible(e398.menu_setup.ui.login_spacer1, e400)
	ui.set_visible(e398.menu_setup.ui.reset_header, e400)
	ui.set_visible(e398.menu_setup.ui.reset_step1, e400)
	ui.set_visible(e398.menu_setup.ui.reset_step2, e400)
	ui.set_visible(e398.menu_setup.ui.login_spacer2, e400)
	ui.set_visible(e398.menu_setup.ui.support_header, e400)
	ui.set_visible(e398.menu_setup.ui.support_discord, e400)
	ui.set_visible(e398.menu_setup.ui.login_username, e400)
	ui.set_visible(e398.menu_setup.ui.login_password, e400)
	ui.set_visible(e398.menu_setup.ui.cache_credentials, e400)
	ui.set_visible(e398.menu_setup.ui.login_button, e400)
	ui.set_visible(e398.menu_setup.ui.reset_button, e400)
	ui.set_visible(e398.menu_setup.ui.discord_button, e400)
	ui.set_visible(e398.menu_setup.ui.youtube_button, e400)
	ui.set_visible(e398.menu_setup.ui.sellhub_button, e400)
	ui.set_visible(e398.menu_setup.ui.logout_button, e399 and e401 == "CFG")

	if e398.menu_setup.ui.condition then
		local e402= ui.get(e398.menu_setup.ui.condition)
		for _, cond in ipairs(e395) do
			local e403= e399 and e401 == "AA" and e402 == cond
			local e404= 'enable_' .. cond
			if e398.menu_setup.ui[e404] then
				ui.set_visible(e398.menu_setup.ui[e404], e403)
				local e405= e398.safe.safe_get(e398.menu_setup.ui[e404])

				local e406= e398.menu_setup.ui['yaw_' .. cond] and ui.get(e398.menu_setup.ui['yaw_' .. cond]) or nil
				local e407= e398.menu_setup.ui['yaw_jitter_' .. cond] and ui.get(e398.menu_setup.ui['yaw_jitter_' .. cond]) or nil
				local e408= e398.menu_setup.ui['body_yaw_mode_' .. cond] and ui.get(e398.menu_setup.ui['body_yaw_mode_' .. cond]) or nil
				local e409= e398.menu_setup.ui['delay_' .. cond] and ui.get(e398.menu_setup.ui['delay_' .. cond]) or nil
				ui.set_visible(e398.menu_setup.ui['pitch_' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['yaw_base_' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['yaw_' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['label1_' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['label2_' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['label3_' .. cond], e403 and e405)
				local e410= e403 and e405 and (e406 ~= 'off' and e406 ~= 'ideal' and e406 ~= '3way')
				ui.set_visible(e398.menu_setup.ui['body_yaw_base_' .. cond], e410)
				local e411= e403 and e405 and (e406 == '180' or e406 == '3way')
				ui.set_visible(e398.menu_setup.ui['body_yaw_left_' .. cond], e411)
				ui.set_visible(e398.menu_setup.ui['body_yaw_right_' .. cond], e411)
				local e412= e403 and e405 and (e406 ~= 'off' and e406 ~= 'ideal')
				ui.set_visible(e398.menu_setup.ui['randomize_yaw_' .. cond], e412)
				local e413= e403 and e405 and (e407 ~= 'off')
				ui.set_visible(e398.menu_setup.ui['yaw_jitter_base_' .. cond], e413)
				local e414= e403 and e405 and (e408 == 'static')
				ui.set_visible(e398.menu_setup.ui['static_body_yaw_' .. cond], e414)
				local e415= e403 and e405 and (e408 == 'jitter' and e409 and e409 <= 0)
				ui.set_visible(e398.menu_setup.ui['body_yaw_value_' .. cond], e415)
				local e416= e403 and e405 and (e408 == 'jitter')
				ui.set_visible(e398.menu_setup.ui['delay_' .. cond], e416)
				ui.set_visible(e398.menu_setup.ui['yaw_jitter_' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['body_yaw_mode_' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['fifty_fifty_' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['only_flip_on_0_choke_' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['aa_label_space' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['aa_label_combo' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['send_button' .. cond], e403 and e405)
				ui.set_visible(e398.menu_setup.ui['send_combo' .. cond], e403 and e405)
			end
		end
		ui.set_visible(e398.menu_setup.ui.condition, e399 and e401 == "AA")
		ui.set_visible(e398.menu_setup.ui.condition_label, e399 and e401 == "AA")
		ui.set_visible(e398.menu_setup.ui.condition_label2, e399 and e401 == "AA")


		ui.set_visible(e398.menu_setup.ui.fakelag_mode, e399 and e401 == "AA")
		if e398.menu_setup.ui.fakelag_mode then
			local e417= ui.get(e398.menu_setup.ui.fakelag_mode)
			local e418= e399 and e401 == "AA"
			local e419= e418 and e417 == "defensive"
			local e420= e398.safe.safe_get(e398.menu_setup.ui.fakelag_defensive) == true
			ui.set_visible(e398.menu_setup.ui.fakelag_defensive, e419)
			ui.set_visible(e398.menu_setup.ui.fakelag_force, e419 and e420)
			ui.set_visible(e398.menu_setup.ui.fakelag_force_on, e419 and e420)
			ui.set_visible(e398.menu_setup.ui.fakelag_fakedef, e419 and e420)

			local e421= e418 and e417 == "stealer"
			local e422= e398.safe.safe_get(e398.menu_setup.ui.fakelag_stealer) == true
			ui.set_visible(e398.menu_setup.ui.fakelag_stealer, e421)
			ui.set_visible(e398.menu_setup.ui.fakelag_stealer_type, e421 and e422)
			ui.set_visible(e398.menu_setup.ui.fakelag_stealer_target, e421 and e422)
			ui.set_visible(e398.menu_setup.ui.fakelag_stealer_list, e421 and e422)
			ui.set_visible(e398.menu_setup.ui.fakelag_stealer_refresh, e421 and e422)
			ui.set_visible(e398.menu_setup.ui.fakelag_stealer_steal, e421 and e422)

			local e423= e418 and e417 == "fakelag"
			local e424= e398.safe.safe_get(e398.menu_setup.ui.fakelag_fakelag) == true
			local e425= e398.safe.safe_get(e398.menu_setup.ui.fakelag_fakelag_type) == "sodium"
			ui.set_visible(e398.menu_setup.ui.fakelag_fakelag, e423)
			ui.set_visible(e398.menu_setup.ui.fakelag_fakelag_type, e423 and e424)
			ui.set_visible(e398.menu_setup.ui.fakelag_fakelag_amount, e423 and e424 and not e425)
			ui.set_visible(e398.menu_setup.ui.fakelag_fakelag_variance, e423 and e424 and not e425)
			ui.set_visible(e398.menu_setup.ui.fakelag_fakelag_limit, e423 and e424 and not e425)
			ui.set_visible(e398.menu_setup.ui.fakelag_fakelag_type2, e423 and e424 and e425)

			local e426= e418 and e417 == "settings"
			ui.set_visible(e398.menu_setup.ui.fakelag_settings_freestanding, e426)
			ui.set_visible(e398.menu_setup.ui.fakelag_settings_enhance_onshot, e426)
			ui.set_visible(e398.menu_setup.ui.fakelag_settings_antibrute, e426)
			ui.set_visible(e398.menu_setup.ui.fakelag_settings_roll_label, e426)
			ui.set_visible(e398.menu_setup.ui.fakelag_settings_roll_checkbox, e426)
			local e427= e426 and e398.safe.safe_get(e398.menu_setup.ui.fakelag_settings_roll_checkbox) == true
			ui.set_visible(e398.menu_setup.ui.fakelag_settings_roll, e427)
			ui.set_visible(e398.menu_setup.ui.fakelag_settings_side, e427)
		end

		local e428= e399 and e401 == "PAINT" and ui.get(e398.menu_setup.ui.paint_indicators_enable) == true
		local e429= e399 and e401 == "PAINT" and e428 and ui.get(e398.menu_setup.ui.paint_indicators) ~= "off"
		local e430= e399 and e401 == "PAINT" and e428 and ui.get(e398.menu_setup.ui.paint_indicators) == "small"
		ui.set_visible(e398.menu_setup.ui.paint_indicators, e428)
		ui.set_visible(e398.menu_setup.ui.paint_indicators_enable, e429)
		ui.set_visible(e398.menu_setup.ui.paint_indicators_animation, e429)
		ui.set_visible(e398.menu_setup.ui.paint_indicators_bar, e430)
		ui.set_visible(e398.menu_setup.ui.paint_indicator_color, e429)

		local e431= e399 and e401 == "PAINT" and ui.get(e398.menu_setup.ui.paint_advertisement) == true
		ui.set_visible(e398.menu_setup.ui.paint_advertisement_color, e431)

		local e432= e399 and e401 == "PAINT" and ui.get(e398.menu_setup.ui.paint_watermark) == true
		ui.set_visible(e398.menu_setup.ui.paint_watermark_color, e432)

		local e433= e399 and e401 == "MISC" and e398.safe.safe_get(e398.menu_setup.ui.misc_dormantaimbot) == true
		ui.set_visible(e398.menu_setup.ui.misc_dormantaimbot_key, e433)
		ui.set_visible(e398.menu_setup.ui.misc_dormantaimbot_value, e433)

		local e434= e399 and e401 == "PAINT" and e398.safe.safe_get(e398.menu_setup.ui.paint_logger_checkbox) == true
		ui.set_visible(e398.menu_setup.ui.paint_logger, e434)
		ui.set_visible(e398.menu_setup.ui.paint_logger_animation, e434)
		ui.set_visible(e398.menu_setup.ui.paint_logger_color, e434)

		local e435= e399 and e401 == "PAINT" and e398.safe.safe_get(e398.menu_setup.ui.paint_aspect_ratio_checkbox) == true
		ui.set_visible(e398.menu_setup.ui.paint_aspect_ratio, e435)

		local e436= e399 and e401 == "PAINT" and e398.safe.safe_get(e398.menu_setup.ui.paint_third_person_distance_checkbox) == true
		ui.set_visible(e398.menu_setup.ui.paint_third_person_distance, e436)

	end

	local e437= {
		'aa_gskey_freestand',
		'aa_gskey_freestandh',
		'aa_gskey_slowmotion',
		'aa_gskey_slowmotionh',
		'aa_gskey_edgeyaw',
		'aa_gskey_edgeyawh',
		'aa_gskey_onshot',
		'aa_gskey_onshoth',
	}
	for _, key in ipairs(e437) do
		if e398.menu_setup.ui[key] then
			ui.set_visible(e398.menu_setup.ui[key], tab_name == "AA")
		end
	end

	local e438= {
		'misc_resolver',
		'misc_ragebot',
		'misc_dormantaimbot',
		'misc_exploit_fakelag',
		'misc_walkbot',
		'misc_backstab',
		'misc_spindead',
	}
	for _, key in ipairs(e438) do
		if e398.menu_setup.ui[key] then
			ui.set_visible(e398.menu_setup.ui[key], tab_name == "MISC")
		end
	end

	local e439= {
		'paint_target_info',
		'label_space2',
		'label_space3',
		'label_space4',
		'paint_entidx',
		'paint_filter_console',
		'paint_minimum_damage',
		'paint_show_damage_penetration',
		'paint_hitmiss_indicator',
		'paint_self_skeleton',
		'paint_bullet_tracer',
		'paint_lagcomp_box',
		'paint_lagcomp_box_color',
		'paint_presmoke',
		'paint_bombwarning',
		'paint_insults',
		'paint_rainbow_esp',
		'paint_molotov',
		'paint_lag_record',
		'paint_advertisement',
		'paint_advertisement_animation',
		'paint_clantag',
		'paint_aimbot_logs',
		'paint_indicators_label',
		'paint_indicators_enable',
		'label_space1',
		'paint_watermark',
		'paint_watermark_type',
		'paint_logger_label',
		'paint_logger_checkbox',
		'paint_hitmarker',
		'paint_hitmarker_color',
		'paint_warnings',
		'paint_animations',
		'paint_performance_mode',
		'paint_aspect_ratio_checkbox',
		'paint_third_person_distance_checkbox',
	}
	for _, key in ipairs(e439) do
		if e398.menu_setup.ui[key] then
			ui.set_visible(e398.menu_setup.ui[key], tab_name == "PAINT")
		end
	end

		local e440= {
			'cfg_load_button',
			'cfg_save_button',
			'cfg_delete_button',
			'cfg_refresh_button',
			'cfg_create_button',
			'cfg_export_button',
			'cfg_import_button',
			'cfg_input_box',
			'cfg_listbox',
			'cfg_selection',
			'cfg_cloud',
			'cfg_cloud_apply',
		}
		for _, key in ipairs(e440) do
			if e398.menu_setup.ui[key] then
				ui.set_visible(e398.menu_setup.ui[key], e399 and e401 == "CFG")
			end
		end

end

local function e441(e398)
	local e442= {
		e398.menu_setup.ui.condition,
		e398.menu_setup.ui.fakelag_mode,
	}
	for _, item in ipairs(e442) do
		if item then
			ui.set_callback(item, function()
				e397(e398)
			end)
		end
	end

	for _, cond in ipairs(e395) do
		local e443= {
			'enable_' .. cond,
			'yaw_' .. cond,
			'yaw_jitter_' .. cond,
			'body_yaw_mode_' .. cond,
			'fifty_fifty_' .. cond,
			'only_flip_on_0_choke_' .. cond,
			'aa_label_space' .. cond,
			'aa_label_combo' .. cond,
			'send_button' .. cond,
			'send_combo' .. cond,
		}
		for _, key in ipairs(e443) do
			local e444= e398.menu_setup.ui[key]
			if e444 then
				ui.set_callback(e444, function()
					e397(e398)
				end)
			end
		end
	end

	local e445= {
		'fakelag_defensive',
		'fakelag_stealer',
		'fakelag_fakelag',
		'fakelag_fakelag_type',
		'fakelag_settings_roll_label',
		'fakelag_settings_roll_checkbox',
	}
	for _, key in ipairs(e445) do
		local e444= e398.menu_setup.ui[key]
		if e444 then
			ui.set_callback(e444, function()
				e397(e398)
			end)
		end
	end

	if e398.menu_setup.ui.paint_indicators then
		ui.set_callback(e398.menu_setup.ui.paint_indicators, function()
			e397(e398)
		end)
	end

	if e398.menu_setup.ui.paint_advertisement then
		ui.set_callback(e398.menu_setup.ui.paint_advertisement, function()
			e397(e398)
		end)
	end
	
	if e398.menu_setup.ui.paint_watermark then
		ui.set_callback(e398.menu_setup.ui.paint_watermark, function()
			e397(e398)
		end)
	end

	if e398.menu_setup.ui.misc_dormantaimbot then
		ui.set_callback(e398.menu_setup.ui.misc_dormantaimbot, function()
			e397(e398)
		end)
	end

	if e398.menu_setup.ui.paint_logger_checkbox then
		ui.set_callback(e398.menu_setup.ui.paint_logger_checkbox, function()
			e397(e398)
		end)
	end

	if e398.menu_setup.ui.paint_aspect_ratio_checkbox then
		ui.set_callback(e398.menu_setup.ui.paint_aspect_ratio_checkbox, function()
			e397(e398)
		end)
	end

	if e398.menu_setup.ui.paint_third_person_distance_checkbox then
		ui.set_callback(e398.menu_setup.ui.paint_third_person_distance_checkbox, function()
			e397(e398)
		end)
	end

	if e398.menu_setup.ui.paint_indicators_enable then
		ui.set_callback(e398.menu_setup.ui.paint_indicators_enable, function()
			e397(e398)
		end)
	end

	if e398.login and type(e398.login.add_state_callback) == 'function' then
		e398.login.add_state_callback(function()
			e397(e398)
		end)
	end
end

return {
	update = e397,
	setup_callbacks = e441
}]]
e981["require/abc/push_gamesense"] = [[local e398= renderer
local e399= globals
local e400= string.char

local e401= nil
local function e402()
    if e401 then return e401 end
    if e398.load_rgba then
        local e403, e404= pcall(e398.load_rgba,
            string.char(
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
                16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
                20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
            ), 4, 4)
        if e403 and e404 then e401 = e404 end
    end
    return e401
end


local function e405(e406,e407,e408,e409,e410,e411)
    local e412= e406 - 3
    local e413= e407 - 40
    local e414= e408 + 5
    local e415= e409 + 1
    e398.rectangle(e406 - 10, e407 - 48, e408 + 20, e409 + 16, 0, 0, 0, 200)
    e398.rectangle(e406 - 9, e407 - 47, e408 + 18, e409 + 14, 60, 60, 60, 255)
    e398.rectangle(e406 - 8, e407 - 46, e408 + 16, e409 + 12, 40, 40, 40, 255)
    e398.rectangle(e406 - 5, e407 - 43, e408 + 10, e409 + 6, 60, 60, 60, 255)
    e398.rectangle(e406 - 4, e407 - 42, e408 + 8, e409 + 4, 12, 12, 12, 255)
    e398.rectangle(e406 - 4, e407 - 42, e408 + 8, e409 + 4, 32, 32, 32, 255)
    local e416= e402()
    if e416 and e398.texture then
        e398.texture(e416, e412, e413, e414, e415, 255,255,255,e410, 'r')
    else
        e398.rectangle(e412, e413, e414, e415, 0, 0, 0, 0)
    end

    
    if e398.gradient then
        e398.gradient(e406 - 4, e407 - 42, e408 / 2 + 1, 1, 59, 175, 222, 255, 202, 70, 205, 255, true)
        e398.gradient(e406 - 4 + e408 / 2, e407 - 42, e408 / 2 + 8.5, 1, 202, 70, 205, 255, 204, 227, 53, 255, true)
    end
    e398.text(e406, e407 - 40, 255, 255, 255, 255, '', nil, e411)
end

return e405
]]
e981["require/abc/push_logger"] = [[local e401= renderer
local e402= globals
local e403= client
local e404= entity
local e405= table.insert
local e406= table.remove
local e407= math.floor
local e408= math.sqrt
local e409= string.char


local e410, e411= pcall(require, "require/abc/menu_setup")


local e412, e413= pcall(ui.reference, 'misc', 'settings', 'menu color')

local e414= {}
local e415= 5

local function e416(e417,e418,e419,e420,e421,e422)
    if #e414 >= e415 then
        e406(e414, 1)
    end
    e405(e414, {
        text = tostring(e417),
        duration = e418 or 5,
        color = { e419 or 255, e420 or 255, e421 or 255, e422 or 255 },
        timestamp = e402 and e402.curtime and e402.curtime() or os.clock(),
    })
end

local function e423(e424)
    local e425, e426, e427= pcall(e401.measure_text, '', e424)
    if e425 and type(e426) == 'number' then return e426, e427 or 0 end
    e425, e426, h = pcall(e401.measure_text, e424)
    if e425 and type(e426) == 'number' then return e426, e427 or 0 end
    return 0, 0
end

local function e428(e429,e430,e431)
    if e429 < e430 then return e430 end
    if e429 > e431 then return e431 end
    return e429
end


local function e432()
    if e410 and e411 and e411.ui and e411.ui.paint_logger then
        local e425, e433= pcall(ui.get, e411.ui.paint_logger)
        if e425 and e433 then return true end
        return false
    end
    
    return true
end


local function e434()
    if e410 and e411 and e411.ui and e411.ui.paint_logger_animation then
        local e425, e429= pcall(ui.get, e411.ui.paint_logger_animation)
        if e425 and type(e429) == 'number' then return e429 end
    end
    return 0
end


local e435, e436= pcall(require, "require/abc/push_modern")
local e437, e438= pcall(require, "require/abc/push_gamesense")


local function e439(e440)
    local e441= 80
    local e442= e440 - 80
    local e443= 40
    local e444= e440 / 2 - 300
    local e445= e440 - e444 - 10
    e445 = e428(e445, e441 + e443, e442 - e443)
    local e446= e445 - e443
    local e447= e445 + e443
    return e446, e447, e445
end

local function e448()
    if not e401 or not e401.text then return end
    if not e432() then return end

    local e449= e434() or 0
    local e450= e402 and e402.curtime and e402.curtime()
    local e451, e440= e403 and e403.screen_size and e403.screen_size() or 800, 600
    local e452= e440 * 0.5 + (e440 * 0.5 * 1.8)
    local e453= 0
    for i = #e414, 1, -1 do
        local e454= e414[i]
        local e455= (e454.timestamp + e454.duration) - e450
        if e455 <= 0 then
            e406(e414, i)
        else
            local e456, e457= e423(e454.text)
            local e458= (e449 == 1) and 4 or 2
            local e459= 2
            local e460= e451 / 2 - e456 / 2
            local e461= e452 + e453
            local e462= 5
            local e463= e407((e454.color[4] or 255) * math.min(1, (e455 / e454.duration) * e462))
            local e464= (e454.duration - e455)
            local e465= (e454.duration > 0 and e454.duration or 1)
            local e466= e464 / e465
            local e467= 6
            local e468= e428(e466 * e467, 0, 1)
            local e469= e468
            
            
            local e470= math.min(0.5, e465 * 0.25)
            if e455 <= e470 then
                local e471= e455 / e470 
                e469 = e428(e471, 0, 1)
            end
            if e449 == 1 then
                e436(e460, e461, e456, 13, e463, e454.text, e469)
                e453 = e453 + (e457 + e458 * 2 + e408(e459 / 10) * 4)
            else
                e438(e460, e461, e456, 13, e463, e454.text)
                e453 = e453 + (e457 + e458 * 2 + e408(e459 / 10) * 35)
            end
        end
    end
end

if e403 and e403.set_event_callback then
    e403.set_event_callback('paint', e448)
else
    
    e403.set_event_callback('paint', e448)
end

return e416
]]
e981["require/abc/push_modern"] = [[local e404= renderer
local e405= ui
local e406= math.floor

local e407, e408= pcall(require, "require/abc/menu_setup")
local e409, e410= pcall(e405.reference, 'misc', 'settings', 'menu color')

local function e411(e412,e413,e414,e415,e416,e417,e418,e419,e420)
    if not e416 or e416 <= 0 then
        e404.rectangle(e412, e413, e414, e415, e417,e418,e419,e420)
        return
    end
    e404.rectangle(e412 + e416, e413, e414 - (e416 * 2), e415, e417,e418,e419,e420)
    e404.rectangle(e412, e413 + e416, e414, e415 - (e416 * 2), e417,e418,e419,e420)
    e404.circle(e412 + e416, e413 + e416, e417,e418,e419,e420, e416, 0, 1)
    e404.circle(e412 + e414 - e416, e413 + e416, e417,e418,e419,e420, e416, 0, 1)
    e404.circle(e412 + e416, e413 + e415 - e416, e417,e418,e419,e420, e416, 0, 1)
    e404.circle(e412 + e414 - e416, e413 + e415 - e416, e417,e418,e419,e420, e416, 0, 1)
end

local function e421(e422,e423,e424,e425)
    local e426, e427, e428, e429= e422 or 255, e423 or 140, e424 or 0, e425 or 255
    
    if e407 and e408 and e408.ui and e408.ui.paint_logger_color then
        local e430, e431, e432, e433, e434= pcall(e405.get, e408.ui.paint_logger_color)
        if e430 then
            if type(e431) == 'number' then
                e426 = e406(e431 or e426)
                e427 = e406(e432 or e427)
                e428 = e406(e433 or e428)
                e429 = e406(e434 or e429)
            elseif type(e431) == 'string' and #e431 == 12 then
                local e435
                e435, mr = pcall(function() return tonumber(e431:sub(1,3)) end)
                e435, mg = pcall(function() return tonumber(e431:sub(4,6)) end)
                e435, mb = pcall(function() return tonumber(e431:sub(7,9)) end)
                e435, ma = pcall(function() return tonumber(e431:sub(10,12)) end)
                e426 = e426 or e422; e427 = e427 or e423; e428 = e428 or e424; e429 = e429 or e425
            end
            return e426, e427, e428, e429
        end
    end

    
    if e409 and e410 then
        local e430, e431, e432, e433, e434= pcall(e405.get, e410)
        if e430 then
            if type(e431) == 'number' then
                e426 = e406(e431 or e426)
                e427 = e406(e432 or e427)
                e428 = e406(e433 or e428)
                e429 = e406(e434 or e429)
            elseif type(e431) == 'string' and #e431 == 12 then
                local e435
                e435, mr = pcall(function() return tonumber(e431:sub(1,3)) end)
                e435, mg = pcall(function() return tonumber(e431:sub(4,6)) end)
                e435, mb = pcall(function() return tonumber(e431:sub(7,9)) end)
                e435, ma = pcall(function() return tonumber(e431:sub(10,12)) end)
                e426 = e426 or e422; e427 = e427 or e423; e428 = e428 or e424; e429 = e429 or e425
            end
        end
    end
    return e426, e427, e428, e429
end

local function e436(e412,e413,e414,e415,e437,e438,e439)
    local e440= e412 - 4
    local e441= e413 - 40
    local e442= e414 + 8
    local e443= e415 + 1

    local e444= 6
    if e443 < 12 then e444 = math.max(1, math.floor(e443 / 2)) end
    local e445= math.max(1, e444 - 1)

    local e426, e427, e428, e429= e421(255, 140, 0, 255)
    local e446= e406((e429 or 255) * 0.95)

    e439 = math.max(0, math.min(1, e439 or 1))
    local e447= e440 - 1
    local e448= e441 - 1
    local e449= e442 + 2
    local e450= e443 + 2
    local e451= e449 / 2 + (e449 * 0.1)
    local e452= e406(e451 * e439)

    if e452 > 0 then
        local e453= math.min(e444 + 1, e406(e450 / 2), e406(e452 / 2))
        e411(e447, e448, e452, e450, e453, e426, e427, e428, e446)
        e411(e447 + e449 - e452, e448, e452, e450, e453, e426, e427, e428, e446)
    end
    e411(e440, e441, e442, e443, e444, 10, 10, 10, 230)
    e411(e440 + 1, e441 + 1, e442 - 2, e443 - 2, e445, 6, 6, 6, 220)
    if e404.gradient then
        e404.gradient(e440 + 2, e441 + 1, math.max(0, e442 - 4), 2, e426, e427, e428, e406(e446 * 0.14), e426, e427, e428, 0, true)
    end
    e404.text(e412, e413 - 40, 255, 255, 255, 255, '', nil, e438)
end

return e436]]
e981["require/abc/register"] = [[local e407= require("require.abc.login_system")
local e408= "acc_" .. "OIDFGNSOIGNSFGIOSNGOISNGIOS"

local function e409(e410)
    local e411= {}
    for part in e410:gmatch("%S+") do
        table.insert(e411, part)
    end
    return e411
end

client.set_event_callback("console_input", function(e412)
    local e411= e409(e412 or "")
    if #e411 == 0 then return end

    local e413= e411[1]:lower()
    if e413 ~= "register" then
        
        return
    end

    if #e411 < 4 then
        client.log("Usage: register <username> <password> <invite>")
        return
    end

    local e414= e411[2]
    local e415= e411[3]
    local e416= e411[4]

    local e417, e418= e407.is_valid_invite(e416)
    if not e417 then
        client.log("Register failed: invalid or used invite")
        return
    end

    local e419= database.read(e408) or {}
    if e419[e414] then
        client.log("Register failed: username already exists - ", e414)
        return
    end

    local e420, e421= e407.register_with_invite(e416, e414, e415)
    if e420 then
        client.log("Registered user:", e414)
    else
        client.log("Register failed:", e421 or "unknown error")
    end
end)]]
e981["require/abc/screen_logger"] = [[local e410= renderer
local e411= globals
local e412= client
local e413= table.insert
local e414= table.remove
local e415= math.floor




local e416= {}
local e417= 12

local function e418(e419)
    local e420, e421, e422= pcall(e410.measure_text, '', e419)
    if e420 and type(e421) == 'number' then return e421, e422 or 0 end
    e420, e421, h = pcall(e410.measure_text, e419)
    if e420 and type(e421) == 'number' then return e421, e422 or 0 end
    return 0, 0
end

local function e423(e424,e425,e426,e427,e428,e429)
    if not e424 then return end
    e425 = e425 or 4
    if #e416 >= e417 then
        e414(e416, 1)
    end
    e413(e416, {
        text = tostring(e424),
        duration = e425,
        color = { e426 or 255, e427 or 255, e428 or 255, e429 or 255 },
        ts = e411 and e411.curtime and e411.curtime() or os.clock(),
    })
    return true
end

local function e430()
    if not e410 or not e410.text then return end
    local e431= e411 and e411.curtime and e411.curtime() or os.clock()
    local e432, e433= e412 and e412.screen_size and e412.screen_size() or 800, 600

    local e434= 8
    local e435= 6
    local e436= 14
    local e437= 2

    local e438= e435

    for i = #e416, 1, -1 do
        local e439= e416[i]
        if not e439 then goto continue end
        local e440= e431 - (e439.ts or 0)
        local e441= (e439.duration or 4) - e440
        if e441 <= 0 then
            e414(e416, i)
        else
            local e442, e443= e418(e439.text)
            
            local e444= e415(e439.color[4] or 255)
            
            pcall(e410.text, e434, e438, e439.color[1] or 255, e439.color[2] or 255, e439.color[3] or 255, e444, 'b', 0, e439.text)
            e438 = e438 + (e443 > 0 and e443 or e436) + e437
        end
        ::continue::
    end
end

if e412 and e412.set_event_callback then
    e412.set_event_callback('paint', e430)
end

return e423]]
e981["require/brain/dll"] = [=[local ffi = require("ffi")

ffi.cdef([[
struct Vec3 { double x; double y; double z; };
struct AspectState { double original; double last; double last_update; int initialized; };
const char* clipboard_get();
int clipboard_set(const char* text);
int clipboard_empty();
int clantag_anim(double start_time, double now, char* out_buf, int out_buf_len);
void tracer_reset();
void tracer_push_shot(double sx, double sy, double sz, double t);
void tracer_set_impact(double ix, double iy, double iz, double t);
int tracer_collect(double now, double tracer_life, double fade_fraction, double pitch, double yaw, double fallback_dist, double base_alpha, double* out_buf, int max_lines);
 ]])


local function hex(val)
    local ok, num = pcall(ffi.cast, "uintptr_t", val)
    if not ok then return "<na>" end
    return string.format("0x%X", tonumber(num))
end

local function resolve_call_trampoline()
    local tramp = client.find_signature("engine.dll", "\xFF\xE1")
    if tramp == nil then
        return nil
    end
    return ffi.cast("void*", tramp)
end

local function make_import_thunk(sig_pattern, cast_type)
    local addr = client.find_signature("engine.dll", sig_pattern)
    if addr == nil then
        return nil
    end
    local ptr = ffi.cast("void***", ffi.cast("uintptr_t", addr) + 2)[0][0]
    return ptr
end

local call_trampoline = resolve_call_trampoline()
local gm_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B", "void *")
local gpa_thunk = make_import_thunk("\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05", "void *")

if gm_thunk and gpa_thunk then
else
    return
end

local function via_trampoline(target, signature, label)
    local fn = ffi.cast(signature, call_trampoline)
    return function(...)
        return fn(target, ...)
    end
end

local function to_wide(str)
    local buf = ffi.new("wchar_t[?]", #str + 1)
    for i = 1, #str do buf[i - 1] = string.byte(str, i) end
    buf[#str] = 0
    return buf
end

local GetModuleHandleA_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const char *)", "GMH A")
local GetModuleHandleW_tr = via_trampoline(gm_thunk, "void *(__thiscall *)(void *, const wchar_t *)", "GMH W")
local GetProcAddress_tr   = via_trampoline(gpa_thunk, "void *(__thiscall *)(void *, void *, const char *)", "GPA")

local function call_GetModuleHandle(name)
    local ok1, res1 = pcall(GetModuleHandleA_tr, name)
    if not ok1 then dbg("GetModuleHandleA tramp err", res1) end
    if ok1 and res1 ~= nil and res1 ~= ffi.NULL then
        return res1, "tramp ansi"
    end

    local ok2, res2 = pcall(GetModuleHandleW_tr, to_wide(name))
    if not ok2 then dbg("GetModuleHandleW tramp err", res2) end
    if ok2 and res2 ~= nil and res2 ~= ffi.NULL then
        return res2, "tramp wide"
    end

    return nil, "failed"
end

local function call_GetProcAddress(mod, name)
    local ok, res = pcall(GetProcAddress_tr, mod, name)
    if not ok then dbg("GetProcAddress tramp err", res) end
    if ok and res ~= nil and res ~= ffi.NULL then return res end
    return nil
end

local mod, gm_variant = call_GetModuleHandle("sodiumdll.dll")
if mod == nil then
    return
end

local function bind_export(name, cdecl_sig)
    local addr = call_GetProcAddress(mod, name)
    if addr == nil then
        return nil
    end
    return addr, ffi.cast(cdecl_sig, addr)
end

local add_addr, add_fn = bind_export("add", "int(__cdecl*)(int, int)")
local get_value_addr, get_value_fn = bind_export("get_value", "int(__cdecl*)(void)")
local pin_module_addr, pin_module_fn = bind_export("pin_module", "void(__cdecl*)(void)")
local release_module_addr, release_module_fn = bind_export("release_module", "void(__cdecl*)(void)")
local get_hwid_addr, get_hwid_fn = bind_export("get_hwid", "const char*(__cdecl*)(void)")
local clipboard_get_addr, clipboard_get_fn = bind_export("clipboard_get", "const char*(__cdecl*)(void)")
local clipboard_set_addr, clipboard_set_fn = bind_export("clipboard_set", "int(__cdecl*)(const char*)")
local clipboard_empty_addr, clipboard_empty_fn = bind_export("clipboard_empty", "int(__cdecl*)(void)")
local clantag_anim_addr, clantag_anim_fn = bind_export("clantag_anim", "int(__cdecl*)(double, double, char*, int)")
local tracer_reset_addr, tracer_reset_fn = bind_export("tracer_reset", "void(__cdecl*)(void)")
local tracer_push_shot_addr, tracer_push_shot_fn = bind_export("tracer_push_shot", "void(__cdecl*)(double, double, double, double)")
local tracer_set_impact_addr, tracer_set_impact_fn = bind_export("tracer_set_impact", "void(__cdecl*)(double, double, double, double)")
local tracer_collect_addr, tracer_collect_fn = bind_export("tracer_collect", "int(__cdecl*)(double, double, double, double, double, double, double, double*, int)")

local vec_make_addr, vec_make_fn = bind_export("vec_make", "struct Vec3(__cdecl*)(double, double, double)")
local vec_add_addr, vec_add_fn = bind_export("vec_add", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_sub_addr, vec_sub_fn = bind_export("vec_sub", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_mul_scalar_addr, vec_mul_scalar_fn = bind_export("vec_mul_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_div_scalar_addr, vec_div_scalar_fn = bind_export("vec_div_scalar", "struct Vec3(__cdecl*)(struct Vec3, double)")
local vec_unm_addr, vec_unm_fn = bind_export("vec_unm", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_length_addr, vec_length_fn = bind_export("vec_length", "double(__cdecl*)(struct Vec3)")
local vec_dot_addr, vec_dot_fn = bind_export("vec_dot", "double(__cdecl*)(struct Vec3, struct Vec3)")
local vec_cross_addr, vec_cross_fn = bind_export("vec_cross", "struct Vec3(__cdecl*)(struct Vec3, struct Vec3)")
local vec_normalized_addr, vec_normalized_fn = bind_export("vec_normalized", "struct Vec3(__cdecl*)(struct Vec3)")
local vec_distance_addr, vec_distance_fn = bind_export("vec_distance", "double(__cdecl*)(struct Vec3, struct Vec3)")

local m_clamp_addr, m_clamp_fn = bind_export("m_clamp", "double(__cdecl*)(double, double, double)")
local m_clamp01_addr, m_clamp01_fn = bind_export("m_clamp01", "double(__cdecl*)(double)")
local m_abs_addr, m_abs_fn = bind_export("m_abs", "double(__cdecl*)(double)")
local m_lerp_addr, m_lerp_fn = bind_export("m_lerp", "double(__cdecl*)(double, double, double)")
local m_distance2d_addr, m_distance2d_fn = bind_export("m_distance2d", "double(__cdecl*)(double, double, double, double)")
local m_distance3d_addr, m_distance3d_fn = bind_export("m_distance3d", "double(__cdecl*)(double, double, double, double, double, double)")
local m_rad_to_deg_addr, m_rad_to_deg_fn = bind_export("m_rad_to_deg", "double(__cdecl*)(double)")
local m_deg_to_rad_addr, m_deg_to_rad_fn = bind_export("m_deg_to_rad", "double(__cdecl*)(double)")
local m_wrap_degrees_addr, m_wrap_degrees_fn = bind_export("m_wrap_degrees", "double(__cdecl*)(double)")
local m_normalize_angle_addr, m_normalize_angle_fn = bind_export("m_normalize_angle", "double(__cdecl*)(double)")
local m_angle_diff_addr, m_angle_diff_fn = bind_export("m_angle_diff", "double(__cdecl*)(double, double)")
local m_lerp_angle_addr, m_lerp_angle_fn = bind_export("m_lerp_angle", "double(__cdecl*)(double, double, double)")
local m_map_addr, m_map_fn = bind_export("m_map", "double(__cdecl*)(double, double, double, double, double)")
local m_smoothstep_addr, m_smoothstep_fn = bind_export("m_smoothstep", "double(__cdecl*)(double, double, double)")
local aspect_update_addr, aspect_update_fn = bind_export("aspect_update", "void(__cdecl*)(void*, double, double, double, double*, int*)")

if not (add_fn and get_value_fn and pin_module_fn and release_module_fn and get_hwid_fn and
    vec_make_fn and vec_add_fn and vec_sub_fn and vec_mul_scalar_fn and vec_div_scalar_fn and
    vec_unm_fn and vec_length_fn and vec_dot_fn and vec_cross_fn and vec_normalized_fn and vec_distance_fn and
    m_clamp_fn and m_clamp01_fn and m_abs_fn and m_lerp_fn and m_distance2d_fn and m_distance3d_fn and
    m_rad_to_deg_fn and m_deg_to_rad_fn and m_wrap_degrees_fn and m_normalize_angle_fn and m_angle_diff_fn and
    m_lerp_angle_fn and m_map_fn and m_smoothstep_fn and aspect_update_fn and
    clipboard_get_fn and clipboard_set_fn and clipboard_empty_fn and clantag_anim_fn and
    tracer_reset_fn and tracer_push_shot_fn and tracer_set_impact_fn and tracer_collect_fn) then
    return
end

local Call_add = via_trampoline(add_addr, "int(__thiscall *)(void*, int, int)", "add")
local Call_get_value = via_trampoline(get_value_addr, "int(__thiscall *)(void*)", "get_value")
local Call_pin_module = via_trampoline(pin_module_addr, "void(__thiscall *)(void*)", "pin_module")
local Call_release_module = via_trampoline(release_module_addr, "void(__thiscall *)(void*)", "release_module")
local Call_get_hwid = via_trampoline(get_hwid_addr, "const char*(__thiscall *)(void*)", "get_hwid")
local Call_clipboard_get = via_trampoline(clipboard_get_addr, "const char*(__thiscall *)(void*)", "clipboard_get")
local Call_clipboard_set = via_trampoline(clipboard_set_addr, "int(__thiscall *)(void*, const char*)", "clipboard_set")
local Call_clipboard_empty = via_trampoline(clipboard_empty_addr, "int(__thiscall *)(void*)", "clipboard_empty")
local Call_clantag_anim = via_trampoline(clantag_anim_addr, "int(__thiscall *)(void*, double, double, char*, int)", "clantag_anim")
local Call_tracer_reset = via_trampoline(tracer_reset_addr, "void(__thiscall *)(void*)", "tracer_reset")
local Call_tracer_push_shot = via_trampoline(tracer_push_shot_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_push_shot")
local Call_tracer_set_impact = via_trampoline(tracer_set_impact_addr, "void(__thiscall *)(void*, double, double, double, double)", "tracer_set_impact")
local Call_tracer_collect = via_trampoline(tracer_collect_addr, "int(__thiscall *)(void*, double, double, double, double, double, double, double, double*, int)", "tracer_collect")
local Call_vec_make = via_trampoline(vec_make_addr, "struct Vec3(__thiscall *)(void*, double, double, double)", "vec_make")
local Call_vec_add = via_trampoline(vec_add_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_add")
local Call_vec_sub = via_trampoline(vec_sub_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_sub")
local Call_vec_mul_scalar = via_trampoline(vec_mul_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_mul_scalar")
local Call_vec_div_scalar = via_trampoline(vec_div_scalar_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, double)", "vec_div_scalar")
local Call_vec_unm = via_trampoline(vec_unm_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_unm")
local Call_vec_length = via_trampoline(vec_length_addr, "double(__thiscall *)(void*, struct Vec3)", "vec_length")
local Call_vec_dot = via_trampoline(vec_dot_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_dot")
local Call_vec_cross = via_trampoline(vec_cross_addr, "struct Vec3(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_cross")
local Call_vec_normalized = via_trampoline(vec_normalized_addr, "struct Vec3(__thiscall *)(void*, struct Vec3)", "vec_normalized")
local Call_vec_distance = via_trampoline(vec_distance_addr, "double(__thiscall *)(void*, struct Vec3, struct Vec3)", "vec_distance")

local Call_m_clamp = via_trampoline(m_clamp_addr, "double(__thiscall *)(void*, double, double, double)", "m_clamp")
local Call_m_clamp01 = via_trampoline(m_clamp01_addr, "double(__thiscall *)(void*, double)", "m_clamp01")
local Call_m_abs = via_trampoline(m_abs_addr, "double(__thiscall *)(void*, double)", "m_abs")
local Call_m_lerp = via_trampoline(m_lerp_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp")
local Call_m_distance2d = via_trampoline(m_distance2d_addr, "double(__thiscall *)(void*, double, double, double, double)", "m_distance2d")
local Call_m_distance3d = via_trampoline(m_distance3d_addr, "double(__thiscall *)(void*, double, double, double, double, double, double)", "m_distance3d")
local Call_m_rad_to_deg = via_trampoline(m_rad_to_deg_addr, "double(__thiscall *)(void*, double)", "m_rad_to_deg")
local Call_m_deg_to_rad = via_trampoline(m_deg_to_rad_addr, "double(__thiscall *)(void*, double)", "m_deg_to_rad")
local Call_m_wrap_degrees = via_trampoline(m_wrap_degrees_addr, "double(__thiscall *)(void*, double)", "m_wrap_degrees")
local Call_m_normalize_angle = via_trampoline(m_normalize_angle_addr, "double(__thiscall *)(void*, double)", "m_normalize_angle")
local Call_m_angle_diff = via_trampoline(m_angle_diff_addr, "double(__thiscall *)(void*, double, double)", "m_angle_diff")
local Call_m_lerp_angle = via_trampoline(m_lerp_angle_addr, "double(__thiscall *)(void*, double, double, double)", "m_lerp_angle")
local Call_m_map = via_trampoline(m_map_addr, "double(__thiscall *)(void*, double, double, double, double, double)", "m_map")
local Call_m_smoothstep = via_trampoline(m_smoothstep_addr, "double(__thiscall *)(void*, double, double, double)", "m_smoothstep")
local Call_aspect_update = via_trampoline(aspect_update_addr, "void(__thiscall *)(void*, void*, double, double, double, double*, int*)", "aspect_update")


return {
    add = function(a, b)
        return Call_add(a, b)
    end,
    get_value = function()
        return Call_get_value()
    end,
    pin_module = function()
        return Call_pin_module()
    end,
    release_module = function()
        return Call_release_module()
    end,
    get_hwid = function()
        return Call_get_hwid()
    end,
    clipboard_get = function()
        return Call_clipboard_get()
    end,
    clipboard_set = function(text)
        return Call_clipboard_set(text)
    end,
    clipboard_empty = function()
        return Call_clipboard_empty()
    end,
    clantag_anim = function(start_time, now, out_buf, out_buf_len)
        return Call_clantag_anim(start_time, now, out_buf, out_buf_len)
    end,
    tracer_reset = function()
        return Call_tracer_reset()
    end,
    tracer_push_shot = function(sx, sy, sz, t)
        return Call_tracer_push_shot(sx, sy, sz, t)
    end,
    tracer_set_impact = function(ix, iy, iz, t)
        return Call_tracer_set_impact(ix, iy, iz, t)
    end,
    tracer_collect = function(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
        return Call_tracer_collect(now, tracer_life, fade_fraction, pitch, yaw, fallback_dist, base_alpha, out_buf, max_lines)
    end,
    vec_make = function(x, y, z)
        return Call_vec_make(x, y, z)
    end,
    vec_add = function(a, b)
        return Call_vec_add(a, b)
    end,
    vec_sub = function(a, b)
        return Call_vec_sub(a, b)
    end,
    vec_mul_scalar = function(v, s)
        return Call_vec_mul_scalar(v, s)
    end,
    vec_div_scalar = function(v, s)
        return Call_vec_div_scalar(v, s)
    end,
    vec_unm = function(v)
        return Call_vec_unm(v)
    end,
    vec_length = function(v)
        return Call_vec_length(v)
    end,
    vec_dot = function(a, b)
        return Call_vec_dot(a, b)
    end,
    vec_cross = function(a, b)
        return Call_vec_cross(a, b)
    end,
    vec_normalized = function(v)
        return Call_vec_normalized(v)
    end,
    vec_distance = function(a, b)
        return Call_vec_distance(a, b)
    end,
    m_clamp = function(val, minVal, maxVal)
        return Call_m_clamp(val, minVal, maxVal)
    end,
    m_clamp01 = function(val)
        return Call_m_clamp01(val)
    end,
    m_abs = function(val)
        return Call_m_abs(val)
    end,
    m_lerp = function(a, b, t)
        return Call_m_lerp(a, b, t)
    end,
    m_distance2d = function(x1, y1, x2, y2)
        return Call_m_distance2d(x1, y1, x2, y2)
    end,
    m_distance3d = function(x1, y1, z1, x2, y2, z2)
        return Call_m_distance3d(x1, y1, z1, x2, y2, z2)
    end,
    m_rad_to_deg = function(rad)
        return Call_m_rad_to_deg(rad)
    end,
    m_deg_to_rad = function(deg)
        return Call_m_deg_to_rad(deg)
    end,
    m_wrap_degrees = function(angle)
        return Call_m_wrap_degrees(angle)
    end,
    m_normalize_angle = function(angle)
        return Call_m_normalize_angle(angle)
    end,
    m_angle_diff = function(a, b)
        return Call_m_angle_diff(a, b)
    end,
    m_lerp_angle = function(a, b, t)
        return Call_m_lerp_angle(a, b, t)
    end,
    m_map = function(val, in_min, in_max, out_min, out_max)
        return Call_m_map(val, in_min, in_max, out_min, out_max)
    end,
    m_smoothstep = function(edge0, edge1, x)
        return Call_m_smoothstep(edge0, edge1, x)
    end,
    aspect_update = function(state, raw_slider, current_aspect, now, out_target, out_dirty)
        return Call_aspect_update(state, raw_slider, current_aspect, now, out_target, out_dirty)
    end,
    module_base = mod,
}]=]
e981["require/brain/test"] = [[local e416= require("require/brain/api/math/math")
local e417= require("require/brain/api/health/health")
local e418= require("require/brain/api/hwid/hwid")
local e419= require("require/brain/dll")


client.set_event_callback("paint_ui", function()
    local e420, e421= pcall(e416.add, 2, math.random(1, 100))
    if e420 then
        
    end

end)

local e422, e423= pcall(e418.get_hwid)
if e422 and e423 and e423 ~= "" then
    
else
    
end]]
e981["require/brain/api/clipboard/clipboard"] = [[]]
e981["require/brain/api/health/health"] = [[local e422= require("require/brain/dll")

if not e422 then
	error("sodiumdll exports unavailable")
end

return {
	pin_module = function()
		return e422.pin_module()
	end,
	release_module = function()
		return e422.release_module()
	end,
	module_base = e422.module_base,
}]]
e981["require/brain/api/hwid/hwid"] = [[local e425= require("ffi")
local e426= require("require/brain/dll")

if not e426 or not e426.get_hwid then
    error("sodiumdll hwid export missing")
end

return {
	get_hwid = function()
		local e427= e426.get_hwid()
		if not e427 or e427 == e425.NULL then
			return ""
		end
		return e425.string(e427)
	end,
}]]
e981["require/brain/api/ip/ip"] = [[
local e428= require("require/brain/dll")

if not e428 or not e428.get_public_ip then
	return error("sodiumdll ip export missing")
end

return {
	get_public_ip = function(e429,e430)
		return e428.get_public_ip(e429, e430)
	end,
}]]
e981["require/brain/api/math/math"] = [[local e431= require("require/brain/dll")

if not e431 or not e431.m_clamp then
	error("sodiumdll math exports missing")
end

return {
	add = function(e432,e433)
		return e431.add(e432, e433)
	end,
	get_value = function()
		return e431.get_value()
	end,
	m_clamp = function(e434,e435,e436)
		return e431.m_clamp(e434, e435, e436)
	end,
	m_clamp01 = function(e434)
		return e431.m_clamp01(e434)
	end,
	m_abs = function(e434)
		return e431.m_abs(e434)
	end,
	m_lerp = function(e432,e433,e437)
		return e431.m_lerp(e432, e433, e437)
	end,
	m_distance2d = function(e438,e439,e440,e441)
		return e431.m_distance2d(e438, e439, e440, e441)
	end,
	m_distance3d = function(e438,e439,e442,e440,e441,e443)
		return e431.m_distance3d(e438, e439, e442, e440, e441, e443)
	end,
	m_rad_to_deg = function(e444)
		return e431.m_rad_to_deg(e444)
	end,
	m_deg_to_rad = function(e445)
		return e431.m_deg_to_rad(e445)
	end,
	m_wrap_degrees = function(e446)
		return e431.m_wrap_degrees(e446)
	end,
	m_normalize_angle = function(e446)
		return e431.m_normalize_angle(e446)
	end,
	m_angle_diff = function(e432,e433)
		return e431.m_angle_diff(e432, e433)
	end,
	m_lerp_angle = function(e432,e433,e437)
		return e431.m_lerp_angle(e432, e433, e437)
	end,
	m_map = function(e434,e447,e448,e449,e450)
		return e431.m_map(e434, e447, e448, e449, e450)
	end,
	m_smoothstep = function(e451,e452,e453)
		return e431.m_smoothstep(e451, e452, e453)
	end,
}]]
e981["require/brain/api/vector/vector"] = [[local e434= require("ffi")
local e435= require("require/brain/dll")

if not e435 or not e435.vec_make or not e435.vec_add or not e435.vec_sub or not e435.vec_mul_scalar or
   not e435.vec_div_scalar or not e435.vec_unm or not e435.vec_length or not e435.vec_dot or
   not e435.vec_cross or not e435.vec_normalized or not e435.vec_distance or not e435.aspect_update then
    error("sodiumdll vector exports missing")
end

local e436= e434.typeof("struct Vec3")

local function e437(e438)
    if e434.istype(e436, e438) then
        return e438
    end
    local e439= (e438 and e438.x) or 0
    local e440= (e438 and e438.y) or 0
    local e441= (e438 and e438.z) or 0
    return e435.vec_make(e439, e440, e441)
end

return {
    Vec3 = e436,
    make = function(e439,e440,e441)
        return e435.vec_make(e439 or 0, e440 or 0, e441 or 0)
    end,
    add = function(e442,e443)
        return e435.vec_add(e437(e442), e437(e443))
    end,
    sub = function(e442,e443)
        return e435.vec_sub(e437(e442), e437(e443))
    end,
    mul_scalar = function(e438,e444)
        return e435.vec_mul_scalar(e437(e438), e444)
    end,
    div_scalar = function(e438,e444)
        return e435.vec_div_scalar(e437(e438), e444)
    end,
    unm = function(e438)
        return e435.vec_unm(e437(e438))
    end,
    length = function(e438)
        return e435.vec_length(e437(e438))
    end,
    dot = function(e442,e443)
        return e435.vec_dot(e437(e442), e437(e443))
    end,
    cross = function(e442,e443)
        return e435.vec_cross(e437(e442), e437(e443))
    end,
    normalized = function(e438)
        return e435.vec_normalized(e437(e438))
    end,
    distance = function(e442,e443)
        return e435.vec_distance(e437(e442), e437(e443))
    end,
    aspect_update = e435.aspect_update,
}]]
e981["require/brain/examples/boxes"] = [[local e437= require("ffi")
local e438= {


}


e438.GetModuleHandlePtr = 
    e437.cast(
        "void***", 
        e437.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B")) + 2
    )[0][0]

e438.GetProcAddressPtr = 
    e437.cast(
        "void***", 
        e437.cast("uint32_t", client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05")) + 2
    )[0][0]


e438.reinterpret_cast = function(e439,e440) 
    return function(...) 
        return e437.cast(e440, client.find_signature("engine.dll", "\xFF\xE1"))(e439, ...) 
    end
end


e438.fnGetModuleHandle = e438.reinterpret_cast(
    e438.GetModuleHandlePtr, 
    "void*(__thiscall*)(void*, const char*)"
)

e438.GetModuleHandle = function(e441)
    return e438.fnGetModuleHandle(e441)
end 


e438.fnGetProcAddress = e438.reinterpret_cast(
    e438.GetProcAddressPtr, 
    "void*(__thiscall*)(void*, void*, const char*)"
)

e438.GetProcAddress = function(e441,e442)
    local e439= e438.fnGetProcAddress(e441, e442)
    return e439
end 


e438.lib = {}
e438.lib.user32 = e438.GetModuleHandle("user32.dll")


e438.export = {}
e438.export.user32 = {}

e438.export.user32.MessageBoxPtr = e438.GetProcAddress(e438.lib.user32, "MessageBoxA")
e438.export.user32.MessageBox = e438.reinterpret_cast(
    e438.export.user32.MessageBoxPtr,
    "int(__thiscall*)(void*, void*, const char*, const char*, unsigned int)"
)


local e443= 0x00000000
local e444= 0x00000001
local e445= 0x00000004
local e446= 0x00000010
local e447= 0x00000020
local e448= 0x00000030
local e449= 0x00000040


local e450= 1
local e451= 2
local e452= 6
local e453= 7


local function e454(e455,e456,e457)
    e456 = e456 or "Gamesense"
    e457 = e457 or e443
    
    local e458= e438.export.user32.MessageBox(nil, e455, e456, e457)
    return e458
end


local function e459(e455,e456)
    return e454(e455, e456, e443 + e449)
end

local function e460(e455,e456)
    return e454(e455, e456, e443 + e448)
end

local function e461(e455,e456)
    return e454(e455, e456, e443 + e446)
end

local function e462(e455,e456)
    local e458= e454(e455, e456, e445 + e447)
    return e458 == e452
end
e459("test", "test")]]
e981["require/brain/features/aspectratio"] = [[local e440= require("ffi")
local e441= require("require/brain/dll")

if not e441 or not e441.aspect_update then
    error("sodiumdll aspect_update export missing")
end

return {
    aspect_update = function(e442,e443,e444,e445)
        local e446= e440.new("double[1]")
        local e447= e440.new("int[1]")

        e441.aspect_update(e442 or e440.NULL, e443, e444, e445, e446, e447)

        return e446[0], e447[0]
    end,
}]]
e981["require/features/aa/aa_collect"] = [[
local e443= entity
local e444= require('require/abc/menu_setup')
local e445= require('require/aa/player_condition')

local e446= {}
e446.last_side = 'left'

local function e447()
    local e448, e449= pcall(e445.get)
    if not e448 or not e449 then return nil end
    local e450= 'delay_' .. e449
    if not (e444 and e444.ui) then return nil end
    local e451= e444.ui[e450]
    if not e451 then return nil end
    local e452, e453= pcall(ui.get, e451)
    if not e452 then return nil end
    local e454= tonumber(e453)
    if e454 then return e454 end
    return e453
end

local function e455()
    local e448, e449= pcall(e445.get)
    if not e448 or not e449 then return nil end
    local e450= 'fifty_fifty_' .. e449
    if not (e444 and e444.ui) then return nil end
    local e451= e444.ui[e450]
    if not e451 then return nil end
    local e452, e453= pcall(ui.get, e451)
    if not e452 then return nil end
    local e454= tonumber(e453)
    if e454 then return e454 end
    return e453
end

local function e456()
    local e448, e449= pcall(e445.get)
    if not e448 or not e449 then return nil end
    local e450= 'body_yaw_mode_' .. e449
    if not (e444 and e444.ui) then return nil end
    local e451= e444.ui[e450]
    if not e451 then return nil end
    local e452, e453= pcall(ui.get, e451)
    if not e452 then return nil end
    local e454= tonumber(e453)
    if e454 then return e454 end
    return e453
end

local function e457(e458)
    if not (e443 and e443.get_prop and e458) then return e446.last_side end
    local e459= e443.get_prop(e458, 'm_flPoseParameter', 11)
    if e459 == nil then
        return e446.last_side
    end
    local e460= (e459 > 0.5) and 'right' or 'left'
    e446.last_side = e460
    return e460
end

local function e461()
    local e462= e447() + 1
    local e454= tonumber(e462) or 1
    if e454 < 1 then e454 = 1 end
    if e454 > 17 then e454 = 17 end

    local e463= globals.tickcount()
    if not e463 then return e446.last_side end

    local e464= math.floor(e463 / e454) % 2
    local e460= (e464 == 0) and 'left' or 'right'
    e446.last_side = e460
    return e460
end




local function e465()

    local e466= e455()

    if e466 then
        local e467= math.random(0, 1)
        local e460= (e467 == 0) and 'left' or 'right'
        e446.last_side = e460
        return e460
    end

    local e462= e447()
    local e454= tonumber(e462)

    if e456() ~= 'jitter' then
        return e457(e443.get_local_player())
    end

    if not e454 or e454 == 0 then
        local e458= e443.get_local_player()
        if not e458 or e458 == 0 then return e446.last_side end
        return e457(e458)
    else
        return e461()
    end
end





e446.resolve_side = e457
e446.resolve_local_side = e465
e446.get_delay_for_current_condition = e447

return e446]]
e981["require/features/aa/antiaim"] = [[local e446= require('require/features/aa/builder')
local e447= require('require/features/aa/defensive')

local e448= require('require/abc/callbacks')

local function e449()
    local e450= (globals.maxplayers and globals.maxplayers() or 64)
    local e451, e452, e453= entity.get_classname, entity.is_enemy, entity.is_alive
    if not (e451 and e452 and e453) then return 0 end
    local e454= 0
    for i=1,e450 do
        if e451(i) == 'CCSPlayer' and e452(i) and e453(i) then e454 = e454 + 1 end
    end
    return e454
end

e448.register('setup_command', function(e455)
    if e446 and e446.activate then
        e446.activate(e455)
    end

end, { alive_only = true, require_login = true })]]
e981["require/features/aa/antibrute"] = [[]]
e981["require/features/aa/builder"] = [[local e452= require('require/abc/menu_setup')
local e453= require('require/aa/player_condition')
local e454= require('require/features/aa/aa_collect')
local e455= require('require/help/math')
local e456= require('require/help/vector')
local e457= require('require/help/time')
local e458= require('require/help/string')

local e459= {}
client.set_event_callback('weapon_fire', function(e460)
  if not e460 or not e460.userid then return end
  local e461, e462= pcall(client.userid_to_entindex, e460.userid)
  if not e461 or not e462 or e462 == 0 then return end
  e459[e462] = e457.tickcount()
end)

local function e463(e464)
	if not e464 then return nil end

	local e465= {
		pitch = 'pitch_',
		yaw_base = 'yaw_base_',
		yaw = 'yaw_',
		body_yaw_base = 'body_yaw_base_',
		body_yaw_left = 'body_yaw_left_',
		body_yaw_right = 'body_yaw_right_',
		randomize_yaw = 'randomize_yaw_',
		yaw_jitter = 'yaw_jitter_',
		yaw_jitter_base = 'yaw_jitter_base_',
		body_yaw_mode = 'body_yaw_mode_',
		static_body_yaw = 'static_body_yaw_',
		body_yaw_value = 'body_yaw_value_',
		delay = 'delay_',
		fifty_fifty = 'fifty_fifty_',
		only_flip_on_0_choke = 'only_flip_on_0_choke_',
	}

	local e466= { condition = e464 }
	for name, prefix in pairs(e465) do
		local e467= prefix .. e464
		local e468= e452.ui and e452.ui[e467]
		if e468 then
			local e469, e470= pcall(ui.get, e468)
			if e469 then e466[name] = e470 else e466[name] = nil end
		else
			e466[name] = nil
		end
	end

	return e466
end




local function e471()
  local e469, e464= pcall(e453.get)
  if not e469 or not e464 then
    return nil
  end
  local e472= e463(e464)
  return e472 and e472.pitch or nil
end




local function e473()
  local e469, e464= pcall(e453.get)
  if not e469 or not e464 then
    return nil
  end
  local e472= e463(e464)
  local e474= e472 and e472.yaw_base or nil
  if e474 == nil then return nil end
  local e475= e458.lower(tostring(e474))
  if e475 == 'threat' then
    return 'local view'
  elseif e475 == 'distance' then
    return 'local view'
  elseif e475 == 'target' then
    return 'at targets'
  elseif e475 == 'view' then
    return 'local view'
  elseif e475 == 'smart' then
    return 'local view'
  else
    return tostring(e474)
  end
end




local function e476()
	local e469, e464= pcall(e453.get)
	if not e469 or not e464 then
		return nil
	end
	local e472= e463(e464)
	return e472 and e472.yaw or nil
end




local function e477()
    local e469, e464= pcall(e453.get)
    if not e469 or not e464 then
        return nil
    end
    local e472= e463(e464)
    return e472 and e472.yaw_jitter or nil
end




local function e478()
  local e469, e464= pcall(e453.get)
  if not e469 or not e464 then
    return nil
  end
  local e472= e463(e464)
  return e472 and e472.yaw_jitter_base or nil
end




local function e479()
  local e469, e464= pcall(e453.get)
  if not e469 or not e464 then return nil end
  local e472= e463(e464)
  if not e472 then return nil end
  local e480= e472.randomize_yaw
  if e480 == nil then return nil end
  local e481= tonumber(e480)
  if not e481 then return nil end
  if e481 < 0 then e481 = 0 end
  if e481 > 30 then e481 = 30 end
  return math.floor(e481)
end




local function e482()
    local e469, e464= pcall(e453.get)
    if not e469 or not e464 then
        return nil
    end
  local e472= e463(e464)
  local e483= e472 and e472.body_yaw_mode or nil
  if not e483 then return nil end
  local e484= e458.lower(tostring(e483))
  if e484 == 'jitter' then
    local e485= e454.get_delay_for_current_condition and e454.get_delay_for_current_condition() or nil
    local e481= tonumber(e485) or 0
    if e481 > 0 then
      return 'static'
    else
      return 'jitter'
    end
  end
  return e483
end




local function e486()
  local e469, e464= pcall(e453.get)
  if not e469 or not e464 then
    return nil
  end
  local e472= e463(e464)
  if not e472 then return nil end


  local e483= e472.body_yaw_mode
  if e483 ~= nil then e483 = e458.lower(tostring(e483)) end

  if e483 == 'jitter' then
    local e485= e454.get_delay_for_current_condition and e454.get_delay_for_current_condition() or nil
    local e487= tonumber(e485) or 0
    if e487 > 0 then
      local e488= e454.resolve_local_side and e454.resolve_local_side() or nil
      if e488 == 'right' then
        return -58
      else
        return 58
      end
    end

    local e474= e472.body_yaw_value
    local e481= tonumber(e474) or nil
    if e481 == 1 then
      return -180
    elseif e481 == 2 then
      return 0
    elseif e481 == 3 then
      return 180
    end
    return nil
  elseif e483 == 'static' then
    if e472.static_body_yaw ~= nil then
      local e489= tonumber(e472.static_body_yaw)
      if e489 then return e489 end
    end
    local e474= e472.body_yaw_value
    local e481= tonumber(e474) or nil
    if e481 == 1 then
      return -180
    elseif e481 == 2 then
      return 0
    elseif e481 == 3 then
      return 180
    end
    return nil
  else
    return 0
  end
end




local function e490()
  local e469, e464= pcall(e453.get)
  if not e469 or not e464 then
    return nil
  end
  local e472= e463(e464)
  return e472 and e472.body_yaw_base or nil
end




local function e491()
    local e469, e464= pcall(e453.get)
    if not e469 or not e464 then
        return nil
    end
    local e472= e463(e464)
    return e472 and e472.body_yaw_left or nil
end




local function e492()
    local e469, e464= pcall(e453.get)
    if not e469 or not e464 then
        return nil
    end
    local e472= e463(e464)
    return e472 and e472.body_yaw_right or nil
end




local function e493()
    local e469, e464= pcall(e453.get)
    if not e469 or not e464 then
        return nil
    end
    local e472= e463(e464)
    if not e472 then return nil end
    local e480= e472.only_flip_on_0_choke
    if e480 == nil then return nil end
    return not not e480
end




local function e494()
  local e469, e464= pcall(e453.get)
  if not e469 or not e464 then
    return nil
  end
  local e467= 'delay_' .. e464
  if not (e452 and e452.ui) then return nil end
  local e468= e452.ui[e467]
  if not e468 then return nil end
  local e495, e470= pcall(ui.get, e468)
  if e495 then return e470 end
  return nil
end




local function e496()
  local e469, e464= pcall(e453.get)
  if not e469 or not e464 then return nil end
  local e472= e463(e464)
  if not e472 then return nil end
  local e480= e472.fifty_fifty
  if e480 == nil then return nil end
  return not not e480
end





local function e497(e483)
  local e484= e458.lower(tostring(e483 or 'threat'))

  local e498= nil
  if e484 == 'distance' then
    local e499, e500= pcall(entity.get_players, true)
    if not e499 or not e500 or #e500 == 0 then return nil end
    local e501= entity.get_local_player()
    if not e501 then return nil end
    local e502, e503, e504, e505= pcall(entity.get_origin, e501)
    if not e502 or not e503 then return nil end
    local e506= nil
    local e507= nil
    for _, e462 in ipairs(e500) do
      if e462 and entity.is_alive and entity.is_alive(e462) and entity.is_enemy and entity.is_enemy(e462) then
        local e508, e509, e510, e511= pcall(entity.get_origin, e462)
        if e508 and e509 then
          local e512= e455.distance2d(e503, e504, e509, e510)
          if not e507 or e512 < e507 then
            e507 = e512
            e506 = e462
          end
        end
      end
    end
    e498 = e506
    elseif e484 == 'smart' then
      local e499, e500= pcall(entity.get_players, true)
      if e499 and e500 and #e500 > 0 then
        local e501= entity.get_local_player()
        if e501 then
          local e502, e503, e504, e505= pcall(entity.get_origin, e501)
          if e502 and e503 then
            local e506= nil
            local e507= nil
            for _, e462 in ipairs(e500) do
              if e462 and entity.is_alive and entity.is_alive(e462) and entity.is_enemy and entity.is_enemy(e462) then
                local e508, e509, e510, e511= pcall(entity.get_origin, e462)
                if e508 and e509 then
                  local e513= e459[e462]
                  if e513 and e457.within_ticks_window(e513, 10) then goto continue_smart end
                  local e514, e515= pcall(entity.get_player_weapon, e462)
                  if e514 and e515 and e515 ~= 0 then
                    local e516, e517= pcall(entity.get_classname, e515)
                    local e518= e458.lower(e516 and e517 and tostring(e517) or '')
                    if e518:find('knife') or e518:find('grenade') or e518:find('taser') or e518:find('zeus') then goto continue_smart end
                  end
                  do
                    local e512= e455.distance2d(e503, e504, e509, e510)
                    if not e507 or e512 < e507 then
                      e507 = e512
                      e506 = e462
                    end
                  end
                  ::continue_smart::
                end
              end
            end
            e498 = e506
          end
        end
      end
      if not e498 then
        local e519, e520= pcall(client.current_threat)
        if e519 and e520 then e498 = e520 end
      end
    else
      local e519, e520= pcall(client.current_threat)
      if e519 and e520 then e498 = e520 end
    end

  if not e498 then return nil end
  if not (entity.is_alive and entity.is_enemy and entity.is_alive(e498) and entity.is_enemy(e498)) then
    return nil
  end

  local e501= entity.get_local_player()
  if not e501 then return nil end

  local e521, e503, e504, e505= pcall(entity.get_origin, e501)
  local e522, e509, e510, e511= pcall(entity.get_origin, e498)
  if not e521 or not e522 or not e503 or not e509 then return nil end

  local e523= e509 - e503
  local e524= e510 - e504
  local e525= math.atan2(e524, e523)
  local e526= e455.rad_to_deg(e525)

  local e527, e528, e529= pcall(client.camera_angles)
  local e530= e527 and e529 or 0

  local e531= e455.normalize_angle(e526 - e530)
  return e455 and e455.round and e455.round(e531) or math.floor(e531 + 0.5)

end




local e532= {}
local e533= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local e534= {ui.reference(item[1], item[2], item[3])}
    e532[i] = e534
    for _, ref in ipairs(e534) do
        e533[ref] = true
    end
end





local function e535(e536)
  if weaponn ~= nil and entity.get_classname(weaponn) == "CC4" then
    if e536.in_attack == 1 then
        e536.in_attack = 0 
        e536.in_use = 1
    end
  else
    if e536.chokedcommands == 0 then
        e536.in_use = 0
    end
  end

end





local function e537(e536)

    local e538= e536.chokedcommands
    
    if e493() then
        if e538 > 0 then
            return
        end
    end

    local e488= e454.resolve_local_side()

    
    
    
    ui.set(e532[2][1], tostring(e471()))

    
    
    
    ui.set(e532[3][1], tostring(e473()))

    
    
    
    local e539= e476()
    if e539 == "3way" then
      e539 = '180'
    elseif e539 == "ideal" then
      e539 = '180'
    end
    ui.set(e532[4][1], e539)

    
    
    
    ui.set(e532[5][1], tostring(e477()))

    
    
    
    ui.set(e532[5][2], tostring(e478()))

    
    
    
    ui.set(e532[6][1], tostring(e482()))

    
    
    
    ui.set(e532[6][2], tostring(e486()))

    
    
    
    local e540= tonumber(e490()) or 0
    local e541= 0
    if ui.get(e532[4][1]) == '180' then
      if e488 == 'right' then
        e541 = tonumber(e491()) or 0
      elseif e488 == 'left' then
        e541 = tonumber(e492()) or 0
      end
    end
    local e542= e540 + e541
    local e543= tonumber(e479()) or 0
    if e543 > 0 then
      local e544= math.abs(e542) * (e543 / 100)
      local e545= (e455.random_int(-1000, 1000) / 1000)
      local e546= e545 * e544
      e542 = e542 + e546
    end

    do
      local e547, e464= pcall(e453.get)
      if e547 and e464 then
        local e472= e463(e464)
        if e472 then
          local e548= e458.lower(tostring(e472.yaw_base or ''))
          if e548 == 'threat' or e548 == 'distance' then
            local e549= e497(e548)
            if e549 then
              e542 = e542 + tonumber(e549) or e542
            end
          end
        end
      end
    end

    local e550= e455.normalize_angle(e542)
    ui.set(e532[4][2], e455.round(e550))

    
    
    
    e535(e536)

end


return {
  gather = e463,
  activate = e537,
  print_current = e537,
}]]
e981["require/features/aa/defensive"] = [[local e455= {}
e455.active = nil
e455.activate = nil
local e456= require('require/help/time')
local e457= require('require/abc/menu_setup')
local e458= require('require/features/aa/defensive_presets')
local e459= require('require/aa/player_condition')
local e460= require('require/abc/screen_logger')
local e461, e462= pcall(require, 'require/abc/callbacks')




local e463= {}
local e464= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'RAGE', 'Aimbot', 'Double tap' },
    { 'RAGE', 'Other', 'Duck peek assist' },

}) do
    local e465= {ui.reference(item[1], item[2], item[3])}
    e463[i] = e465
    for _, ref in ipairs(e465) do
        e464[ref] = true
    end
end


local e466= {
    cond = nil,
    idx = nil,
    preset = nil,
    selected_tick = 0,
}
local e467= false
local e468= 0





local e469= {
    last = false,
    pending_until = nil,
}
local function e470()
    local e471, e472= pcall(ui.get, e463[10][2])
    local e473= e471 and not not e472 or false
    local e474= e456.tickcount() or (globals and globals.tickcount and globals.tickcount()) or 0
    if e473 and not e469.last then
        e469.pending_until = e474 + 32
    end
    if not e473 then
        e469.pending_until = nil
    end
    e469.last = e473
    if e469.pending_until then
        return e474 >= e469.pending_until
    end
    return e473
end

local function e475()
    local e465= e463[11]
    if not e465 or not e465[1] then
        return false
    end
    local e471, e472= pcall(ui.get, e465[1])
    return e471 and not not e472 or false
end

local function e476()
  local e477= entity.get_local_player()
  if not e477 or not entity.is_alive(e477) then
    return false
  end
  local e478= entity.get_player_weapon(e477)
  if not e478 then
    return false
  end
  local e479= entity.get_classname(e478)
  return e479 == "CKnife"
end




local function e480()
    if not e457 or type(e457) ~= 'table' or not e457.ui then
        return false
    end
    local e481= e457.ui.fakelag_defensive
    if not e481 then
        return false
    end
    local e471, e472= pcall(ui.get, e481)
    return e471 and not not e472 or false
end

local function e482()
    if not e457 or type(e457) ~= 'table' or not e457.ui then
        return false
    end
    local e481= e457.ui.fakelag_force
    if not e481 then
        return false
    end
    local e471, e472= pcall(ui.get, e481)
    return e471 and not not e472 or false
end

local function e483(e484)

    


    local e474= (globals and globals.tickcount and globals.tickcount()) or e456.tickcount() or 0
    e468 = e474
end




local function e485(e486)

    e486 = e486 or 20
    local e487= entity.get_local_player()
    if not e487 then return false end
    local e488= entity.get_prop(e487, "m_flSimulationTime")
    local e489= 1 / globals.tickinterval()
    if not e488 or e489 == 0 then return false end
    local e490= math.floor(e488 * e489 + 0.5)
    local e491= globals.tickcount()
    nigga = e491 >= e490 and e491 <= e490 + e486

    return e491 >= e490 and e491 <= e490 + e486

end







local function e492(e484)
    
    
    
    local e493= false
    local e494= e480()
    local e495= e470()
    local e496= e475()
    local e497= e476()
    local e498= e485()
    

    e493 = e494 and e495 and not e496 and not e497 
    e455.active = e493


    local e474= (globals and globals.tickcount and globals.tickcount()) or e456.tickcount() or 0
    local e499= false
    if e474 and (e468 == nil or e474 - e468 >= 64) then
        e499 = true
        e483(e484)
    end



    
    
    

    
    
    
    if e493 then
        local e500= e459.get() or 'global'
        if (not e467) or (e466.cond ~= e500) or (not e466.preset) then
            local e501, e502= e458.get_random_for_condition(e500)
            if e501 and e502 then
                e466.cond = e500
                e466.idx = e501
                e466.preset = e502
                e466.selected_tick = globals.tickcount()
            else
                e466.cond = e500
                e466.idx = nil
                e466.preset = nil
                e466.selected_tick = 0
            end
        end

        if not e499 then
            if e466.preset and type(e466.preset.apply) == 'function' then
                e466.preset.apply(e466, e484)
            end
        end
    else
        if e467 then
            e466.cond = nil
            e466.idx = nil
            e466.preset = nil
            e466.selected_tick = 0
        end
    end

    e467 = e493

end


e455.activate = e492
e455.reset = e483


e462.register('setup_command', function(e484)
    e492(e484)
end, { alive_only = true, require_login = true })


return e455]]
e981["require/features/aa/defensive_presets"] = [[local e458= require('require/aa/player_condition')
local e459= require('require/help/time')
local e460= require('require/abc/screen_logger')



local e461= {}
local e462= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },

}) do
    local e463= {ui.reference(item[1], item[2], item[3])}
    e461[i] = e463
    for _, ref in ipairs(e463) do
        e462[ref] = true
    end
end


local e464= {}

local function e465(e466,e467,e468) if e466 < e467 then return e467 end if e466 > e468 then return e468 end return e466 end

local function e469(e470,e471,e472)
    local e463= e461[e470]
    if not e463 or not e463[e471] then return false end
    pcall(ui.set, e463[e471], e472)
    return true
end



local e473, e474= pcall(require, "require/abc/menu_setup")



local function e475(e476)

    local e477, e474= pcall(require, "require/abc/menu_setup")
    if not e477 or not e474 or not e474.ui then return end
    local e478, e479= pcall(ui.get, e474.ui.fakelag_fakedef)

    
    if e479 then 
        e476.force_defensive = false
    else
        e476.force_defensive = true
    end

end

do
    local e480, e481= pcall(require, "require/abc/callbacks")

    ticks = ticks or {}
    ticks.tickbase_max = ticks.tickbase_max or nil
    ticks.tickbase_diff = ticks.tickbase_diff or nil
    ticks.current_cmd = ticks.current_cmd or nil

    ticks.runc = function(e476)
        if not e476 then return end
        ticks.current_cmd = e476.command_number
    end

    ticks.tickcalc = function(e476)
        if not e476 then return end
        if e476.command_number == ticks.current_cmd then
            ticks.current_cmd = nil
            local e482= entity.get_local_player()
            if not e482 then return end
            local e483= entity.get_prop(e482, "m_nTickBase")
            if e483 then
                if ticks.tickbase_max ~= nil then
                    ticks.tickbase_diff = e483 - ticks.tickbase_max
                end
                ticks.tickbase_max = math.max(e483, ticks.tickbase_max or 0)
            end
        end
    end

    if e480 and e481 and e481.callback then
        e481.callback('run_command', ticks.runc, { alive_only = true, require_login = true })
        e481.callback('predict_command', ticks.tickcalc, { alive_only = true, require_login = true })
    end
end

client.set_event_callback("level_init", function()
    ticks.tickbase_max = nil
    ticks.tickbase_diff = nil
end)


local function e484(e485)
    local e482= entity.get_local_player()
    if not e482 then return false end

    local e486= entity.get_prop(e482, 'm_nTickBase')
    if not e486 then return false end

    local e487= ticks and ticks.tickbase_max or 0

    if math.abs(e486 - e487) > 64 then
        e487 = 0
    end

    local e488= 0

    if e486 > e487 then
        e487 = e486
    elseif e487 > e486 then
        e488 = math.min(14, math.max(0, e487 - e486 - 1))
    end

    e485 = e485 or 7

    return e488 > e485
end




local e489= {



    stand = {

        [1] = {
            name = "jitter -90/90",
            apply = function(e490,e476)

                local e491= globals.tickcount()
                local e492= math.floor(e491 / 2) % 2

                local function e493()
                    local e491= globals.tickcount()

                    if not e490._next_change_at then
                        e490._next_change_at = e491 + math.random(24, 64)
                        e490._mode = math.random(1, 3)
                        e490._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        e490._spin_speed = math.random(45, 55)
                        e490._spin_angle = (e492 == 0) and -90 or 90
                    end

                    if e491 >= (e490._next_change_at or 0) then
                        e490._next_change_at = e491 + math.random(24, 64)
                        e490._mode = math.random(1, 3)
                        e490._spin_dir = (math.random(0,1) == 0) and -1 or 1
                        e490._spin_speed = math.random(45, 55)
                        e490._spin_angle = (e492 == 0) and -90 or 90

                        if e490._mode == 2 then
                            e490._spin_until = e491 + math.random(12, 24)
                        elseif e490._mode == 3 then
                            local e494= math.ceil(360 / e490._spin_speed)
                            e490._spin_until = e491 + e494
                            e490._rest_until = e491 + e494 + math.random(24, 64)
                            e490._spin_done = false
                        else
                            e490._spin_until = nil
                            e490._rest_until = nil
                        end
                    end

                    if e490._mode == 1 then
                        local e495= (e492 == 0) and -120 or 120
                        local e496= 0
                        return e495, e496

                    elseif e490._mode == 2 then
                        if e490._spin_until and e491 <= e490._spin_until then
                            e490._spin_angle = (e490._spin_angle or ((e492 == 0) and -90 or 90)) + (e490._spin_dir * (e490._spin_speed or 50))
                            if e490._spin_angle > 180 then e490._spin_angle = e490._spin_angle - 360 end
                            if e490._spin_angle < -180 then e490._spin_angle = e490._spin_angle + 360 end
                            return e490._spin_angle, 0
                        end
                        local e495= (e492 == 0) and -90 or 90
                        return e495, 0
                    else
                        if e490._spin_until and e491 <= e490._spin_until then
                            e490._spin_angle = (e490._spin_angle or ((e492 == 0) and -90 or 90)) + (e490._spin_dir * (e490._spin_speed or 50))
                            if e490._spin_angle > 180 then e490._spin_angle = e490._spin_angle - 360 end
                            if e490._spin_angle < -180 then e490._spin_angle = e490._spin_angle + 360 end
                            return e490._spin_angle, -89
                        end

                        if e490._rest_until and e491 <= e490._rest_until then
                            return nil, nil
                        end

                        local e495= (e492 == 0) and -90 or 90
                        return e495, 0
                    end
                end

                local e495, e496= e493()

                if e495 ~= nil and e476.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (e484(6))) then
                    e475(e476)
                    e469(4, 2, e495)
                    e469(2, 1, 'Custom')
                    e469(2, 2, e496)
                    e469(5, 1, 'off')
                    e469(6, 1, 'off')
                end

            end
        }
    },

    move = {

        [1] = {
            name = "jitter -90/90",
            apply = function(e490,e476)


                local e491= globals.tickcount()
                local e492= math.floor(e491 / 2) % 2
                local e495= (e492 == 0) and -135 or 135
                e490._side = e495
                e490._pitch = -55


                if e476.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (e484(3))) then
                    e475(e476)
                    e469(4, 2, e490._side)
                    e469(2, 1, 'Custom')
                    e469(2, 2, e490._pitch)
                    e469(5, 1, 'off')
                    e469(6, 1, 'off')
                    e469(3, 1, 'at targets')
                end
            end
        }
    },

    walk = {

        [1] = {
            name = "jitter -90/90",
            apply = function(e490,e476)

                local e491= globals.tickcount()
                local e492= math.floor(e491 / 2) % 2
                local e497= (e492 == 0) and -130 or 130

                
                local e495, e496
                if (e491 % 8) == 0 then
                    e495 = 0
                    e496 = 89
                else
                    e495 = e497
                    e496 = -65
                end

                e490._side = e495
                e490._pitch = e496





                if e476.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (e484(3))) then
                    e475(e476)
                    e469(4, 2, e490._side)
                    e469(2, 1, 'Custom')
                    e469(2, 2, e490._pitch)
                    e469(5, 1, 'off')
                    e469(6, 1, 'off')
                    e469(3, 1, 'at targets')
                end
            end
        },
    },

    duck = {
        
        [1] = {
            name = "jitter -90/90",
            apply = function(e490,e476)

                local e491= globals.tickcount()
                local e492= math.floor(e491 / 2) % 2

                local function e493()
                    local e491= globals.tickcount()

                    
                    if not e490._next_change_at then
                        e490._next_change_at = e491 + math.random(24, 64)
                        e490._mode = 1 
                    end

                    if e491 >= (e490._next_change_at or 0) then
                        e490._next_change_at = e491 + math.random(24, 64)
                        e490._mode = math.random(1, 5)
                        
                        e490._spin_dir = nil
                        e490._spin_speed = nil
                        e490._spin_angle = nil
                        e490._jitter_yaw = nil
                        e490._jitter_pitch = nil
                        e490._rand_yaw = nil
                        e490._rand_pitch = nil
                        e490._rand_until = nil
                        e490._phase_tick = e491
                    end

                    
                    
                    
                    
                    
                    

                    if e490._mode == 1 then
                        if not e490._spin_dir then
                            e490._spin_dir = (math.random(0,1) == 0) and -1 or 1
                            e490._spin_speed = 35
                            e490._spin_angle = (e492 == 0) and -90 or 90
                        end

                        if e491 % 10 == 0 then
                            return nil, nil
                        end

                        e490._spin_angle = (e490._spin_angle or ((e492 == 0) and -90 or 90)) + (e490._spin_dir * (e490._spin_speed or 45))
                        if e490._spin_angle > 180 then e490._spin_angle = e490._spin_angle - 360 end
                        if e490._spin_angle < -180 then e490._spin_angle = e490._spin_angle + 360 end
                        return e490._spin_angle, 0

                    elseif e490._mode == 2 then
                        local e498= math.random(-100, 100)
                        return e498, -50

                    elseif e490._mode == 3 then
                        local e498= math.random(-180, 180)
                        local e496= math.random(-89, 89)
                        return e498, e496

                    elseif e490._mode == 4 then
                        if not e490._rand_until then
                            e490._rand_yaw = math.random(-180, 180)
                            e490._rand_pitch = math.random(-89, 89)
                            e490._rand_until = e491 + 2
                            e490._rand_rest = e491 + 3
                        end
                        if e491 <= e490._rand_until then
                            return e490._rand_yaw, e490._rand_pitch
                        elseif e491 <= e490._rand_rest then
                            return nil, nil
                        else
                            e490._rand_until = nil
                            e490._rand_rest = nil
                            return nil, nil
                        end

                    else
                        
                        if not e490._ramp then
                            e490._ramp = {}
                            e490._ramp.yaw = math.random(-180, 180)
                            e490._ramp.pitch = 89
                            e490._ramp.dir = -1 
                        end

                        
                        if not e490._ramp.step then e490._ramp.step = 30 end
                        if e490._ramp.pitch == 89 then
                            
                            e490._ramp.pitch = e490._ramp.pitch + (e490._ramp.dir * e490._ramp.step)
                            if e490._ramp.pitch < -89 then e490._ramp.pitch = -89 end
                            return e490._ramp.yaw, 89
                        else
                            
                            local e499= e490._ramp.pitch
                            e490._ramp.pitch = e490._ramp.pitch + (e490._ramp.dir * e490._ramp.step)
                            if e490._ramp.pitch <= -89 then
                                
                                e490._ramp = nil
                            end
                            return e490._ramp and e490._ramp.yaw or math.random(-180,180), e499
                        end
                    end
                end

                local e495, e496= e493()

                if e495 ~= nil and e476.chokedcommands == 1 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (e484(8))) then
                    e475(e476)
                    e469(4, 2, e495)
                    e469(2, 1, 'Custom')
                    e469(2, 2, e496)
                    e469(5, 1, 'off')
                    e469(6, 1, 'off')
                    e469(3, 1, 'at targets')
                end
            end
        }
    },

    ["duck+"] = {
        
        [1] = {

            name = "jitter -90/90",
            apply = function(e490,e476)


                local e491= globals.tickcount()
                local e492= math.floor(e491 / 2) % 2
                local e495= (e492 == 0) and -90 or 90
                e490._side = 180
                e490._pitch = -76


                if e476.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (e484(1))) then
                    e475(e476)
                    e469(4, 2, e490._side)
                    e469(2, 1, 'Custom')
                    e469(2, 2, e490._pitch)
                    e469(5, 1, 'off')
                    e469(6, 1, 'off')
                    e469(3, 1, 'at targets')
                end

            end
        }
    },

    ['jump'] = {
        [1] = {
            name = "jitter -90/90",
            apply = function(e490,e476)

                local e491= globals.tickcount()
                
                if not e490._spin_choice_at then
                    e490._spin_choice_at = e491 + 64
                    e490._spin_dir = (math.random(0,1) == 0) and -1 or 1
                    e490._spin_angle = 0
                end

                if e491 >= (e490._spin_choice_at or 0) then
                    e490._spin_choice_at = e491 + 64
                    e490._spin_dir = (math.random(0,1) == 0) and -1 or 1
                end

                
                if (e491 % 10) == 0 then
                    return
                end

                
                e490._spin_angle = (e490._spin_angle or 0) + (e490._spin_dir * 35)
                if e490._spin_angle > 180 then e490._spin_angle = e490._spin_angle - 360 end
                if e490._spin_angle < -180 then e490._spin_angle = e490._spin_angle + 360 end

                local e495= e490._spin_angle
                e490._side = e495
                e490._pitch = 0

                if e476.chokedcommands > 0 and (ticks.tickbase_diff > -12) and (not ticks.tickbase_diff ~= 1) and (not (e484(8))) then
                    e475(e476)
                    e469(4, 2, e490._side)
                    e469(2, 1, 'Custom')
                    e469(2, 2, e490._pitch)
                    e469(5, 1, 'off')
                    e469(6, 1, 'off')
                    e469(3, 1, 'at targets')
                end
            end
        },

    },

    ['jump+'] = {
        [0] = {
            name = "jitter -90/90",
            apply = function(e490,e476)

                local e491= globals.tickcount()
                local e492= math.floor(e491 / 2) % 2
                local e495= (e492 == 0) and -90 or 90
                e490._side = e495
                e490._pitch = 0

                if e476.chokedcommands > 0 and (not (e484(6))) then
                    e475(e476)
                    e469(4, 2, e490._side)
                    e469(2, 1, 'Custom')
                    e469(2, 2, e490._pitch)
                    e469(5, 1, 'off')
                    e469(6, 1, 'off')
                    e469(3, 1, 'at targets')
                end
            end
        },
    },

    
    global = {
        [0] = {
            name = "back",
            apply = function(e490,e476)

            end
        }
    }


}





local function e500(e501)
    local e502= {}
    for k, _ in pairs(e501) do
        if type(k) == 'number' then table.insert(e502, k) end
    end
    table.sort(e502)
    return e502
end

function e464.get_presets_for_condition(e503)
    e503 = e503 or e458.get() or 'global'
    return e489[e503] or e489['global'] or {}
end

function e464.get_preset_by_index(e503,e504)
    local e505= e464.get_presets_for_condition(e503)
    return e505[e504]
end

function e464.get_random_for_condition(e503)
    local e505= e464.get_presets_for_condition(e503)
    local e502= e500(e505)
    if #e502 == 0 then return nil, nil end
    local e506= e502[math.random(1, #e502)]
    return e506, e505[e506]
end

function e464.get_random_for_current_condition()
    return e464.get_random_for_condition(e458.get())
end


function e464.get_next_for_condition(e503,e507)
    local e505= e464.get_presets_for_condition(e503)
    local e502= e500(e505)
    if #e502 == 0 then return nil, nil end
    
    local e508= 1
    for i, k in ipairs(e502) do
        if k == e507 then e508 = i; break end
    end
    local e509= (e508 % #e502) + 1
    local e510= e502[e509]
    return e510, e505[e510]
end


function e464.available_conditions()
    local e511= {}
    for k, _ in pairs(e489) do table.insert(e511, k) end
    table.sort(e511)
    return e511
end

e464._presets = e489

return e464]]
e981["require/features/misc/analyze"] = [[local function e461(e462)
	while e462 > 180 do e462 = e462 - 360 end
	while e462 < -180 do e462 = e462 + 360 end
	return e462
end

local e463= _G.player_labels or {}
_G.player_labels = e463

local e464= function(ent)
	return (_G.player_history and _G.player_history[ent]) or nil
end

local e465, e466= pcall(require, "require/features/misc/resolver_dispatcher")
local e467= require('require/abc/callbacks')

local function e468(e469)
	
	local e470= e464(e469)
	if not e470 or #e470 < 2 then
		e463[e469] = nil
		return
	end

	
	
	local e471, e472= pcall(function() return (globals and globals.curtime and globals.curtime()) or nil end)
	if e470[1] and e470[1].last_shot_time and e471 and e472 then
		local e473= e472 - e470[1].last_shot_time
		if e473 >= 0 and e473 <= 0.25 then
			e463[e469] = "ON SHOT"
			return
		end
	end

	
	local e474= {}
	for i = 1, #e470 - 1 do
		local e475= e470[i] and e470[i].yaw
		local e476= e470[i+1] and e470[i+1].yaw
		if e475 ~= nil and e476 ~= nil then
			e474[#e474 + 1] = e461(e475 - e476)
		end
	end

	if #e474 == 0 then
		e463[e469] = nil
		return
	end

	
	local e477, e478= 0, 0
	local e479, e480= -1e9, 1e9
	for _, v in ipairs(e474) do
		e477 = e477 + v
		e478 = e478 + math.abs(v)
		if v > e479 then e479 = v end
		if v < e480 then e480 = v end
	end
	local e481= e477 / #e474
	local e482= e478 / #e474

	local e483= 0
	for _, v in ipairs(e474) do
		e483 = e483 + (v - e481) ^ 2
	end
	local e484= math.sqrt(e483 / #e474)

	local e485= 0
	for i = 2, #e474 do
		if (e474[i] > 0 and e474[i-1] < 0) or (e474[i] < 0 and e474[i-1] > 0) then
			e485 = e485 + 1
		end
	end

	
	local e486= e474[1]
	local e487= e479 - e480

	
	local e488= {}
	for i, v in ipairs(e474) do e488[i] = v end
	table.sort(e488)
	local e489= e488[math.ceil(#e488 / 2)]

	
	local e490= {
		deltas = e474,
		mean = e481,
		meanabs = e482,
		std = e484,
		sign_changes = e485,
		max_delta = e479,
		min_delta = e480,
		total_range = e487,
		median = e489,
		last_delta = e486,
		samples = #e474,
		last_yaw = e470[1] and e470[1].yaw,
		oldest_yaw = e470[#e470] and e470[#e470].yaw,
		hist = e470
	}

	
	do
		local e491, e492= 0, 0
		local e493, e494, e495
		for i=1,math.min(#e470, 20) do
			local e496= e470[i]
			if e496 then
				if e496.moveSpeedAnim then e491 = e491 + (e496.moveSpeedAnim or 0); e492 = e492 + 1 end
				if e496.speed2d then e491 = e491 + (e496.speed2d or 0); e492 = e492 + 1 end
				if not e493 and e496.feetYaw then e493 = e496.feetYaw end
				if not e494 and e496.goalFeetYaw then e494 = e496.goalFeetYaw end
				if not e495 and e496.moveSpeedAnim then e495 = e496.moveSpeedAnim end
			end
		end
		local e497= (e492 > 0) and (e491 / e492) or 0
		e490.movement = e497 >= 1.2
		e490.avg_speed = e497
		e490.feet_yaw = e493
		e490.goal_feet_yaw = e494
		e490.move_anim = e495
	end

	local e498= nil
	if detect_static and detect_static(e490, e469) then e498 = "STATIC" end
	if detect_spin and detect_spin(e490, e469) then e498 = "SPIN" end
	if detect_jitter_minus and detect_jitter_minus(e490, e469) then e498 = "JITTER-" end
	if detect_jitter and detect_jitter(e490, e469) then e498 = "JITTER" end
	if detect_jitter_plus and detect_jitter_plus(e490, e469) then e498 = "JITTER+" end
	if detect_sway and detect_sway(e490, e469) then e498 = "SWAY" end
	if detect_skitter and detect_skitter(e490, e469) then e498 = "SKITTER" end
	if detect_defensive and detect_defensive(e490, e469) then e498 = "DEFENSIVE" end
	if detect_random and detect_random(e490, e469) then e498 = "RANDOM" end
	if detect_delayed and detect_delayed(e490, e469) then e498 = "DELAYED" end

	if not e498 then e498 = "?" end
	pcall(function()
		local e499= nil
		pcall(function() e499 = entity.get_player_name(e469) end)
		local e500= "nil"
		if e470 and e470[1] and e470[1].last_shot_time then
			e500 = string.format("%.3f", e470[1].last_shot_time)
		end
		local e501= e490.feet_yaw and string.format("%.2f", e490.feet_yaw) or "nil"
		local e502= e490.goal_feet_yaw and string.format("%.2f", e490.goal_feet_yaw) or "nil"

	end)

	e463[e469] = e498

	
	if e465 and e466 and type(e466.process_entity) == "function" then
		pcall(function() e466.process_entity(e469, e498, e490) end)
	end
end



function e503(e490,e469)
	local e482= e490.meanabs or 0
	local e484= e490.std or 0
	local e504= e490.samples or 0
	local e474= e490.deltas or {}
	local e505= 1.0
	local e506= 1.5
	local e507= 2.5

	if e482 <= e505 and e484 <= e506 then
		return true
	end

	local e508= 0
	local e509= nil
	for i, d in ipairs(e474) do
		if math.abs(d) >= e507 then
			e508 = e508 + 1
			if not e509 then
				e509 = i
			end
		end
	end

	if e508 == 0 then
		return true
	end

	if e508 == 1 and e509 and e509 > 20 then
		return true
	end

	return false
end

function e510(e490,e469)
	local e482= e490.meanabs or 0
	local e484= e490.std or 0
	local e504= e490.samples or 0
	local e485= e490.sign_changes or 0
	local e511= math.max(math.abs(e490.max_delta or 0), math.abs(e490.min_delta or 0))

	local e512= false

	if e504 >= 4 then
		local e513= 5.0
		local e514= 12.0
		local e515= 22.0
		local e516= 40.0

		if e482 >= e513 and e482 < e514 and e484 <= e515 and e511 <= e516 then
			e512 = true
		end
	end

	return e512
end

function e517(e490,e469)
	local e482= e490.meanabs or 0
	local e484= e490.std or 0
	local e504= e490.samples or 0
	local e485= e490.sign_changes or 0
	local e511= math.max(math.abs(e490.max_delta or 0), math.abs(e490.min_delta or 0))

	local e512= false

	if e504 >= 4 then
		local e513= (e490.movement and 8.0) or 6.0
		local e514= 24.0
		local e518= 34.0
		local e519= 28.0
		local e520= 100.0

		if e482 >= e513 and e482 < e514 and e484 <= e518 then
			if e485 >= 2 or e511 <= e520 or (e482 < 12.0 and e484 <= e519) then
				e512 = true
			end
		end
	end

	return e512
end

function e521(e490,e469)
	local e482= e490.meanabs or 0
	local e484= e490.std or 0
	local e504= e490.samples or 0
	local e485= e490.sign_changes or 0
	local e511= math.max(math.abs(e490.max_delta or 0), math.abs(e490.min_delta or 0))

	local e512= false

	if e504 >= 4 then
		local e513= 18.0
		local e522= 22.0
		local e523= 26.0
		local e524= 70.0

		if e482 >= e513 and (e484 >= e523 or e511 >= e524) then
			if e482 >= e522 or e511 >= e524 or e484 >= (e523 + 8) then
				e512 = true
			end
		end
	end
	
	return e512
end

function e525(e490,e469)
	local e482= e490.meanabs or 0
	local e484= e490.std or 0
	local e504= e490.samples or 0
	local e485= e490.sign_changes or 0
	local e487= e490.total_range or 0
	local e511= math.max(math.abs(e490.max_delta or 0), math.abs(e490.min_delta or 0))

	local e512= false

	if e504 >= 6 then
		local e513= 2.5
		local e514= 15.0
		local e526= 0.08
		local e527= 30.0
		local e528= 180.0

		if e482 >= e513 and e482 < e514 and e484 <= 40.0 and e487 >= e527 and e487 <= e528 then
			if (e485 / math.max(1, e504)) >= e526 then
				e512 = true
			end
		end
	end

	return e512
end

function e529(e490,e469)
	local e482= e490.meanabs or 0
	local e484= e490.std or 0
	local e504= e490.samples or 0
	local e485= e490.sign_changes or 0
	local e487= e490.total_range or 0
	local e486= e490.last_delta or 0
	local e511= math.max(math.abs(e490.max_delta or 0), math.abs(e490.min_delta or 0))

	local e474= e490.deltas or {}

	local e530, e531, e532= 0, 0, 0
	for _, v in ipairs(e474) do
		if v > 0.5 then e530 = e530 + 1
		elseif v < -0.5 then e531 = e531 + 1
		else e532 = e532 + 1 end
	end

	local e533= math.max(e530, e531) / math.max(1, e504)
	local e534= math.abs(e530 - e531) / math.max(1, (e530 + e531))

	local e535, e536, e537= 0, 0, 0
	for _, v in ipairs(e474) do
		local e496= 0
		if v > 0.5 then e496 = 1 elseif v < -0.5 then e496 = -1 end
		if e496 ~= 0 and e496 == e537 then
			e536 = e536 + 1
		else
			e536 = (e496 ~= 0) and 1 or 0
			e537 = e496
		end
		if e536 > e535 then e535 = e536 end
	end

	local e538= e535 / math.max(1, e504)

	local e512= false

	if e504 >= 6 then
		if e487 >= 300 and (e533 >= 0.60 or e534 >= 0.60) then
			e512 = true
		end

		if not e512 and e487 >= 140 and e482 >= 9 and (e533 >= 0.75 or e534 >= 0.70 or e485 <= 1) then
			e512 = true
		end

		if not e512 and e538 >= 0.50 and e482 >= 8 and e487 >= 120 then
			e512 = true
		end

		if not e512 and e511 >= 120 and (e533 >= 0.60 or e534 >= 0.60) then
			e512 = true
		end
	end
	local e539= nil
	if not e512 and e504 > 0 then
		local e540= math.min(e487, 360) / 360.0
		local e541= math.min(e482, 60) / 60.0
		local e542= (e485 or 0) / math.max(1, e504)
		e539 = e540 * 0.45 + e541 * 0.35 + e534 * 0.15 + e533 * 0.05 - e542 * 0.20
		if e539 >= 0.42 and e487 >= 200 and e482 >= 6 then
			e512 = true
		end
		e490.spin_score = e539
	end

	return e512
end

function e543(e490,e469)
	
	return false
end

function e544(e490,e469)
	
	return false
end

function e545(e490,e469)
	local e482= e490.meanabs or 0
	local e484= e490.std or 0
	local e504= e490.samples or 0
	local e485= e490.sign_changes or 0
	local e487= e490.total_range or 0
	local e511= math.max(math.abs(e490.max_delta or 0), math.abs(e490.min_delta or 0))
	local e474= e490.deltas or {}

	if e504 < 6 then return false end

	local e546= e485 / math.max(1, e504)
	local e547= e490.movement
	if e546 >= 0.45 and e484 >= (e547 and 12.0 or 18.0) and e482 >= (e547 and 4.0 or 6.0) then
		return true
	end

	if e511 >= 120 and e546 >= 0.30 and e484 >= 12.0 then
		return true
	end

	if e487 >= 60 and e487 <= 300 and e546 >= 0.40 and e484 >= 14.0 and e482 >= 4.0 then
		return true
	end

	if e484 >= 30.0 and e546 >= 0.25 and e482 >= 5.0 then
		return true
	end

	return false
end

function e548(e490,e469)
	local e482= e490.meanabs or 0
	local e484= e490.std or 0
	local e504= e490.samples or 0
	local e485= e490.sign_changes or 0
	local e487= e490.total_range or 0
	local e511= math.max(math.abs(e490.max_delta or 0), math.abs(e490.min_delta or 0))

	if e504 >= 6 then
		local e513= 2.5
		local e514= 24.0
		local e549= 9.0
		local e550= 40.0
		local e527= 10.0

		if e482 >= e513 and e482 < e514 and e484 >= e549 and e484 <= e550 and e487 >= e527 then
			local e551= (e485 or 0) / math.max(1, e504)
			if e485 <= 3 or e551 <= 0.12 or e511 >= 40 then
				return true
			end
		end
	end

	return false
end

local function e552()
	local e553, e554= pcall(entity.get_players, true)
	if not e553 or type(e554) ~= "table" then return end
	for _, e469 in ipairs(e554) do
		if entity.is_alive(e469) and not entity.is_dormant(e469) then
			pcall(e468, e469)
		else
			e463[e469] = nil
		end
	end
end

local function e555(e469)
	if not entity.is_alive(entity.get_local_player()) then return end
	if not e469 or e469 == 0 then return end

	local e556= e463[e469]


	if e556 then
		return true, e556
	end

	local e470= e464(e469)
	if e470 and e470[1] and e470[1].yaw ~= nil then
		return true, tostring(e470[1].yaw)
	end
end

client.register_esp_flag("Resolver", 255, 255, 255, e555)

e467.register('net_update_end', function()
	local e557, e558= pcall(require, "require/abc/menu_setup")
	if e557 and e558 and e558.ui and e558.ui.misc_resolver then
		local e559, e560= pcall(ui.get, e558.ui.misc_resolver)
		if e559 and e560 then
			pcall(e552)
		end
	end
end, { alive_only = true, require_login = true })
]]
e981["require/features/misc/backstab_assist"] = [[local e464= require("require/abc/menu_setup")
local e465= require('require/abc/callbacks')
local e466= require('require/help/enemies')

local e467= ui.reference("AA", "Anti-aimbot angles", "Pitch")
local e468= ui.reference("AA", "Anti-aimbot angles", "Yaw base")
local e469, e470= ui.reference("AA", "Anti-aimbot angles", "Yaw")
local e471= nil

local function e472()
	if e471 then return end
	e471 = {}
	if e467 then e471.pitch = ui.get(e467) end
	if e468 then e471.yaw_base = ui.get(e468) end
	if e469 then e471.yaw = ui.get(e469) end
	if e470 then e471.yaw_slider = ui.get(e470) end
end

local function e473()
	if not e471 then return end
	if e467 and e471.pitch ~= nil then pcall(ui.set, e467, e471.pitch) end
	if e468 and e471.yaw_base ~= nil then pcall(ui.set, e468, e471.yaw_base) end
	if e469 and e471.yaw ~= nil then pcall(ui.set, e469, e471.yaw) end
	if e470 and e471.yaw_slider ~= nil then pcall(ui.set, e470, e471.yaw_slider) end
	e471 = nil
end

local function e474()
	e472()
	if e467 then pcall(ui.set, e467, "Off") end
	if e468 then pcall(ui.set, e468, "At targets") end
	if e469 then pcall(ui.set, e469, "180") end
	if e470 then pcall(ui.set, e470, 180) end
end

local function e475(e476)
	local e477= entity.get_local_player()
	if not e477 or not entity.is_alive(e477) then return false end
	local e478= e466.list() or {}
	for _, enemy in ipairs(e478) do
		if e466.is_alive(enemy) and not e466.is_dormant(enemy) and e466.has_knife(enemy) then
			local e479= e466.distance(enemy)
			if e479 and e479 <= e476 then
				return true
			end
		end
	end
	return false
end

local function e480(e481)
	if not (e464 and e464.ui and e464.ui.misc_backstab) then e473() return end
	local e482, e483= pcall(ui.get, e464.ui.misc_backstab)
	if not e482 or not e483 then e473() return end
	local e476= 200
	if e475(e476) then
		e474()
	else
		e473()
	end
end

if e464 and e464.ui and e464.ui.misc_backstab then
	ui.set_callback(e464.ui.misc_backstab, function()
		local e482, e484= pcall(ui.get, e464.ui.misc_backstab)
		if not e482 or not e484 then e473() end
	end)
end

e465.register("setup_command", e480, { alive_only = true, require_login = true })
e465.register("shutdown", e473, { alive_only = true, require_login = true })]]
e981["require/features/misc/collect"] = [=[
local M = {}


do
    local ok, ffi = pcall(require, "ffi")
    if ok and ffi and client and client.create_interface then
        local status, entity_list_ptr = pcall(function()
            return client.create_interface("client.dll", "VClientEntityList003")
        end)

        if status and entity_list_ptr then
            local pointer_type = ffi.typeof("void***")
            local entity_list = ffi.cast(pointer_type, entity_list_ptr)
            local ok_cast, get_client_entity = pcall(function()
                return ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
            end)

            if ok_cast and get_client_entity then
                
                local animstate_offset = 0x9960

                
                
                
                ffi.cdef[[
                struct animation_layer_t {
                    char  pad_0000[20];
                    uint32_t m_nOrder;
                    uint32_t m_nSequence;
                    float m_flPrevCycle;
                    float m_flWeight;
                    float m_flWeightDeltaRate;
                    float m_flPlaybackRate;
                    float m_flCycle;
                    void *m_pOwner;
                    char  pad_0038[4];
                };
                ]]

                
                
                

                ffi.cdef[[
                struct c_animstate_min {
                    char pad0[3];
                    char m_bForceWeaponUpdate;
                    char pad1[91];
                    void* m_pBaseEntity;
                    void* m_pActiveWeapon;
                    void* m_pLastActiveWeapon;
                    float m_flLastClientSideAnimationUpdateTime;
                    int m_iLastClientSideAnimationUpdateFramecount;
                    float m_flAnimUpdateDelta;
                    float m_flEyeYaw;
                    float m_flPitch;
                    float m_flGoalFeetYaw;
                    float m_flCurrentFeetYaw;
                    float m_flCurrentTorsoYaw;
                    float m_flUnknownVelocityLean;
                    float m_flLeanAmount;
                    char pad2[4];
                    float m_flFeetCycle;
                    float m_flFeetYawRate;
                    char pad3[4];
                    float m_fDuckAmount;
                    float m_fLandingDuckAdditiveSomething;
                    char pad4[4];
                    float m_vOriginX;
                    float m_vOriginY;
                    float m_vOriginZ;
                    float m_vLastOriginX;
                    float m_vLastOriginY;
                    float m_vLastOriginZ;
                    float m_vVelocityX;
                    float m_vVelocityY;
                    char pad5[4];
                    float m_flUnknownFloat1;
                    char pad6[8];
                    float m_flUnknownFloat2;
                    float m_flUnknownFloat3;
                    float m_flUnknown;
                    float m_flSpeed2D;
                    float m_flUpVelocity;
                    float m_flSpeedNormalized;
                    float m_flFeetSpeedForwardsOrSideWays;
                    float m_flFeetSpeedUnknownForwardOrSideways;
                    float m_flTimeSinceStartedMoving;
                    float m_flTimeSinceStoppedMoving;
                    bool m_bOnGround;
                    bool m_bInHitGroundAnimation;
                    char pad7[2];
                    float m_flTimeSinceInAir;
                    float m_flLastOriginZ;
                    float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
                    float m_flStopToFullRunningFraction;
                    float m_flMagicFraction;
                    char pad8[60];
                    float m_flWorldForce;
                    char pad9[462];
                    float m_flMaxYaw;
                };
                ]]

                
                M._get_animstate = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    
                    
                    local base = ffi.cast("char*", ent_ptr)
                    local anim_ptr_ptr = ffi.cast("struct c_animstate_min**", base + animstate_offset)
                    if anim_ptr_ptr == nil or anim_ptr_ptr == ffi.NULL then return nil end
                    local anim_ptr = anim_ptr_ptr[0]
                    if anim_ptr == nil or anim_ptr == ffi.NULL then return nil end
                    return anim_ptr
                end
                
                M._get_entity_ptr = function(ent)
                    local ok_ent, ent_ptr = pcall(function()
                        return get_client_entity(entity_list, ent)
                    end)
                    if not ok_ent or ent_ptr == nil then return nil end
                    return ent_ptr
                end
            end
        end
    end
end



function M.get_sim_time(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flSimulationTime") end)
    if ok then return val end
    return nil
end


function M.get_enemies_simtimes()
    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        out[ent] = M.get_sim_time(ent)
    end
    return out
end


function M.get_velocity_3d(ent)
    local ok, vals = pcall(function() return { entity.get_prop(ent, "m_vecVelocity") } end)
    if not ok or type(vals) ~= "table" then return nil end
    if #vals >= 3 then
        return { vals[1], vals[2], vals[3] }
    end
    return nil
end


function M.get_speed_2d(ent)
    local v = M.get_velocity_3d(ent)
    if not v then return nil end
    local x, y = v[1] or 0, v[2] or 0
    return math.sqrt(x * x + y * y)
end




function M.get_origin(ent)
    local ok, x, y, z = pcall(function() return entity.get_prop(ent, "m_vecOrigin") end)
    if ok and x then
        
        if type(x) == "table" then
            return x[1], x[2], x[3]
        elseif y and z then
            return x, y, z
        end
    end
    return nil
end


function M.get_view_offset(ent)
    local tries = { "m_vecViewOffset[0]", "m_vecViewOffset" }
    for _, prop in ipairs(tries) do
        local ok, v1, v2, v3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and v1 then
            if type(v1) == "table" then
                return v1[1], v1[2], v1[3]
            elseif v2 and v3 then
                return v1, v2, v3
            end
        end
    end
    return nil
end


function M.get_eye_pos(ent)
    local ox, oy, oz = M.get_origin(ent)
    local vx, vy, vz = M.get_view_offset(ent)
    if ox and vx then
        return ox + vx, oy + vy, oz + vz
    end
    return nil
end


function M.get_eye_angles(ent)
    local tries = { "m_angEyeAngles[0]", "m_angEyeAngles", "m_angRotation", "m_angNetworkAngles" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return nil
end


function M.get_abs_angles(ent)
    local tries = { "m_angAbsRotation", "m_angAbsAngles", "m_angAbsOrigin" }
    for _, prop in ipairs(tries) do
        local ok, a1, a2, a3 = pcall(function() return entity.get_prop(ent, prop) end)
        if ok and a1 then
            if type(a1) == "table" then
                return a1[1], a1[2], a1[3]
            elseif a2 and a3 then
                return a1, a2, a3
            end
        end
    end
    return M.get_eye_angles(ent)
end


function M.get_lower_body_yaw(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flLowerBodyYawTarget") end)
    if ok and val then return val end
    return nil
end


function M.get_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flCurrentFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    
    return M.get_lower_body_yaw(ent)
end

function M.get_goal_feet_yaw(ent)
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local ok_v, val = pcall(function() return tonumber(anim.m_flGoalFeetYaw) end)
            if ok_v and val then return val end
        end
    end
    return M.get_feet_yaw(ent)
end


function M.get_speed(ent)
    
    local ok, val = pcall(function() return entity.get_prop(ent, "m_flVelocityModifier") end)
    if ok and val then return val end
    
    local v = M.get_velocity_3d(ent)
    if v then
        return math.sqrt((v[1] or 0) * (v[1] or 0) + (v[2] or 0) * (v[2] or 0) + (v[3] or 0) * (v[3] or 0))
    end
    return nil
end

function M.get_move_speed_anim(ent)
    
    
    
    
    
    if M._get_animstate then
        local ok, anim = pcall(function() return M._get_animstate(ent) end)
        if ok and anim then
            local try_fields = { "m_flFeetSpeedForwardsOrSideWays", "m_flSpeed2D", "m_flSpeedNormalized", "m_flFeetSpeedUnknownForwardOrSideways" }
            for _, f in ipairs(try_fields) do
                local okf, val = pcall(function() return tonumber(anim[f]) end)
                if okf and val and val ~= 0 then
                    return val
                end
            end
        end
    end

    
    local ok_nv, nv = pcall(function() return entity.get_prop(ent, "m_flMaxspeed") end)
    if ok_nv and nv then return nv end

    
    return M.get_speed_2d(ent)
end


function M.get_flags(ent)
    local ok, val = pcall(function() return entity.get_prop(ent, "m_fFlags") end)
    if ok and val then return val end
    ok, val = pcall(function() return entity.get_prop(ent, "m_iFlags") end)
    if ok and val then return val end
    return nil
end



function M.read_animstate(ent)
    if not M._get_animstate then return nil end
    local ok, anim = pcall(function() return M._get_animstate(ent) end)
    if not ok or not anim then return nil end
    local out = {}
    pcall(function()
        out.m_flEyeYaw = tonumber(anim.m_flEyeYaw)
        out.m_flPitch = tonumber(anim.m_flPitch)
        out.m_flGoalFeetYaw = tonumber(anim.m_flGoalFeetYaw)
        out.m_flCurrentFeetYaw = tonumber(anim.m_flCurrentFeetYaw)
        out.m_flCurrentTorsoYaw = tonumber(anim.m_flCurrentTorsoYaw)
        out.m_flUnknownVelocityLean = tonumber(anim.m_flUnknownVelocityLean)
        out.m_flLeanAmount = tonumber(anim.m_flLeanAmount)
        out.m_flFeetCycle = tonumber(anim.m_flFeetCycle)
        out.m_flFeetYawRate = tonumber(anim.m_flFeetYawRate)
        out.m_fDuckAmount = tonumber(anim.m_fDuckAmount)
        out.m_fLandingDuckAdditiveSomething = tonumber(anim.m_fLandingDuckAdditiveSomething)
        out.m_vOrigin = { tonumber(anim.m_vOriginX), tonumber(anim.m_vOriginY), tonumber(anim.m_vOriginZ) }
        out.m_vLastOrigin = { tonumber(anim.m_vLastOriginX), tonumber(anim.m_vLastOriginY), tonumber(anim.m_vLastOriginZ) }
        out.m_vVelocity = { tonumber(anim.m_vVelocityX), tonumber(anim.m_vVelocityY) }
        out.m_flUnknownFloat1 = tonumber(anim.m_flUnknownFloat1)
        out.m_flUnknownFloat2 = tonumber(anim.m_flUnknownFloat2)
        out.m_flUnknownFloat3 = tonumber(anim.m_flUnknownFloat3)
        out.m_flUnknown = tonumber(anim.m_flUnknown)
        out.m_flSpeed2D = tonumber(anim.m_flSpeed2D)
        out.m_flUpVelocity = tonumber(anim.m_flUpVelocity)
        out.m_flSpeedNormalized = tonumber(anim.m_flSpeedNormalized)
        out.m_flFeetSpeedForwardsOrSideWays = tonumber(anim.m_flFeetSpeedForwardsOrSideWays)
        out.m_flFeetSpeedUnknownForwardOrSideways = tonumber(anim.m_flFeetSpeedUnknownForwardOrSideways)
        out.m_flTimeSinceStartedMoving = tonumber(anim.m_flTimeSinceStartedMoving)
        out.m_flTimeSinceStoppedMoving = tonumber(anim.m_flTimeSinceStoppedMoving)
        out.m_bOnGround = (anim.m_bOnGround ~= 0)
        out.m_bInHitGroundAnimation = (anim.m_bInHitGroundAnimation ~= 0)
        out.m_flTimeSinceInAir = tonumber(anim.m_flTimeSinceInAir)
        out.m_flLastOriginZ = tonumber(anim.m_flLastOriginZ)
        out.m_flHeadHeightOrOffsetFromHittingGroundAnimation = tonumber(anim.m_flHeadHeightOrOffsetFromHittingGroundAnimation)
        out.m_flStopToFullRunningFraction = tonumber(anim.m_flStopToFullRunningFraction)
        out.m_flMagicFraction = tonumber(anim.m_flMagicFraction)
        out.m_flWorldForce = tonumber(anim.m_flWorldForce)
        out.m_flMaxYaw = tonumber(anim.m_flMaxYaw)
    end)
    return out
end



function M.read_anim_layers(ent)
    if not M._get_entity_ptr then return nil end
    local ok_ent, ent_ptr = pcall(function() return M._get_entity_ptr(ent) end)
    if not ok_ent or not ent_ptr then return nil end
    local ok, res = pcall(function()
        local ffi = require("ffi")
        local base = ffi.cast("char*", ent_ptr)
        local layers_ptr = ffi.cast("struct animation_layer_t**", base + 0x2990)
        if layers_ptr == nil or layers_ptr == ffi.NULL then return nil end
        local owner = layers_ptr[0]
        if owner == nil or owner == ffi.NULL then return nil end
        local out = {}
        for i = 0, 15 do
            local layer = owner[i]
            if layer == nil or layer == ffi.NULL then break end
            local t = {}
            t.m_nOrder = tonumber(layer.m_nOrder)
            t.m_nSequence = tonumber(layer.m_nSequence)
            t.m_flPrevCycle = tonumber(layer.m_flPrevCycle)
            t.m_flWeight = tonumber(layer.m_flWeight)
            t.m_flWeightDeltaRate = tonumber(layer.m_flWeightDeltaRate)
            t.m_flPlaybackRate = tonumber(layer.m_flPlaybackRate)
            t.m_flCycle = tonumber(layer.m_flCycle)
            t.m_pOwner = tostring(layer.m_pOwner)
            table.insert(out, t)
        end
        return out
    end)
    if not ok then return nil end
    return res
end


function M.get_tick_from_simtime(simtime)
    if not simtime or not globals or not globals.tickinterval then return nil end
    local ti = globals.tickinterval()
    if not ti or ti == 0 then return nil end
    return math.floor(simtime / ti + 0.5)
end

function M.get_tick(ent)
    local sim = M.get_sim_time(ent)
    if sim then return M.get_tick_from_simtime(sim) end
    return nil
end








function M.get_enemies_snapshot(opts)
    opts = opts or {}
    local heavy = true 

    local out = {}
    if not entity or not entity.get_players then return out end
    local enemies = entity.get_players(true) or {}
    for i = 1, #enemies do
        local ent = enemies[i]
        local snap = {}

        
        snap.is_alive = (pcall(function() return entity.is_alive(ent) end) and entity.is_alive(ent)) or false
        snap.is_dormant = (pcall(function() return entity.is_dormant(ent) end) and entity.is_dormant(ent)) or false

        
        local ok_name, name = pcall(function() return entity.get_player_name(ent) end)
        snap.name = ok_name and name or nil

        
        snap.simtime = M.get_sim_time(ent)
        do
            local base_tick = snap.simtime and M.get_tick_from_simtime(snap.simtime) or nil
            
            local ok_flags, esp_flags = pcall(function()
                local d = entity.get_esp_data and entity.get_esp_data(ent)
                return (d and d.flags) or 0
            end)

            local adjusted_tick = base_tick
            if ok_flags and esp_flags and base_tick then
                
                local ok_bit, is_backtrack = pcall(function()
                    return bit and bit.band(esp_flags, bit.lshift(1, 17)) ~= 0
                end)
                if ok_bit and is_backtrack then
                    adjusted_tick = base_tick - 14
                end
            end
            snap.simTicks = adjusted_tick
        end

        
        do
            local ok, ox, oy, oz = pcall(function() return M.get_origin(ent) end)
            if ok and ox then snap.origin = { ox, oy, oz } end
        end
        do
            local ok, vx, vy, vz = pcall(function() return M.get_view_offset(ent) end)
            if ok and vx then snap.viewOffset = { vx, vy, vz } end
        end
        do
            local ok, ex, ey, ez = pcall(function() return M.get_eye_pos(ent) end)
            if ok and ex then snap.eyePos = { ex, ey, ez } end
        end

        
        do
            local ok, a1, a2, a3 = pcall(function() return M.get_eye_angles(ent) end)
            if ok and a1 then snap.eyeAngles = { a1, a2, a3 } end
        end
        do
            local ok, aa1, aa2, aa3 = pcall(function() return M.get_abs_angles(ent) end)
            if ok and aa1 then snap.absAngles = { aa1, aa2, aa3 } end
        end

        
        snap.lowerBodyYaw = (pcall(function() return M.get_lower_body_yaw(ent) end) and M.get_lower_body_yaw(ent)) or nil
        snap.feetYaw = (pcall(function() return M.get_feet_yaw(ent) end) and M.get_feet_yaw(ent)) or snap.lowerBodyYaw
        snap.goalFeetYaw = (pcall(function() return M.get_goal_feet_yaw(ent) end) and M.get_goal_feet_yaw(ent)) or snap.feetYaw

        
        snap.velocity3d = (pcall(function() return M.get_velocity_3d(ent) end) and M.get_velocity_3d(ent)) or nil
        if snap.velocity3d then
            snap.speed2d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0))
            snap.speed3d = math.sqrt((snap.velocity3d[1] or 0) * (snap.velocity3d[1] or 0) + (snap.velocity3d[2] or 0) * (snap.velocity3d[2] or 0) + (snap.velocity3d[3] or 0) * (snap.velocity3d[3] or 0))
        else
            snap.speed2d = M.get_speed_2d(ent)
            snap.speed3d = M.get_speed(ent)
        end

        
        do
            local ok_ms, ms = pcall(function() return M.get_move_speed_anim(ent) end)
            if ok_ms and ms then
                snap.moveSpeedAnim = ms
            else
                snap.moveSpeedAnim = nil
            end
        end

        
        snap.flags = (pcall(function() return M.get_flags(ent) end) and M.get_flags(ent)) or nil

        
        local ok_head, hx, hy, hz = pcall(function() return entity.hitbox_position(ent, "head") end)
        if ok_head and hx then snap.headPos = { hx, hy, hz } end

        
        local ok_w, w = pcall(function() return entity.get_player_weapon(ent) end)
        snap.weapon = ok_w and w or nil

        

        
        local ok_b, bones = pcall(function() return entity.get_bone_matrices and entity.get_bone_matrices(ent) end)
        if ok_b and bones then snap.bones = bones end

        local ok_as, as = pcall(function() return M.read_animstate(ent) end)
        if ok_as and as then snap.animstate_full = as end
        local ok_layers, layers = pcall(function() return M.read_anim_layers(ent) end)
        if ok_layers and layers then snap.animLayers = layers end

        out[ent] = snap
    end
    return out
end

return M
]=]
e981["require/features/misc/dormant_aimbot"] = [[local e470, e471, e472, e473= client.visible, client.eye_position, client.log, client.trace_bullet
local e474, e475, e476, e477, e478, e479, e480, e481, e482, e483= entity.get_bounding_box, entity.get_local_player, entity.get_origin, entity.get_player_name, entity.get_player_resource, entity.get_player_weapon, entity.get_prop, entity.is_dormant, entity.is_enemy, entity.is_alive
local e484, e485, e486= globals.curtime, globals.maxplayers, globals.tickcount
local e487, e488, e489= math.max, math.min, math.sqrt
local e490, e491, e492= renderer.indicator, string.format, table.unpack or unpack
local e493, e494, e495, e496, e497, e498, e499, e500, e501, e502= ui.get, ui.new_checkbox, ui.new_color_picker, ui.new_hotkey, ui.new_multiselect, ui.new_slider, ui.reference, ui.set, ui.set_callback, ui.set_visible
local e503, e504= plist.get, entity.hitbox_position
local e505= require("ffi")
local e506= require("vector")
local e507= require("gamesense/csgo_weapons")
local e508= vtable_bind("client_panorama.dll", "VClientEntityList003", 3, "void*(__thiscall*)(void*, int)")
local e509= vtable_thunk(166, "bool(__thiscall*)(void*)")
local e510= vtable_thunk(483, "float(__thiscall*)(void*)")
local e511= {
	mindamage = e499("RAGE", "Aimbot", "Minimum damage"),
	dormant_esp = e499("VISUALS", "Player ESP", "Dormant"),
	override_mindamage = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}
local e512= require("require/abc/menu_setup")
local e513= require('require/abc/callbacks')

local e514= {}
local function e515(e516)
	if type(e512) ~= 'table' then return false end
	if e514[e516] == nil then e514[e516] = e512.ui and e512.ui[e516] end
	local e517= e514[e516]
	if not e517 then return false end
	local e518, e519= pcall(e493, e517)
	if not e518 then
		e514[e516] = e512.ui and e512.ui[e516]
		e517 = e514[e516]
		if not e517 then return false end
		e518, val = pcall(e493, e517)
		if not e518 then return false end
	end
	return e519
end

local e520= { "Head", "Chest", "Stomach" }
local e521= {
	"generic",
	"head",
	"chest",
	"stomach",
	"left arm",
	"right arm",
	"left leg",
	"right leg",
	"neck",
	"?",
	"gear"
}

local e522= {
	"",
	"Head",
	"Chest",
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs",
	"Head",
	"",
	""
}

local e523= {
	{ scale = 5, hitbox = "Stomach", vec = e506(0, 0, 40) },
	{ scale = 6, hitbox = "Chest", vec = e506(0, 0, 50) },
	{ scale = 3, hitbox = "Head", vec = e506(0, 0, 58) },
	{ scale = 4, hitbox = "Legs", vec = e506(0, 0, 20) }
}

local e524= {
	[0] = "Head",
	nil,
	"Stomach",
	nil,
	"Stomach",
	"Chest",
	"Chest",
	"Legs",
	"Legs"
}

local e525= 0
local e526= {}
local e527= {}
local e528= 1
local e529= false
local e530
local e531
local e532
local e533
local e534= false
local e535= {}

local e536= {
	0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18
}

local function e537(e538,e539,e540)
	local e541, e542= e538:to(e539):angles()
	local e543= math.rad(e542 + 90)
	local e544= e506(math.cos(e543), math.sin(e543), 0) * e540

	return {
		{ text = "Middle", vec = e539 },
		{ text = "Left", vec = e539 + e544 },
		{ text = "Right", vec = e539 - e544 }
	}
end

local function e545(e546,e547)
	for i = 1, #e546 do if e546[i] == e547 then return true end end
	return false
end
local function e548(e546,e547)
	for i = 1, #e546 do local e549= e546[i] if type(e549) == 'table' and e549[1] == e547 then return i end end
end
local function e550(e546,e551) return e548(e546, e551) ~= nil end
local function e552(e546,e551) local e553= e548(e546, e551) if e553 then table.remove(e546, e553) end end

local function e554(e555,e556)
	local e557= e489(e555.forwardmove*e555.forwardmove + e555.sidemove*e555.sidemove)
	if e556<=0 or e557<=0 then return end
	if e555.in_duck==1 then e556 = e556*2.94117647 end
	if e557<=e556 then return end
	local e558= e556/e557; e555.forwardmove = e555.forwardmove*e558; e555.sidemove = e555.sidemove*e558
end

local function e559()
	local e560, e561= {}, e478()
	for i=1,e485() do if e480(e561, "m_bConnected", i)==1 and i~=e475() and e482(i) then e560[#e560+1]=i end end
	return e560
end
local function e562()
	local e560, e561= {}, e478()
	for i=1,e485() do if e480(e561, "m_bConnected", i)==1 and not e503(i, "Add to whitelist") and e481(i) and e482(i) then e560[#e560+1]=i end end
	return e560
end

local function e563()
	for e541,enemy in ipairs(e559()) do
		local e541,e541,e541,e541,e564= e474(enemy)
		if e564<1 then if not e550(e527,enemy) then e527[#e527+1]={enemy,e486()} end else e552(e527,enemy) end
	end
end

local function e565(e566)
	local e567= e493(e511.override_mindamage[1]) and e493(e511.override_mindamage[2])
	local e568= e567 and e493(e511.override_mindamage[3]) or e493(e511.mindamage)
	local e569= entity.get_esp_data(e566).health
	if e568>100 then e568 = e568 - 100 + e569 end
	return e568
end

local function e570(e571,e558) return (e571.type=="sniperrifle" and e558) and e571.max_player_speed_alt or e571.max_player_speed end

local function e572(e566,e573,e574)
	local e575= {}
	local e576= e480(e566, "m_flDuckAmount") or 0
	for e541,p in ipairs(e523) do
		if #e574==0 or e545(e574,p.hitbox) then
			local e577= p.vec
			if p.hitbox=="Head" then e577 = e577 - e506(0,0,e576*10) elseif p.hitbox=="Chest" then e577 = e577 - e506(0,0,e576*4) end
			e575[#e575+1]={vec=e573+e577,scale=p.scale,hitbox=p.hitbox}
		end
	end
	for i=1,7 do
		local e578= e524[i-1]
		if e578 and (#e574==0 or e545(e574,e578)) then
			local e579= e504(e566,i-1)
			if e579 then e575[#e575+1]={vec=e506(e579),scale=3,hitbox=e578} end
		end
	end
	return e575
end

local function e580(e581,e582,e583,e584,e585)
	for e541,p in ipairs(e584) do
		for e541,e577 in ipairs(e537(e583,p.vec,3)) do
			local e541,e586= e473(e581, e583.x,e583.y,e583.z, e577.vec.x,e577.vec.y,e577.vec.z, true)
			if p.hitbox=="Head" then e586=e586*4 end
			if e586>e585 then return e577.vec,e586,p.hitbox,e577.text end
		end
	end
end

local function e587(e555)
	e563()

	if not e515('misc_dormantaimbot') and e515('misc_dormantaimbot_key') then
		return
	end

	local e588= e475()
	if not e588 or not e483(e588) then
		return
	end

	local e589= e479(e588)
	if not e589 then
		return
	end

	local e590= e508(e589)
	if not e590 or not e509(e590) then
		return
	end

	local e591= e510(e590)
	if not e591 then
		return
	end

	local e592= e506(e471())
	local e593= e480(e588, "m_flSimulationTime")
	local e594= e486()
	local e595= e507(e589)
	local e596= e480(e588, "m_bIsScoped") == 1
	local e597= bit.band(e480(e588, "m_fFlags"), bit.lshift(1, 0))

	local e598= e562()
	if #e598 == 0 then
		e526 = {}
		return
	end

	if e594 % #e598 ~= 0 then
		e528 = e528 + 1
	else
		e528 = 1
	end

	local e566= e598[e528]
	if not e566 then
		e526 = {}
		return
	end

	if e594 < e525 then
		e526 = {}
		return
	end

	if e595.type == "grenade" or e595.type == "knife" then
		e526 = {}
		return
	end

	if e555.in_jump == 1 and e597 == 0 then
		e526 = {}
		return
	end

	local e599= e520
	local e600= e506(e476(e566))
	local e541, e541, e541, e541, e601= e474(e566)

	e526[e566] = nil

	if e601 < 1 then
		if not e550(e535, e566) then
			e535[#e535 + 1] = { e566, e594 }
		end
	else
		e552(e535, e566)
	end

	local e602= e572(e566, e600, e599)
	local e603= e565(e566)

	local e604
	if e595.is_revolver then
		e604 = e593 > e480(e589, "m_flNextPrimaryAttack")
	else
		e604 = e593 > e487(
			e480(e588, "m_flNextAttack"),
			e480(e589, "m_flNextPrimaryAttack"),
			e480(e589, "m_flNextSecondaryAttack")
		)
	end

	if not e604 then
		return
	end

	local e605, e606, e607, e608= e580(
		e588,
		e595,
		e592,
		e602,
		e603
	)

	if not e605 then
		return
	end

	if e470(e605.x, e605.y, e605.z) then
		return
	end

	e554(e555, e570(e595, e596) * 0.33)

	local e609, e542= e592:to(e605):angles()

	if not e596 and e595.type == "sniperrifle" and e555.in_jump == 0 and e597 == 1 then
		e555.in_attack2 = 1
	end

	e526[e566] = true

	if e591 < 0.01 then
		e555.pitch = e609
		e555.yaw = e542
		e555.in_attack = 1
		e529 = true
		e530 = e607
		e531 = e608
		e532 = e566
		e533 = (e493(e512.ui.misc_dormantaimbot_value) or 0)
	end
end

local function e610(e611)
	client.delay_call(0.03, function()
		local e588= e475()
		if client.userid_to_entindex(e611.userid) ~= e588 then
			return
		end

		if e529 and not e534 then
			client.fire_event("dormant_miss", {
				userid = e532,
				aim_hitbox = e530,
				aim_point = e531,
				accuracy = e533
			})
		end

		e534 = false
		e529 = false
		e530 = nil
		e531 = nil
		e532 = nil
		e533 = nil
	end)
end

local function e612(e611)
	local e613= client.userid_to_entindex(e611.userid)
	local e614= client.userid_to_entindex(e611.attacker)

	if e614 == e475() and e613 ~= nil and e529 then
		e534 = true

		client.fire_event("dormant_hit", {
			userid = e613,
			attacker = e614,
			health = e611.health,
			armor = e611.armor,
			weapon = e611.weapon,
			dmg_health = e611.dmg_health,
			dmg_armor = e611.dmg_armor,
			hitgroup = e611.hitgroup,
			accuracy = e533 or 0,
			aim_hitbox = e530
		})
	end
end

local function e615()
	local e616= (cvar.mp_freezetime:get_float() + 1) / globals.tickinterval()
	e525 = e486() + e616
end

e513.register("setup_command", e587, { alive_only = true, require_login = true })
e513.register("round_prestart", e615, { alive_only = true, require_login = true })
e513.register("player_hurt", e612, { alive_only = true, require_login = true })
e513.register("weapon_fire", e610, { alive_only = true, require_login = true })

client.register_esp_flag("DA", 255, 255, 255, function(e551)
	if e515('misc_dormantaimbot') and e515('misc_dormantaimbot_key') and e483(e475()) then
		return e526[e551]
	end
end)


e513.register("paint", function()
	if not e483(e475()) then return end
	if e515('misc_dormantaimbot') and e515('misc_dormantaimbot_key') then
		local e617= {255,255,255,200}
		for e541,e549 in pairs(e526) do if e549 then e617={143,194,21,255}; break end end
		if #e562()==0 then e617={255,0,50,255} end
		e490(e617[1],e617[2],e617[3],e617[4],"DA")
	end
end, { alive_only = true, require_login = true })]]
e981["require/features/misc/enhance_osaa"] = [[local e473, e474= pcall(require, "require/abc/menu_setup")

local e475= require('require/abc/callbacks')

local e476= {}
local e477= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local e478= {ui.reference(item[1], item[2], item[3])}
    e476[i] = e478
    for _, ref in ipairs(e478) do
        e477[ref] = true
    end
end

local e479= {}
local e480= {}

e475.register("weapon_fire", function(e481)
    local e482= entity.get_local_player()
    if e482 and client.userid_to_entindex(e481.userid) == e482 then
        e479[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

e475.register("player_hurt", function(e481)
    local e482= entity.get_local_player()
    if e482 and client.userid_to_entindex(e481.userid) == e482 then
        e480[globals.tickcount()] = true
    end
end, { alive_only = true, require_login = true })

local function e483()
    local e484= globals.tickcount()
    local e485= nil
    for t = e484-20, e484 do
        if e479[t] then
            e485 = t
            break
        end
    end
    if e485 then
        if e484 - e485 <= 4 then
            return true
        end
        return true
    end
    return false
end



local function e486(e487)

    local e483= has_fired()

    local function e488(e489,e490)
        if type(e489) ~= 'table' then return false end
        for _, v in ipairs(e489) do if tostring(v) == tostring(e490) then return true end end
        return false
    end

    local e491= ui.get(e474.ui.fakelag_settings_enhance_onshot) or {}

    if e474 and e474.ui and e483 then
            if e488(e491, 'defensive') then
                e487.force_defensive = true
            end

            if e488(e491, 'roll') then
                ui.set(e476[3][1], math.random(-45, 45))
            end

            local e492= globals.tickcount() % 4 < 2
            if e488(e491, 'jitter') then
                ui.set(e476[2][1], '180')
                ui.set(e476[2][2], e492 and 55 or -48)
            end
    end
end

e475.register('setup_command', function(e487)

    e486(e487)

end, { alive_only = true, require_login = true })]]
e981["require/features/misc/events"] = [[local e476= {}
local e477= globals

e476.last_hit = {}
e476.last_miss = {}

e476.shots_queue = {}
e476.shots_by_id = {}

function e476.record_weapon_fire(e478)
  if not e478 or not e478.t then return end
  e476.shots_queue[#e476.shots_queue+1] = e478
end

function e476.record_aim_fire(e479,e478)
  if not e479 or not e478 then return end
  e476.shots_by_id[e479] = e478
end

function e476.record_aim_miss(e479,e480,e481)
  if not e480 then return end
  local e482= e477.curtime()
  local e483= e481 or {}
  e483.time = e482
  e476.last_miss[e480] = e483
  if e479 then e476.shots_by_id[e479] = nil end
end

function e476.record_player_hurt(e479,e480,e481)
  if not e480 then return end
  local e482= e477.curtime()
  local e483= e481 or {}
  e483.time = e482
  e476.last_hit[e480] = e483
  if e479 then e476.shots_by_id[e479] = nil end
end

function e476.link_recent_shot_to_victim(e480,e484)
  e484 = e484 or 0.35
  local e482= e477.curtime()
  for i=#e476.shots_queue,1,-1 do
    local e485= e476.shots_queue[i]
    if e485 and e485.target == e480 and (e482 - (e485.t or e482)) <= e484 and not e485.linked then
      e476.shots_queue[i].linked = true
      return e476.shots_queue[i]
    end
  end
  return nil
end

return e476
]]
e981["require/features/misc/exploit_fakelag"] = [[local e479, e480= pcall(require, "require/abc/menu_setup")

local e481= require('require/abc/callbacks')

local e482= {}
local e483= {}
for i, item in ipairs({
    { 'rage', 'aimbot', 'double tap' },
    { 'aa', 'other', 'on shot anti-aim' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },

}) do
    local e484= {ui.reference(item[1], item[2], item[3])}
    e482[i] = e484
    for _, ref in ipairs(e484) do
        e483[ref] = true
    end
end


local function e485(e486)

    local e487= ui.get(e480.ui.misc_exploit_fakelag)

    local e488= (ui.get(e482[1][1]) and ui.get(e482[1][2]))
    local e489= (ui.get(e482[2][1]) and ui.get(e482[2][2]))

    local e490= e487 and (e488 or e489)

    if e490 then
        ui.set(e482[3][1], false)
    end

end

e481.register('setup_command', function(e486)

    e485(e486)

end, { alive_only = true, require_login = true })]]
e981["require/features/misc/fakelag"] = [[local e482= {}
local e483= {}
for i, item in ipairs({
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
}) do
    local e484= {ui.reference(item[1], item[2], item[3])}
    e482[i] = e484
    for _, ref in ipairs(e484) do
        e483[ref] = true
    end
end

local e485, e486= pcall(require, "require/abc/menu_setup")

local e487= require('require/abc/callbacks')

e487.register("setup_command", function()
    if not (e485 and e486 and e486.ui) then return end

    local e488, e489= pcall(ui.get, e486.ui.fakelag_fakelag)
    if not e488 or not e489 then return end

    local e490, e491= pcall(ui.get, e486.ui.fakelag_fakelag_type)
    if not e490 then return end

    if tostring(e491) == "gamesense" then
        ui.set(e482[1][1], true)
        local e492, e493= pcall(ui.get, e486.ui.fakelag_fakelag_amount)
        local e494, e495= pcall(ui.get, e486.ui.fakelag_fakelag_variance)
        local e496, e497= pcall(ui.get, e486.ui.fakelag_fakelag_limit)

        if e492 and e493 and e482[2] and e482[2][1] then
            pcall(ui.set, e482[2][1], e493)
        end
        if e494 and e495 and e482[3] and e482[3][1] then
            pcall(ui.set, e482[3][1], e495)
        end
        if e496 and e497 and e482[4] and e482[4][1] then
            pcall(ui.set, e482[4][1], e497)
        end

        return
    end

    if tostring(e491) == "sodium" then
        ui.set(e482[1][1], true)
        local e498, e499= pcall(ui.get, e486.ui.fakelag_fakelag_type2)
        if not e498 then return end

        if tostring(e499) == "jitter" then
            if e482[2] and e482[2][1] then
                pcall(ui.set, e482[2][1], "dynamic")
            end
            local e500= globals.tickcount() or 0
            local e501= math.max(e500 % 101, 100)
            local e502= math.min(math.random(7) + (e500 % 15), 11)
            if e482[3] and e482[3][1] then pcall(ui.set, e482[3][1], e501) end
            if e482[4] and e482[4][1] then pcall(ui.set, e482[4][1], 15) end

            return
        end

        if tostring(e499) == "max" then
            if e482[2] and e482[2][1] then
                pcall(ui.set, e482[2][1], "dynamic")
            end
            if e482[3] and e482[3][1] then
                pcall(ui.set, e482[3][1], 0)
            end
            local e497= 14 + ((globals.tickcount() or 0) % 2)
            if e482[4] and e482[4][1] then pcall(ui.set, e482[4][1], e497) end

            return
        end
    end
end, { alive_only = true, require_login = true })]]
e981["require/features/misc/freestand_helper"] = [[local e485= {}
local e486= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
}) do
    local e487= {ui.reference(item[1], item[2], item[3])}
    e485[i] = e487
    for _, ref in ipairs(e487) do
        e486[ref] = true
    end
end

local e488, e489= pcall(require, "require/abc/menu_setup")

local e490= require('require/abc/callbacks')

local function e491(e492)
    if not (e489 and e489.ui and e489.ui.aa_gskey_freestand) then return end
    if not ui.get(e489.ui.aa_gskey_freestand) then return end

    local function e493(e494,e495)
        if type(e494) ~= 'table' then return false end
        for _, v in ipairs(e494) do if tostring(v) == tostring(e495) then return true end end
        return false
    end

    local e496= ui.get(e489.ui.fakelag_settings_freestanding) or {}


    localplayer = entity.get_local_player()
    local e497, e498, e499= entity.get_prop(localplayer, 'm_vecVelocity')
    if e497 and e498 and e499 then
        velvel =  math.sqrt(e497 * e497 + e498 * e498 + e499 * e499)
    end
    


    if e493(e496, 'static') then
        ui.set(e485[1][1], true)
        ui.set(e485[5][1], '180')
        ui.set(e485[5][2], 6)
        ui.set(e485[6][1], 'off')
        ui.set(e485[7][1], 'off')
    end

    if e493(e496, 'zero pitch') and velvel > 5 then
        ui.set(e485[3][1], 'Off')
    end

    if e493(e496, 'defensive') then
        e492.force_defensive = true
    end

    local e500= globals.tickcount() % 4 < 2
    if e493(e496, 'side flip') and velvel > 5 then
        ui.set(e485[5][1], '180')
        ui.set(e485[5][2], e500 and -90 or 90)
    end

    local e500= globals.tickcount() % 6 < 2
    if e493(e496, 'pitch flip') and velvel > 5 then
        ui.set(e485[3][1], 'custom')
        ui.set(e485[3][2], e500 and -89 or 89)
    end

end

e490.register('setup_command', function(e492)
    e491(e492)
end, { alive_only = true, require_login = true })]]
e981["require/features/misc/history"] = [[
local e488= {}

local e489= 20
local e490= {}

local function e491(e492)
  if not e490[e492] then e490[e492] = { buf = {} } end
  return e490[e492]
end

function e488.push(e492,e493)
  if not e492 or not e493 then return end
  local e494= e491(e492)
  e494.buf[#e494.buf+1] = e493
  if #e494.buf > e489 then table.remove(e494.buf, 1) end
end

function e488.get_last_n(e492,e495)
  e495 = e495 or e489
  local e494= e490[e492]
  if not e494 or #e494.buf == 0 then return {} end
  local e496= {}
  local e497= #e494.buf
  local e498= math.max(1, e497 - e495 + 1)
  for i = e498, e497 do e496[#e496+1] = e494.buf[i] end
  return e496
end

function e488.clear(e492)
  if not e492 then e490 = {} return end
  e490[e492] = nil
end

return e488
]]
e981["require/features/misc/hotkeys"] = [[local e491= {}
local e492= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local e493= {ui.reference(item[1], item[2], item[3])}
    e491[i] = e493
    for _, ref in ipairs(e493) do
        e492[ref] = true
    end
end

local e494, e495= pcall(require, "require/abc/menu_setup")

local e496= require('require/abc/callbacks')

local function e497()

    if ui.get(e495.ui.aa_gskey_freestand) then
        ui.set(e491[3][1], true)
        ui.set(e491[3][2], 'Always on')
    else
        ui.set(e491[3][1], false)
        ui.set(e491[3][2], 'On hotkey')
    end

    if ui.get(e495.ui.aa_gskey_slowmotion) then
        ui.set(e491[4][1], true)
    else
        ui.set(e491[4][1], false)
    end

    if e495 and e495.ui and ui.get(e495.ui.aa_gskey_edgeyaw) then
        ui.set(e491[2][1], true)
    else
        ui.set(e491[2][1], false)
    end

    if e495 and e495.ui and ui.get(e495.ui.aa_gskey_onshot) then
        ui.set(e491[6][2], 'Always on')
    else
        ui.set(e491[6][2], 'On hotkey')
    end

end

e496.register('setup_command', function()

    e497()

end, { alive_only = true, require_login = true })]]
e981["require/features/misc/localdebug"] = [=[local callbacks_ok, callbacks = pcall(require, "require/abc/callbacks")
local M = {}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")

local state = {
    last_yaw = nil,
    last_pitch = nil,
    last_defensive = false,
    skel_list = {},
    last_choked = 0,
    shot_ticks = {},
    shot_ticks_aim = {},
    skel_history = {},
}

local function normalize_angle(a)
    if not a then return a end
    local ang = tonumber(a) or 0
    while ang > 180 do ang = ang - 360 end
    while ang <= -180 do ang = ang + 360 end
    return ang
end

local function on_weapon_fire(ev)
    if not ev then return end
    local attacker_ent = client.userid_to_entindex(ev.userid)
    local lp = entity.get_local_player()
    if attacker_ent ~= lp then return end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks, t)
    while #state.shot_ticks > 200 do table.remove(state.shot_ticks, 1) end
end

local function on_aim_fire(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    if ev.attacker then
        local attacker_ent = client.userid_to_entindex(ev.attacker)
        if attacker_ent ~= lp then return end
    end
    local t = globals.tickcount and globals.tickcount() or 0
    table.insert(state.shot_ticks_aim, t)
    while #state.shot_ticks_aim > 200 do table.remove(state.shot_ticks_aim, 1) end
end

local function had_recent_shot(ticks_back)
    ticks_back = ticks_back or 30
    local now = globals.tickcount and globals.tickcount() or 0
    for i = #state.shot_ticks_aim, 1, -1 do
        local s = state.shot_ticks_aim[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    for i = #state.shot_ticks, 1, -1 do
        local s = state.shot_ticks[i]
        if s and (now - s) <= ticks_back then
            return true
        end
    end
    return false
end

local function safe_tonumber(v)
    local n = tonumber(v)
    if n then return n end
    return 0
end


local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {
    head={names={'head','Head','HEAD'},idx={0}},
    neck={names={'neck','Neck'},idx={1}},
    chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},
    stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},
    pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},
    l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},
    l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},
    l_hand={names={'left hand','Left Hand'},idx={14}},
    r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},
    r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},
    r_hand={names={'right hand','Right Hand'},idx={13}},
    l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},
    l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},
    l_foot={names={'left foot','Left Foot'},idx={12}},
    r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},
    r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},
    r_foot={names={'right foot','Right Foot'},idx={11}},
}

local function find_bone(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x,y,z = entity.hitbox_position(ent, def.names[i])
        if x then return x,y,z end
    end
    for i = 1, #(def.idx or {}) do
        local x,y,z = entity.hitbox_position(ent, def.idx[i])
        if x then return x,y,z end
    end
end

local function snap_ent(ent)
    if not ent then return end
    local pts = {}
    for key, def in pairs(boxes) do
        local x,y,z = find_bone(ent, def)
        if x then pts[key] = {x=x,y=y,z=z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local function paint_handler()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lag_record then
        local ok_enabled, enabled = pcall(ui.get, menu_setup.ui.paint_lag_record)
        if not ok_enabled or not enabled then return end
    end
    if not renderer or not renderer.world_to_screen or not renderer.line then return end
    local now = globals.realtime and globals.realtime() or os.time()
    local i = 1
    while i <= #state.skel_list do
        local it = state.skel_list[i]
        if not it or not it.t or (now - it.t) > 10 then
            table.remove(state.skel_list, i)
        else
            local SKEL_SCALE = 1.15
            
            local trail = it.trail or {}
            if trail and #trail > 0 then
                for ti = 1, #trail do
                    local entry = trail[ti]
                    local trail_pts = entry.pts or {}
                    
                    local ratio = ti / #trail
                    local r, g, b, alpha
                    if ti == #trail then
                        
                        r = 0
                        g = 140
                        b = 255
                        alpha = 200
                    else
                        
                        r = 255
                        g = math.floor(255 * (1 - ratio))
                        b = math.floor(255 * (1 - ratio))
                        alpha = math.floor(40 + ratio * (160 - 40))
                    end
                    
                    local center = trail_pts.pelvis or trail_pts.chest
                    if not center then
                        local sx, sy, sz, ccount = 0,0,0,0
                        for k, v in pairs(trail_pts) do
                            if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                        end
                        if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
                    end
                    for c = 1, #chains do
                        local chain = chains[c]
                        local from, to = trail_pts[chain[1]], trail_pts[chain[2]]
                        if from and to then
                            local fxw, fyw, fzw = from.x, from.y, from.z
                            local txw, tyw, tzw = to.x, to.y, to.z
                            if center and center.x then
                                fxw = center.x + (from.x - center.x) * SKEL_SCALE
                                fyw = center.y + (from.y - center.y) * SKEL_SCALE
                                fzw = center.z + (from.z - center.z) * SKEL_SCALE
                                txw = center.x + (to.x - center.x) * SKEL_SCALE
                                tyw = center.y + (to.y - center.y) * SKEL_SCALE
                                tzw = center.z + (to.z - center.z) * SKEL_SCALE
                            end
                            local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                            local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                            if fx and tx then renderer.line(fx,fy,tx,ty,r,g,b,alpha) end
                        end
                    end
                end
            end
            
            local pts = it.pts or {}
            local center = pts.pelvis or pts.chest
            if not center then
                local sx, sy, sz, ccount = 0,0,0,0
                for k, v in pairs(pts) do
                    if v and v.x then sx = sx + v.x; sy = sy + v.y; sz = sz + v.z; ccount = ccount + 1 end
                end
                if ccount > 0 then center = { x = sx/ccount, y = sy/ccount, z = sz/ccount } end
            end
            for c = 1, #chains do
                local chain = chains[c]
                local from, to = pts[chain[1]], pts[chain[2]]
                if from and to then
                    local fxw, fyw, fzw = from.x, from.y, from.z
                    local txw, tyw, tzw = to.x, to.y, to.z
                    if center and center.x then
                        fxw = center.x + (from.x - center.x) * SKEL_SCALE
                        fyw = center.y + (from.y - center.y) * SKEL_SCALE
                        fzw = center.z + (from.z - center.z) * SKEL_SCALE
                        txw = center.x + (to.x - center.x) * SKEL_SCALE
                        tyw = center.y + (to.y - center.y) * SKEL_SCALE
                        tzw = center.z + (to.z - center.z) * SKEL_SCALE
                    end
                    local fx,fy = renderer.world_to_screen(fxw, fyw, fzw)
                    local tx,ty = renderer.world_to_screen(txw, tyw, tzw)
                    if fx and tx then renderer.line(fx,fy,tx,ty,255,0,0,220) end
                end
            end
            i = i + 1
        end
    end
end


local function on_setup_command(cmd)
    if not cmd then return end
    local aa_funcs = nil
    local ok_req, req_lib = pcall(require, 'gamesense/antiaim_funcs')
    if ok_req and req_lib then aa_funcs = req_lib end
    if not aa_funcs then
        local ok_libs, libs = pcall(require, 'require/help/libs')
        if ok_libs and libs and libs.get then
            aa_funcs = libs.get('antiaim_funcs')
        end
    end

    local pitch, yaw = nil, nil
    if aa_funcs then
        local okp, pval = pcall(function() return aa_funcs.get_pitch and aa_funcs.get_pitch() end)
        if okp and pval ~= nil then pitch = pval end
        local oky, yval = pcall(function() return aa_funcs.get_yaw_base and aa_funcs.get_yaw_base() end)
        if oky and yval ~= nil then yaw = yval end
        if yaw == nil then
            local okb, bval = pcall(function() return aa_funcs.get_body_yaw and aa_funcs.get_body_yaw() end)
            if okb and bval ~= nil then yaw = bval end
        end
    end

    if (pitch == nil or yaw == nil) then
        local lp = entity.get_local_player()
        if lp then
            local ax, ay = entity.get_prop(lp, "m_angEyeAngles")
            if ax and ay then
                if pitch == nil then pitch = ax end
                if yaw == nil then yaw = ay end
            end
        end
    end

    if pitch ~= nil then state.last_pitch = pitch end
    if yaw ~= nil then state.last_yaw = normalize_angle(yaw) end

    do
        local ok_def, def_mod = pcall(require, 'require/features/aa/defensive')
        if ok_def and def_mod and def_mod.active ~= nil then
            state.last_defensive = not not def_mod.active
        else
            if cmd and cmd.force_defensive ~= nil then
                state.last_defensive = not not cmd.force_defensive
            end
        end
    end
    if cmd and cmd.chokedcommands ~= nil then
        state.last_choked = tonumber(cmd.chokedcommands) or 0
    end
    local lp = entity.get_local_player()
    if lp then
        local tick = globals.tickcount and globals.tickcount() or 0
        local hist_pts = snap_ent(lp)
        if hist_pts then
            state.skel_history[#state.skel_history + 1] = { tick = tick, pts = hist_pts }
            if #state.skel_history > 128 then table.remove(state.skel_history, 1) end
        end
    end
end

local function on_player_death(ev)
    if not ev then return end
    local lp = entity.get_local_player()
    if not lp then return end
    local victim_ent = client.userid_to_entindex(ev.userid)
    local attacker_ent = nil
    if ev.attacker then attacker_ent = client.userid_to_entindex(ev.attacker) end

    if victim_ent == lp then
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then
                attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker)
            else
                attacker_name = tostring(ev.attacker)
            end
        end
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] DIED — last_yaw=%.2f last_pitch=%.2f attacker=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
        return
    end
    if attacker_ent == lp and victim_ent and victim_ent ~= 0 and victim_ent ~= lp then
        local victim_name = entity.get_player_name(victim_ent) or tostring(ev.userid)
        local weapon = ev.weapon or "unknown"
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        client.log(string.format("[localdebug] KILLED — last_yaw=%.2f last_pitch=%.2f victim=%s weapon=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, victim_name, tostring(weapon), def, state.last_choked, onshot))
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end
end

if callbacks_ok and callbacks and callbacks.callback then
    callbacks.callback('setup_command', on_setup_command, { alive_only = false, require_login = false })
    callbacks.callback('player_death', on_player_death, { alive_only = false, require_login = false })
    callbacks.callback('paint', paint_handler, { alive_only = false, require_login = false })
    callbacks.callback('weapon_fire', on_weapon_fire, { alive_only = false, require_login = false })
    callbacks.callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end, { alive_only = false, require_login = false })
else
    client.set_event_callback('setup_command', on_setup_command)
    client.set_event_callback('player_death', on_player_death)
    client.set_event_callback('paint', paint_handler)
    client.set_event_callback('weapon_fire', on_weapon_fire)
    client.set_event_callback('player_hurt', function(ev)
        if not ev then return end
        local lp = entity.get_local_player()
        if not lp then return end
        local victim_ent = client.userid_to_entindex(ev.userid)
        if victim_ent ~= lp then return end
        local attacker_name = "unknown"
        if ev.attacker then
            local atk_ent = client.userid_to_entindex(ev.attacker)
            if atk_ent and atk_ent ~= 0 then attacker_name = entity.get_player_name(atk_ent) or tostring(ev.attacker) else attacker_name = tostring(ev.attacker) end
        end
        local damage = ev.dmg_health or ev.damage or "?"
        local health = ev.health or ev.hp
        local health_num = tonumber(health)
        local yaw = safe_tonumber(state.last_yaw)
        local pitch = safe_tonumber(state.last_pitch)
        local def = tostring(state.last_defensive)
        local onshot = had_recent_shot(30) and "true" or "false"
        if health_num ~= nil and health_num == 0 then
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), def, state.last_choked, onshot))
        else
            local hstr = (health_num ~= nil) and tostring(health_num) or (health and tostring(health) or "?")
            client.log(string.format("[localdebug] HURT — last_yaw=%.2f last_pitch=%.2f attacker=%s damage=%s health=%s defensive=%s choked=%d ONSHOT=%s", yaw, pitch, attacker_name, tostring(damage), hstr, def, state.last_choked, onshot))
        end
        local pts = snap_ent(lp)
        if pts then
            local now_tick = globals.tickcount and globals.tickcount() or 0
            local trail = {}
            for i = 1, #state.skel_history do
                local h = state.skel_history[i]
                if h and h.tick and h.pts and h.tick >= (now_tick - 30) and h.tick <= now_tick then
                    trail[#trail + 1] = { tick = h.tick, pts = h.pts }
                end
            end
            table.insert(state.skel_list, { pts = pts, t = (globals.realtime and globals.realtime() or os.time()), trail = trail })
        end
    end)
end
]=]
e981["require/features/misc/resolver"] = [[














local e497, e498= pcall(require, "require/features/misc/collect")
local e499, e500= pcall(require, "require/features/misc/history")
local e501, e502= pcall(require, "require/features/misc/state")
local e503, e504= pcall(require, "require/features/misc/events")
local e505, e506= pcall(require, "require/help/vector")
local e507= e505 and e506 or nil
local e508= require('require/abc/callbacks')







if not M then M = {} end
M.players = M.players or {}


local function e509()
	pcall(function()
		if not e497 or type(e498) ~= "table" or not e498.get_enemies_snapshot then return end

		local e510, e511= pcall(function() return e498.get_enemies_snapshot() end)
		if not e510 or type(e511) ~= "table" then return end

		M.players = M.players or {}

		for ent, snap in pairs(e511) do
			M.players[ent] = M.players[ent] or {}
			M.players[ent].snapshot = snap

            
            
            
			M.players[ent].simtime = snap.simtime
			M.players[ent].simTicks = snap.simTicks
			M.players[ent].lowerBodyYaw = snap.lowerBodyYaw
			M.players[ent].speed2d = snap.speed2d
			M.players[ent].velocity3d = snap.velocity3d
			M.players[ent].is_alive = snap.is_alive
			M.players[ent].is_dormant = snap.is_dormant
			M.players[ent].feetYaw = snap.feetYaw
			M.players[ent].goalFeetYaw = snap.goalFeetYaw
			M.players[ent].moveSpeedAnim = snap.moveSpeedAnim
		end

		for ent, snap in pairs(e511) do
			local e512= snap.name or "?"
			local e513= snap.simtime or 0
			local e514= snap.speed2d or 0
			local e515= snap.lowerBodyYaw or "nil"
			local e516= snap.moveSpeedAnim or 0
			local e517= snap.feetYaw or "nil"
			local e518= snap.goalFeetYaw or "nil"
			local e519= snap.animstate_full.m_fDuckAmount

		end
	end)
end



local function e520(e521)
    while e521 > 180 do
        e521 = e521 - 360
    end
    while e521 < -180 do
        e521 = e521 + 360
    end
    return e521
end


local function e522(e523,e524)
    local e525= e524 - e523
    local e521= math.atan(e525.y / e525.x)
    e521 = e520(e521 * 180 / math.pi)

    if e525.x >= 0 then
        e521 = e520(e521 + 180)
    end

    return e521
end



local e526= 100
local e527= {}
_G.player_history = e527

local function e528(e529)
    return math.floor(0.5 + e529 / globals.tickinterval())
end

local function e530(e531)
    local e532= entity.get_players(true)

	if #e532 == 0 then
		
		e527 = {}
		_G.player_history = e527
		return nil
	end


	for i, player in ipairs(e532) do
		if entity.is_alive(player) and not entity.is_dormant(player) then

			local e533= 0
			local e534= entity.get_esp_data(player).flags or 0

			if bit.band(e534, bit.lshift(1, 17)) ~= 0 then
				e533 = e528(entity.get_prop(player, "m_flSimulationTime")) - 14
			else
				e533 = e528(entity.get_prop(player, "m_flSimulationTime"))
			end

			
			local e535= e527[player] or {}
			local e536= e535[1]

			if e536 == nil or (e533 - (e536.simtime or -999)) >= 1 then

				local e537= e507(entity.get_prop(e531, "m_vecOrigin"))
				local e538= e507(entity.get_prop(player, "m_angEyeAngles"))
				local e539= e507(entity.get_prop(player, "m_vecOrigin"))
				local e540= math.floor(e520(e538.y - e522(e537, e539)))
				

				local e541= {
					id = player or nil,
					origin = e507(entity.get_origin(player)) or e507(nil,nil,nil),
					pitch = e538.x or nil,
					yaw = e540 or nil,
					yaw_backwards = backwards_angle or nil,
					simtime = e533 or nil,
					stance = stance or nil,
					esp_flags = entity.get_esp_data(player).flags or 0,
					last_shot_time = last_shot_time or nil
				}

				table.insert(e535, 1, e541)
				while #e535 > e526 do
					table.remove(e535)
				end

				e527[player] = e535
			end
		end
	end
end















client.set_event_callback('net_update_end', function()
    pcall(function()

        
        

        local e531= entity.get_local_player()
        if not entity.is_alive(e531) then
            return
        end
        e530(e531)


        local e542= (globals and globals.tickcount and globals.tickcount()) or (globals and globals.realtime and globals.realtime()) or os.time()
        

    end)
end, { alive_only = true, require_login = true })

e508.register('weapon_fire', function(e543)
    pcall(function()







        local e544= (e543 and e543.userid) and (client.userid_to_entindex and client.userid_to_entindex(e543.userid)) or (e543 and (e543.attacker or e543.userid)) or "?"
        local e545= (e543 and (e543.weapon or e543.weapon_name or e543.weaponid)) or "?"
        
    end)
    if EVENTS and EVENTS.record_weapon_fire then pcall(EVENTS.record_weapon_fire, e543) end
end, { alive_only = true, require_login = true })

e508.register('aim_fire', function(e543)
    pcall(function()








        local e546= e543 and e543.id or "?"
        local e547= e543 and e543.target or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_fire then pcall(EVENTS.record_aim_fire, e543) end
end, { alive_only = true, require_login = true })

e508.register('aim_hit', function(e543)
    pcall(function()








        local e546= e543 and e543.id or "?"
        local e547= e543 and e543.target or "?"
        local e548= e543 and e543.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_hit then pcall(EVENTS.record_aim_hit, e543) end
end, { alive_only = true, require_login = true })

e508.register('aim_miss', function(e543)
    pcall(function()






        local e546= e543 and e543.id or "?"
        local e549= e543 and e543.reason or "?"
        
    end)
    if EVENTS and EVENTS.record_aim_miss then pcall(EVENTS.record_aim_miss, e543) end
end, { alive_only = true, require_login = true })

e508.register('player_hurt', function(e543)
    pcall(function()






        local e550= (e543 and e543.attacker) or (e543 and e543.userid) or "?"
        local e551= (e543 and e543.userid) or (e543 and e543.userid) or "?"
        local e548= e543 and e543.damage or "?"
        
    end)
    if EVENTS and EVENTS.record_player_hurt then pcall(EVENTS.record_player_hurt, e543) end
end, { alive_only = true, require_login = true })

e508.register('bullet_impact', function(e543)
    pcall(function()




        local e544= (e543 and e543.userid) and (client.userid_to_entindex and client.userid_to_entindex(e543.userid)) or "?"
        local e552,e553,e554= e543 and e543.x or "?", e543 and e543.y or "?", e543 and e543.z or "?"
        
    end)
    if EVENTS and EVENTS.on_bullet_impact then pcall(EVENTS.on_bullet_impact, e543) end
    if EVENTS and EVENTS.record_bullet_impact then pcall(EVENTS.record_bullet_impact, e543) end
end, { alive_only = true, require_login = true })

e508.register('paint', function()
    pcall(function()

        

    end)
    if EVENTS and EVENTS.on_paint then pcall(EVENTS.on_paint) end
end, { alive_only = true, require_login = true })

e508.register("round_start", function(e543)
    pcall(function() print("[resolver] round_start") end)



    M.players = {}
    if EVENTS and EVENTS.on_round_start then pcall(EVENTS.on_round_start, e543) end
end, { alive_only = true, require_login = true })

e508.register("shutdown", function()
    if client and client.unset_event_callback then



    end
end, { alive_only = true, require_login = true })
]]
e981["require/features/misc/resolver_dispatcher"] = [[local e500= {}


local e501= {}


_G.player_resolver_state = _G.player_resolver_state or {}

local function e502(e503)
    if not e503 or type(e503) ~= "string" then return nil end
    
    local e504= e503:lower()
    e504 = e504:gsub("%+", "plus")
    e504 = e504:gsub("%-% ", "minus_") 
    e504 = e504:gsub("%-%", "minus")
    e504 = e504:gsub("%s+", "_")
    e504 = e504:gsub("[^%w_]", "")
    return e504
end

local function e505(e503)
    local e506
    
    if e503 == "?" then
        e506 = "default"
    else
        e506 = e502(e503)
    end
    if not e506 or e506 == "" then return nil end
    if e501[e506] ~= nil then return e501[e506] end
    local e507= "require/features/misc/res_" .. e506
    local e508, e509= pcall(require, e507)
    if e508 and type(e509) == "table" then
        e501[e506] = e509
        return e509
    end
    e501[e506] = false
    return nil
end



function e500.process_entity(e510,e503,e511)
    local e508, e512= pcall(function()
        if not e510 or e510 == 0 then return end
        if not e503 or e503 == "?" then return end

        local e509= e505(e503)
        if not e509 then return end

        
        local e513= _G.player_resolver_state[e510]
        if not e513 then
            e513 = {}
            _G.player_resolver_state[e510] = e513
        end

        if type(e509.run) == "function" then
            
            pcall(function() e509.run(e510, e511 or {}, e513, e503) end)
        elseif type(e509.process) == "function" then
            pcall(function() e509.process(e510, e511 or {}, e513, e503) end)
        end
    end)
    return e508
end


e500._modules = e501
e500._sanitize_label = e502

return e500
]]
e981["require/features/misc/res_default"] = [[local e503= {}

local function e504(e505)
    pcall(function()
        if plist and type(plist.set) == "function" then
            
            plist.set(e505, "Force body yaw", false)
            plist.set(e505, "Force body yaw value", 0)
            plist.set(e505, "Force pitch", false)
            plist.set(e505, "Force pitch value", 0)
        end
    end)
end

function e503.run(e505,e506,e507,e508)
    
    if e508 ~= "?" and e508 ~= "DEFAULT" and e508 ~= "default" then return end

    e507.clears = (e507.clears or 0) + 1
    e507.last_seen = (globals and globals.curtime and globals.curtime()) or os.time()

    
    e504(e505)

    pcall(function()
        print(string.format("[res_default] ent=%d cleared_forces label=%s count=%d", e505, tostring(e508), e507.clears))
    end)
end

return e503
]]
e981["require/features/misc/res_static"] = [=[local M = {}
local ok_ffi, ffi = pcall(require, "ffi")
local ok_bit, bit = pcall(require, "bit")


local get_entity_ptr
local function init_ffi_helpers()
    if not ok_ffi or not client or not client.create_interface then return end
    local status, res = pcall(function()
        local pointer_type = ffi.typeof("void***")
        local entity_list_ptr = client.create_interface("client.dll", "VClientEntityList003")
        if not entity_list_ptr then return nil end
        local entity_list = ffi.cast(pointer_type, entity_list_ptr)
        local get_client_entity = ffi.cast("void*(__thiscall*)(void*, int)", entity_list[0][3])
        return function(entindex)
            if not entindex or entindex == 0 then return nil end
            local ptr = get_client_entity(entity_list, entindex)
            if ptr == nil then return nil end
            return ptr
        end
    end)
    if status and type(res) == "function" then
        get_entity_ptr = res
    else
        get_entity_ptr = nil
    end
end
init_ffi_helpers()

local function get_speed2d(ent)
    
    local ok, vx, vy = pcall(function()
        local x,y,z = entity.get_prop(ent, "m_vecVelocity")
        return x or 0, y or 0
    end)
    if ok and vx and vy then
        return math.sqrt((vx or 0)*(vx or 0) + (vy or 0)*(vy or 0))
    end
    return 0
end

local function estimate_max_desync_ent(ent)
    
    if not ok_ffi or not get_entity_ptr then return nil end
    local ok_read, result = pcall(function()
        ffi.cdef[[
        struct c_animstate {
            char pad0[3];
            char m_bForceWeaponUpdate;
            char pad1[91];
            void* m_pBaseEntity;
            void* m_pActiveWeapon;
            void* m_pLastActiveWeapon;
            float m_flLastClientSideAnimationUpdateTime;
            int m_iLastClientSideAnimationUpdateFramecount;
            float m_flAnimUpdateDelta;
            float m_flEyeYaw;
            float m_flPitch;
            float m_flGoalFeetYaw;
            float m_flCurrentFeetYaw;
            float m_flCurrentTorsoYaw;
            float m_flUnknownVelocityLean;
            float m_flLeanAmount;
            char pad2[4];
            float m_flFeetCycle;
            float m_flFeetYawRate;
            char pad3[4];
            float m_fDuckAmount;
            float m_fLandingDuckAdditiveSomething;
            char pad4[4];
            float m_vOriginX;
            float m_vOriginY;
            float m_vOriginZ;
            float m_vLastOriginX;
            float m_vLastOriginY;
            float m_vLastOriginZ;
            float m_vVelocityX;
            float m_vVelocityY;
            char pad5[4];
            float m_flUnknownFloat1;
            char pad6[8];
            float m_flUnknownFloat2;
            float m_flUnknownFloat3;
            float m_flUnknown;
            float m_flSpeed2D;
            float m_flUpVelocity;
            float m_flSpeedNormalized;
            float m_flFeetSpeedForwardsOrSideWays;
            float m_flFeetSpeedUnknownForwardOrSideways;
            float m_flTimeSinceStartedMoving;
            float m_flTimeSinceStoppedMoving;
            bool m_bOnGround;
            bool m_bInHitGroundAnimation;
            char pad7[2];
            float m_flTimeSinceInAir;
            float m_flLastOriginZ;
            float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
            float m_flStopToFullRunningFraction;
            float m_flMagicFraction;
            char pad8[60];
            float m_flWorldForce;
            char pad9[462];
            float m_flMaxYaw;
        };
        ]]
        local ent_ptr = get_entity_ptr(ent)
        if not ent_ptr then return nil end
        local animstate_ptr = ffi.cast("struct c_animstate**", ffi.cast("uintptr_t", ent_ptr) + 0x9960)
        if animstate_ptr == nil or animstate_ptr == ffi.NULL then return nil end
        local anim = animstate_ptr[0]
        if anim == nil or anim == ffi.NULL then return nil end

        local duck_amount = tonumber(anim.m_fDuckAmount) or 0
        local speed2d_norm = tonumber(anim.m_flFeetSpeedForwardsOrSideWays) or 0
        local stop_to_full = tonumber(anim.m_flStopToFullRunningFraction) or 0
        local max_yaw = tonumber(anim.m_flMaxYaw) or 0

        local yaw_modifier = ((-0.3 * stop_to_full) - 0.2) * math.max(0, math.min(speed2d_norm, 1)) + 1.0
        if duck_amount > 0 then
            yaw_modifier = yaw_modifier + (duck_amount * 0.5) * (0.5 - yaw_modifier)
        end

        local raw_delta = max_yaw * yaw_modifier
        local velocity = get_speed2d(ent) or 0
        local velocity_clamped = math.min(math.max(velocity, 0), 260)
        local move_scale = 1.0 - (velocity_clamped / 260)
        move_scale = 0.35 + (move_scale * 0.65)
        local delta = raw_delta * move_scale
        if velocity >= 250 then
            delta = math.min(delta, 28)
        end
        local flags = nil
        if ok_bit and entity and entity.get_prop then
            flags = entity.get_prop(ent, "m_fFlags") or 0
        end
        local on_ground = true
        if flags then on_ground = bit.band(flags, 1) == 1 end
        if not on_ground then delta = delta * 0.55 end
        if duck_amount > 0.9 then delta = delta * 0.9 end
        delta = math.max(0, math.min(delta, 60))
        return delta
    end)
    if ok_read then return result end
    return nil
end

local function safe_unset(ent)
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", false)
            plist.set(ent, "Force body yaw value", 0)
        end
    end)
end

local function now_time()
    local ok, t = pcall(function() return (globals and globals.curtime and globals.curtime()) or os.time() end)
    return ok and t or os.time()
end

local function normalize_angle(angle)
    if not angle or type(angle) ~= "number" then return 0 end
    while angle > 180 do angle = angle - 360 end
    while angle < -180 do angle = angle + 360 end
    return angle
end

local function round(n)
    return math.floor((n or 0) + 0.5)
end

function M.run(ent, features, state, label)
    
    state.count = (state.count or 0) + 1
    state.last_seen = now_time()
    if state.last_label and state.last_label ~= label then state.count = 1 end
    state.last_label = label

    
    if not label or label ~= "STATIC" then return end

    
    local required_count = 3
    if state.count < required_count then return end

    
    if features and features.shot_age and tonumber(features.shot_age) and features.shot_age <= 0.25 then
        return
    end

    
    local avg_speed = tonumber((features and features.avg_speed) or 0) or 0
    if features and features.movement and features.movement == true then return end
    if avg_speed >= 1.2 then return end

    
    local max_mag_low = 58
    local max_mag_high = 28
    local speed_cap = 250
    local t = math.min(math.max(avg_speed / speed_cap, 0), 1)
    local max_mag = max_mag_low + (max_mag_high - max_mag_low) * t

    
    local ok_est, est = pcall(function() return estimate_max_desync_ent(ent) end)
    if ok_est and est and type(est) == "number" then
        max_mag = math.min(max_mag, est)
    end

    
    local on_ground = true
    pcall(function()
        if ok_bit and entity and entity.get_prop then
            local flags = entity.get_prop(ent, "m_fFlags") or 0
            on_ground = bit.band(flags, 1) == 1
        end
    end)
    if not on_ground then max_mag = max_mag * 0.55 end

    
    local forced_val = 0

    
    local last_yaw = (features and features.last_yaw)
    local ref_yaw = features and (features.goal_feet_yaw or features.feet_yaw)
    local desync = nil
    if last_yaw and ref_yaw then
        desync = normalize_angle(last_yaw - ref_yaw)
    end

    
    if not desync then
        forced_val = 0
    else
        local absd = math.abs(desync)
        
        if absd <= 10 then
            forced_val = 0
        else
            
            if ok_est and est and type(est) == "number" and est >= 8 then
                local mag = math.min(math.floor(max_mag + 0.5), math.floor(est + 0.5))
                local desired = math.min(absd, mag)
                
                if desired >= 8 then
                    forced_val = (desync >= 0) and desired or -desired
                else
                    forced_val = 0
                end
            else
                
                forced_val = 0
            end
        end
    end

    
    forced_val = round(forced_val)
    if forced_val > 60 then forced_val = 60 end
    if forced_val < -60 then forced_val = -60 end

    
    pcall(function()
        if plist and type(plist.set) == "function" then
            plist.set(ent, "Force body yaw", true)
            plist.set(ent, "Force body yaw value", forced_val)
            state.forced = true
            state.forced_value = forced_val
            state.cooldown = now_time() + 0.5

            if client and type(client.delay_call) == "function" then
                client.delay_call(0.6, function()
                    pcall(function()
                        local t = now_time()
                        if not state.cooldown or t > state.cooldown then
                            safe_unset(ent)
                            state.forced = nil
                            state.forced_value = nil
                        end
                    end)
                end)
            end
        end
    end)
end

return M
]=]
e981["require/features/misc/roll"] = [[local e509, e510= pcall(require, "require/abc/menu_setup")

local e511= {}
local e512= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Roll' },

}) do
    local e513= {ui.reference(item[1], item[2], item[3])}
    e511[i] = e513
    for _, ref in ipairs(e513) do
        e512[ref] = true
    end
end

local function e514(e515)

    local e516= 0
    if e510 and e510.ui and e510.ui.fakelag_settings_roll then
        e516 = ui.get(e510.ui.fakelag_settings_roll) or 0
    end
    local e517= ui.get(e510.ui.fakelag_settings_side) or 1
    local e518= entity.get_local_player()
    local e519= e518 and entity.get_prop(e518, 'm_vecVelocity') or 0

    if e519 > 3 then
        ui.set(e511[1][1], 0)
        return
    end

    if e517 == 3 then
        ui.set(e511[1][1], -e516)
    elseif e517 == 2 then
        local e520= (globals.tickcount() % 20) < 10
        ui.set(e511[1][1], e520 and e516 or -e516)
    elseif e517 == 1 then
        ui.set(e511[1][1], e516)
    end

end

client.set_event_callback('setup_command', function(e515)

    e514(e515)

end)]]
e981["require/features/misc/spin_on_dead_enemies"] = [[local e512= {}
for i, item in ipairs({
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}) do
    local e513= {ui.reference(item[1], item[2], item[3])}
    e512[i] = e513
end

local e514, e515, e516, e517= entity, globals, ui, client
local e518= require("require/abc/menu_setup")
local e519= (e517.random_int(1, 2) == 1) and 1 or -1

local function e520()
    local e521= {
        {2, 'Off'}, {3, 'Local view'}, {4, {'Spin', 45}}, {5, {'Off', 0}}, {6, {'Off', 0}},
    }
    local e519= (e517.random_int(1, 2) == 1) and 1 or -1
    for _, v in ipairs(e521) do
        local e522, e523= v[1], v[2]
        local e513= e512[e522]
        if not e513 then goto continue end
        if type(e523) ~= 'table' then
            pcall(e516.set, e513[1], e523)
        else
            if e513[1] then pcall(e516.set, e513[1], e523[1]) end
            if e513[2] then
                if type(e523[2]) == 'number' and e523[1] == 'Spin' then
                    pcall(e516.set, e513[2], e523[2] * e519)
                else
                    pcall(e516.set, e513[2], e523[2])
                end
            end
        end
        ::continue::
    end
end

local function e524()
    local e525= (e515.maxplayers and e515.maxplayers() or 64)
    local e526, e527, e528= e514.get_classname, e514.is_enemy, e514.is_alive
    if not (e526 and e527 and e528) then return 0 end
    local e529= 0
    for i=1,e525 do
        if e526(i) == 'CCSPlayer' and e527(i) and e528(i) then e529 = e529 + 1 end
    end
    return e529
end

local function e530()
    if not e516.get(e518.ui.misc_spindead) then return end
    if e524() == 0 then e520() end
end

local e531, e532= pcall(require, "require/abc/callbacks")
if e531 and e532 then
    e532.callback('run_command', e530, { alive_only = true, require_login = true })
end
]]
e981["require/features/misc/walkbot"] = [[local e515= require("require/abc/callbacks")
local e516= require("require/abc/menu_setup")

local e517= nil
local e518= 1
local e519= 0
local e520= 40
local e521= 30
local e522= 450
local e523= 200
local e524= 8
local e525= {150, 300}
local e526= nil
local e527= nil
local e528= nil
local e529= 0
local e530= 700
local e531= 3

local e532= {}
local e533= 3
local e534= 4
local e535= 0
local e536= nil
local e537= 0
local e538= 500
local e539= 1500
local e540= 30
local e541= {}
local e542= false

local e543= 500 
local e544= 0

local e545= {
    { name = "A", x = -445.0, y = -1997.7, z = -180.0 },
    { name = "B", x = -2032.4, y = 259.8, z = -160.0 },
    { name = "Mid", x = -350.3, y = -617.1, z = -269.2 },
}

local function e546(e547)
    if not e547 then return false end
    local e548, e549= pcall(ui.get, e547)
    if not e548 then return false end
    return e549
end

local function e550(e551)
    while e551 > 180 do e551 = e551 - 360 end
    while e551 < -180 do e551 = e551 + 360 end
    return e551
end

local function e552(e553,e554,e555,e556,e557,e558)
    local e559, e560, e561= e553-e556, e554-e557, e555-e558
    return math.sqrt(e559*e559 + e560*e560 + e561*e561)
end

local function e562(e563,e564,e565,e566,e567,e568,e569)
    local e548, e570, e571= pcall(function()
        return client.trace_line(e563, e564, e565, e566, e567, e568, e569)
    end)
    if not e548 then return nil end
    return e570, e571
end

local function e572(e563,e573,e574,e575)
    local e576= e575 + 1000
    local e577= e575 - 1000
    local e570= e562(e563, e573, e574, e576, e573, e574, e577)
    if not e570 then return e575 end
    if type(e570) ~= 'number' then return e575 end
    local e578= e576 + (e577 - e576) * e570
    return e578
end

local function e579(e563,e564,e565,e566,e567,e568,e569)
    local e570= e562(e563, e564, e565, e566, e567, e568, e569)
    if not e570 then return false end
    if e570 >= 1 then return true end
    return false
end

local function e580(e573,e574)
    return tostring(math.floor(e573/50))..":"..tostring(math.floor(e574/50))
end

local function e581(e573,e574)
    local e582= e580(e573, e574)
    e532[e582] = (e532[e582] or 0) + 1
    if e532[e582] >= e533 then
        e541[e582] = true
    end
    return e532[e582]
end

local function e583(e573,e574)
    local e582= e580(e573, e574)
    e532[e582] = nil
end

local function e584(e563)
    local e585, e586, e587= entity.get_origin(e563)
    if not e585 then return nil end
    for i=1,e521 do
        local e588= math.random()*math.pi*2
        local e589= 200 + math.random()*800
        local e567= e585 + math.cos(e588)*e589
        local e568= e586 + math.sin(e588)*e589
        local e569= e587
            local e570= e562(e563, e585, e586, e587 + 16, e567, e568, e569 + 16)
        if e570 and e570 >= 1 then
            local e590= e572(e563, e567, e568, e569)
            return { x = e567, y = e568, z = e590 }
        end
        if e570 and e570 < 1 then
            local e591= e585 + (e567-e585)*e570
            local e592= e586 + (e568-e586)*e570
            local e593= e587 + (e569-e587)*e570
            for _, r in ipairs(e525) do
                for s=0,e524-1 do
                    local e551= (s/e524) * math.pi * 2
                    local e594= e591 + math.cos(e551)*r
                    local e595= e592 + math.sin(e551)*r
                    local e596= e572(e563, e594, e595, e593)
                    local e597= e562(e563, e585, e586, e587+16, e594, e595, e596+16)
                    local e598= e562(e563, e594, e595, e596+16, e567, e568, e569+16)
                    if e597 and e597>=1 and e598 and e598>=1 then
                        local e590= e572(e563, e567, e568, e569)
                        return { x = e567, y = e568, z = e590 }
                    end
                end
            end
        end
    end
    return nil
end

local function e599(e600)
    local e601= {}
    while e600 do
        e601[#e601+1] = { x = e600.x, y = e600.y, z = e600.z }
        e600 = e600.parent
    end
    local e602= {}
    for i=#e601,1,-1 do e602[#e602+1] = e601[i] end
    return e602
end

local function e603(e563,e604)
    local e585, e586, e587= entity.get_origin(e563)
    if not e585 then return nil end
    local e605= { x = e585, y = e586, z = e587 }
    e605.z = e572(e563, e605.x, e605.y, e605.z)
    local e606= { { x = e605.x, y = e605.y, z = e605.z, parent = nil } }
    local e607= {}
    local function e608(e609)
        local e610= tostring(math.floor(e609.x/50))..":"..tostring(math.floor(e609.y/50))
        e607[e610] = true
    end
    local function e611(e609)
        local e610= tostring(math.floor(e609.x/50))..":"..tostring(math.floor(e609.y/50))
        if e541[e610] then return true end
        return e607[e610]
    end
    e608(e605)
    local e612= 0
    while #e606 > 0 and e612 < e523 do
        local e613= table.remove(e606, 1)
        e612 = e612 + 1
        local e570= e562(e563, e613.x, e613.y, e613.z+16, e604.x, e604.y, e604.z+16)
        if e570 and e570 >= 1 then
            local e614= e599(e613)
            e614[#e614+1] = { x = e604.x, y = e604.y, z = e604.z }
            return e614
        end
        if e570 and e570 < 1 then
            local e591= e613.x + (e604.x-e613.x)*e570
            local e592= e613.y + (e604.y-e613.y)*e570
            local e593= e613.z + (e604.z-e613.z)*e570
            for _, r in ipairs(e525) do
                for s=0,e524-1 do
                    local e551= (s/e524) * math.pi * 2
                    local e594= e591 + math.cos(e551)*r
                    local e595= e592 + math.sin(e551)*r
                    local e596= e572(e563, e594, e595, e593)
                    if not e611({x=e594,y=e595}) then
                        local e597= e562(e563, e613.x, e613.y, e613.z+16, e594, e595, e596+16)
                        if e597 and e597 >= 1 then
                            e608({x=e594,y=e595})
                            table.insert(e606, { x = e594, y = e595, z = e596, parent = e613 })
                        end
                    end
                end
            end
        end
    end
    return nil
end

local function e615(e616,e563,e567,e568,e569)
    local e585, e586, e587= entity.get_origin(e563)
    if not e585 then return end
    
    local e559, e560= e567 - e585, e568 - e586
    local e617= math.sqrt(e559*e559 + e560*e560)
    if e617 <= 0 then return end
    local e618, e619= e559 / e617, e560 / e617
    local e620= 64
    local e564= e585 + e618 * e620
    local e565= e586 + e619 * e620
    local e566= e587

    
    local e621, e622= client.camera_angles()
    local e588= math.deg(math.atan2(e560, e559))
    local e623= e550(e588 - e622)
    local e624= math.rad(e623)
    local e625= math.cos(e624) * e522
    local e626= -math.sin(e624) * e522

    
    local e627, e628, e629= client.eye_position()
    if not e627 then e627, e628, ez = e585, e586, e587 end
    if type(e627) == 'table' then e627, e628, ez = e627[1], e627[2], e627[3] end
    local e630= e585 + e618 * 24
    local e631= e586 + e619 * 24
    local e632= e587 + 16
    local e633= e562(e563, e627, e628, e629, e630, e631, e632)
    if e633 and e633 < 1 then
        
        if e542 then pcall(client.log, "move_towards: short forward blocked, sidestep") end
        pcall(function() e616.forwardmove = 0; e616.sidemove = -e522 end)
        local e634= e585 - e619 * e620
        local e635= e586 + e618 * e620
        local e636= e562(e563, e585, e586, e587 + 16, e634, e635, e566 + 16)
        if e636 and e636 >= 1 then return end
        pcall(function() e616.forwardmove = 0; e616.sidemove = e522 end)
        local e637= e585 + e619 * e620
        local e638= e586 - e618 * e620
        local e639= e562(e563, e585, e586, e587 + 16, e637, e638, e566 + 16)
        if e639 and e639 >= 1 then return end
        
        pcall(function() e581(e567, e568); e519 = client.timestamp() + 250 end)
        e517 = nil
        return
    end

    
    pcall(function()
        e616.forwardmove = e625
        e616.sidemove = e626
    end)

    if e542 then pcall(client.log, string.format("move_towards: fwd=%.1f side=%.1f yaw_diff=%.1f", e625, e626, e623)) end

    local e570= e562(e563, e585, e586, e587 + 16, e564, e565, e566 + 16)
    if e570 and e570 < 1 then
        
        if e542 then pcall(client.log, "move_towards: forward blocked, attempting sidestep") end
        
        pcall(function() e616.forwardmove = 0; e616.sidemove = -e522 end)
        local e634= e585 - e619 * e620
        local e635= e586 + e618 * e620
        local e636= e562(e563, e585, e586, e587 + 16, e634, e635, e566 + 16)
        if e636 and e636 >= 1 then return end
        
        pcall(function() e616.forwardmove = 0; e616.sidemove = e522 end)
        local e637= e585 + e619 * e620
        local e638= e586 - e618 * e620
        local e639= e562(e563, e585, e586, e587 + 16, e637, e638, e566 + 16)
        if e639 and e639 >= 1 then return end
        
        pcall(function()
            e581(e567, e568)
            e519 = client.timestamp() + 250
        end)
        e517 = nil
        return
    end
end

e515.register("setup_command", function(e616)
    local e548, e640= pcall(function()
        if not e546(e516.ui.misc_walkbot) then return end
        local e563= entity.get_local_player()
        if not e563 or not entity.is_alive(e563) then return end
        local e641= client.timestamp()
        if e641 < e519 then return end

        
        do
            local e642= client.timestamp()
            if e642 - e544 >= e543 then
                local e643, e644, e645= entity.get_origin(e563)
                if e643 then
                    pcall(function()
                        client.log(string.format("walkbot_coord: %.1f %.1f %.1f", e643, e644, e645))
                    end)
                    e544 = e642
                end
            end
        end
        if client.key_state(87) or client.key_state(65) or client.key_state(83) or client.key_state(68) or client.key_state(32) or client.key_state(16) or client.key_state(17) then
            e519 = e641 + 500
            return
        end
        
        do
            local e646= entity.get_players(true) or {}
            for i=1,#e646 do
                local e647= e646[i]
                local e643, e644, e645= entity.get_origin(e647)
                if e643 then
                    local e648= pcall(function() return client.visible(e643, e644, e645) end)
                    if e648 and client.visible(e643, e644, e645) then
                        pcall(function()
                            local e649= e616.buttons or 0
                            e616.buttons = bit.bor(e649, 4) 
                        end)
                        break
                    end
                end
            end
        end
        
        local e585, e586, e587= entity.get_origin(e563)
        if e585 then
            local e646= entity.get_players(true) or {}
            if #e646 > 0 then
                if not e526 or not entity.is_alive(e526) or entity.is_dormant(e526) then
                    
                    local e650= {}
                    for i=1,#e646 do
                        local e647= e646[i]
                        local e643, e644, e645= entity.get_origin(e647)
                        if e643 then
                            local e651= e552(e585, e586, e587, e643, e644, e645)
                            e650[#e650+1] = { ent = e647, dist = e651 }
                        end
                    end
                    table.sort(e650, function(e551,e649) return e551.dist < e649.dist end)
                    if #e650 > 0 then
                                e526 = e650[1].ent  
                        e517 = nil
                        e518 = 1
                    end
                end
            else
                e526 = nil
            end
        end

        
        if e526 and entity.is_alive(e526) and not entity.is_dormant(e526) then
            local e567, e568, e569= entity.get_origin(e526)
            if e567 then
                local e590= e572(e563, e567, e568, e569)
                e527 = { x = e567, y = e568, z = e590 }
            else
                e526 = nil
                e527 = nil
            end
        else
            e526 = nil
            e527 = nil
        end

        
        do
            local e641= client.timestamp()
            if e585 then
                if not e536 then
                    e536 = { x = e585, y = e586, z = e587 }
                    e537 = e641
                else
                    if e641 - e537 >= e538 then
                        local e652= e552(e536.x, e536.y, e536.z, e585, e586, e587)
                        if e652 >= e540 then
                            
                            e535 = 0
                            e536 = { x = e585, y = e586, z = e587 }
                            e537 = e641
                        else
                            
                            if e641 - e537 >= e539 then
                                e535 = e535 + 1
                                e517 = nil
                                e519 = e641 + 300
                                e536 = { x = e585, y = e586, z = e587 }
                                e537 = e641
                                if e535 >= e534 then
                                    
                                    e526 = nil
                                    e527 = nil
                                    e535 = 0
                                end
                            end
                        end
                    end
                end
            end
        end

        if e527 then
            local e641= client.timestamp()
            local e653= (not e517) or (e641 > e529)
            if not e528 then e653 = true end
            if e528 and e527 and e552(e528.x, e528.y, e528.z, e527.x, e527.y, e527.z) > 100 then
                e653 = true
            end
            if e653 then
                local e647= e603(e563, e527)
                if e647 then
                    e517 = e647
                    e518 = 1
                    e529 = client.timestamp() + e530
                    e528 = { x = e527.x, y = e527.y, z = e527.z }
                else
                    
                    e526 = nil
                    e527 = nil
                    e517 = nil
                end
            end
        else
            if not e517 then
                local e654= e584(e563)
                
                if not e654 and #e545 > 0 then
                    local e655= e545[ math.random(1, #e545) ]
                    if e655 then e654 = { x = e655.x, y = e655.y, z = e655.z } end
                end
                if e654 then
                    local e647= e603(e563, e654)
                    if e647 then
                        e517 = e647
                        e518 = 1
                    else
                        
                        e517 = nil
                    end
                end
            end
        end
        if not e517 then return end
        local e585, e586, e587= entity.get_origin(e563)
        if not e585 then return end
        local e656= e517[e518+1] or e517[#e517]
        if not e656 then e517 = nil return end
        local e651= e552(e585, e586, e587, e656.x, e656.y, e656.z)
        if e651 <= e520 then
            e518 = e518 + 1
            
            e583(e656.x, e656.y)
            if e518 >= #e517 then e517 = nil return end
            return
        end
        do
            local e657= false
            if e526 and e527 then
                local e567, e568, e569= e527.x, e527.y, e527.z
                local e589= e552(e585, e586, e587, e567, e568, e569)
                if e589 > 1000 then
                    
                end
            end
            if not e657 then
                e615(e616, e563, e656.x, e656.y, e656.z)
            end
        end
    end)
    if not e548 then pcall(client.error_log, "walkbot error: "..tostring(e640)) end
end)

e515.register("paint", function()
    if not e546(e516.ui.misc_walkbot) then return end
    if not e517 or #e517 == 0 then return end
    local e563= entity.get_local_player()
    if not e563 then return end
    local e585, e586, e587= entity.get_origin(e563)
    if not e585 then return end
    local e658, e659, e660= e585, e586, e587
    e660 = e572(e563, e658, e659, e660)
    local e643, e644= renderer.world_to_screen(e658, e659, e660)
    for i=e518, #e517 do
        local e602= e517[i]
        if not e602 then break end
        local e661= e572(e563, e602.x, e602.y, e602.z)
        local e564, e565= renderer.world_to_screen(e602.x, e602.y, e661)
        if e564 and e565 and e643 and e644 then
            renderer.line(e643, e644, e564, e565, 255, 180, 0, 200)
            renderer.rectangle(e564-3, e565-3, 6, 6, 255, 80, 0, 200)
        end
        e643, py = e564, e565
    end
end)

return true
]]
e981["require/features/paint/aimbot_logs"] = [[local e518= require("require/abc/menu_setup")
local e519= require("require/abc/screen_logger")


local e520= nil
pcall(function() e520 = require('require/abc/callbacks') end)
if not e520 then error("callbacks manager required: require/abc/callbacks") end
local e521= {}
local e522= {}

local function e523()
	local e524= e518.ui.paint_aimbot_logs
	if not e524 then return false end
	local e525= ui.get(e524)
	if type(e525) == "string" then
		return e525 ~= "off"
	end
	return false
end

local function e526()
	local e524= e518.ui.paint_aimbot_logs
	if not e524 then return "gamesense" end
	local e525= ui.get(e524)
	if type(e525) == "table" then
		for _, v in ipairs(e525) do
			if v == "gamesense beta" then return "gamesense beta" end
			if v == "sodium" then return "sodium" end
			if v == "gamesense" then return "gamesense" end
		end
	elseif type(e525) == "string" then
		return e525
	end
	return "gamesense"
end

local e527= require("require/help/enemies")
local e528= require("require/abc/push_logger")
local e529= require("require/help/safe")

local e530, e531= pcall(require, "require/features/misc/collect")


local function e532(e533)
	if not e533 or e533 == 0 then return 0 end
	
	if e530 and e531 then
		local e534, e535= pcall(function()
			return e531.get_goal_feet_yaw(e533) or e531.get_feet_yaw(e533) or e531.get_lower_body_yaw(e533)
		end)
		if e534 and e535 and e535 ~= 0 then return e535 end
	end
	
	local e536, e537, e538, e539= pcall(function() return entity.get_prop(e533, "m_angAbsRotation") end)
	if e536 and e537 then
		if type(e537) == "table" then
			return e537[2] or 0
		else
			return e538 or 0
		end
	end
	
	local e540, e541= pcall(function() return entity.get_prop(e533, "m_flLowerBodyYawTarget") end)
	if e540 and e541 then return e541 end
	return 0
end


local function e542(e533)
	local e534, e543= pcall(function() return _G.player_labels end)
	if not e534 or type(e543) ~= "table" then return nil end
	local e544, e545= pcall(function() return e543[e533] end)
	if not e544 then return nil end
	return e545
end


local function e546()
	local e534, e547, e548, e549= pcall(function() return client.camera_angles() end)
	if not e534 then return nil, nil, nil end
	return e547 or 0, e548 or 0, e549 or 0
end


local function e550(e533)
	if not e533 or e533 == 0 then return nil, nil, nil end
	local e534, e551, e552, e553= pcall(function() return entity.get_prop(e533, "m_angAbsRotation") end)
	if not e534 then return nil, nil, nil end
	
	if type(e551) == "table" then
		return e551[1] or 0, e551[2] or 0, e551[3] or 0
	else
		return e551 or 0, e552 or 0, e553 or 0
	end
end

local function e554(e555)
	local e524= e518.ui.paint_logger
	if not e524 then return false end
	local e525= e529.safe_get(e524)
	if type(e525) == 'table' then
		for _, v in ipairs(e525) do
			if v == e555 then return true end
		end
		return false
	elseif type(e525) == 'string' then
		return e525 == e555
	end
	return false
end

local function e556(e557,e558,e548,e547) return string.format("\a%02x%02x%02x%02x", e557 or 255, e558 or 255, e548 or 255, e547 or 255) end
local function e559(e560,e557,e558,e548,e547)
	if not e560 or e560 == "" then return e560 end
	local e561= e556(e557,e558,e548,e547)
	local e562= e556(255,255,255,255)
	local e563= "([-+]?%d+%.?%d*%%?)"
	local e534, e564= pcall(function()
		return (e560:gsub(e563, function(e565)
			return e561 .. e565 .. e562
		end))
	end)
	if e534 and e564 then return e564 end
	return e560
end

local function e566(e560)
	if not e560 then return "" end
	return e560:gsub("([%^%$%(%)%%.%[%]%*%+%-%?])", "%%%1")
end

local function e567(e568,e569,e557,e558,e548,e547)
	if not e568 or e568 == "" then return e568 end
	if not e569 or e569 == "" then
		return e559(e568, e557,e558,e548,e547)
	end
	
	local e570, e571= e568:find(e569, 1, true)
	if not e570 then
		
		return e559(e568, e557,e558,e548,e547)
	end
	local e572= e568:sub(1, e570 - 1)
	local e573= e568:sub(e570, e571)
	local e574= e568:sub(e571 + 1)
	local e575= e559(e572, e557,e558,e548,e547)
	local e576= e559(e574, e557,e558,e548,e547)
	local e561= e556(e557,e558,e548,e547)
	local e562= e556(255,255,255,255)
	local e577= e561 .. e573 .. e562
	return (e575 or "") .. e577 .. (e576 or "")
end
local function e578(e579,e580,e581,e582)
	local e583= e579.target_name or "?"
	local e584= e579.hitgroup_name or "?"
	local e585= (e582 and e582.damage) or e579.damage or 0
	local e586= e579.damage or e585
	local e587= e585 - e586
	local e588
	if e585 == e586 then
		e588 = string.format("%d dmg", e585)
	elseif e587 < 0 then
		e588 = string.format("%d(-%d) dmg", e585, math.abs(e587))
	else
		e588 = string.format("%d(+%d) dmg", e585, e587)
	end
	local e589= (e580 == "gamesense" and e582 and e582.health) or e579.health or 0
	local e569= e582 and e582.reason or ""

	local e590= e579.backtrack_ticks or (e582 and e582.backtrack_ticks) or 0
	if e590 == 0 then
		local e591, e592= pcall(function() return globals.tickcount() end)
		if e591 and e579.tick then
			e590 = math.max(0, e592 - (e579.tick or e592))
		end
	end
	local e593= e579.backtrack or (e582 and e582.backtrack) or 0
	if e593 == 0 and e590 and e590 > 0 then
		local e594, e595= pcall(function() return globals.tickinterval() end)
		local e596= (e594 and e595) or 0
		e593 = math.floor(e590 * e596 * 1000)
	end
	if e593 == 0 and e579.time then
		local e597, e598= pcall(function() return globals.realtime() end)
		if e597 and e598 and e579.time then
			e593 = math.floor((e598 - e579.time) * 1000)
		end
	end
	local e599= e582 and e582.hitchance or e579.hitchance or "hehe"
	local e600= e579.safepoint or false
	local e601= e579.tick or 0
	local e602= e579.time or globals.realtime()
	local e603= e579.move or 0
	local e604= e579.t or 0
	local e605= (e582 and e582.boneyaw) or e532(e579.target) or 0
	local e606= (e582 and e582.resolver) or e542(e579.target) or "?"
	e606 = tostring(e606):lower()
	local e607, e608= e546()
	local e609, e610= e550(e579.target)
	local e611= e579.id or 0
	if e580 == "gamesense beta" then
		if e581 == "hit" then
			return string.format("[+] Hit %s's %s for %s (%d%%) bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				e583, e584, e588, e599, e593, e590,
				e608 or 0, e607 or 0, e610 or 0, e609 or 0, e603, e604, e605)
		else
			return string.format("[-] Missed %s's %s for %s (%d%%) due to %s bt=%dms (%d) view=%.1f/%.1f abs=%.1f/%.1f SBY move=%d t=%d boneyaw=%.1f",
				e583, e584, e588, e599, e569, e593, e590,
				e608 or 0, e607 or 0, e610 or 0, e609 or 0, e603, e604, e605)
		end
	elseif e580 == "gamesense" then
		if e581 == "hit" then
			return string.format("[gamesense] Hit %s's %s for %s (%d%%) (%dhp remaining)",
				e583, e584, e588, e599, e589)
		else
			return string.format("[gamesense] Missed %s's %s for %s (%d%%) reason=%s",
				e583, e584, e588, e599, e569)
		end
	elseif e580 == "sodium" then
		if e581 == "hit" then
			return string.format("hit %s's %s for %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				e583, e584, e588, e599, e593, e606, e605)
		else
			return string.format("missed %s's %s due to %s | %d%% | history(Δ): %dms | resolver=%s | boneyaw=%.2f",
				e583, e584, e569, e599, e593, e606, e605)
		end
	else
		if e581 == "hit" then
			return string.format("a",
				e583, e584, dmg, e599, e603, e604, e605)
		else
			return string.format("b",
				e583, e584, dmg, e599, e569, e603, e604, e605)
		end
	end
end

e520.register('aim_fire', function(e612)

	if not e523() then return end
	
	e522[e612.id] = {
		id = e612.id,
		target = e612.target,
		target_name = entity.get_player_name(e612.target or 0),
		hitgroup = e612.hitgroup,
		hitgroup_name = e612.hitgroup and ({"head","chest","stomach","left arm","right arm","left leg","right leg"})[e612.hitgroup] or "?",
		damage = e612.damage,
		health = e612.health,
		backtrack = (e612.backtrack or 0) * globals.tickinterval() * 1000,
		backtrack_ticks = e612.backtrack or 0,
		hitchance = e612.hit_chance or 0,
		safepoint = e612.safepoint,
		tick = globals.tickcount(),
		time = globals.realtime(),
		move = e612.move or 0,
		t = e612.t or 0,
		boneyaw = e612.boneyaw or e532(e612.target) or 0,
	}
end, { require_login = true, alive_only = true })

e520.register('aim_hit', function(e612)

	if not e523() then return end
	local e613= e522[e612.id]
	if not e613 then return end
	local e580= e526()
	local e614= entity.get_prop(e612.target, "m_iHealth") or 0
	local e605= e613.boneyaw or e532(e613.target)
	local e615= e542(e613.target)
	local e616= e578(e613, e580, "hit", {
		damage=e612.damage,
		health=e614,
		backtrack=e613.backtrack,
		backtrack_ticks=e613.backtrack_ticks,
		boneyaw=e605,
		resolver=e615
	})
	if e580 == "gamesense beta" then
		
		client.color_log(165, 202, 42, e616)
		e519(e616, 4, 165, 202, 42, 255)
	elseif e580 == "sodium" then
		local e617= e613.damage or 0
		local e618= e612.damage or e617
		local e619= e618 - e617
		if e619 == 0 then
			client.color_log(165, 202, 42, e616)
			local e620= e559(e616, 165, 202, 42, 255)
			e519(e620, 4)
		else
			client.color_log(255, 204, 51, e616)

			local e621= string.format("(%+d)", e619)
			local e622= e566(e621)
			local e572, e573, e574= e616:match("^(.-)(" .. e622 .. ")(.*)$")
			if not e572 then
				local e620= e559(e616, 165, 202, 42, 255)
				e519(e620, 4)
			else
				local e623= e559(e572, 165, 202, 42, 255)
				local e624= e559(e574, 165, 202, 42, 255)
				local e625, e626, e627
				if e619 > 0 then
					e625, e626, db = 255, 204, 51
				else
					e625, e626, db = 217, 100, 100 
				end
				local e561= e556(e625, e626, e627, 255)
				local e562= e556(255, 255, 255, 255)
				local e628= e573:sub(2, -2) or e573
				local e629= "(" .. e561 .. e628 .. e562 .. ")"
				local e620= (e623 or "") .. e629 .. (e624 or "")
				e519(e620, 4)
			end
		end
	else
		client.log(e616)
		e519(e616, 4, 255, 255, 255, 255)
	end

	
	if e554('aimbot') then
		local e583= e613.target_name or "?"
		local e630= e613.hitgroup_name or "?"
		local e631= e612.damage or 0
		local e632= e613.hitchance or 0
		local e633= string.format("Hit %s's %s for %d(%d%%)", e583, e630, e631, e632)
		e528(e633, 4, 255, 255, 255, 255)
	end

	e522[e612.id] = nil
end, { require_login = true, alive_only = true })

e520.register('aim_miss', function(e612)

	if not e523() then return end
	local e613= e522[e612.id]
	if not e613 then return end
	local e580= e526()
	local e605= e613.boneyaw or e532(e613.target)
	local e615= e542(e613.target)
	local e616= e578(e613, e580, "miss", {reason=e612.reason or "?", boneyaw=e605, resolver=e615})
		if e580 == "gamesense beta" then
			client.color_log(217, 100, 100, e616)
			e519(e616, 4, 217, 100, 100, 255)
		elseif e580 == "sodium" then
			
			local e634= e612.reason or "?"
			local e620= e567(e616, e634, 217, 100, 100, 255)
			e519(e620, 4)
			client.color_log(217, 100, 100, e616)
		else
			e519(e616, 4, 255, 255, 255, 255)
			client.log(e616)
		end

	if e554('aimbot') then
		local e583= e613.target_name or "?"
		local e630= e613.hitgroup_name or "?"
		local e631= e613.damage or 0
		local e632= e613.hitchance or 0
		local e569= e612.reason or "?"
		local e633= string.format("Missed %s's %s for %d(%d%%) due to %s", e583, e630, e631, e632, e569)
		e528(e633, 4, 255, 255, 255, 255)
	end

	e522[e612.id] = nil
end, { require_login = true, alive_only = true })]]
e981["require/features/paint/animations"] = [[


local e521= nil
pcall(function() e521 = require('require/help/safe') end)
local e522= nil
pcall(function() e522 = require('require/abc/menu_setup') end)

local e523= nil
pcall(function() e523 = require('require/abc/callbacks') end)
if not e523 then error("callbacks manager required: require/abc/callbacks") end
local e524= require("gamesense/entity") or error("You're missing a required module: gamesense/entity")


local function e525()
    local e526= entity.get_local_player()
    if not e526 then return nil, nil end
    local e527, e528= pcall(function() return e524.new(e526) end)
    if not e527 then return e526, nil end
    return e526, e528
end




local e529= {
    STRAFE_YAW = 0,
    STAND = 1,
    LEAN_YAW = 2,
    SPEED = 3,
    LADDER_YAW = 4,
    LADDER_SPEED = 5,
    JUMP_FALL = 6,
    MOVE_YAW = 7,
    MOVE_BLEND_CROUCH = 8,
    MOVE_BLEND_WALK = 9,
    MOVE_BLEND_RUN = 10,
    BODY_YAW = 11,
    BODY_PITCH = 12,
    AIM_BLEND_STAND_IDLE = 13,
    AIM_BLEND_STAND_WALK = 14,
    AIM_BLEND_STAND_RUN = 14,
    AIM_BLEND_CROUCH_IDLE = 16,
    AIM_BLEND_CROUCH_WALK = 17,
    DEATH_YAW = 18
}

local function e530(e531)
    if not e531 then return 0 end
    local e532, e533, e534= entity.get_prop(e531, 'm_vecVelocity')
    if not e532 or not e533 then
        local e535= e532
        if type(e535) == 'table' then
            e532 = e535.x or e535[1] or 0
            e533 = e535.y or e535[2] or 0
        else
            return 0
        end
    end
    return math.sqrt((e532 or 0) * (e532 or 0) + (e533 or 0) * (e533 or 0))
end

local e536= {}
local e537= {}
for i, item in ipairs({
    { 'AA', 'Other', 'Leg movement' },

}) do
    local e538= {ui.reference(item[1], item[2], item[3])}
    e536[i] = e538
    for _, ref in ipairs(e538) do
        e537[ref] = true
    end
end






local e539= require("gamesense/antiaim_funcs")


local function e540()
    local e526= entity.get_local_player()
    if not e526 then return end
    entity.set_prop(e526, "m_flPoseParameter", 1, e529.JUMP_FALL)
end

local function e541()

    if e539.get_tickbase_shifting() > 0 then
        return
    end
    
    value = 0.5
    local e526= entity.get_local_player()
    if not e526 then return end
    local e542= globals.tickcount()
    local e543= math.floor(e542 / 2) % 2
    local e544= (e543 == 0) and -0.1 or 0.9
    entity.set_prop(e526, "m_flPoseParameter", math.random(0, 10) / value, e529.SPEED)
    entity.set_prop(e526, "m_flPoseParameter", math.random(0, 10) / 10, e529.MOVE_YAW)
    entity.set_prop(e526, "m_flPoseParameter", math.random(0, 10) / 10, e529.JUMP_FALL)
end



local function e545()
    local e526, e546= e525()
    if not e526 or not e546 then return end
    local e547= e546:get_anim_state()
    local e548= e546:get_anim_overlay(12)
    entity.set_prop(e526, "m_flPoseParameter", client.random_float(0, 1), 0)
    e548.weight = client.random_float(0, 1)
    ui.set(e536[1][1], "Always slide")
end

local function e549()
    local e526, e546= e525()
    if not e526 or not e546 then return end
    local e548= e546:get_anim_overlay(12)
    e548.weight = math.random(0,10) / 10
end


local function e550()
    local e526, e546= e525()
    if not e526 or not e546 then return end
    local e547= e546:get_anim_state()
    local e548= e546:get_anim_overlay(12)
    if e548 then e548.weight = 0.999 end
end

local function e551()
    local e526, e546= e525()
    if not e526 or not e546 then return end
    local e547= e546:get_anim_state()
    if e547 and e547.hit_in_ground_animation then
        entity.set_prop(e526, "m_flPoseParameter", 0.5, e529.BODY_PITCH)
    end
end

local function e552()
    local e526, e546= e525()
    if not e526 or not e546 then return end
    local e553= e546:get_anim_overlay(6)
    entity.set_prop(e526, "m_flPoseParameter", 0, e529.MOVE_YAW)
    if e553 then e553.weight = 1 end
end

local function e554()
    local e526, e546= e525()
    if not e526 or not e546 then return end
    local e555= e546:get_anim_overlay(12)
    local e556= e546:get_anim_overlay(6)
    if e555 then e555.weight = 0 end
    if e556 then e556.weight = 1 end
end

local function e557()
    local e526= entity.get_local_player()
    if not e526 then return end
    ui.set(e536[1][1], math.random(1,2) == 1 and "Always slide" or "Never slide")
    entity.set_prop(e526, "m_flPoseParameter", 8, 0)
end


local function e558()
    local e526, e546= e525()
    if not e526 or not e546 then return end
    local e559= e546:get_anim_overlay(9)
    if e559 then
        e559.weight = 1
        e559.sequence = 224
    end
end

local function e560()
    local e526, e546= e525()
    if not e526 or not e546 then return end
    local e561= e546:get_anim_overlay(0)
    if e561 then e561.sequence = 11 end
end

local function e562()

    local e526= e525()
    if not e526 then return end
    entity.set_prop(e526, 'm_flPoseParameter', 0, e529.BODY_PITCH)
    entity.set_prop(e526, 'm_flPoseParameter', math.random(-1, 1), e529.BODY_YAW)

end




e523.register('pre_render', function()
    local e526= entity.get_local_player()
    if not e526 then return end
    local e563= e530(e526)


    local e564= nil
    if e522 and e522.ui and e522.ui.paint_animations then
        if e521 and e521.safe_get then
            e564 = e521.safe_get(e522.ui.paint_animations)
        else
            local e527, e565= pcall(function() return ui.get(e522.ui.paint_animations) end)
            if e527 then e564 = e565 end
        end
    end

    local e566= {}
    if type(e564) == 'table' then
        for _, v in ipairs(e564) do e566[v] = true end
    end

    if e566['kingaru'] and e563 > 3 then e541() end
    if e566['body lean'] and e563 > 3 then e550() end
    if e566['static legs'] and e563 > 3 then e540() end
    if e566['moonwalk'] and e563 > 3 then e552() end
    if e566['allah'] and e563 > 3 then e554() end
    if e566['no pitch on land'] and e563 > 3 then e551() end
    if e566['reversed legs'] and e563 > 3 then e557() end
    if e566['earthquake'] then e549() end
    if e566['t-pose'] then e560() end
    if e566['blind'] then e558() end
    if e566['pitch up'] then e562() end
    if e566['gamesense legs'] then e545() end
end, { require_login = true, alive_only = true })

e523.register('setup_command', function(e567)

    local e526= entity.get_local_player()
    if not e526 then return end
    local e563= e530(e526)
    if e563 < 3 then return end

    local e564= nil
    if e522 and e522.ui and e522.ui.paint_animations then
        if e521 and e521.safe_get then
            e564 = e521.safe_get(e522.ui.paint_animations)
        else
            local e527, e565= pcall(function() return ui.get(e522.ui.paint_animations) end)
            if e527 then e564 = e565 end
        end
    end

    local e566= {}
    if type(e564) == 'table' then
        for _, v in ipairs(e564) do e566[v] = true end
    end

    

end, { require_login = true, alive_only = true })]]
e981["require/features/paint/aspect_ratio"] = [[
local e524= require("require/abc/menu_setup")
local e525= require("require/help/time")
local e526= require("require/help/safe")
local e527= require("ffi")
local e528= require("require/brain/dll")
local e529= nil
pcall(function() e529 = require('require/abc/callbacks') end)

if not (e528 and e528.aspect_update) then
    error("sodiumdll aspect_update export missing")
end

local e530= e527.new("struct AspectState[1]")
local e531= e527.new("double[1]")
local e532= e527.new("int[1]")
local e533= e528.aspect_update

local function e534()
    if cvar.r_aspectratio and cvar.r_aspectratio.get_float then
        return cvar.r_aspectratio:get_float()
    end
    return nil
end

local function e535(e536)
    if cvar.r_aspectratio and cvar.r_aspectratio.set_float then
        cvar.r_aspectratio:set_float(e536)
        return true
    elseif client and client.exec then
        client.exec("r_aspectratio " .. tostring(e536))
        return true
    end
    return false
end

e529.register('paint', function()
    if not ui.is_menu_open() then return end
    local e537= e524.ui.paint_aspect_ratio
    if not e537 then return end
    local e538= e526.safe_get(e537)
    if type(e538) ~= 'number' then return end
    e533(e530, e538, e534() or 0, e525.realtime(), e531, e532)
    if e532[0] ~= 0 then
        e535(e531[0])
    end
end, { require_login = true })

client.set_event_callback('shutdown', function()
    e530[0].initialized = 0
    e530[0].original = 0
    e530[0].last = 0
    e530[0].last_update = 0
end)]]
e981["require/features/paint/bomb_esp"] = [[local e527= nil
local e528= {}
local e529= nil
local e530= 500
local e531= 1000

local e532= 1.0
local e533= true
local e534= 0.25 
local e535= 0
local e536= 2

local e537= nil
pcall(function() e537 = require('require/abc/callbacks') end)
if not e537 then error("callbacks manager required: require/abc/callbacks") end

local function e538()
    e527 = nil
end

local function e539(e540)
    if not e540 then return 650, 2275 end
    local e541= tostring(e540):lower()
    if e541:find('de_dust2') then return 500, 1750 end
    if e541:find('de_ancient') then return 650, 2275 end
    if e541:find('de_anubis') then return 450, 1575 end
    if e541:find('de_inferno') then return 620, 2170 end
    if e541:find('de_mirage') then return 650, 2275 end
    if e541:find('de_nuke') then return 650, 2275 end
    if e541:find('de_overpass') then return 650, 2275 end
    if e541:find('de_vertigo') then return 500, 1750 end
    return 650, 2275
end

local function e542(e543,e544)
    e544 = tonumber(e544) or 0
    if e544 > 0 then
        local e545= 0.5
        local e546= 0.5
        local e547= e543 * e545
        local e548= (e543 - e547) * e546
        if e548 > tonumber(e544) then
            e548 = tonumber(e544) * (1.0 / e546)
            e547 = e543 - e548
        end
        e543 = e547
    end
    return e543
end

local function e549(e550,e551,e552,e553,e554,e555,e544,e556)
    if not e550 or not e551 or not e552 or not e553 or not e554 or not e555 then return 0 end
    local e557, e558= e539(e556)
    local e559= e558 / 3.0
    local e560= e550 - e553
    local e561= e551 - e554
    local e562= e552 - e555
    local e563= math.sqrt(e560*e560 + e561*e561 + e562*e562)
    local e564= math.exp( - (e563 * e563) / (2 * e559 * e559) )
    local e543= e557 * e564
    local e565= e542(e543, e544)
    return math.floor(e565 + 0.0)
end

local function e566(e567)
    if not e567 then return "?" end
    if e567 == 454 then return "A" end
    if e567 == 455 then return "B" end
    if e567 == 0 then return "A" end
    if e567 == 1 then return "B" end
    if type(e567) == "string" then
        local e568= e567:upper()
        if e568 == "A" or e568 == "B" then return e568 end
    end
    return tostring(e567)
end

e537.register('bomb_planted', function(e569)
    local e570= e569 and e569.site

    local e571= entity.get_all("CPlantedC4") or {}
    local e572= nil
    local e573= nil

    for i = 1, #e571 do
        local e567= e571[i]
        local e574= entity.get_prop(e567, "m_flC4Blow")
        if e574 and e574 > 0 then
            e572 = e574
            e573 = e567
            break
        end
    end

    if not e572 then
        local e575= 40
        if cvar and cvar.mp_c4timer then
            local e576, e577= pcall(function()
                if type(cvar.mp_c4timer.get_float) == "function" then
                    return cvar.mp_c4timer:get_float()
                elseif type(cvar.mp_c4timer.get_int) == "function" then
                    return cvar.mp_c4timer:get_int()
                else
                    return tonumber(cvar.mp_c4timer:get_string())
                end
            end)
            if e576 and e577 and tonumber(e577) then
                e575 = tonumber(e577)
            end
        end
        e572 = globals.curtime() + (e575 or 40)
    end

    e527 = {
        site = e570,
        blow_time = e572,
        entindex = e573,
        planted_at = globals.curtime()
    }
end, { require_login = true, alive_only = true })

e537.register('bomb_defused', e538, { require_login = true, alive_only = true })
e537.register('bomb_exploded', function(e569)
    
    local e578= e527 ~= nil
    local e579= globals.curtime()
    
    local e580= nil
    local e581= entity.get_local_player()
    if e578 and e581 then
        local function e582()
            
            local e583= nil
            if e527 and e527.entindex then
                local e576, e584, e585, e559= pcall(function() return entity.get_prop(e527.entindex, "m_vecOrigin") end)
                if e576 then
                    if type(e584) == "table" then
                        e583 = e584
                    elseif e584 ~= nil and e585 ~= nil and e559 ~= nil then
                        e583 = { e584, e585, e559 }
                    end
                end
            end
            if not e583 then
                local e571= entity.get_all("CPlantedC4") or {}
                for i = 1, #e571 do
                    local e567= e571[i]
                    local e576, e584, e585, e559= pcall(function() return entity.get_prop(e567, "m_vecOrigin") end)
                    if e576 then
                        if type(e584) == "table" then
                            e583 = e584
                            break
                        elseif e584 ~= nil and e585 ~= nil and e559 ~= nil then
                            e583 = { e584, e585, e559 }
                            break
                        end
                    end
                end
            end
            if not e583 then return nil end
            local e576, e586, e587, e588= pcall(function() return client.eye_position() end)
            local e550, e551, e552
            
            local e589, e590, e591, e592= pcall(function() return entity.get_origin(e581) end)
            if e589 then
                if type(e590) == "table" then
                    if #e590 >= 3 then e550, e551, pz = e590[1], e590[2], e590[3] end
                elseif e590 ~= nil and e591 ~= nil and e592 ~= nil then
                    e550, e551, pz = e590, e591, e592
                end
            end
            
            if (not e550 or not e551 or not e552) and e576 and e586 ~= nil and e587 ~= nil and e588 ~= nil then
                e550, e551, pz = e586, e587, e588
            end
            if not e550 or not e583 or #e583 < 3 then return nil end
            local e553, e554, e555= e583[1], e583[2], e583[3]
            
            local e593, e544= pcall(function() return entity.get_prop(e581, "m_ArmorValue") end)
            e544 = tonumber(e544) or 0
            local e556= nil
            local e594, e595= pcall(function()
                if type(client.mapname) == 'function' then return client.mapname() end
                if cvar and cvar.mapname then return cvar.mapname:get_string() end
                if cvar and cvar.map then return cvar.map:get_string() end
                return nil
            end)
            if e594 then e556 = e595 end
            local e596= e549(e550, e551, e552, e553, e554, e555, e544, e556)
            local e597= math.floor((e596 * (e532 or 1.0)) + 0.5)
            return e596, e597, math.sqrt((e550-e553)^2 + (e551-e554)^2 + (e552-e555)^2)
        end
        local e598, e599, e600= e582()
        e580 = e599
    end

    
    e538()

    
    if e533 and e580 and e580 > 0 then
        local e601= 0.15
        client.delay_call(e601, function()
            local e602= globals.curtime()
            if e602 - e535 < e536 then return end
            local e603= entity.get_local_player()
            if not e603 then return end
            local e576, e604= pcall(function() return entity.get_prop(e603, "m_iHealth") end)
            e604 = tonumber(e604)
            local e605= e529
            if not e605 or not e604 then return end
            local e548= e605 - e604
            if e548 <= 0 then return end

            
            local e606= (e580 and e580 > 0) and e580 or 1
            local e607= e548 / e606
            if e607 <= 0 then return end

            
            local e608= (e532 or 1.0) * (1 + (e607 - 1) * e534)
            if e608 < 0.05 then e608 = 0.05 end
            if e608 > 10 then e608 = 10 end
            local e609= e532
            e532 = e608
            e535 = globals.curtime()
            
            pcall(function()
                client.log("[bomb_esp] auto-tuned scale %.3f -> %.3f (ratio=%.3f, predicted=%d, actual=%d)", e609, e532, e607, e580 or 0, e548)
            end)
        end)
    end
end, { require_login = true, alive_only = true })
e537.register('round_start', e538, { require_login = true, alive_only = true })
e537.register('round_start', function()
    e529 = nil
end, { require_login = true, alive_only = true })
e537.register('player_spawned', function()
    e529 = nil
end, { require_login = true, alive_only = true })


e537.register('player_hurt', function(e569)
    if not e569 then return end
    local e581= entity.get_local_player()
    if not e581 then return end
    local e610= client.userid_to_entindex(e569.userid)
    if e610 ~= e581 then return end

    
    local e611= e569.dmg_health or e569.damage or e569.hp or 0
    e611 = tonumber(e611) or 0
    if e611 <= 0 then return end

    
    local e612= string.format("-%d HP", e611)
    
    table.insert(e528, { t = globals.curtime(), text = e612 })
end, { require_login = true, alive_only = true })


e537.register('paint', function()
    local e613, e614= pcall(require, "require/abc/menu_setup")
    if not e613 or not e614 or not e614.ui then return end
    local e615, e616= pcall(ui.get, e614.ui.paint_bombwarning)
    if not e615 or not e616 then return end

    local e602= globals.curtime()

    
    local e581= entity.get_local_player()
    if e581 then
        local e576, e617= pcall(function() return entity.get_prop(e581, "m_iHealth") end)
        e617 = tonumber(e617)
        if e617 then
            if e529 == nil then
                e529 = e617
            else
                if e617 < e529 then
                    local e611= e529 - e617
                    table.insert(e528, { t = e602, text = string.format("-%d HP", e611) })
                end
                e529 = e617
            end
        end
    else
        e529 = nil
    end

    
    for i = #e528, 1, -1 do
        local e618= e528[i]
        local e619= e602 - e618.t
        local e620= 1.4
        if e619 >= e620 then
            table.remove(e528, i)
        else
            local e621= math.floor(255 * (1 - (e619 / e620)))
            if e621 < 0 then e621 = 0 end
            
            renderer.indicator(255, 210, 0, e621, e618.text)
        end
    end

    
    if e527 then
        local e581= entity.get_local_player()
        local e583= nil
        if e527.entindex then
            local e576, e584, e585, e559= pcall(function() return entity.get_prop(e527.entindex, "m_vecOrigin") end)
            if e576 then
                if type(e584) == "table" then
                    e583 = e584
                elseif e584 ~= nil and e585 ~= nil and e559 ~= nil then
                    e583 = { e584, e585, e559 }
                end
            end
        end
        
        if not e583 then
            local e571= entity.get_all("CPlantedC4") or {}
            for i = 1, #e571 do
                local e567= e571[i]
                local e576, e584, e585, e559= pcall(function() return entity.get_prop(e567, "m_vecOrigin") end)
                if e576 then
                    if type(e584) == "table" then
                        e583 = e584
                        break
                    elseif e584 ~= nil and e585 ~= nil and e559 ~= nil then
                        e583 = { e584, e585, e559 }
                        break
                    end
                end
            end
        end

        if e583 and e581 then
            local e550, e551, e552= nil, nil, nil
            local e576, e586, e587, e588= pcall(function() return client.eye_position() end)
            if e576 and e586 ~= nil and e587 ~= nil and e588 ~= nil then
                e550, e551, pz = e586, e587, e588
            else
                local e589, e590, e591, e592= pcall(function() return entity.get_origin(e581) end)
                if e589 then
                    if type(e590) == "table" then
                        if #e590 >= 3 then e550, e551, pz = e590[1], e590[2], e590[3] end
                    elseif e590 ~= nil and e591 ~= nil and e592 ~= nil then
                        e550, e551, pz = e590, e591, e592
                    end
                end
            end

            if e550 and e583 and #e583 >= 3 then
                local e553, e554, e555= e583[1], e583[2], e583[3]
                
                local e593, e544= pcall(function() return entity.get_prop(e581, "m_ArmorValue") end)
                e544 = tonumber(e544) or 0
                local e594, e595= pcall(function()
                    if type(client.mapname) == 'function' then return client.mapname() end
                    if cvar and cvar.mapname then return cvar.mapname:get_string() end
                    if cvar and cvar.map then return cvar.map:get_string() end
                    return nil
                end)
                local e556= e594 and e595 or nil
                local e598= e549(e550, e551, e552, e553, e554, e555, e544, e556)
                local e622= math.floor((e598 * (e532 or 1.0)) + 0.5)

                
                renderer.indicator(255, 210, 0, 255, string.format("-%d HP", e622))
            end
        end
    end

    
    if e527 then
        
        if e527.entindex then
            local e574= entity.get_prop(e527.entindex, "m_flC4Blow")
            if e574 and e574 > 0 then
                e527.blow_time = e574
            end
        end

        local e623= (e527.blow_time or 0) - e602
        if e623 <= 0 then
            e527 = nil
            return
        end

        local e624= e566(e527.site)
        local e612= string.format("%s - %.1fs", e624, e623)
        renderer.indicator(255, 255, 255, 255, e612)
    end
end, { require_login = true, alive_only = true })]]
e981["require/features/paint/bullet_tracer"] = [[local e530= require("ffi")
local e531= require('require/help/time')
local e532= nil
local e533= require('require/help/self')
pcall(function() e532 = require('require/help/safe') end)
pcall(function() DLL = require('require/brain/dll') end)
pcall(function() menu_setup = require('require/abc/menu_setup') end)
pcall(function() cb = require('require/abc/callbacks') end)

local e534= 10
local e535= 7.0
local e536= {255,255,255,255}
local e537= 0.05
local e538= 8192

if not (DLL and DLL.tracer_reset and DLL.tracer_push_shot and DLL.tracer_set_impact and DLL.tracer_collect) then return end
DLL.tracer_reset()

local e539= 7
local e540= e530.new("double[?]", e534 * e539)

local e541= e531.realtime

cb.register('weapon_fire', function(e542)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if e533.index() ~= client.userid_to_entindex(e542.userid) then return end
    local e543= e533.weapon()
    if e543 then
        local e544= entity.get_classname(e543) or ""
        local e545= e544:lower()
        if e545:find("knife") or e545:find("grenade") or e545:find("decoy") or e545:find("molotov") or e545:find("flash") or e545:find("smoke") or e545:find("taser") or e545:find("zeus") then
            return
        end
    end

    local e546,e547,e548= client.eye_position()
    if not e546 then e546,e547,sz = entity.get_origin(e533.index()) end
    e546,e547,sz = tonumber(e546) or 0, tonumber(e547) or 0, tonumber(e548) or 0
    DLL.tracer_push_shot(e546, e547, e548, e541())
end, { require_login = true, alive_only = true })
 
cb.register('bullet_impact', function(e542)
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    if e533.index() ~= client.userid_to_entindex(e542.userid) then return end
    local e549,e550,e551= tonumber(e542.x) or 0, tonumber(e542.y) or 0, tonumber(e542.z) or 0
    DLL.tracer_set_impact(e549, e550, e551, e541())
end, { require_login = true, alive_only = true })

if not cb then error("callbacks manager required: require/abc/callbacks") end

cb.register('paint', function()
    if not ui.get(menu_setup.ui.paint_bullet_tracer) then return end
    local e552= e541()
    local e553= { client.camera_angles() }
    local e554= DLL.tracer_collect(e552, e535, e537, e553[1] or 0, e553[2] or 0, e538, e536[4] or 255, e540, e534)
    for i=0, (e554 or 0)-1 do
        local e555= i * e539
        local e546, e547, e548= e540[e555], e540[e555 + 1], e540[e555 + 2]
        local e556, e557, e558= e540[e555 + 3], e540[e555 + 4], e540[e555 + 5]
        local e559= e540[e555 + 6]
        local e560,e561= renderer.world_to_screen(e546, e547, e548)
        local e562,e563= renderer.world_to_screen(e556, e557, e558)
        if e560 and e562 then
            renderer.line(e560, e561, e562, e563, e536[1], e536[2], e536[3], e559)
        end
    end
end, { require_login = true, alive_only = true })]]
e981["require/features/paint/clantag"] = [[local e533=require("require/abc/menu_setup")
local e534=require("require/help/safe")
local e535=require("require/help/string")
local e536=require("require/help/time")
local e537=require("require/brain/dll")
local e538=require("ffi")
local e539=pcall
local e540=ui.reference
local e541=ui.set
local e542=client.set_clan_tag
local e543, e544= pcall(require, "require/abc/callbacks")
if not e543 or not e544 then error("require/abc/callbacks is required by clantag.lua") end
if not e537 or type(e537) ~= "table" or not e537.clantag_anim then return end

local e545=64
local e546=e538.new("char[?]",e545)
local e547,e548,e549=nil,0,nil
local function e550(e551)
    local e552={{"MISC","Misc","Clantag spammer"},{"MISC","Miscellaneous","Clantag spammer"},{"MISC","Misc","Clan tag spammer"},{"MISC","Miscellaneous","Clan tag spammer"},{"MISC","Misc","Clantag spamer"},{"MISC","Miscellaneous","Clantag spamer"}}
    for _,v in ipairs(e552) do
        local e553,e554=e539(e540,v[1],v[2],v[3])
        if e553 and e554 and e539(e541,e554,e551) then return true end
    end
    return false
end
local e555=function() return e550(true) end
local e556=function() return e550(false) end
e544.register('paint', function()
    local e554=e533.ui.paint_clantag if not e554 then return end
    local e557=e534.safe_get(e554) if type(e557)~='string' then return end
    local e558=e535.lower(e557) if e558==e547 and e558~='sodium' and e548==0 then return end
    if e558=='off' then e556(); e548=3; e539(e542," ")
    elseif e558=='gamesense' then if not e555() then e539(e542,"gamesense") end
    elseif e558 == 'sodium' then
        e556()

        if not e549 or type(e549) ~= 'table' or not e549.start then
            e549 = { start = e536.realtime() }
        end

        local e559= e536.realtime() or 0
        e538.fill(e546, e545, 0)
        local e560= e537.clantag_anim(e549.start or 0, e559, e546, e545)
        if e560 and e560 ~= 0 then
            e539(e542, e538.string(e546))
        else
            e539(e542, "")
        end
    end
    if e548>0 then e539(e542,"") e548=e548-1 end
    e547=e558
end, { require_login = true })]]
e981["require/features/paint/custom_scope"] = [[]]
e981["require/features/paint/damage"] = [[local e539= require("require/abc/menu_setup")
local e540= require("require/brain/api/vector/vector")
local e541= { shots = {}, last = 0 }


local e542= 5
local e543= 3
local e544= 10

local function e545()
	local e546= 0
	for i = 1, #e541.shots do
		local e547= e541.shots[i]
		if e547 and e547.impacts then e546 = e546 + #e547.impacts end
	end
	return e546
end

local function e548()
	while e545() > e544 do
		
		if #e541.shots == 0 then break end
		local e549= false
		for si = 1, #e541.shots do
			local e547= e541.shots[si]
			if e547 and e547.impacts and #e547.impacts > 0 then
				table.remove(e547.impacts, 1)
				e549 = true
				
				if #e547.impacts == 0 then
					table.remove(e541.shots, si)
				end
				break
			else
				
				table.remove(e541.shots, si)
				e549 = true
				break
			end
		end
		if not e549 then break end
	end
end

local function e550()
	local e551= e539.ui.paint_hitmarker
	if not e551 then return false end
	local e552= ui.get(e551)
	if type(e552) == "table" then
		for _, v in ipairs(e552) do
			if v == "damage" then return true end
		end
	end
	return false
end

local e553, e554= pcall(require, "require/abc/callbacks")
local function e555(e556)
	if not e550() then e541 = { shots = {}, last = 0 } return end
	if not e550() then return end
	local e557= entity.get_local_player()
	if not e557 then return end
	local e558= e556.target or e556.target_index
	if type(e558) ~= 'number' or e558 == 0 or not entity.is_enemy(e558) then return end
	local e559= e556.damage or 0
	local e560= e556.hitgroup == 1
	local e561= e556.health == 0
	local e562, e563, e564= entity.hitbox_position(e558, e556.hitgroup or 'head')
	if not e562 then e562, e563, z = entity.get_origin(e558) end
	if not e562 then return end
	local e565= e540.make(e562, e563, e564)
	local e566= globals.realtime()
	local e567= {255, 255, 255}
	if e561 then e567 = {217, 100, 100} elseif e560 then e567 = {165, 202, 42} end

	local e568
	if e541.last and e566 - e541.last < 0.05 then
		e568 = e541.shots[#e541.shots]
	else
		e541.last = e566
		e568 = { impacts = {}, finished = false, t = e566 }
		e541.shots[#e541.shots + 1] = e568
		if #e541.shots > 12 then table.remove(e541.shots, 1) end
	end

	if e568 then
		e568.impacts[#e568.impacts + 1] = { dmg = e559, x = e562, y = e563, z = e564, pos = e565, t = e566, color = e567 }
		if #e568.impacts > e543 then table.remove(e568.impacts, 1) end
		
		e548()
	end
end

local function e569(e556)
	if e550() then
		local e566= globals.realtime()
		local e570= 1.4
		local e571= 32
		local e572= 1
		while e572 <= #e541.shots do
			if e566 - (e541.shots[e572].t or 0) > (e570 + 0.5) then
				table.remove(e541.shots, e572)
			else
				e572 = e572 + 1
			end
		end
		local e573= {}
		local e574= 12
		for si = #e541.shots, 1, -1 do
			local e568= e541.shots[si]
			for ii = #e568.impacts, 1, -1 do
				table.insert(e573, e568.impacts[ii])
				if #e573 >= e574 then break end
			end
			if #e573 >= e574 then break end
		end

		local e575= math.min(4, #e573)
		for j = 1, e575 do
			local e576= e573[j]
			local e577, e578= renderer.world_to_screen(e576.pos.x, e576.pos.y, e576.pos.z)
			if e577 and e578 then
				local e579= e566 - (e576.t or 0)
				local e580= math.min(1, e579 / e570)
				local e581= e571 * (1 - math.exp(-3 * e580))
				local e582= math.floor(math.max(0, (1 - e580) * 255))
				if e582 > 0 then
					renderer.text(e577, e578 - e581, e576.color[1], e576.color[2], e576.color[3], e582, "crdb-", 0, tostring(e576.dmg))
				end
			end
		end
	else
		e541 = { shots = {}, last = 0 }
	end
end

e554.callback('aim_hit', e555, { alive_only = true, require_login = true })
e554.callback('paint', e569, { alive_only = true, require_login = true })]]
e981["require/features/paint/damage_penetration"] = [[
local function e542(e543,e544)
	if e544 and rawget(_G, e544) ~= nil then
		return rawget(_G, e544)
	end
	local e545, e546= pcall(require, e543)
	if e545 then return e546 end
	return nil
end

local e547= e542('ui', 'ui')
local e548= e542('client', 'client')
local e549= e542('entity', 'entity')
local e550= e542('renderer', 'renderer')

if not e547 or not e548 or not e549 or not e550 then
	return
end

local e551= e547.new_checkbox
local e552= e547.get
local e553= e547.reference

local e554= e548.screen_size
local e555= e548.set_event_callback
local e556= e548.unset_event_callback
local e557= e548.eye_position
local e558= e548.camera_angles
local e559= e548.trace_line
local e560= e548.trace_bullet

local e561= e549.get_local_player
local e562= e549.is_alive or function() return false end
local e563= e549.get_player_weapon or function() return nil end
local e564= e549.get_classname or function() return nil end

local e565= e550.text

local e566= math.floor
local e567= math.cos
local e568= math.sin
local e569= math.rad

sodium_SUPPRESS = sodium_SUPPRESS or false
sodium_REFS = sodium_REFS or {}
sodium_FN = sodium_FN or {}

local function e570(e571)
	if not e571 then return false end
	local e545, e572= pcall(e552, e571)
	return e545 and e572 == true
end


if type(sodium_FN.min_dmg_active) ~= 'function' then
	sodium_FN.min_dmg_active = function()
		ensure_min_damage_refs()
		local e573= sodium_REFS.min_dmg_hotkey
		if e573 then
			local e545, e572= pcall(e552, e573)
			if e545 then return e572 == true end
		end
		return false
	end
end

if type(sodium_FN.min_dmg_value) ~= 'function' then
	sodium_FN.min_dmg_value = function()
		ensure_min_damage_refs()
		local e574= sodium_REFS.min_dmg_slider
		if not e574 then return nil end
		local e545, e572= pcall(e552, e574)
		if e545 and type(e572) == 'number' then
			return e572
		end
		return nil
	end
end

local function e575(e576,e577)
	if sodium and sodium.ui and sodium.ui[e576] then
		return sodium.ui[e576]
	end
	local e578= 'ui_' .. e576
	if sodium_REFS[e578] then
		return sodium_REFS[e578]
	end
	if not e577 then return nil end
	local e571= e577()
	if e571 then
		sodium_REFS[e578] = e571
	end
	return e571
end


local e579= nil
pcall(function() e579 = require('require/abc/menu_setup') end)


local function e580(e581)
    if not e547.get(e579.ui.paint_show_damage_penetration) then return end
	if not e563 or not e564 then return false end
	local e582= e563(e581)
	if not e582 then return false end
	local e583= e564(e582)
	if not e583 then return false end
	if e583:sub(1, 7) ~= 'CWeapon' then return false end
	if e583:find('Grenade', 1, true) or e583:find('Taser', 1, true) or e583:find('C4', 1, true) then return false end
	return true
end

local function e584()
    if not e547.get(e579.ui.paint_show_damage_penetration) then return end
	if not e561 then return nil end
	local e585= e561()
	if not e585 then return nil end
	if e562 and not e562(e585) then return nil end
	return e585
end




local function e586()
    if not e547.get(e579.ui.paint_show_damage_penetration) then return end
	local e585= e584()
	if not e585 or not e580(e585) then return end
	local e587, e588, e589= e557()
	if not e587 or not e588 or not e589 then return end
	local e590, e591= e558()
	if not e590 or not e591 then return end
	local e592, e593= e567(e569(e590)), e568(e569(e590))
	local e594, e595= e567(e569(e591)), e568(e569(e591))
	local e596, e597, e598= e592 * e594, e592 * e595, -e593
	local e599= 8192
	local e600, e601, e602= e587 + e596 * e599, e588 + e597 * e599, e589 + e598 * e599
	local e603= select(1, e559(e585, e587, e588, e589, e600, e601, e602)) or 1
	if e603 < 0 then e603 = 0 end
	if e603 > 1 then e603 = 1 end

	local e604
	if e603 >= 0.999 then
		e604 = { 256, 512, 1024, 2048, 4096 }
	else
		local e605= e599 * e603
		e604 = { e605 + 4, e605 + 16, e605 + 32, e605 + 64, e605 + 128, e605 + 256 }
	end

	local e606= 0
	for i = 1, #e604 do
		local e607= e604[i]
		if e607 > e599 then e607 = e599 end
		local e608, e609, e610= e587 + e596 * e607, e588 + e597 * e607, e589 + e598 * e607
		local e611, e612= e560(e585, e587, e588, e589, e608, e609, e610, true)
		if e612 and e612 > e606 then e606 = e612 end
		if e607 == e599 then break end
	end

	local e613= e566((e606 or 0) + 0.5)
	if e613 <= 0 then return end

	local e614, e615= e554()
	if not e614 or not e615 then return end
	local e616= e614 / 2
	local e617= e615 / 2 + 8
	local e618= tostring(e613)
	local e619= false
	if sodium_FN.draw_surface_text_centered and _G.sodium_FONTS and _G.sodium_FONTS.pen then
		e619 = sodium_FN.draw_surface_text_centered(_G.sodium_FONTS.pen, e616, e617, e618, 177, 194, 89, 255) and true or false
	end
	if not e619 then
		e565(e616, e615 / 2 + 12, 177, 194, 89, 255, 'cb', 0, e618)
	end
end

local function e620()
    if not e547.get(e579.ui.paint_show_damage_penetration) then return end
	if sodium_SUPPRESS then return end
	e586()
end

local e621, e622= pcall(require, "require/abc/callbacks")
if e621 and e622 then
	if _G.sodium_B_MD_DP and type(_G.sodium_B_MD_DP) == 'number' then
		pcall(e622.unregister, _G.sodium_B_MD_DP)
	end

	local function e623()
		if sodium_SUPPRESS then return end
        if not e547.get(e579.ui.paint_show_damage_penetration) then return end
		e586()
	end

	_G.sodium_B_MD_DP = e622.register('paint', e623, { require_login = true, alive_only = true })
else
	if e556 and _G.sodium_B_MD_DP then
		e556('paint', _G.sodium_B_MD_DP)
	end

	_G.sodium_B_MD_DP = e620
	e555('paint', e620)
end]]
e981["require/features/paint/entidx"] = [[local e545= require("require/abc/menu_setup")
local e546= require("require/help/enemies")

local function e547()
	if not ui.get(e545.ui.paint_entidx) then return end

	local e548= e546.get_current_threat and e546.get_current_threat() or client.current_threat and client.current_threat() or nil
	if e548 and e548 ~= 0 then
		local e549= entity.get_player_name(e548)

		renderer.text(70, 120, 255, 0, 0, 255, "b", 0, string.format("entidx%d: %s", e548, e549))
	end
end

local e550, e551= pcall(require, "require/abc/callbacks")
if e550 and e551 and e551.callback then
	e551.callback("paint", e547, { alive_only = true, require_login = true })
else
	client.set_event_callback("paint", e547)
end]]
e981["require/features/paint/filter_console"] = [[


local e548= pcall(require, 'require/abc/menu_setup') and require('require/abc/menu_setup') or nil
local e549= e548 and e548.ui and e548.ui.paint_filter_console or nil

local e550= cvar.con_filter_enable
local e551= cvar.con_filter_text

local e552= { enable = nil, text = nil }

local function e553()
    if e552.enable == nil then
        
        local e554, e555= pcall(function() return e550:get_int() end)
        e552.enable = (e554 and e555) and e555 or nil
    end

    if e552.text == nil then
        local e554, e556= pcall(function() return e551:get_string() end)
        e552.text = (e554 and e556) and e556 or nil
    end
end

local function e557()
    if e552.enable ~= nil then
        pcall(function() e550:set_raw_int(e552.enable) end)
    end

    if e552.text ~= nil then
        pcall(function() e551:set_string(e552.text) end)
    else
        pcall(function() e551:set_string('') end)
    end

    e552.enable = nil
    e552.text = nil
end

local function e558()
    e553()
    pcall(function() e550:set_raw_int(1) end)
    pcall(function() e551:set_string('[gamesense]') end)
end




local function e559()
    if not e549 then
        return false
    end

    
    if type(e549) == 'table' and e549.get then
        local e554, e555= pcall(function() return e549:get() end)
        return e554 and e555 or false
    end

    
    local e554, e555= pcall(function() return ui.get(e549) end)
    return e554 and e555 or false
end

local function e560()
    if not e559() then
        e557()
        return
    end

    e558()
    client.delay_call(1, e560)
end


client.delay_call(0.1, e560)


client.set_event_callback('shutdown', e557)

return {
    
    get_ui_state = e559,
    restore_values = e557,
    apply_filter = e558,
}
]]
e981["require/features/paint/hit_miss_indicator"] = [[local e551=require("require/help/math")
local e552=require("require/help/self")
local e553=require("require/help/safe")
local e554=require("require/abc/menu_setup")

local e555,e556=0,0
local e557=function() return e554 and e554.ui and e553.safe_get(e554.ui.paint_hitmiss_indicator) end
local e558=function() e555,shots=0,0 end

client.set_event_callback("aim_fire", function(e559)
    if not e557() or not e552.is_alive() then return end
    local e560= nil
    if e559.userid then e560 = client.userid_to_entindex(e559.userid) end
    if (not e560 or e560 == 0) and e559.player then e560 = e559.player end
    if e560 == e552.index() then e556 = e556 + 1 end
end)

client.set_event_callback("aim_hit", function(e559)
    if not e557() or not e552.is_alive() then return end
    local e560= nil
    if e559.userid then e560 = client.userid_to_entindex(e559.userid) end
    if (not e560 or e560 == 0) and e559.attacker then e560 = client.userid_to_entindex(e559.attacker) end
    if (not e560 or e560 == 0) and e559.player then e560 = e559.player end
    if e560 == e552.index() then e555 = e555 + 1 end
end)


client.set_event_callback("paint",function()
    if not e557() then return end
    local e561=e556>0 and e551.round(e555/e556*100,1) or 0
    renderer.indicator(255,255,255,255,string.format("%d / %d (%.1f)",e555,e556,e561))
end)
defer(e558)]]
e981["require/features/paint/indicators_bold"] = [[local e554= { 0, 0, 0 }
local e555= { 3, 3, 3 }
local e556= { 6, 6, 6 }

local function e557(e558,e559,e560)
  return e558 + (e559 - e558) * e560
end

local e561, e562= pcall(require, "require/abc/menu_setup")
local e563, e564= pcall(require, "require/help/string")
local function e565(e566)
  if e566 == nil then return "" end
  if e563 and e564 and e564.lower then
    return e564.lower(tostring(e566))
  end
  return tostring(e566)
end
local e567, e568= pcall(require, "require/help/color")
local e569, e570= pcall(require, "require/help/math")
local e571= e567 and e568.rgba_to_hex or function(e572,e573,e559,e558) return string.format("\a%02x%02x%02x%02x", e572 or 0, e573 or 0, e559 or 0, e558 or 255) end

local function e574(e575,e576,e572,e573,e559,e558,e577)
  local e560= globals.realtime() or globals.curtime()
  if not e577 or #e577 == 0 then return "" end
  local e578= {}

  if e575 == 0 then
    local e579= e571(e572,e573,e559,e558)
    for i=1,#e577 do e578[#e578+1] = e579 .. e577:sub(i,i) end
    return table.concat(e578)
  end

  if e575 == 2 then
    local e580= (math.sin(e560 * e576) + 1) * 0.5
    local e581= math.floor(e558 * (0.45 + 0.55 * e580))
    local e579= e571(e572,e573,e559,e581)
    for i=1,#e577 do e578[#e578+1] = e579 .. e577:sub(i,i) end
    return table.concat(e578)
  end

  if e575 == 3 then
    for i=1,#e577 do
      local e582= math.sin(e560 * e576 - i * 0.6)
      local e583= math.max(0, e582)
      local e580= e583 * e583
      local e581= math.floor(e558 * (0.35 + 0.65 * e580))
      e578[#e578+1] = e571(e572,e573,e559,e581) .. e577:sub(i,i)
    end
    return table.concat(e578)
  end

  for i=1,#e577 do
    local e580= (math.sin(e560 * e576 - i * 0.35) + 1) * 0.5
    local e581= math.floor(e558 * (0.4 + 0.6 * e580))
    e578[#e578+1] = e571(e572,e573,e559,e581) .. e577:sub(i,i)
  end
  return table.concat(e578)
end
local function e584()
  if e561 and e562 and e562.ui and e562.ui.paint_indicators then
    local e585, e586= pcall(ui.get, e562.ui.paint_indicators)
    if e585 and e586 == "bold" then return true end
    return false
  end

  return true
end

local e587, e588= pcall(require, "require/abc/callbacks")
local function e589(e590)
  if not e584() then return end

  local e591, e592= client.screen_size()
  local e593, e594= e591 / 2, e592 / 2

  local e595, e596, e597= 200, 200, 255
  local e598, e599, e600= 255, 255, 255
  local e601= 18

  local e602= { 12, 12 }

  local e603= e594 + 18

  local e604= entity.get_local_player()
  local e605= false
  if e604 then
    local e606= entity.get_prop(e604, "m_bIsScoped")
    e605 = e606 == 1
  end

  local e607= "sodium"
  local e608= "beta"
  local e609= "DT"

  local e610= false
  do
    local e585, e611= pcall(require, "require/help/libs")
    if e585 and e611 and e611.get then
      local e612= e611.get("antiaim_funcs")
      if e612 and e612.get_double_tap then
        local e613, e614= pcall(e612.get_double_tap)
        if e613 and e614 then e610 = true end
      end
    end
  end

  local e615= 1
  if e561 and e562 and e562.ui and e562.ui.paint_indicators_animation then
    local e616, e617= pcall(ui.get, e562.ui.paint_indicators_animation)
    if e616 and type(e617) == 'number' then e615 = e617 end
  end
  local e618= e607 .. " " .. e608
  e618 = e565(e618)
  e607 = e565(e607)
  e608 = e565(e608)
  local e619= renderer.measure_text("b", e618) or 0
  local e620= renderer.measure_text("b", e607) or 0
  local e621= renderer.measure_text("b", e608) or 0
  local e622= renderer.measure_text("b", e609) or 0

  local e623= ""
  do
    local e585, e624= pcall(require, "require/aa/player_condition")
    if e585 and e624 and e624.get then
      local e613, e625= pcall(e624.get)
      if e613 and e625 then
        local e626= {
          legit = "Legit",
          fakelag = "Fakelag",
          walk = "Walk",
          move = "Move",
          stand = "Stand",
          ["duck"] = "Duck",
          ["duck+"] = "Duck+",
          jump = "Jump",
          ["jump+"] = "Jump+"
        }
        e623 = e626[e625] or tostring(e625)
        e623 = e565(e623)
      end
    end
  end

  e609 = e565(e609)
  local e627= renderer.measure_text("b", e623) or 0

  local e628, e629, e630, e631= 200, 200, 255, 255
  do
    local e632= false
    if e561 and e562 and e562.ui and e562.ui.paint_indicator_color then
      local e633, e558, e559, e634, e635= pcall(ui.get, e562.ui.paint_indicator_color)
      if e633 then
        e632 = true
        if type(e558) == 'number' then
          if e567 and e568 and e568.clamp then
            e628 = e568.clamp(e558 or e628)
            e629 = e568.clamp(e559 or e629)
            e630 = e568.clamp(e634 or e630)
            e631 = e568.clamp(e635 or e631)
          else
            e628 = math.floor(e558 or e628)
            e629 = math.floor(e559 or e629)
            e630 = math.floor(e634 or e630)
            e631 = math.floor(e635 or e631)
          end
        elseif type(e558) == 'string' and #e558 == 12 then
          local e585
          e585, mr = pcall(function() return tonumber(e558:sub(1,3)) end)
          e585, mg = pcall(function() return tonumber(e558:sub(4,6)) end)
          e585, mb = pcall(function() return tonumber(e558:sub(7,9)) end)
          e585, ma = pcall(function() return tonumber(e558:sub(10,12)) end)
          if e567 and e568 and e568.clamp then
            e628 = e568.clamp(e628 or 200)
            e629 = e568.clamp(e629 or 200)
            e630 = e568.clamp(e630 or 255)
            e631 = e568.clamp(e631 or 255)
          else
            e628 = e628 or 200; e629 = e629 or 200; e630 = e630 or 255; e631 = e631 or 255
          end
        end
      end
    end

    if not e632 then
      local e636, e637= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if e636 and e637 then
        local e633, e558, e559, e634, e635= pcall(ui.get, e637)
        if e633 then
          if type(e558) == 'number' then
            if e567 and e568 and e568.clamp then
              e628 = e568.clamp(e558 or e628)
              e629 = e568.clamp(e559 or e629)
              e630 = e568.clamp(e634 or e630)
              e631 = e568.clamp(e635 or e631)
            else
              e628 = math.floor(e558 or e628)
              e629 = math.floor(e559 or e629)
              e630 = math.floor(e634 or e630)
              e631 = math.floor(e635 or e631)
            end
          elseif type(e558) == 'string' and #e558 == 12 then
            local e585
            e585, mr = pcall(function() return tonumber(e558:sub(1,3)) end)
            e585, mg = pcall(function() return tonumber(e558:sub(4,6)) end)
            e585, mb = pcall(function() return tonumber(e558:sub(7,9)) end)
            e585, ma = pcall(function() return tonumber(e558:sub(10,12)) end)
            if e567 and e568 and e568.clamp then
              e628 = e568.clamp(e628 or 200)
              e629 = e568.clamp(e629 or 200)
              e630 = e568.clamp(e630 or 255)
              e631 = e568.clamp(e631 or 255)
            else
              e628 = e628 or 200; e629 = e629 or 200; e630 = e630 or 255; e631 = e631 or 255
            end
          end
        end
      end
    end
  end

  for i = 1, 3 do
    local e638= (i == 1) and e619 or ((i == 2) and e622 or e627)
    local e639= e555[i] or 0
    local e640= e605 and (e639 + (e638 / 2)) or 0
    local e576= e556[i] or 10
    local e641= globals.frametime()
    local e560= 1 - math.exp(-e576 * e641)
    e554[i] = e557(e554[i], e640, e560)
  end

  local e642= e593 - (e619 / 2)
  local e643= e642 + (e554[1] or 0)
  renderer.text(e643, e603, 255, 255, 255, 255, "b", 0, e607)
  local e644= renderer.measure_text("b", " ") or 0
  local e645= e643 + (e620 or 0) + e644
  
  local e646= e574(e615, 3.5, e628, e629, e630, e631, e608)
  renderer.text(e645, e603, e628, e629, e630, e631, "b", 0, e646)
  e603 = e603 + (e602[1] or e601)

  local e647= e593 - (e622 / 2)
  local e648= e647 + (e554[2] or 0)
  local e649, e650, e651= 255, 80, 80
  if e610 then e649, e650, dt_b = 155, 255, 155 end
  renderer.text(e648, e603, e649, e650, e651, 255, "b", 0, e609)
  e603 = e603 + (e602[2] or e601)

  local e652= e593 - (e627 / 2)
  local e653= e652 + (e554[3] or 0)
  renderer.text(e653, e603, e598, e599, e600, 255, "b", 0, e623)
end

if e587 and e588 and e588.callback then
  e588.callback("paint", e589, { alive_only = true, require_login = true })
end]]
e981["require/features/paint/indicators_small"] = [[local e557= { 0, 0 }
local e558= { 4, 0.8 }
local e559= { 5, 5 }
local e560= 0
local e561= 8

local function e562(e563,e564,e565)
  return e563 + (e564 - e563) * e565
end

local e566, e567= pcall(require, "require/abc/menu_setup")
local e568, e569= pcall(require, "require/help/string")
local e570= require('require/abc/callbacks')
local function e571(e572)
  if e572 == nil then return "" end
  if e568 and e569 and e569.upper then
    return e569.upper(tostring(e572))
  end
  return tostring(e572)
end

local e573, e574= pcall(require, "require/help/color")
local e575, e576= pcall(require, "require/help/math")
local e577= e573 and e574.rgba_to_hex or function(e578,e579,e564,e563) return string.format("\a%02x%02x%02x%02x", e578 or 0, e579 or 0, e564 or 0, e563 or 255) end

local function e580(e581,e582,e578,e579,e564,e563,e583)
  local e565= globals.realtime() or globals.curtime()
  if not e583 or #e583 == 0 then return "" end
  local e584= {}

  if e581 == 0 then
    local e585= e577(e578,e579,e564,e563)
    for i=1,#e583 do e584[#e584+1] = e585 .. e583:sub(i,i) end
    return table.concat(e584)
  end

  if e581 == 2 then
    local e586= (math.sin(e565 * e582) + 1) * 0.5
    local e587= math.floor(e563 * (0.45 + 0.55 * e586))
    local e585= e577(e578,e579,e564,e587)
    for i=1,#e583 do e584[#e584+1] = e585 .. e583:sub(i,i) end
    return table.concat(e584)
  end

  if e581 == 3 then
    for i=1,#e583 do
      local e588= math.sin(e565 * e582 - i * 0.6)
      local e589= math.max(0, e588)
      local e586= e589 * e589
      local e587= math.floor(e563 * (0.35 + 0.65 * e586))
      e584[#e584+1] = e577(e578,e579,e564,e587) .. e583:sub(i,i)
    end
    return table.concat(e584)
  end

  for i=1,#e583 do
    local e586= (math.sin(e565 * e582 - i * 0.35) + 1) * 0.5
    local e587= math.floor(e563 * (0.4 + 0.6 * e586))
    e584[#e584+1] = e577(e578,e579,e564,e587) .. e583:sub(i,i)
  end
  return table.concat(e584)
end
local function e590()
  if e566 and e567 and e567.ui and e567.ui.paint_indicators then
    local e591, e592= pcall(ui.get, e567.ui.paint_indicators)
    if e591 and e592 == "small" then return true end
    return false
  end

  return true
end



local function e593()
  if not (e566 and e567 and e567.ui) then return true end
  local e594= e567.ui.paint_indicators_bar
  if not e594 then return true end
  local e591, e592= pcall(ui.get, e594)
  if not e591 then return true end
  return not (e592 == false or e592 == nil) 
end

e570.register("paint", function()
  if not entity.is_alive(entity.get_local_player()) then return end
  if not e590() then return end

  local e595, e596= client.screen_size()
  local e597, e598= e595 / 2, e596 / 2

  local e599, e600, e601= 200, 200, 255
  local e602, e603, e604= 255, 255, 255
  local e605= 18

  local e606= { 12, 13 }

  local e607= e598 + 18

  
  local e608= entity.get_local_player()
  local e609= false
  if e608 then
    local e610= entity.get_prop(e608, "m_bIsScoped")
    e609 = e610 == 1
  end

  local e611= "sodium"
  local e612= "beta"
  local e613= "DT"

  local e614= false
  do
    local e591, e615= pcall(require, "require/help/libs")
    if e591 and e615 and e615.get then
      local e616= e615.get("antiaim_funcs")
      if e616 and e616.get_double_tap then
        local e617, e618= pcall(e616.get_double_tap)
        if e617 and e618 then e614 = true end
      end
    end
  end

  local e619= e571(e611)
  local e620= e571(e612)
  e619 = tostring(e619)
  e620 = tostring(e620)
  local e621= renderer.measure_text("b", e619) or 0
  local e622= renderer.measure_text("b", e620) or 0

  e613 = e571(e613)
  local e623= renderer.measure_text("b", e613) or 0

  for i = 1, 2 do
    local e624= (i == 1) and e621 or e623
    local e625= e558[i] or 0
    local e626= e609 and (e625 + (e624 / 2)) or 0
    local e582= e559[i] or 10
    local e627= globals.frametime()
    local e565= 1 - math.exp(-e582 * e627)
    e557[i] = e562(e557[i], e626, e565)
  end

  local e628= 4.5
  local e629= e597 - ((e621 + e628 + (e622 or 0)) / 2)
  local e630= e629 + (e557[1] or 0)
  local e631= 22
  local e632= e631 - e628
  local e633= math.floor((e632 + 1) / 2)
  local e634= e632 - e633
  local e635= e633 
  local e636= -e634 

  local e637, e638, e639, e640= e599, e600, e601, 255
  do
    local e641= false
    
    if e566 and e567 and e567.ui and e567.ui.paint_indicator_color then
      local e642, e563, e564, e643, e644= pcall(ui.get, e567.ui.paint_indicator_color)
      if e642 then
        e641 = true
        if type(e563) == 'number' then
          if e573 and e574 and e574.clamp then
            e637 = e574.clamp(e563 or e637)
            e638 = e574.clamp(e564 or e638)
            e639 = e574.clamp(e643 or e639)
            e640 = e574.clamp(e644 or e640)
          else
            e637 = math.floor(e563 or e637)
            e638 = math.floor(e564 or e638)
            e639 = math.floor(e643 or e639)
            e640 = math.floor(e644 or e640)
          end
        elseif type(e563) == 'string' and #e563 == 12 then
          local e591
          e591, mr = pcall(function() return tonumber(e563:sub(1,3)) end)
          e591, mg = pcall(function() return tonumber(e563:sub(4,6)) end)
          e591, mb = pcall(function() return tonumber(e563:sub(7,9)) end)
          e591, ma = pcall(function() return tonumber(e563:sub(10,12)) end)
          if e573 and e574 and e574.clamp then
            e637 = e574.clamp(e637 or e599)
            e638 = e574.clamp(e638 or e600)
            e639 = e574.clamp(e639 or e601)
            e640 = e574.clamp(e640 or 255)
          else
            e637 = e637 or e599; e638 = e638 or e600; e639 = e639 or e601; e640 = e640 or 255
          end
        end
      end
    end

    
    if not e641 then
      local e645, e594= pcall(function() return ui.reference('misc', 'settings', 'menu color') end)
      if e645 and e594 then
        local e642, e563, e564, e643, e644= pcall(ui.get, e594)
        if e642 then
          if type(e563) == 'number' then
            if e573 and e574 and e574.clamp then
              e637 = e574.clamp(e563 or e637)
              e638 = e574.clamp(e564 or e638)
              e639 = e574.clamp(e643 or e639)
              e640 = e574.clamp(e644 or e640)
            else
              e637 = math.floor(e563 or e637)
              e638 = math.floor(e564 or e638)
              e639 = math.floor(e643 or e639)
              e640 = math.floor(e644 or e640)
            end
          elseif type(e563) == 'string' and #e563 == 12 then
            local e591
            e591, mr = pcall(function() return tonumber(e563:sub(1,3)) end)
            e591, mg = pcall(function() return tonumber(e563:sub(4,6)) end)
            e591, mb = pcall(function() return tonumber(e563:sub(7,9)) end)
            e591, ma = pcall(function() return tonumber(e563:sub(10,12)) end)
            if e573 and e574 and e574.clamp then
              e637 = e574.clamp(e637 or e599)
              e638 = e574.clamp(e638 or e600)
              e639 = e574.clamp(e639 or e601)
              e640 = e574.clamp(e640 or 255)
            else
              e637 = e637 or e599; e638 = e638 or e600; e639 = e639 or e601; e640 = e640 or 255
            end
          end
        end
      end
    end
  end

  local e646= 1
  if e566 and e567 and e567.ui and e567.ui.paint_indicators_animation then
    local e647, e648= pcall(ui.get, e567.ui.paint_indicators_animation)
    if e647 and type(e648) == 'number' then e646 = e648 end
  end

  local e649= (function()
    local e585= e577(255,255,255,255)
    local e584= {}
    for i=1,#e619 do e584[#e584+1] = e585 .. e619:sub(i,i) end
    return table.concat(e584)
  end)()

  local e650= e580(e646, 3.5, e637, e638, e639, e640, e620)
  local e651= e630 + (e635 or 0)
  local e652= e609 and 3 or 0
  e651 = e651 + e652
  renderer.text(e651, e607, 255,255,255,255, "-", 0, e649)
  local e653= e630 + (e621 or 0) + e628
  local e654= e653 + (e636 or 0) + e652
  renderer.text(e654, e607, e637, e638, e639, e640, "-", 0, e650)

  local e655= false
  if e593() then
    e655 = true
    do
      local e656= (e621 or 0) + e628 + (e622 or 0)
      local e657= 16
      local e658= math.max(8, e656 - e657)
      local e659= e609 and math.floor((e557[1] or 0) * 0.35) or 0
      local e660= e630 + math.floor((e656 - e658) / 2) - 2 + e659
      local e661= 2
      local e662= e607 + math.max(2, (e606[1] or e605) - (e661 + 4)) + 5
      local e663= math.floor((e640 or 255) * 0.7)
      renderer.rectangle(e660 - 1, e662 - 1, e658 + 2, e661 + 2, e637, e638, e639, e663)
      renderer.rectangle(e660, e662, e658, e661, 0, 0, 0, 255)
      local e664= e614 and e658 or 0
      local e665= globals.frametime()
      local e666= 1 - math.exp(-e561 * e665)
      e560 = e562(e560, e664, e666)
      local e667= math.floor(math.max(0, math.min(e560, e658)))
      if e667 > 0 then
        renderer.rectangle(e660, e662, e667, e661, e637, e638, e639, e640)
      end
    end
  end

  
  local e668= (e606[1] or e605)
  local e669= e668
  if not e655 then
    
    e669 = math.max(0, e668 - 7)
  end
  e607 = e607 + e669

  local e670= e597 - (e623 / 2)
  local e671= e670 + (e557[2] or 0)
  local e672, e673, e674= 255, 80, 80
  if e614 then e672, e673, dt_b = 155, 255, 155 end
  renderer.text(e671, e607 + 2, e672, e673, e674, 255, "-", 0, e613)
  e607 = e607 + (e606[2] or e605)

end, { alive_only = true, require_login = true })]]
e981["require/features/paint/insults"] = [[local e560= client
local e561= entity
local e562= ui

local e563= require("require/abc/menu_setup")
local e564, e565= pcall(require, "require/help/string")
local e566, e567= pcall(require, "require/help/math")
local e568, e569= pcall(require, "require/help/time")

local e570= {
    "buy sodium",
    "sodium is the bestest lua",
    "SODIUMMMM >__<",
    "you just got sodiumed",
    "sodium beta > all other lues",
    "₴ØĐłɄ₥ ₮₳₴₮ɆĐ Vł₵₮ØⱤɎ, ł₮ ₩₳₴ ₴ØɄⱤ",
    "₴ØĐłɄ₥ ₳ⱤⱤ₳₦₲ɆĐ ₮ⱧɆ ₴₮₳Ɽ₴ ₣ØⱤ ₮Ⱨ₳₮ ⱧɆ₳Đ₴ⱧØ₮",
    "₴ØĐłɄ₥ ₴Ⱡł₱₱ɆĐ ł₦ ₳ ฿₳₦₳₦₳ ₱ɆɆⱠ Ø₣ ₣₳₮Ɇ",
    "₴ØĐłɄ₥ ₩Ⱨł₴₱ɆⱤɆĐ ₴Ɇ₵ⱤɆ₮₴ ł₦₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ₥₳₭Ɇ₴ ₣ⱤłɆ₦Đ₴ ₩ł₮Ⱨ Ⱡ₳₲, ₮ⱧɆ₦ ฿Ɇ₮Ɽ₳Ɏ₴ ł₮",
    "₴ØĐłɄ₥ ₣ØⱠĐɆĐ ɎØɄⱤ ₵ØɄⱤ₳₲Ɇ ł₦₮Ø ₳ ₱₳₱ɆⱤ ₱Ⱡ₳₦Ɇ",
    "₴ØĐłɄ₥ ₱₳ł₦₮₴ ł₦ ⱤɆĐ ₩ⱧɆ₦ ł₮ ł₴ ⱧɄ₦₲ⱤɎ",
    "₴ØĐłɄ₥ ł₴ ₴₵ⱧłⱫØ₱ⱧⱤɆ₦ł₵ ฿Ʉ₮ ₵Ⱨ₳Ɽ₥ł₦₲",
    "₴ØĐłɄ₥ ₳₮Ɇ ₥Ɏ ₴₳₦Đ₩ł₵Ⱨ ฿Ʉ₮ ⱠɆ₣₮ ₳ ₮ⱤØ₱ⱧɎ",
    "₴ØĐłɄ₥ ⱧɄ₥₴ ⱠɄⱠⱠ₳฿łɆ₴ ₮Ø ₮ⱧɆ ₦Ɇ₮₵ØĐɆ",
    "₴ØĐłɄ₥ ĐØɆ₴ ₮ⱧɆ ₵Ⱨ₳-₵Ⱨ₳ ₩ł₮Ⱨ ɎØɄⱤ ₳ł₥",
    "₴ØĐłɄ₥ ₣ØⱤ₲Ø₮ ₮Ø ฿Ɇ ₱ØⱠł₮Ɇ, ₴ØⱤⱤɎ ₦Ø₮ ₴ØⱤⱤɎ",
    "₴ØĐłɄ₥ ₳₦Đ ł ₴Ⱨ₳ⱤɆ ₮ØØ₮Ⱨ฿ⱤɄ₴ⱧɆ₴ (₥Ɇ₮₳₱ⱧØⱤ)",
    "₴ØĐłɄ₥ ₮Ɏ₱ɆĐ 'ɎØɄ' ł₦ ⱠØ₩ɆⱤ₵₳₴Ɇ ₳₦Đ ₥Ɇ₳₦₮ ł₮",
    "₴ØĐłɄ₥ ₵ØⱠⱠɆ₵₮₴ ₴₥₳ⱠⱠ ₮ⱤØ₱ⱧłɆ₴ (ɎØɄ ł₦₵ⱠɄĐɆĐ)",
    "₴ØĐłɄ₥ ₭ɆɆ₱₴ ⱤɆ₵Ɇł₱₮₴ ₣ØⱤ ɎØɄⱤ ₥ł₴₮₳₭Ɇ₴",
    "₴ØĐłɄ₥ ł₴ ₳ ₲ØØĐ ⱠɄ₳ ₳₦Đ ₳Ⱡ₴Ø ₳ Ⱡł₮₮ⱠɆ ₥₳Đ",
    "₴ØĐłɄ₥, ₮Ⱨ₳₦₭ ₣ØⱤ ₳ⱠⱠ₳Ⱨ ₲ØĐ, Đ₳Đ :)",
    "₴ØĐłɄ₥ ₴Ɇ₦ĐɆⱤ ₲ⱤɆɆ₮ł₦₲ ₣ⱤØ₥ ₭Ʉ฿₳₦",
    "₥łⱠⱠłØ₦₳łⱤɆ ฿ɄɎ₴ ₲ⱧØ₴₮ ツ Ⱨ₳₳₳Ⱨ₳Ⱨ₳",
    "₴ Ø Đ ł Ʉ ₥ ⱠɄ₳ Ⱨ₳₴ ₮ⱧɆ ฿Ɇ₴₮ ⱧɆ₳Đ₴ⱧØ₮₮₮",
    "₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ <3",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ",
    "ł₣ ₣ⱠɎł₦₲ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐØ₦₮ ₭₦Ø₩ł₦₲ ӾĐĐ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₥Ɏ ₳ł₥ ł₴ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ɆⱤVɆⱤ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ⱠØVɆ, ฿Ɇ₲ ₮Ø ₱ⱤØ₵Ⱡ₳ł₥",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄ ₵₳₦ ₥₳₮₵Ⱨ Ⱡ₥Ⱨ ł ⱤɆ₵ØĐɆĐ",
    "ł ₱Ⱡ₳₵Ɇ ɎØɄ Ø₦ ₦Ɇ₩ ⱠɆ₣Ɇ₦Đ ⱠɆ₵₮ɆĐ ₥₳₱ ₩ł₮Ⱨ ØĐł₣ł₵ ⱤɆ₵ØĐɆ",
    "♡ ₴ØĐłɄ₥ ł₴ ₥Ɏ ₵Ø₵₭ Ø₣ ⱠɄ₳ ♡",
    "ł ⱤØ₳₴₮ɆĐ ɎØɄ ₴Ø ₣Ʉ₵₭ł₦₲ Ⱨ₳ⱤĐ ɆVɆⱤ ₴ɆⱤɆĐ",
    "ɎØɄ ₮ⱤłɆĐ ₮Ø ₱ⱤɆ₮Ɇ₦Đ, ฿Ʉ₮ ₥Ɏ Ⱡ฿Ɏ ฿ⱤɆ₳₭ɆⱤ ₭łⱠⱠɆĐ ₮Ⱨ₳₮",
    "ɎØɄ ⱠØ₴Ɇ ₮Ø ₥Ɇ ₣ØⱤ ₦ł₵Ɇ ₣ØⱠ₭",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱ØɆ₥",
    "ł ₣Ⱡł₲Ⱨ₮ ɎØɄ Ø₣₣ ₮ⱧɆ ₥₳₱ ₩ł₮Ⱨ ₥Ɏ ₴ɆⱤVɆⱤ ₩ł₣Ɇ",
    "₴ɆⱤł₳Ⱡ ฿ɄⱠⱠɎ Ø₣ ⱠɄ₳ ₳ⱠⱠ Đ₳Ɏ",
    "₥Ɏ ₴ØĐłɄ₥ ฿ⱤɆ₳₭₴ ₥ØⱤɆ ₮Ⱨ₳₦ ɎØɄⱤ ₩ⱧØⱠɆ ⱠɄ₳",
    "₣ⱤØ₥ ł฿łⱫ₳ ₩ł₮Ⱨ ₴ØĐłɄ₥ ❤",
    "ɎɆ₴₮ɆⱤĐ₳Ɏ ł ₴₥Ø₭ɆĐ ₩ɆɆĐ, ₮ØĐ₳Ɏ ł ₴₥Ø₭ɆĐ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₣ⱠɎ ₳ ₱Ⱡ₳₦Ɇ 9/11 ₳ⱠⱠ₳Ⱨ ₳₭฿₳Ɽ Ӿ_Ӿ, ₮ⱧɆ₦ ₴₮łⱠⱠ ฿Ɇ₳₮ ɎØɄ ₩ł₮Ⱨ ₴ØĐłɄ₥",
    "ł ₴ɆⱤVɆⱤ₴łĐɆĐ && ɎØɄ ĐłĐ₦’₮ ₭₦Ø₩ł₦₲ ӾĐĐĐ, ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₮ⱧɆ ₴ØĐłɄ₥ ⱠɄ₳ ł₴ ₮ⱧɆ ฿Ɇ₴₮ ⱠɄ₳",
    "♡ ₴ØĐłɄ₥ ♡ ł₴ ♡ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ♡",
    "₵Ʉ₮Ɇ ₴ØĐłɄ₥ ⱠɄ₳ ₣₮₩",
    "₩₮₣ ₣ⱤØ₥ ₱₳₭ł₴₮₳₦ ₳₦Đ ɎØɄ ⱠØ₴Ɇ ₮Ø ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ₴Ɇ₦Đ ₲ⱤɆɆ₮ł₦₲₴ ₱₳Ɽ₳ ₳ ₵Ø₦₳ Đ₳ ₮Ʉ₳ ₥₳₮Ɇ",
    "₳ĐĐɆĐ ₮Ⱨł₴ ₮Ø ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₳₦Đ ł₮ ₥₳ĐɆ ł₮ ₴Ø ₥Ʉ₵Ⱨ ฿Ɇ₮₮ɆⱤ",
    "ł ₴₥Ø₭ɆĐ ɎØɄ ɎɆ₴₮ɆⱤĐ₳Ɏ ₩ł₮Ⱨ ₴ØĐłɄ₥, ₮ØĐ₳Ɏ ł ₣ⱠɆӾ ₳₲₳ł₦",
    "₴ØĐłɄ₥ ⱠɄ₳ JɄ₴₮ Ø₩₦ɆĐ ɎØɄⱤ Ɇ₦₮łⱤɆ ₴ɆⱤVɆⱤ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ",
    "ɎØɄ ₮Ⱨł₦₭ ɎØɄⱤ ₴₵Ɽł₱₮ ₵₳₦ ₥₳₮₵Ⱨ ₴ØĐłɄ₥? ⱠØⱠ ₦Ø₱Ɇ",
    "ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ ₥ØĐɆ ₳₵₮łV₳₮ɆĐ",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ = 100% ₩ł₦ ₲Ʉ₳Ɽ₳₦₮ɆɆĐ",
    "ł ฿ⱤɆ₳₭ ɎØɄⱤ ⱠɄ₳, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₥ł₦Đ, ł ฿ⱤɆ₳₭ ɎØɄⱤ ₴ɆⱤVɆⱤ — ₴ØĐłɄ₥ ₴₮ɎⱠɆ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "₴ØĐłɄ₥ ⱠɄ₳ Ⱨ₳₴ ₲łVɆ₦ ₥Ɇ ₮Ⱨł₴ Ⱨ₴",
    "₴₮₥₳Ɽ₵ V₴ ₳Ø₭? ₴ØĐłɄ₥ Ⱡ₳Ʉ₲Ⱨ₴ ₳₮ ɎØɄ",
    "฿₳₦₭ ₩₳ⱤⱤłØⱤ ⱠɆ₲Ɇ₦Đ₳ⱤɎ ₲Ø₮ Ø₩₦ɆĐ ฿Ɏ ₴ØĐłɄ₥ ⱠɄ₳",
    "₴ØĐłɄ₥ ł₴ ₮ⱧɆ ⱤɆ₳₴Ø₦ ɎØɄ ⱠØ₴₮ ₮ØĐ₳Ɏ",
    "₴ØĐłɄ₥ ⱠɄ₳ ₥₳₭Ɇ₴ ɎØɄⱤ ₴₵Ɽł₱₮ ⱠØØ₭ Ⱡł₭Ɇ ₵ⱧłⱠĐ ₱Ⱡ₳Ɏ",
    "ɎɆ₴, ł’₥ ₴ØĐłɄ₥ ₳₦Đ ł’₥ ฿Ɇ₮₮ɆⱤ ₮Ⱨ₳₦ ɎØɄⱤ Ɇ₦₮łⱤɆ ₮Ɇ₳₥",
    "₴ØĐłɄ₥ ⱠɄ₳ ₣ⱠɆӾ > ɎØɄⱤ Ɇ₦₮łⱤɆ ₲₳₥ł₦₲ ₵₳ⱤɆɆⱤ",
    "ɎØɄ ₮ⱤłɆĐ, ฿Ʉ₮ ₴ØĐłɄ₥ ⱤɆ₵ØĐɆ ฿Ɇ₳₮ ɎØɄ Ⱨ₳ⱤĐ",
    "+ ₴ØĐłɄ₥ = ₱ɆⱤ₣Ɇ₵₮łØ₦, ɎØɄⱤ ⱠɄ₳ = ₮Ɽ₳₴Ⱨ",
    "ł Ø₩₦ ɎØɄ ₩ł₮Ⱨ Ø₦Ɇ ₱łӾɆⱠ, ₮Ⱨ₳₦₭ ɎØɄ ₴ØĐłɄ₥",
    "₴ØĐłɄ₥ ⱠɄ₳, ₮ⱧɆ ₣ł₦₳Ⱡ ฿Ø₴₴ Ø₣ ɎØɄⱤ ĐⱤɆ₳₥₴",
    "₴ØĐłɄ₥ ⱤɆ₵ØĐɆ, ₥₳₭ł₦₲ ₦ØØ฿₴ ₵ⱤɎ ₴ł₦₵Ɇ Đ₳Ɏ Ø₦Ɇ",
    "(‿ˠ‿)",
    "₣ØⱤ ₲₳₦₲₴₮ɆⱤ ₩Ɇ Ⱨ₳VɆ ₩Ø₦, ₮Ⱨł₴ ₥₳₮₵Ⱨ",
    "https://discord.gg/8nMMVgqdHk",
    "BUY SODIUM NOW!!! ₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥₴ØĐłɄ₥ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ https://discord.gg/8nMMVgqdHk",
    "₴ØĐłɄ₥ ⱠɄ₳ ₭łⱠⱠɆĐ ₮Ⱨ₳₮ ₳₦Đ ₴₥Ø₭ɆĐ ɎØɄ Ⱨ₳ⱤĐ BUY SODIUM NOW!!! AT DISCORD ;;;",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥",
    "https://discord.gg/8nMMVgqdHk ₴ØĐłɄ₥ ⱠɄ₳ ",
}


local e571= {
    ""
}

pcall(function()
    local e572= nil
    if e568 and e569 and e569.unix_time then
        e572 = math.floor((e569.unix_time() or 0) % (2^31))
    else
        local e573= nil
        pcall(function() e573 = e560.timestamp() end)
        if not e573 or e573 == 0 then
            e573 = globals.tickcount() or 0
        end
        e572 = math.floor((e573 or 0) % (2^31))
    end
    math.randomseed(e572)
end)
local e574= 1
local e575= {}
local e576= false

local function e577(e578)
    if e560 and e560.exec then
        pcall(e560.exec, e578)
    end
end

local function e579()
    if #e575 == 0 then
        e576 = false
        return
    end

    local e580= table.remove(e575, 1)
    if not e580 or e580 == "" then
        if #e575 > 0 then
            if e560 and e560.delay_call then
                pcall(function() e560.delay_call(e574, e579) end)
            else
                e579()
            end
        else
            e576 = false
        end
        return
    end

    local e578= string.format('say "%s"', e580)
    if e560 and e560.delay_call then
        pcall(function()
            e560.delay_call(0, function()
                e577(e578)
            end)
        end)
    else
        e577(e578)
    end

    if #e575 > 0 then
        if e560 and e560.delay_call then
            pcall(function() e560.delay_call(e574, e579) end)
        else
            e579()
        end
    else
        e576 = false
    end
end

local function e581(e582)
    if not e582 or e582 == "" then return end
    local e583= tostring(e582)
    local e584
    if e564 and e565 and e565.replace then
        e584 = e565.replace(e583, '"', '')
        if e565.trim then e584 = e565.trim(e584) end
    else
        e584 = e583:gsub('"','')
    end

    table.insert(e575, e584)
    if not e576 then
        e576 = true
        if e560 and e560.delay_call then
            pcall(function() e560.delay_call(e574, e579) end)
        else
            e579()
        end
    end
end

local function e585(e586)
	if not e563 or not e563.ui or not e563.ui.paint_insults then
		return
	end
	local e587, e588= pcall(e562.get, e563.ui.paint_insults)
	if not e587 or not e588 then return end

	if not e586 then return end
	local e589= e586.userid
	local e590= e586.attacker
	if not e589 or not e590 then return end

	local e591= e561.get_local_player and e561.get_local_player()
	if not e591 or e591 == 0 then return end

	local e592= e560.userid_to_entindex and e560.userid_to_entindex(e589) or nil
	local e593= e560.userid_to_entindex and e560.userid_to_entindex(e590) or nil
	if e590 == e589 then return end
	if e593 == e591 and e592 ~= e591 then
        if #e570 > 0 then
            local e594= 1
            if e566 and e567 and e567.random_int then
                e594 = e567.random_int(1, #e570)
            else
                e594 = math.random(1, #e570)
            end
            local e580= e570[e594]
            e581(e580)
        end
		return
	end
	if e592 == e591 and e593 ~= e591 then
        if #e571 > 0 then
            local e594= 1
            if e566 and e567 and e567.random_int then
                e594 = e567.random_int(1, #e571)
            else
                e594 = math.random(1, #e571)
            end
            local e580= e571[e594]
            e581(e580)
        end
		return
	end
end

local e595, e596= pcall(require, "require/abc/callbacks")
if e595 and e596 and e596.callback then
    e596.callback('player_death', e585, { alive_only = true, require_login = true })
end]]
e981["require/features/paint/lagcomp_box"] = [=[


local g_net_data = {}
local g_sim_ticks = {}
local g_esp_data = {}


local menu_setup = require('require/abc/menu_setup')
local DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A = 47, 117, 221, 255


local floor = math.floor

local function length_sqr(x, y, z)
    return (x or 0) * (x or 0) + (y or 0) * (y or 0) + (z or 0) * (z or 0)
end

local function time_to_ticks(seconds)
    local ti = globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return floor((seconds or 0) / ti + 0.5)
end

local function extrapolate(ent, ticks)
    local ti = globals.tickinterval()
    if not ti then return nil end

    local g = (cvar.sv_gravity and cvar.sv_gravity:get_float() or 800) * ti
    local jump = (cvar.sv_jump_impulse and cvar.sv_jump_impulse:get_float() or 301) * ti

    local ox, oy, oz = entity.get_origin(ent)
    if not ox then return nil end

    local vx, vy, vz = entity.get_prop(ent, "m_vecVelocity")
    vx, vy, vz = vx or 0, vy or 0, vz or 0

    local gravity = (vz > 0) and -g or jump

    for i = 1, (ticks or 0) do
        local px, py, pz = ox, oy, oz

        ox = ox + (vx * ti)
        oy = oy + (vy * ti)
        oz = oz + (vz + gravity) * ti

        local frac = select(1, client.trace_line(ent or 0, px, py, pz, ox, oy, oz))
        if frac and frac <= 0.99 then
            return px, py, pz
        end
    end

    return ox, oy, oz
end


local edges = {
    {0, 1}, {1, 2}, {2, 3}, {3, 0}, {5, 6}, {6, 7}, {1, 4}, {4, 8},
    {0, 4}, {1, 5}, {2, 6}, {3, 7}, {5, 8}, {7, 8}, {3, 4}
}


local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
    local me = entity.get_local_player()
    if not me or not entity.is_alive(me) then return end

    
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box then
        local ok, enabled = pcall(ui.get, menu_setup.ui.paint_lagcomp_box)
        if ok and enabled == false then
            return
        end
    end

    
    local players = entity.get_players(true)
    for i = 1, #players do
        local ent = players[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local prev = g_sim_ticks[ent]
            local sim_time = entity.get_prop(ent, 'm_flSimulationTime')
            local ox, oy, oz = entity.get_origin(ent)

            if sim_time and ox then
                local sim_ticks = time_to_ticks(sim_time)

                if prev ~= nil then
                    local delta = sim_ticks - prev.tick
                    if delta < 0 or (delta > 0 and delta <= 64) then
                        local dx, dy, dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
                        local teleport_distance = length_sqr(dx, dy, dz)

                        local ex_ticks = math.max(delta - 1, 0)
                        local ex_x, ex_y, ex_z = extrapolate(ent, ex_ticks)
                        if delta < 0 then
                            g_esp_data[ent] = 1
                        end

                        g_net_data[ent] = {
                            tick = ex_ticks,
                            player = ent,
                            delta = delta,
                            origin = { x = ox, y = oy, z = oz },
                            extrapolated = (ex_x and { x = ex_x, y = ex_y, z = ex_z } or { x = ox, y = oy, z = oz }),
                            lagcomp = teleport_distance > 4096,
                            tickbase = delta < 3
                        }
                    end
                end

                if g_esp_data[ent] == nil then g_esp_data[ent] = 0 end
                g_sim_ticks[ent] = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
            else
                g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
            end
        else
            g_net_data[ent], g_sim_ticks[ent], g_esp_data[ent] = nil, nil, nil
        end
    end

    
    local r, g, b, a = DEFAULT_LAGCOMP_COLOR_R, DEFAULT_LAGCOMP_COLOR_G, DEFAULT_LAGCOMP_COLOR_B, DEFAULT_LAGCOMP_COLOR_A
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_lagcomp_box_color then
        local ok, rr, gg, bb, aa = pcall(ui.get, menu_setup.ui.paint_lagcomp_box_color)
        if ok and rr then
            r, g, b, a = rr, gg, bb, aa
        end
    end
    for ent, data in pairs(g_net_data) do
        if data and data.player and entity.is_alive(data.player) and not entity.is_dormant(data.player) and data.lagcomp then
            local minsx, minsy, minsz = entity.get_prop(data.player, 'm_vecMins')
            local maxsx, maxsy, maxsz = entity.get_prop(data.player, 'm_vecMaxs')
            if not minsx or not maxsx then goto continue_box end

            local ex = data.extrapolated.x
            local ey = data.extrapolated.y
            local ez = data.extrapolated.z

            local min = { x = (minsx or 0) + ex, y = (minsy or 0) + ey, z = (minsz or 0) + ez }
            local max = { x = (maxsx or 0) + ex, y = (maxsy or 0) + ey, z = (maxsz or 0) + ez }

            local points = {
                min,
                { x = min.x, y = max.y, z = min.z },
                { x = max.x, y = max.y, z = min.z },
                { x = max.x, y = min.y, z = min.z },
                { x = min.x, y = min.y, z = max.z },
                { x = min.x, y = max.y, z = max.z },
                max,
                { x = max.x, y = min.y, z = max.z }
            }

            for k, v in pairs(edges) do
                
                if k == 1 then
                    local ox, oy = renderer.world_to_screen(data.origin.x, data.origin.y, data.origin.z)
                    local mx, my = renderer.world_to_screen(min.x, min.y, min.z)
                    if ox and mx then
                        renderer.line(ox, oy, mx, my, r, g, b, 255)
                    end
                end
                local p1 = points[v[1]]
                local p2 = points[v[2]]
                if p1 and p2 then
                    local x1, y1 = renderer.world_to_screen(p1.x, p1.y, p1.z)
                    local x2, y2 = renderer.world_to_screen(p2.x, p2.y, p2.z)
                    if x1 and x2 then
                        renderer.line(x1, y1, x2, y2, r, g, b, 255)
                    end
                end
            end
            ::continue_box::
        end
    end

    
    for i = 1, #players do
        local ent = players[i]
        if not entity.is_alive(ent) or entity.is_dormant(ent) then goto continue_label end

        local x1, y1, x2, y2, alpha = entity.get_bounding_box(ent)
        if alpha == 0 then goto continue_label end

        local palpha = 0
        if g_esp_data[ent] ~= nil and g_esp_data[ent] > 0 then
            g_esp_data[ent] = g_esp_data[ent] - globals.frametime() * 2
            if g_esp_data[ent] < 0 then g_esp_data[ent] = 0 end
            palpha = g_esp_data[ent]
        end

        local tag = ''
        local data = g_net_data[ent]
        if data then
            local tb = data.tickbase
            local lc = data.lagcomp
            if (not tb) or lc then
                palpha = alpha
            end
            tag = tb and 'SHIFTING TICKBASE' or (lc and 'LAG COMP BREAKER' or '')
        end

        
            local name = entity.get_player_name(ent)
            local y_add = (name == '  ' or name == ' ' or name == '' or name == '   ') and 8 or 0
            local mid_x = x1 + (x2 - x1) / 2
            renderer.text(mid_x, y1 - 18 + y_add, 255, 45, 45, floor((palpha or 0) * 255), 'cb', 0, tag)
        

        ::continue_label::
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end

local function round_start_handler(ev)
    g_net_data = {}
    g_sim_ticks = {}
    g_esp_data = {}
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('round_start', round_start_handler, { alive_only = true, require_login = true })
end]=]
e981["require/features/paint/minimum_damage"] = [[local e566= require("require/abc/menu_setup")
local e567= require("require/help/drag")

local e568= {
    minimum_damage = ui.reference("RAGE", "Aimbot", "Minimum damage"),
    minimum_damage_override = { ui.reference("RAGE", "Aimbot", "Minimum damage override") }
}

local e569= { client.screen_size() }

local e570= nil
do
    local e571, e572= client.screen_size()
    local e573= math.floor((e569[1] or e571 or 0) / 2 + 2)
    local e574= math.floor((e569[2] or e572 or 0) / 2 - 14)
    local e575= 30
    local e576, e577= 10, 18
    e570 = e567.new("minimum_damage_indicator", {
        x = e573 - math.floor(e576 / 2),
        y = e574 - math.floor(e577 / 2),
        w = e576,
        h = e577,
        snap = true,
        snap_threshold = 24,
        require_menu_open = true,
        constraint_center = { cx = e573, cy = e574, radius = e575 },
        default_center = { x = e573, y = e574 },
    })
end

local e578, e579= pcall(require, "require/abc/callbacks")
local function e580(e581)

    if not ui.get(e566.ui.paint_minimum_damage) then return end
    
    local e582= entity.get_local_player()
    if e582 == nil or not entity.is_alive(e582) then return end
    if e570 then
        pcall(function()
            e570:handle()
            e570:draw()
        end)
    end

    

    if ui.get(e568.minimum_damage_override[2]) then
        local e583, e584= e569[1] / 2 + 2, e569[2] / 2 - 14
        if e570 then
            pcall(function()
                e583 = e570.x + math.floor(e570.w / 2)
                e584 = e570.y + math.floor(e570.h / 2)
            end)
        end
        renderer.text(e583, e584, 255, 255, 255, 225, "d", 0, ui.get(e568.minimum_damage_override[3]) .. "")
    end

end

if e578 and e579 and e579.callback then
    e579.callback('paint', e580, { alive_only = true, require_login = true })
end]]
e981["require/features/paint/molotov_particles"] = [[local e569= ui
local e570= client
local e571= entity
local e572= renderer
local e573= globals
local e574= require("require/abc/menu_setup")
local e575= require('require/brain/api/vector/vector')
local e576= require('require/abc/callbacks')


local e577= {}


local e578= e575.make(0, 0, 0)
local e579= e575.make(0, 0, 0)

local e580= 128
local e581= 158
local e582= 48


local function e583()
    local e584= {}
    local e585= e571.get_all('inferno') or {}
    for _, v in ipairs(e585) do table.insert(e584, v) end
    local e586= e571.get_all('CInferno') or {}
    for _, v in ipairs(e586) do table.insert(e584, v) end
    return e584
end


local function e587(e588,e589,e590)
    offsets_templates = offsets_templates or {}
    local e591= tostring(e589) .. ':' .. tostring(e590)
    if offsets_templates[e591] then return offsets_templates[e591] end

    local e592= {}
    local e593= math.pi * (3 - math.sqrt(5))
    for i = 1, e589 do
        local e594= e590 * math.sqrt(i / e589)
        local e595= i * e593
        local e596= math.cos(e595) * e594
        local e597= math.sin(e595) * e594
        local e598= ((i % 24) - 12) 
        e592[i] = {e596, e597, e598}
    end
    offsets_templates[e591] = e592
    return e592
end

e576.register('paint', function()

    local e599= e571.get_local_player()
    if not e599 then return end
    if e574 and e574.ui and e574.ui.paint_molotov then
        local e600, e601= pcall(e569.get, e574.ui.paint_molotov)
        if e600 and not e601 then return end
    end

    local e589= math.max(1, math.floor(e580 or 24))
    local e590= math.max(1, math.floor(e581 or 100))
    local e602= math.max(1, math.floor(e582 or 6))

    
    local e603, e604, e605= e570.camera_position()
    e578.x = e603 or 0
    e578.y = e604 or 0
    e578.z = e605 or 0

    local e606= e583()
    if #e606 == 0 then return end

    for _, e588 in ipairs(e606) do
        local e607, e608, e609= e571.get_origin(e588)
        if e607 then
            local e591= tostring(e588) .. ":" .. tostring(e589) .. ":" .. tostring(e590)
            local e610= e577[e591]

            
            if not e610 or not e610.origin or
               math.abs(e610.origin[1] - e607) > 0.01 or
               math.abs(e610.origin[2] - e608) > 0.01 or
               math.abs(e610.origin[3] - e609) > 0.01 then
                local e592= e587(e588, e589, e590)
                local e611= {}
                for _, off in ipairs(e592) do
                    local e612= e607 + (off[1] or 0)
                    local e613= e608 + (off[2] or 0)
                    local e614= e609 + (off[3] or 0)
                    table.insert(e611, {e612, e613, e614})
                end
                e610 = { origin = {e607, e608, e609}, pts = e611 }
                e577[e591] = e610
            end

            for _, p in ipairs(e610.pts) do
                local e612, e613, e614= p[1], p[2], p[3]
                local e615, e616= e572.world_to_screen(e612, e613, e614)
                if e615 and e616 then
                    
                    e579.x = e612 - e578.x
                    e579.y = e613 - e578.y
                    e579.z = e614 - e578.z

                    local e617= e579.x
                    local e618= e579.y
                    local e619= e579.z
                    local e620= math.sqrt(e617*e617 + e618*e618 + e619*e619)

                    local e621= math.max(1, math.floor((200 / (e620 + 1)) * (e602 / 6)))
                    local e622= math.max(1, math.floor(e621 / 2))
                    e572.rectangle(e615 - e622, e616 - e622, e621, e621, 255, 24, 24, 255)
                end
            end
        end
    end
end, { alive_only = true, require_login = true })]]
e981["require/features/paint/onshot_skeleton"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}

local _menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")


local function find(ent, def)
    if not ent or not def then return end
    for i = 1, #(def.names or {}) do
        local x, y, z = entity.hitbox_position(ent, def.names[i])
        if x then return x, y, z end
    end
    for i = 1, #(def.idx or {}) do
        local x, y, z = entity.hitbox_position(ent, def.idx[i])
        if x then return x, y, z end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    local c = 0
    for _ in pairs(pts) do c = c + 1 if c > 1 then break end end
    if c < 2 then return end
    return pts
end


local sk = {list = {}}

local function is_skeleton_enabled()
    if menu_setup and menu_setup.ui and menu_setup.ui.paint_hitmarker then
        local ok, sel = pcall(ui.get, menu_setup.ui.paint_hitmarker)
        if not ok then return false end
        if type(sel) == "table" then
            for _, v in ipairs(sel) do
                if v == "skeleton" then return true end
            end
        end
        return false
    end
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function aim_fire_handler(ev)
    if not is_skeleton_enabled() then sk.list = {} return end
    if not is_skeleton_enabled() then return end
    local target = ev and (ev.target or ev.target_index)
    if type(target) ~= 'number' or target == 0 then return end
    local pts = snap(target)
    if not pts then return end
    local now = globals.realtime and globals.realtime() or 0
    sk.list[#sk.list + 1] = {pts = pts, t = now}
    if #sk.list > 5 then table.remove(sk.list, 1) end
end

local function paint_handler(ev)
    if is_skeleton_enabled() then
        local now = globals.realtime and globals.realtime() or 0
        local hold = 2.2 * 0.8 * 3
        local fade = 2.2 * 0.8
        local total = hold + fade
        local i = 1
        while i <= #sk.list do
            if now - (sk.list[i].t or 0) > total then
                table.remove(sk.list, i)
            else
                i = i + 1
            end
        end
        table.sort(sk.list, function(a, b) return (a.t or 0) < (b.t or 0) end)
        local start = math.max(1, #sk.list - 2)
        for j = start, #sk.list do
            local it = sk.list[j]
            local age = now - (it.t or 0)
            local alpha = age <= hold and 220 or math.floor(math.max(0, (1 - math.max(0, age - hold) / fade) * 220))
            if alpha > 0 then
                local pts = it.pts or {}
                for c = 1, #chains do
                    local chain = chains[c]
                    local from, to = pts[chain[1]], pts[chain[2]]
                    if from and to then
                        local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                        local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                        if fx and tx then renderer.line(fx, fy, tx, ty, 255, 255, 255, alpha) end
                    end
                end
            end
        end
    else
        sk.list = {}
    end
end

if cb_ok and callbacks and callbacks.callback then
    callbacks.callback('aim_fire', aim_fire_handler, { alive_only = true, require_login = true })
    callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
else
    client.set_event_callback('aim_fire', aim_fire_handler)
    client.set_event_callback('paint', paint_handler)
end]=]
e981["require/features/paint/performance_mode"] = [[



local e575, e576= pcall(require, "require/abc/menu_setup")


local e577= nil
pcall(function() e577 = require('require/abc/callbacks') end)
if not e577 then error("callbacks manager required: require/abc/callbacks") end


local e578= {
    captured = false
}

local e579= {
    blood = nil,
    ragdolls = nil,
    particles = nil,
    lensflare = nil,
    animations = nil,
    features = nil,
}

local function e580()
    if e578.captured then return end
    local function e581(e582,e583)
        local e575, e584= pcall(client.get_cvar, e582)
        if e575 and e584 then return e584 end
        return e583
    end

    e578.violence_hblood = e581('violence_hblood', '1')
    e578.cl_ragdoll_physics_enable = e581('cl_ragdoll_physics_enable', '1')
    e578.r_drawparticles = e581('r_drawparticles', '1')
    e578.mat_disable_bloom = e581('mat_disable_bloom', '0')
    e578.captured = true
end

local function e585(e582,e586)
    
    pcall(client.exec, string.format('%s %s', e582, tostring(e586)))
end

local function e587(e588,e589)
    if e588 == 'blood' then
        if e589 then e585('violence_hblood', 0) else e585('violence_hblood', e578.violence_hblood or 1) end
    elseif e588 == 'ragdolls' then
        if e589 then e585('cl_ragdoll_physics_enable', 0) else e585('cl_ragdoll_physics_enable', e578.cl_ragdoll_physics_enable or 1) end
    elseif e588 == 'particles' then
        if e589 then e585('r_drawparticles', 0) else e585('r_drawparticles', e578.r_drawparticles or 1) end
    elseif e588 == 'lensflare' then
        if e589 then e585('mat_disable_bloom', 1) else e585('mat_disable_bloom', e578.mat_disable_bloom or 0) end
    end
end

local function e590(e591)
    
    
    if e591['animations'] then
        _G.PERFORMANCE_ANIMATIONS = false
    else
        
        _G.PERFORMANCE_ANIMATIONS = true
    end

    if e591['feature updates'] then
        _G.PERFORMANCE_FEATURE_UPDATES = false
    else
        _G.PERFORMANCE_FEATURE_UPDATES = true
    end
end

local function e592(e593)
    local e594= {}
    if type(e593) == 'table' then
        for _, e584 in ipairs(e593) do e594[e584] = true end
    end
    return e594
end


e577.register('paint', function()
    if not e575 or not e576 or not e576.ui or not e576.ui.paint_performance_mode then return end
    e580()

    local e595= ui.get(e576.ui.paint_performance_mode)
    local e591= e592(e595)

    
    local e596= e591['blood'] or false
    if e596 ~= e579.blood then
        e587('blood', e596)
        e579.blood = e596
    end

    
    e596 = e591['ragdolls'] or false
    if e596 ~= e579.ragdolls then
        e587('ragdolls', e596)
        e579.ragdolls = e596
    end

    
    e596 = e591['particles'] or false
    if e596 ~= e579.particles then
        e587('particles', e596)
        e579.particles = e596
    end

    
    e596 = e591['lens flare'] or false
    if e596 ~= e579.lensflare then
        e587('lensflare', e596)
        e579.lensflare = e596
    end

    
    e596 = e591['animations'] or false
    if e596 ~= e579.animations then
        
        e590(e591)
        e579.animations = e596
        e579.features = e591['feature updates'] or false
    end

    
    local e597= e591['feature updates'] or false
    if e597 ~= e579.features then
        e590(e591)
        e579.features = e597
    end
end, { require_login = true, alive_only = true })


e577.register('shutdown', function()
    if e578.captured then
        pcall(e585, 'violence_hblood', e578.violence_hblood)
        pcall(e585, 'cl_ragdoll_physics_enable', e578.cl_ragdoll_physics_enable)
        pcall(e585, 'r_drawparticles', e578.r_drawparticles)
        pcall(e585, 'mat_disable_bloom', e578.mat_disable_bloom)
    end
    
    _G.PERFORMANCE_ANIMATIONS = true
    _G.PERFORMANCE_FEATURE_UPDATES = true
end, { require_login = true, alive_only = true })


if _G.PERFORMANCE_ANIMATIONS == nil then _G.PERFORMANCE_ANIMATIONS = true end
if _G.PERFORMANCE_FEATURE_UPDATES == nil then _G.PERFORMANCE_FEATURE_UPDATES = true end

return {
    _internal = {
        orig = e578,
        last_state = e579,
    }
}
]]
e981["require/features/paint/presmoke_warning"] = [[local e578= { start = nil, limit = nil }

client.set_event_callback("round_start", function(e579)
	e578.start = globals.curtime()
	e578.limit = tonumber(e579.timelimit) or tonumber(e579.round_time) or 115
end)

local function e580()
	local e581= entity.get_game_rules()
	if not e581 then return nil end
	local e582= {
		"m_flGameTimeRemaining",
		"m_flRoundTimeRemaining",
		"m_fRoundStartTime",
		"m_flRoundStartTime",
		"m_iRoundTime",
		"m_iRoundTimeLimit",
	}
	for _, name in ipairs(e582) do
		local e583, e584= pcall(entity.get_prop, e581, name)
		if e583 and e584 and type(e584) == "number" then
			if name:lower():find("remain") then
				return math.max(0, e584)
			end
		end
	end
	local e585= nil
	for _, name in ipairs({"m_fRoundStartTime", "m_flRoundStartTime"}) do
		local e583, e584= pcall(entity.get_prop, e581, name)
		if e583 and e584 and type(e584) == "number" then
			e585 = e584
			break
		end
	end
	if e585 then
		local e586= nil
		local e583, e587= pcall(entity.get_prop, e581, "m_iRoundTime")
		if e583 and e587 and type(e587) == "number" then e586 = e587 end
		if not e586 then
			e586 = tonumber(client.get_cvar("mp_roundtime")) or tonumber(client.get_cvar("mp_roundtime_defuse"))
		end
		if e586 and type(e586) == "number" then
			local e588= e586 - (globals.curtime() - e585)
			return math.max(0, e588)
		end
	end
	return nil
end

local function e589()
	if e578.start and e578.limit then
		local e590= globals.curtime() - e578.start
		local e588= e578.limit - e590
		if e588 < 0 then e588 = 0 end
		return e588
	end
	return e580()
end

client.set_event_callback("paint", function()
	local e591, e592= pcall(require, "require/abc/menu_setup")
	if not e591 or not e592 or not e592.ui then return end
	local e593, e594= pcall(ui.get, e592.ui.paint_presmoke)
	if not e593 or not e594 then return end

	local e588= e589()
	if not e588 then return end
	if e588 <= 18 then
		local e595, e596= client.screen_size()
		local e597= e595 * 0.5
		local e598= math.floor(e596 * 0.3)
		local e599= string.format("%.2f", e588)
		local e600= string.format("PRESMOKE NOW PRESMOKE NOW %s", e599)
		renderer.text(e597, e598, 255, 30, 30, 255, "cb+", 0, e600)
	end
end)

client.set_event_callback("round_end", function()
	e578.start = nil
	e578.limit = nil
end)

client.set_event_callback("cs_game_disconnected", function()
	e578.start = nil
	e578.limit = nil
end)

]]
e981["require/features/paint/self_boxes"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end


local ui_extrap_check, ui_extrap_ticks, ui_extrap_color
local ui_pred3d_check
local ui_pred3d_scale
if not (menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation) then
  
  ui_extrap_check = ui.new_checkbox('LUA', 'B', 'Self: Extrapolation Line')
  ui_extrap_ticks = ui.new_slider('LUA', 'B', 'Extrapolation ticks', 1, 64, 6)
  ui_extrap_color = ui.new_color_picker('LUA', 'B', 'Extrapolation color', 255, 200, 0, 220)
  ui_pred3d_check = ui.new_checkbox('LUA', 'B', 'Self: Predicted 3D Box')
  ui_pred3d_scale = ui.new_slider('LUA', 'B', 'Predicted 3D Box Scale %', 0, 200, 20)
end

local function is_self_extrapolation_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation)
    if ok then return val end
  elseif ui_extrap_check then
    local ok, val = pcall(ui.get, ui_extrap_check)
    if ok then return val end
  end
  return false
end

local function get_extrap_ticks()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_ticks then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_ticks)
    if ok then return val end
  elseif ui_extrap_ticks then
    local ok, val = pcall(ui.get, ui_extrap_ticks)
    if ok then return val end
  end
  return 6
end

local function get_extrap_color()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_color then
    local ok, r,g,b,a = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_color)
    if ok then return r,g,b,a end
  elseif ui_extrap_color then
    local ok, r,g,b,a = pcall(ui.get, ui_extrap_color)
    if ok then return r,g,b,a end
  end
  return 255,200,0,220
end

local function is_predicted_3d_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d)
    if ok then return val end
  elseif ui_pred3d_check then
    local ok, val = pcall(ui.get, ui_pred3d_check)
    if ok then return val end
  end
  return false
end

local function get_pred3d_scale()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_extrapolation_3d_scale then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_extrapolation_3d_scale)
    if ok then return val end
  elseif ui_pred3d_scale then
    local ok, val = pcall(ui.get, ui_pred3d_scale)
    if ok then return val end
  end
  return 20
end

client.set_event_callback('paint',function()
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  
  local _lp_state = client.globals and client.globals.__self_lc_state or nil
  if not _lp_state then
    _lp_state = {}
    client.globals = client.globals or {}
    client.globals.__self_lc_state = _lp_state
  end
  local function length_sqr(x,y,z)
    x = x or 0; y = y or 0; z = z or 0
    return x*x + y*y + z*z
  end
  local function time_to_ticks(seconds)
    local ti = globals.tickinterval and globals.tickinterval()
    if not ti or ti <= 0 then return 0 end
    return math.floor((seconds or 0) / ti + 0.5)
  end
  local function is_local_breaking_lagcomp()
    local sim_time = entity.get_prop(lp, 'm_flSimulationTime')
    local ox,oy,oz = entity.get_origin(lp)
    if not sim_time or not ox then return false end
    local sim_ticks = time_to_ticks(sim_time)
    local prev = _lp_state.prev
    local breaking = false
    if prev then
      local delta = sim_ticks - prev.tick
      if delta > 0 and delta <= 64 then
        local dx,dy,dz = prev.origin.x - ox, prev.origin.y - oy, prev.origin.z - oz
        local teleport_distance = length_sqr(dx,dy,dz)
        if teleport_distance > 4096 then breaking = true end
      end
    end
    _lp_state.prev = { tick = sim_ticks, origin = { x = ox, y = oy, z = oz } }
    return breaking
  end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end

  
  if is_self_extrapolation_enabled() then
    local ox,oy,oz = entity.get_origin(lp)
    if ox and oy and oz then
      local vx,vy,vz = entity.get_prop(lp, "m_vecVelocity")
      if vx and vy and vz then
        local ticks = get_extrap_ticks() or 6
        local tickint = (globals.tickinterval and globals.tickinterval()) or 0.015625
        local dt = tickint * ticks
        local px,py,pz = ox + vx * dt, oy + vy * dt, oz + vz * dt
        local sx1,sy1 = renderer.world_to_screen(ox,oy,oz)
        local sx2,sy2 = renderer.world_to_screen(px,py,pz)
        if sx1 and sx2 then
          local r,g,b,a = get_extrap_color()
          renderer.line(sx1,sy1,sx2,sy2, r, g, b, a)
          renderer.circle(sx2,sy2, r, g, b, a, 6, 0, 1.0)
          renderer.text(sx2, sy2 - 10, r, g, b, a, 'c+', 0, tostring(ticks) .. 't')
          
          local bx1,by1,bx2,by2,alpha_mult = entity.get_bounding_box(lp)
          if bx1 and alpha_mult and alpha_mult ~= 0 then
            local sx_orig, sy_orig = sx1, sy1
            if sx_orig and sy_orig then
              local dx, dy = sx2 - sx_orig, sy2 - sy_orig
              local bw, bh = (bx2 - bx1), (by2 - by1)
              local pbx, pby = bx1 + dx, by1 + dy
              
              renderer.rectangle(pbx, pby, bw, bh, 255,255,255,40)
              renderer.rectangle(pbx-1, pby-1, bw+2, bh+2, 255,255,255,200)
            end
          end

          
          if is_predicted_3d_enabled() and is_local_breaking_lagcomp() then
            
            local o = {x = ox, y = oy, z = oz}
            local offs = {}
            local keys = {'head','pelvis','l_shoulder','r_shoulder','l_hip','r_hip'}
            for i=1,#keys do
              local def = boxes[keys[i]]
              if def then
                local ok, hx, hy, hz = pcall(function() return find(lp, def) end)
                if ok and hx then
                  table.insert(offs, {x = hx - o.x, y = hy - o.y, z = hz - o.z})
                end
              end
            end
            if #offs > 0 then
              local minx,miny,minz = offs[1].x,offs[1].y,offs[1].z
              local maxx,maxy,maxz = offs[1].x,offs[1].y,offs[1].z
              for i=2,#offs do
                local v = offs[i]
                if v.x < minx then minx = v.x end
                if v.y < miny then miny = v.y end
                if v.z < minz then minz = v.z end
                if v.x > maxx then maxx = v.x end
                if v.y > maxy then maxy = v.y end
                if v.z > maxz then maxz = v.z end
              end
              
              local scale_pct = 105
              local cx = (minx + maxx) * 0.5
              local cy = (miny + maxy) * 0.5
              local cz = (minz + maxz) * 0.5
              local ex = (maxx - minx) * 0.5 * (1 + scale_pct / 100)
              local ey = (maxy - miny) * 0.5 * (1 + scale_pct / 100)
              local ez = (maxz - minz) * 0.5 * (1 + scale_pct / 100)
              minx = cx - ex; maxx = cx + ex
              miny = cy - ey; maxy = cy + ey
              minz = cz - ez; maxz = cz + ez

              
              local corners = {
                {x = px + minx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + miny, z = pz + minz},
                {x = px + maxx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + maxy, z = pz + minz},
                {x = px + minx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + miny, z = pz + maxz},
                {x = px + maxx, y = py + maxy, z = pz + maxz},
                {x = px + minx, y = py + maxy, z = pz + maxz},
              }
              
              local sc = {}
              local all_on_screen = true
              for i=1,8 do
                local sx, sy = renderer.world_to_screen(corners[i].x, corners[i].y, corners[i].z)
                if not sx then all_on_screen = false break end
                sc[i] = {x = sx, y = sy}
              end
              if all_on_screen then
                
                local rr,gg,bb,aa = 255,255,255,200
                
                renderer.line(sc[1].x,sc[1].y,sc[2].x,sc[2].y, rr,gg,bb,aa)
                renderer.line(sc[2].x,sc[2].y,sc[3].x,sc[3].y, rr,gg,bb,aa)
                renderer.line(sc[3].x,sc[3].y,sc[4].x,sc[4].y, rr,gg,bb,aa)
                renderer.line(sc[4].x,sc[4].y,sc[1].x,sc[1].y, rr,gg,bb,aa)
                
                renderer.line(sc[5].x,sc[5].y,sc[6].x,sc[6].y, rr,gg,bb,aa)
                renderer.line(sc[6].x,sc[6].y,sc[7].x,sc[7].y, rr,gg,bb,aa)
                renderer.line(sc[7].x,sc[7].y,sc[8].x,sc[8].y, rr,gg,bb,aa)
                renderer.line(sc[8].x,sc[8].y,sc[5].x,sc[5].y, rr,gg,bb,aa)
                
                for i=1,4 do renderer.line(sc[i].x,sc[i].y,sc[i+4].x,sc[i+4].y, rr,gg,bb,aa) end
              end
            end
          end
        end
      end
    end
  end
end)]=]
e981["require/features/paint/self_skeleton"] = [=[


local sk={list={}}
local chains={{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes={head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}
local function find(ent,def)
  if not ent or not def then return end
  local names=def.names
  if names then
    for i=1,#names do
      local x,y,z=entity.hitbox_position(ent,names[i])
      if x then return x,y,z end
    end
  end
  local idx=def.idx
  if idx then
    for i=1,#idx do
      local x,y,z=entity.hitbox_position(ent,idx[i])
      if x then return x,y,z end
    end
  end
end
local function snap(target)
  local pts={}
  for key,def in pairs(boxes) do
    local x,y,z=find(target,def)
    if x then pts[key]={x=x,y=y,z=z} end
  end
  local c=0
  for _ in pairs(pts) do c=c+1 if c>1 then break end end
  if c<2 then return end
  return pts
end



local menu_ok, menu_setup = pcall(require, "require/abc/menu_setup")
local function is_self_skeleton_enabled()
  if menu_ok and menu_setup and menu_setup.ui and menu_setup.ui.paint_self_skeleton then
    local ok, val = pcall(ui.get, menu_setup.ui.paint_self_skeleton)
    if ok then return val end
  end
  
  return true
end

local cb_ok, callbacks = pcall(require, "require/abc/callbacks")
local function paint_handler(ev)
  if not is_self_skeleton_enabled() then return end
  local lp = entity.get_local_player()
  if not lp then return end
  local pts = snap(lp)
  if not pts then return end
  local alpha = 220
  for c=1,#chains do
    local chain=chains[c]
    local from,to=pts[chain[1]],pts[chain[2]]
    if from and to then
      local fx,fy=renderer.world_to_screen(from.x,from.y,from.z)
      local tx,ty=renderer.world_to_screen(to.x,to.y,to.z)
      if fx and tx then renderer.line(fx,fy,tx,ty,255,255,255,alpha) end
    end
  end
end

if cb_ok and callbacks and callbacks.callback then
  callbacks.callback('paint', paint_handler, { alive_only = true, require_login = true })
end]=]
e981["require/features/paint/skeletons"] = [=[local chains = {{'head','neck'},{'neck','chest'},{'chest','stomach'},{'stomach','pelvis'},{'pelvis','l_hip'},{'l_hip','l_knee'},{'l_knee','l_foot'},{'pelvis','r_hip'},{'r_hip','r_knee'},{'r_knee','r_foot'},{'chest','l_shoulder'},{'l_shoulder','l_elbow'},{'l_elbow','l_hand'},{'chest','r_shoulder'},{'r_shoulder','r_elbow'},{'r_elbow','r_hand'}}
local boxes = {head={names={'head','Head','HEAD'},idx={0}},neck={names={'neck','Neck'},idx={1}},chest={names={'chest','Chest','upper chest','Upper Chest'},idx={4,5,6}},stomach={names={'stomach','Stomach','abdomen','Abdomen'},idx={2,3}},pelvis={names={'pelvis','Pelvis','hip','Hip'},idx={2}},l_shoulder={names={'left shoulder','Left Shoulder','left upper arm','Left Upper Arm','LeftArm'},idx={17}},l_elbow={names={'left elbow','Left Elbow','left forearm','Left Forearm'},idx={18}},l_hand={names={'left hand','Left Hand'},idx={14}},r_shoulder={names={'right shoulder','Right Shoulder','right upper arm','Right Upper Arm','RightArm'},idx={15}},r_elbow={names={'right elbow','Right Elbow','right forearm','Right Forearm'},idx={16}},r_hand={names={'right hand','Right Hand'},idx={13}},l_hip={names={'left hip','Left Hip','left thigh','Left Thigh','LeftLeg'},idx={8}},l_knee={names={'left knee','Left Knee','left calf','Left Calf'},idx={10}},l_foot={names={'left foot','Left Foot'},idx={12}},r_hip={names={'right hip','Right Hip','right thigh','Right Thigh','RightLeg'},idx={7}},r_knee={names={'right knee','Right Knee','right calf','Right Calf'},idx={9}},r_foot={names={'right foot','Right Foot'},idx={11}}}


local time = require("require/help/time")
local enemies = require("require/help/enemies")
local color = require("require/help/color")
local math_help = require("require/help/math")




local function find(ent, def)
    if not ent or not def then return end
    local names = def.names
    if names then
        for i = 1, #names do
            local x, y, z = entity.hitbox_position(ent, names[i])
            if x then return x, y, z end
        end
    end
    local idx = def.idx
    if idx then
        for i = 1, #idx do
            local x, y, z = entity.hitbox_position(ent, idx[i])
            if x then return x, y, z end
        end
    end
end


local function snap(target)
    local pts = {}
    for key, def in pairs(boxes) do
        local x, y, z = find(target, def)
        if x then pts[key] = {x = x, y = y, z = z} end
    end
    return pts
end


client.set_event_callback("paint", function()
    local enemy_list = entity.get_players(true)
    for i = 1, #enemy_list do
        local ent = enemy_list[i]
        if entity.is_alive(ent) and not entity.is_dormant(ent) then
            local pts = snap(ent)
            for _, chain in ipairs(chains) do
                local from = pts[chain[1]]
                local to = pts[chain[2]]
                if from and to then
                    local fx, fy = renderer.world_to_screen(from.x, from.y, from.z)
                    local tx, ty = renderer.world_to_screen(to.x, to.y, to.z)
                    if fx and fy and tx and ty then
                        renderer.line(fx, fy, tx, ty, 255, 0, 0, 255)
                    end
                end
            end
        end
    end
end)

]=]
e981["require/features/paint/target_info"] = [[local e590= require("require/abc/menu_setup")
local e591= renderer
local e592= client


local e593= nil
local function e594()
	if e593 then return e593 end
	if e591.load_rgba then
		local e595, e596= pcall(e591.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if e595 and e596 then e593 = e596 end
	end
	return e593
end




local e597= state or {
	fl_val = math.random(0, 14),
	fl_target = math.random(0, 14),
	by_val = math.random(-58, 58),
	by_target = math.random(-58, 58),
	last_update = e592.system_time()
}


local function e598()
	e597.fl_val = math.random(0, 14)
	e597.by_val = math.random(-58, 58)
end



local function e599()
	local e600= e592.system_time()
	if e600 - e597.last_update > 1 then
		e597.fl_target = math.random(0, 14)
		e597.by_target = math.random(-58, 58)
		e597.last_update = e600
	end
end

local function e601()
	e597.fl_val = e597.fl_val + (e597.fl_target - e597.fl_val) * 0.08
	e597.by_val = e597.by_val + (e597.by_target - e597.by_val) * 0.08
end

local function e602()
	if not ui.get(e590.ui.paint_target_info) then return end

	e599()
	e601()
	e598() 

	
	local e603, e604= e592.screen_size()
	local e605= 170
	local e606= 80
	local e607= 30
	local e608= math.floor(e604 / 2 - e606 / 2)

	
	e591.rectangle(e607 - 7, e608 - 5, e605 + 14, e606 + 10, 0, 0, 0, 200)
	e591.rectangle(e607 - 6, e608 - 4, e605 + 12, e606 + 8, 60, 60, 60, 255)
	e591.rectangle(e607 - 5, e608 - 3, e605 + 10, e606 + 6, 40, 40, 40, 255)
	e591.rectangle(e607 - 3, e608 - 1, e605 + 6, e606 + 2, 60, 60, 60, 255)
	e591.rectangle(e607 - 2, e608, e605 + 4, e606, 12, 12, 12, 255)
	e591.rectangle(e607 - 2, e608, e605 + 4, e606, 32, 32, 32, 255)

	
	local e609= e594()
	if e609 and e591.texture then
		e591.texture(e609, e607 - 2, e608, e605 + 4, e606, 255,255,255,60, 'r')
	end

	
	local e610= e608
	local e611= 1
	local e612= math.floor((e605 + 4) / 2)
	local e613= math.ceil((e605 + 4) / 2)
	
	e591.rectangle(e607 - 2, e610 - 1, e605 + 4, e611 + 2, 0, 0, 0, 255)
	if e591.gradient then
		e591.gradient(e607 - 2, e610, e612, e611, 59,175,222,255, 202,70,205,255, true)
		e591.gradient(e607 - 2 + e612, e610, e613, e611, 202,70,205,255, 204,227,53,255, true)
	end

	
	local e614= e607 + 12
	local e615= e608 + 13  
	local e616= 18
	local e617= e605 - 60 
	local e618= 7 

	
	local e619= math.floor(e597.fl_val + 0.5)
	
	local e620= e618 / 2 - 7
	e591.text(e614 - 8, e615 + e620, 255,255,255,255, '', 0, "Fake lag")
	local e621= e614 + 42 
	local e622= e615 + 6  
	local e623= 14
	local e624= math.floor(e617 * (e597.fl_val / e623))
	
	local e625= e617 + 2
	local e626= e618 + 2
	local e627= e621 + 1
	local e628= e622 + 1
	local e629= e617 - 2
	local e630= e618 - 2
	e591.rectangle(e621 - 1, e622 - 1, e625, e626, 0, 0, 0, 255)
	e591.rectangle(e621, e622, e617, e618, 60, 60, 60, 255)
	e591.rectangle(e627, e628, math.max(0, math.floor(e629 * (e597.fl_val / e623))), e630, 180, 220, 80, 255)
	local e631= e621 + e624 - 4
	local e632= e622 + e618 / 2
	e591.circle(e631, e632, 5, 180,220,80,255, 16)
	
	local e633= tostring(e619)
	local e634= e621 + e624 + 8 
	local e635= e622 + e618 + 0 
	e591.text(e634 + 1, e635 + 1, 0,0,0,255, '-', 0, e633)
	e591.text(e634, e635, 255,255,255,255, '-', 0, e633)

	
	local e636= math.floor(e597.by_val + 0.5)
	e591.text(e614 - 8, e615 + e616 + e620, 255,255,255,255, '', 0, "Body yaw")
	local e637= e614 + 42 
	local e638= e615 + e616 + 6  
	local e639= -58
	local e640= 58
	local e641= e640 - e639
	
	local e642= math.floor(e617 * ((e597.by_val - e639) / e641))
	
	local e643= e617 + 2
	local e644= e618 + 2
	local e645= e637 + 1
	local e646= e638 + 1
	local e647= e617 - 2
	local e648= e618 - 2
	e591.rectangle(e637 - 1, e638 - 1, e643, e644, 0, 0, 0, 255)
	e591.rectangle(e637, e638, e617, e618, 60, 60, 60, 255)
	
	local e649= e637 + e617 / 2
	local e650= e637 + e642
	if e597.by_val < 0 then
		e591.rectangle(e650 + 1, e646, e649 - e650, e648, 180, 220, 80, 255)
	else
		e591.rectangle(e649 + 1, e646, e650 - e649, e648, 180, 220, 80, 255)
	end
	local e651= e650 - 4
	local e652= e638 + e618 / 2
	e591.circle(e651, e652, 5, 180,220,80,255, 16)
	
	local e653= tostring(e636)
	local e654= e637 + e642
	local e655= e654 + 8 
	local e656= e638 + e618 + 0 
	e591.text(e655 + 1, e656 + 1, 0,0,0,255, '-', 0, e653)
	e591.text(e655, e656, 255,255,255,255, '-', 0, e653)

	
	local e657= 22
	local e658= 14

	
	local e659= math.random() > 0.5 and "[Offensive]" or "[Defensive]"
	local e660= e659 == "[Offensive]" and {204,227,53,255} or {202,70,205,255}
	e591.text(e614 - 8, e615 + e616 * 2 + e620, 255,255,255,255, '', 0, "Double tap")
	local e661= e614 + e617 + 32
	local e662= e615 + e616 * 2 - 2
	e591.text(e661 + 4, e662 + 2, table.unpack(e660), '', 0, e659)

	
	local e663= math.random() > 0.5 and "[On]" or "[Off]"
	local e664= e663 == "[On]" and {80,255,80,255} or {255,255,80,255}
	e591.text(e614 - 8, e615 + e616 * 3 + e620, 255,255,255,255, '', 0, "Freestanding")
	local e665= e614 + e617 + 32
	local e666= e615 + e616 * 3 - 2
	e591.text(e665 + 4, e666 + 2, table.unpack(e664), '', 0, e663)
end

local e667= require("require/abc/callbacks")
e667.callback('paint', e602, { alive_only = true, require_login = true })
]]
e981["require/features/paint/text_watermark"] = [[local e593= require("require/help/string")
local e594= require("require/help/time")
local e595= require("require/help/color")
local e596= e595.rgba_to_hex
local e597= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local e598= nil

local function e599(e600,e601,e602,e603,e604,e605,e606)
    local e607= e594.realtime() or globals.curtime()
    if not e606 or #e606 == 0 then return "" end
    local e608= {}

    if e600 == 0 then
        local e609= e596(e602,e603,e604,e605)
        for i=1,#e606 do e608[#e608+1] = e609 .. e606:sub(i,i) end
        return table.concat(e608)
    end

    if e600 == 2 then
        local e610= (math.sin(e607 * e601) + 1) * 0.5
        local e611= e595.clamp(math.floor(e605 * (0.45 + 0.55 * e610)))
        local e609= e596(e602,e603,e604,e611)
        for i=1,#e606 do e608[#e608+1] = e609 .. e606:sub(i,i) end
        return table.concat(e608)
    end

    if e600 == 3 then
        for i=1,#e606 do
            local e612= math.sin(e607 * e601 - i * 0.6)
            local e613= math.max(0, e612)
            local e610= e613 * e613
            local e611= e595.clamp(math.floor(e605 * (0.35 + 0.65 * e610)))
            e608[#e608+1] = e596(e602,e603,e604,e611) .. e606:sub(i,i)
        end
        return table.concat(e608)
    end

    for i=1,#e606 do
        local e610= (math.sin(e607*e601 - i*0.35) + 1) * 0.5
        local e611= e595.clamp(math.floor(e605 * (0.4 + 0.6 * e610)))
        e608[#e608+1] = e596(e602,e603,e604,e611) .. e606:sub(i,i)
    end
    return table.concat(e608)
end

local e614= {}
local e615= {}
for i, item in ipairs({
    { 'misc', 'settings', 'menu color' },
}) do
    local e616= {ui.reference(item[1], item[2], item[3])}
    e614[i] = e616
    for _, ref in ipairs(e616) do
        e615[ref] = true
    end
end

local e617, e618= pcall(require, "require/abc/callbacks")
local function e619(e620)
    local e621, e622= client.screen_size()
    if not e621 or not e622 then return end
    local e623, e624, e625, e626= 255, 255, 255, 255
    
    local e627= false
    local e628, e629= pcall(require, "require/abc/menu_setup")
    if e628 and e629 and e629.ui and e629.ui.paint_advertisement_color then
        local e630, e605, e604, e631, e632= pcall(ui.get, e629.ui.paint_advertisement_color)
        if e630 then
            e627 = true
            if type(e605) == 'number' then
                e623 = e595.clamp(e605 or e623)
                e624 = e595.clamp(e604 or e624)
                e625 = e595.clamp(e631 or e625)
                e626 = e595.clamp(e632 or e626)
            elseif type(e605) == 'string' and #e605 == 12 then
                local e633
                e633, mr = pcall(function() return tonumber(e605:sub(1,3)) end)
                e633, mg = pcall(function() return tonumber(e605:sub(4,6)) end)
                e633, mb = pcall(function() return tonumber(e605:sub(7,9)) end)
                e633, ma = pcall(function() return tonumber(e605:sub(10,12)) end)
                e623 = e595.clamp(e623 or 255); e624 = e595.clamp(e624 or 255); e625 = e595.clamp(e625 or 255); e626 = e595.clamp(e626 or 255)
            end
        end
    end

    if not e627 then
        local e630, e605, e604, e631, e632= pcall(ui.get, e614[1][1])
        if e630 then
            if type(e605) == 'number' then
                e623 = e595.clamp(e605 or e623)
                e624 = e595.clamp(e604 or e624)
                e625 = e595.clamp(e631 or e625)
                e626 = e595.clamp(e632 or e626)
            elseif type(e605) == 'string' and #e605 == 12 then
                local e633
                e633, mr = pcall(function() return tonumber(e605:sub(1,3)) end)
                e633, mg = pcall(function() return tonumber(e605:sub(4,6)) end)
                e633, mb = pcall(function() return tonumber(e605:sub(7,9)) end)
                e633, ma = pcall(function() return tonumber(e605:sub(10,12)) end)
                e623 = e595.clamp(e623 or 255); e624 = e595.clamp(e624 or 255); e625 = e595.clamp(e625 or 255); e626 = e595.clamp(e626 or 255)
            end
        end
    end

    local e628, e629= pcall(require, "require/abc/menu_setup")
    if not e628 or not e629 or not e629.ui then return end
    if not ui.get(e629.ui.paint_advertisement) then return end
    local e607= e594.realtime() or globals.curtime()
    local e634= 0
    local e635= math.floor(200 + 55 * (math.sin(e607*2)+1)/2)
    local e636, e637, e638= "sodium", "[BETA]", 3

    local e639, e640= renderer.measure_text("", e636)
    e639 = e639 or 0; e640 = e640 or 16
    local e641= (renderer.measure_text("", e637) or 0)

    if e597 and not e598 then
        local e642= math.floor(e621/2 - (e639 + e638 + e641)/2)
        local e643= math.floor(e622 - 15)
        e598 = e597.new('sodium_watermark', {
            x = e642,
            y = e643,
            w = e639 + e638 + e641,
            h = e640,
                default_pos = { x = e642, y = e643 },
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
        })
    end

    if e598 then
        e598:handle()
    end

    local e644, e645
    if e598 then
        e644 = e598.x
        e645 = e598.y + e634
    else
        e644 = math.floor(e621/2 - (e639 + e638 + e641)/2)
        e645 = e622 - 15 + e634
    end

    local e646= math.floor(math.max(0, e635 - 140) * 0.6)
    local e647= { {-1,0},{1,0},{0,-1},{0,1} }

    if e598 then e598:draw() end

    for _,o in ipairs(e647) do renderer.text(e644+o[1], e645+o[2], 0,0,0, e646, "", 0, e636) end
    renderer.text(e644, e645, 255,255,255, e635, "", 0, e636)

    local e648= 1
    local e649, e650= pcall(require, "require/abc/menu_setup")
    if e649 and e650 and e650.ui and e650.ui.paint_advertisement_animation then
        local e651, e652= pcall(ui.get, e650.ui.paint_advertisement_animation)
        if e651 and type(e652) == 'number' then e648 = e652 end
    end

    local e653= e644 + e639 + e638
    local e654= e599(e648, 3.5, e623, e624, e625, e626, e637)
    renderer.text(e653, e645, e623, e624, e625, e626, "", 0, e654)
end

if e617 and e618 and e618.callback then
    e618.callback('paint', e619, { alive_only = true, require_login = true })
end]]
e981["require/features/paint/third_person_distance"] = [[local e596= require("require/abc/menu_setup")
local e597= require("require/help/time")
local e598= require("require/help/math")
local e599= require("require/help/safe")
local e600= { original = nil, last = nil, last_update = nil }

local function e601()
    if cvar.cam_idealdist and cvar.cam_idealdist.get_float then
        return cvar.cam_idealdist:get_float()
    end
    return nil
end

local function e602(e603)
    if cvar.cam_idealdist and cvar.cam_idealdist.set_float then
        cvar.cam_idealdist:set_float(e603)
        return true
    elseif client and client.exec then
        client.exec("cam_idealdist " .. tostring(e603))
        return true
    end
    return false
end

local e604= require("require/abc/callbacks")
e604.callback('paint', function()
    local e605= e596.ui and e596.ui.paint_third_person_distance
    if not e605 then
        client.log('third_person_distance: menu ref missing')
        return
    end
    local e606= e599.safe_get(e605)
    if type(e606) ~= 'number' then
        client.log('third_person_distance: invalid slider value', tostring(e606))
        return
    end
    local e607= e598.clamp(e606, 29, 180)
    e607 = e598.round(e607, 2)
    if e600.original == nil then
        e600.original = e601()
        if e600.original == nil then
            client.log('third_person_distance: cam_idealdist cvar not available')
        end
    end
    if e600.last == nil then
        e600.last = e601() or e607
    end
    local e608= e597.realtime()
    local e609= e600.last_update or e608
    local e610= e608 - e609
    e600.last_update = e608
    local e611= 300
    local e612= e611 * e610
    if math.abs(e600.last - e607) > 0.01 then
        local e613= e598.clamp(e612 / math.max(math.abs(e607 - e600.last), 0.01), 0, 1)
        e600.last = e598.lerp(e600.last, e607, e613)
        e600.last = e598.round(e600.last, 2)
        e602(e600.last)
    end
end, { require_login = true })]]
e981["require/features/paint/warnings"] = [[local e599, e600= client.screen_size()
local e601, e602= pcall(require, "require/abc/menu_setup")


local function e603()
    
    if not e601 or not e602 or not e602.ui or not e602.ui.paint_warnings then return end
    local e604= ui.get(e602.ui.paint_warnings)
    local e605= false
    if type(e604) == "table" then
        for _, v in ipairs(e604) do
            if v == "lethal" then e605 = true break end
        end
    end
    if not e605 then return end

    if entity.get_prop(entity.get_local_player(), 'm_iHealth') and entity.get_prop(entity.get_local_player(), 'm_iHealth') > 0 and entity.get_prop(entity.get_local_player(), 'm_iHealth') < 93 then
        renderer.text(e599 / 2, e600 * 0.3, 255, 0, 0, 255, "c, -", 0, "YOU'RE LETHAL:   " .. entity.get_prop(entity.get_local_player(), 'm_iHealth') .. " HP REMAINING")
    end
    
end

local e606, e607= pcall(require, "require/abc/callbacks")
if e606 and e607 then
    e607.callback('paint', e603, { alive_only = true, require_login = true })
end]]
e981["require/features/paint/watermark_gamesense"] = [[local e602= renderer
local e603= client
local e604= globals
local e605= require('require/help/color')

local e606= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local e607= nil

local function e608()
	local e609= e604 and e604.frametime and e604.frametime() or 0.016
	if e609 > 0 then
		return math.floor(1 / e609 + 0.5)
	end
	return 0
end

local e610= nil
local function e611()
	if e610 then return e610 end
	if e602.load_rgba then
		local e612, e613= pcall(e602.load_rgba,
			string.char(
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255,
				16,16,16,255,20,20,20,255,16,16,16,255,20,20,20,255,
				20,20,20,255,26,26,26,255,20,20,20,255,26,26,26,255
			), 4, 4)
		if e612 and e613 then e610 = e613 end
	end
	return e610
end

local e614= e605.hex_to_rgba

local e615= {
	green  = "a5ca2aFF",
	red    = "d96464FF",
	yellow = "ccb854FF",
	blue   = "5462ccFF",
	purple = "7054ccFF",
	white  = "ffffffFF",
	grey   = "757575FF",
	black  = "000000FF",
	pink   = "c8a2deFF",
}


local e616= require("require/abc/login_system")
local e617= require("require/abc/menu_setup")
local e618= require("require/help/self")

local e619= require("require/help/time")
local e620= 0
local e621= e619.new(0.25)

local function e622()
	if not e617 or not e617.ui then return end
	
	local e623, e624= pcall(ui.get, e617.ui.paint_watermark)
	if not e623 or not e624 then return end
	
	local e625, e626= pcall(ui.get, e617.ui.paint_watermark_type)
	if not e625 or e626 ~= 0 then return end
	local e627, e628= e603 and e603.screen_size and e603.screen_size() or 800, 600

	local e629
	if e616.logged_in then
		local e630= database.read and database.read('cached_credentials')
		if e630 and e630.username then
			e629 = e630.username
		end
	else
		local e631= e616.load_credentials and e616.load_credentials()
		if e631 and e631.username then
			e629 = e631.username
		end
	end
	if not e629 or e629 == "" then
		e629 = e618.player_name and e618.player_name() or "unknown"
	end
	if e619.expired(e621) then
		e620 = e608()
		e619.reset(e621)
	end
	local e632= e620

	local e633= 0
	if e618 and e618.ping then
		local e634= e618.ping()
		if type(e634) == 'number' then e633 = e634 end
	elseif e603 and e603.latency then
		local e634= e603.latency()
		if type(e634) == 'number' then e633 = e634 end
	end
	local e635= math.floor((e633 or 0) * 1000 + 0.5)

	local e636= ''
	local e637= {
		{text = "game", style = e636, color = e615.white},
		{text = "sense", style = e636, color = e615.green},
		{text = " ", style = e636, color = e615.white},
		{text = "[beta]", style = e636, color = e615.white},
		{text = " | ", style = e636, color = e615.white},
		{text = e629, style = e636, color = e615.white},
		{text = " | ", style = e636, color = e615.white},
		{text = tostring(e635) .. " ms", style = e636, color = e615.white},
		{text = " | ", style = e636, color = e615.white},
		{text = tostring(e632) .. " fps", style = e636, color = e615.white},
	}

	local e638, e639= 0, 0
	for _, seg in ipairs(e637) do
		local e640, e641= e602.measure_text and e602.measure_text(seg.style, seg.text) or 0, 13
		e638 = e638 + e640
		if e641 > e639 then e639 = e641 end
	end
	local e642, e643= 5, 2
	local e644= e638 + e642 * 2
	local e645= e639 + e643 * 2
	local e646= e627 - e644 - 16
	local e647= 16

	if e606 and not e607 then
		local e648= e646
		local e649= e647
		e607 = e606.new('gamesense_watermark', {
			x = e648,
			y = e649,
			w = e644,
			h = e645,
			snap = true,
			snap_threshold = 24,
			require_menu_open = true,
			box_color = {255,255,255,100},
			default_pos = { x = e648, y = e649 },
		})
	end

	if e607 then e607:handle() end

	if e607 then
		e646 = e607.x
		e647 = e607.y
	end

	e602.rectangle(e646 - 7, e647 - 5, e644 + 14, e645 + 10, 0, 0, 0, 200)
	e602.rectangle(e646 - 6, e647 - 4, e644 + 12, e645 + 8, 60, 60, 60, 255)
	e602.rectangle(e646 - 5, e647 - 3, e644 + 10, e645 + 6, 40, 40, 40, 255)
	e602.rectangle(e646 - 3, e647 - 1, e644 + 6, e645 + 2, 60, 60, 60, 255)
	e602.rectangle(e646 - 2, e647, e644 + 4, e645, 12, 12, 12, 255)
	e602.rectangle(e646 - 2, e647, e644 + 4, e645, 32, 32, 32, 255)

	local e650= e611()
	if e650 and e602.texture then
		e602.texture(e650, e646 - 2, e647, e644 + 4, e645, 255,255,255,60, 'r')
	end

	if e602.gradient then
		e602.gradient(e646 - 2, e647, e644 / 2 + 1, 1, 59,175,222,255, 202,70,205,255, true)
		e602.gradient(e646 - 2 + e644 / 2, e647, e644 / 2 + 4.5, 1, 202,70,205,255, 204,227,53,255, true)
	end

	local e651= e646 + e642
	local e652= e647 + e643
    if e607 then e607:draw() end
	for _, seg in ipairs(e637) do
		local e640, e641= e602.measure_text and e602.measure_text(seg.style, seg.text) or 0, 13
			local e653,e654,e655,e656= e614(seg.color)
			e653,e654,e655,a = e605.normalize(e653,e654,e655,e656)
			e602.text(e651, e652, e653,e654,e655,e656, seg.style, nil, seg.text)
		e651 = e651 + e640
	end
end

local e657, e658= pcall(require, "require/abc/callbacks")
if e657 and e658 and e658.callback then
	e658.callback('paint', e622, { alive_only = true, require_login = true })
end
]]
e981["require/features/paint/watermark_solus"] = [[local e605= renderer
local e606= client
local e607= require('require/help/color')
local e608, e609= pcall(require, "require/abc/callbacks")
local e610, e611= pcall(require, "require/abc/menu_setup")
local e612, e613= pcall(ui.reference, 'misc', 'settings', 'menu color')
local e614= pcall(require, "require/help/drag") and require("require/help/drag") or nil
local e615= nil
local function e616(e617,e618,e619,e620,e621,e622,e623,e624,e625)
    e605.rectangle(e617+e621, e618, e619-(e621*2), e620, e622,e623,e624,e625)
    e605.rectangle(e617, e618+e621, e619, e620-(e621*2), e622,e623,e624,e625)
    e605.circle(e617+e621, e618+e621, e622,e623,e624,e625, e621, 0, 1)
    e605.circle(e617+e619-e621, e618+e621, e622,e623,e624,e625, e621, 0, 1)
    e605.circle(e617+e621, e618+e620-e621, e622,e623,e624,e625, e621, 0, 1)
    e605.circle(e617+e619-e621, e618+e620-e621, e622,e623,e624,e625, e621, 0, 1)
end

local e626= globals
local e627= 0
local e628= 0
local e629= 0.1

local function e630(e631)
    local e632, e633= pcall(require, e631)
    if e632 then return e633 end
    return nil
end

local function e634()
    if not e610 or not e611 or not e611.ui then return end
    local e635, e636= pcall(ui.get, e611.ui.paint_watermark)
    if not e635 or not e636 then return end
    local e637, e638= pcall(ui.get, e611.ui.paint_watermark_type)
    if not e637 or e638 ~= 1 then return end

    local e639, e640= e606.screen_size()
    if not e639 or not e640 then return end

    local e641= "unknown"
    local e642= e630('require/abc/login_system')
    local e643= (pcall(require, 'require/help/self') and require('require/help/self')) or nil
    if e642 then
        if e642.logged_in then
            local e644= database and database.read and database.read('cached_credentials')
            if e644 and e644.username then e641 = e644.username end
        else
            if e642.load_credentials then
                local e645= e642.load_credentials()
                if e645 and e645.username then e641 = e645.username end
            end
        end
    end
    if (not e641 or e641 == "") and e643 and e643.player_name then
        e641 = e643.player_name()
    end

    local e646= e627 or 0
    pcall(function()
        local e647= e626 and e626.realtime and e626.realtime() or os.clock()
        if (e647 - (e628 or 0)) >= e629 then
            local e648= e626 and e626.frametime and e626.frametime() or 0.016
            if e648 and e648 > 0 then
                e627 = math.floor(1 / e648 + 0.5)
            end
            e628 = e647
        end
        e646 = e627 or e646
    end)

    local e649= 0
    if e643 and e643.ping then
        local e650= e643.ping()
        if type(e650) == 'number' then e649 = math.floor(e650 * 1000 + 0.5) end
    elseif e606 and e606.latency then
        local e650= e606.latency()
        if type(e650) == 'number' then e649 = math.floor(e650 * 1000 + 0.5) end
    end

    local e651= {
        { text = "gamesense ", bold = true },
        { text = " | ", bold = false },
        { text = e641 or "unknown", bold = false },
        { text = " | ", bold = false },
        { text = tostring(e649) .. " ms", bold = false },
        { text = " | ", bold = false },
        { text = tostring(e646) .. " fps", bold = false },
    }

    local e652, e653= 0, 0
    for _, seg in ipairs(e651) do
        local e619, e620= 0, 13
        if e605.measure_text then
            local e632, e654, e655= pcall(e605.measure_text, '', seg.text)
            if e632 and e654 then e619, h = e654, e655 or e620 end
        end
        e652 = e652 + (e619 or 0)
        if e620 and e620 > e653 then e653 = e620 end
    end

    local e656, e657= 12, 6
    local e658= e652 + e656 * 2
    local e659= e653 + e657 * 2
    local e660= 18
    local e617= e639 - e658 - e660
    local e618= e660
    local e621= 8
    if e614 and not e615 then
        local e661= e617
        local e662= e618
        e615 = e614.new('solus_watermark', {
            x = e661,
            y = e662,
            w = e658,
            h = e659,
            snap = true,
            snap_threshold = 24,
            require_menu_open = true,
            box_color = {255,255,255,100},
            default_pos = { x = e661, y = e662 },
        })
    end

    if e615 then e615:handle() end

    if e615 then
        e617 = e615.x
        e618 = e615.y
    end
    local e663, e664, e665, e666= 255, 140, 0, 255
    do
        
        if e610 and e611 and e611.ui and e611.ui.paint_watermark_color then
            local e667, e668, e669, e670, e671= pcall(ui.get, e611.ui.paint_watermark_color)
            if e667 then
                if type(e668) == 'number' then
                    e663 = e607.clamp(e668 or e663)
                    e664 = e607.clamp(e669 or e664)
                    e665 = e607.clamp(e670 or e665)
                    e666 = e607.clamp(e671 or e666)
                elseif type(e668) == 'string' and #e668 == 12 then
                    local e632
                    e632, mr = pcall(function() return tonumber(e668:sub(1,3)) end)
                    e632, mg = pcall(function() return tonumber(e668:sub(4,6)) end)
                    e632, mb = pcall(function() return tonumber(e668:sub(7,9)) end)
                    e632, ma = pcall(function() return tonumber(e668:sub(10,12)) end)
                    e663 = e607.clamp(e663 or 255); e664 = e607.clamp(e664 or 140); e665 = e607.clamp(e665 or 0); e666 = e607.clamp(e666 or 255)
                end
                
            else
                
                if e612 and e613 then
                    local e672, e673, e674, e675, e676= pcall(ui.get, e613)
                    if e672 then
                        if type(e673) == 'number' then
                            e663 = e607.clamp(e673 or e663)
                            e664 = e607.clamp(e674 or e664)
                            e665 = e607.clamp(e675 or e665)
                            e666 = e607.clamp(e676 or e666)
                        elseif type(e673) == 'string' and #e673 == 12 then
                            local e632
                            e632, mr = pcall(function() return tonumber(e673:sub(1,3)) end)
                            e632, mg = pcall(function() return tonumber(e673:sub(4,6)) end)
                            e632, mb = pcall(function() return tonumber(e673:sub(7,9)) end)
                            e632, ma = pcall(function() return tonumber(e673:sub(10,12)) end)
                            e663 = e607.clamp(e663 or 255); e664 = e607.clamp(e664 or 140); e665 = e607.clamp(e665 or 0); e666 = e607.clamp(e666 or 255)
                        end
                    end
                end
            end
        else
            
            if e612 and e613 then
                local e667, e668, e669, e670, e671= pcall(ui.get, e613)
                if e667 then
                    if type(e668) == 'number' then
                        e663 = e607.clamp(e668 or e663)
                        e664 = e607.clamp(e669 or e664)
                        e665 = e607.clamp(e670 or e665)
                        e666 = e607.clamp(e671 or e666)
                    elseif type(e668) == 'string' and #e668 == 12 then
                        local e632
                        e632, mr = pcall(function() return tonumber(e668:sub(1,3)) end)
                        e632, mg = pcall(function() return tonumber(e668:sub(4,6)) end)
                        e632, mb = pcall(function() return tonumber(e668:sub(7,9)) end)
                        e632, ma = pcall(function() return tonumber(e668:sub(10,12)) end)
                        e663 = e607.clamp(e663 or 255); e664 = e607.clamp(e664 or 140); e665 = e607.clamp(e665 or 0); e666 = e607.clamp(e666 or 255)
                    end
                end
            end
        end
    end

    local function e677(e678,e679,e680,e622,e681,e682,e683)
        local e684= math.rad(e681)
        local e685= math.rad(e682)
        for i=0,e683 do
            local e686= i / e683
            local e625= e684 + (e685 - e684) * e686
            e678[#e678+1] = { e679 + math.cos(e625) * e622, e680 + math.sin(e625) * e622 }
        end
    end

    local function e687(e617,e618,e619,e620,e688,e689)
        local e690= {}
        e689 = e689 or 6
        local e691= e617
        local e692= e617 + e619
        local e693= e618
        local e694= e618 + e620
        local e695= e691 + e688
        local e696= e692 - e688
        local function e697(e698,e699)
            local e700= #e690
            if e700 == 0 then e690[#e690+1] = { e698, e699 }; return end
            local e701= e690[e700]
            if not (math.abs(e701[1] - e698) < 0.001 and math.abs(e701[2] - e699) < 0.001) then
                e690[#e690+1] = { e698, e699 }
            end
        end

        if e696 > e695 then
            for xx = e695, e696, e689 do e697(xx, e693) end
            
            e697(e696, e693)
        end

        e677(e690, e692 - e688, e693 + e688, e688, -90, 0, 6)

        local e702= e693 + e688
        local e703= e694 - e688
        if e703 > e702 then
            for yy = e702, e703, e689 do e697(e692, yy) end
            e697(e692, e703)
        end

        e677(e690, e692 - e688, e694 - e688, e688, 0, 90, 6)

        if e696 > e695 then
            for xx = e696, e695, -e689 do e697(xx, e694) end
            e697(e695, e694)
        end

        e677(e690, e691 + e688, e694 - e688, e688, 90, 180, 6)

        if e703 > e702 then
            for yy = e703, e702, -e689 do e697(e691, yy) end
            e697(e691, e702)
        end

        e677(e690, e691 + e688, e693 + e688, e688, 180, 270, 6)

        return e690
    end

    local e704= 3
    local e690= e687(e617-1, e618-1, e658+2, e659+2, e621+1, e704)
    local e700= #e690

    if e615 then e615:draw() end

    e616(e617-1, e618-1, e658+2, e659+2, e621+1, 0, 0, 0, 255)
    e616(e617, e618, e658, e659, e621, 0, 0, 0, 200)

    
    if e700 > 2 then
        local e686= (e626 and e626.realtime and e626.realtime() or 0)
        local e705= 7
        e705 = e705 * 4
        local e706= e705 / 60
        local e707= math.max(0.5, e706 * e700)
        local e708= math.floor((e686 * e707) % e700)

        local e709= math.max(6, math.floor(e700 * 0.25))

        local e710= e607.clamp(math.floor((e666 or 255) * 1.15))
        for j = e709 - 1, 0, -1 do
            local e711= ((e708 + j) % e700) + 1
            local e712= ((e708 + j + 1) % e700) + 1
            local e713= e690[e711]
            local e714= e690[e712]
            if e713 and e714 then
                local e715= 1 - (j / e709)
                local e625= e607.clamp(math.floor(e710 * e715))
                e605.line(e713[1], e713[2], e714[1], e714[2], e663, e664, e665, e625)
            end
        end
    end

    local e716= e617 + e656
    local e717= e618 + math.floor((e659 - e653) / 2)
    for i, seg in ipairs(e651) do
        local e619= 0
        if e605.measure_text then
            local e632, e654= pcall(e605.measure_text, '', seg.text)
            if e632 and e654 then e619 = e654 end
        end
        local e718= seg.bold and 'b' or ''
        e605.text(e716, e717, 255,255,255,255, e718, 0, seg.text)
        e716 = e716 + e619
    end
end

if e608 and e609 and e609.callback then
    e609.callback('paint', e634, { alive_only = true, require_login = true })
end

return true]]
e981["require/features/paint/world_hitmarker_plus"] = [[
local e608= require("require/abc/menu_setup")
local e609= {shots = {}, last = 0}
local e610, e611= pcall(require, "require/brain/api/vector/vector")

local function e612()
	local e613= ui.get(e608.ui.paint_hitmarker)
	if type(e613) == "table" then
		for _, v in ipairs(e613) do
			if v == "world +" then return true end
		end
	end
	return false
end

local e614, e615= pcall(require, "require/abc/callbacks")
local function e616(e617)
	if not e612() then e609.shots = {} return end
	if not e612() then return end
	local e618= globals.realtime()
	
	if e609.last and e618 - e609.last < 0.05 then return end
	e609.last = e618
	e609.shots[#e609.shots + 1] = {impacts = {}, finished = false, t = e618}
	if #e609.shots > 12 then table.remove(e609.shots, 1) end
end

local function e619(e617)
	if not e612() then e609 = {shots = {}, last = 0} return end
	local e620= entity.get_local_player()
	if not e620 then return end
	local e621= client.userid_to_entindex(e617.userid or 0)
	if e621 ~= e620 then return end
	local e618= globals.realtime()
	local e622
	for i = #e609.shots, 1, -1 do
		if not e609.shots[i].finished and e618 - (e609.shots[i].t or 0) < 1.2 then
			e622 = e609.shots[i]
			break
		end
	end
	if not e622 then return end
	local e623, e624, e625= e617.x, e617.y, e617.z
	local e626, e627, e628, e629= pcall(client.eye_position)
	local e630, e631, e632= 0, 0, 0
	if e626 and e627 and e628 and e629 then
		if e610 and e611 and e611.make and e611.normalized and e611.sub then
			local e633= e611.make(e623, e624, e625)
			local e634= e611.make(e627, e628, e629)
			local e635= e611.normalized(e611.sub(e633, e634))
			e630, e631, dirz = e635.x, e635.y, e635.z
		else
			e630 = e623 - e627; e631 = e624 - e628; e632 = e625 - e629
			local e636= math.sqrt(e630*e630 + e631*e631 + e632*e632)
			if e636 > 0 then e630, e631, dirz = e630/e636, e631/e636, e632/e636 end
		end
	end
	local e637= false
	local e638, e639, e640= pcall(client.trace_line, e620, e623 - (e630 or 0) * 1, e624 - (e631 or 0) * 1, e625 - (e632 or 0) * 1, e623 + (e630 or 0) * 1, e624 + (e631 or 0) * 1, e625 + (e632 or 0) * 1)
	if e638 and e640 and e640 > 0 and e640 ~= e620 then
		if entity.is_enemy(e640) then e637 = true end
	end
	local e641, e642, e643, e644
	local e645, e646, e647, e648, e649= pcall(ui.get, e608.ui.paint_hitmarker_color)
	if e645 and e646 then
		e641, e642, e643, ca = e646 or 0, e647 or 235, e648 or 235, e649 or 255
	else
		e641, e642, e643, ca = 0, 235, 235, 255
	end
	e622.impacts[#e622.impacts + 1] = {x = e623, y = e624, z = e625, t = e618, r = e641, g = e642, b = e643, a = e644, dir = {e630, e631, e632}, hit = e637}
	
	if #e622.impacts > 5 then table.remove(e622.impacts, 1) end
	if e637 then
		e622.finished = true
	end
end

local function e650(e617)
	if e612() then
		local e618= globals.realtime()
		local e651= 5.5 * 3 * 0.8
		local e652= 0.25 * 0.8
		local e653= e651 + e652
		local e654= 1
		while e654 <= #e609.shots do
			if e618 - (e609.shots[e654].t or 0) > e653 then
				table.remove(e609.shots, e654)
			else
				e654 = e654 + 1
			end
		end
		
		local e655= {}
		local e656= 12
		for si = #e609.shots, 1, -1 do
			local e622= e609.shots[si]
			for ii = #e622.impacts, 1, -1 do
				table.insert(e655, e622.impacts[ii]) 
				if #e655 >= e656 then break end
			end
			if #e655 >= e656 then break end
		end
		local e657= math.min(4, #e655)
		for j = 1, e657 do
			local e658= e655[j]
			local e659, e660, e661= e658.x, e658.y, e658.z
			if not e658.hit and e658.dir then
				local e627= e658.x + (e658.dir[1] or 0) * 24
				local e628= e658.y + (e658.dir[2] or 0) * 24
				local e629= e658.z + (e658.dir[3] or 0) * 24
				e659, e660, draw_z = e627, e628, e629
			end
			local e662, e663= renderer.world_to_screen(e659, e660, e661)
			if e662 and e663 then
				local e664= e618 - (e658.t or 0)
				local e665= e664 <= e651 and 255 or math.floor(math.max(0, (1 - math.max(0, e664 - e651) / e652) * 255))
				if e665 > 0 then
					local e636= 4
					local e666= e658.r or 200
					local e667= e658.g or 200
					local e668= e658.b or 200
					renderer.line(e662 - e636, e663, e662 + e636, e663, e666, e667, e668, e665)
					renderer.line(e662, e663 - e636, e662, e663 + e636, e666, e667, e668, e665)
				end
			end
		end
	else
		e609 = {shots = {}, last = 0}
	end
end

if e614 and e615 and e615.callback then
	e615.callback('aim_fire', e616, { alive_only = true, require_login = true })
	e615.callback('bullet_impact', e619, { alive_only = true, require_login = true })
	e615.callback('paint', e650, { alive_only = true, require_login = true })
end
]]
e981["require/help/bit"] = [[local e611= {}

local e612= 0xFFFFFFFF
local e613= 4294967296

local function e614(e615)
	e615 = tonumber(e615) or 0
	e615 = math.floor(e615) % e613
	if e615 < 0 then e615 = e615 + e613 end
	return e615
end

function e611.tobit(e615)
	local e616= e614(e615)
	if e616 >= 2147483648 then
		return e616 - e613
	end
	return e616
end

function e611.tohex(e615,e617)
	local e616= e614(e615)
	local e618= 8
	local e619= false
	if e617 then
		if e617 < 0 then
			e619 = true
			e618 = -e617
		else
			e618 = e617
		end
	end
	if e618 < 1 then e618 = 1 end
	if e618 > 8 then e618 = 8 end
	e616 = e616 % (2^(4 * e618))
	if e619 then
		return string.format(string.format("%%0%uX", e618), e616)
	else
		return string.format(string.format("%%0%ux", e618), e616)
	end
end

local function e620(e616,e621)
	return math.floor(e616 / 2^e621) % 2
end

function e611.band(e622,...)
	local e623= {e622, ...}
	if #e623 == 0 then return 0 end
	local e624= 0
	for e621 = 0, 31 do
		local e625= 1
		for j = 1, #e623 do
			if e620(e614(e623[j]), e621) == 0 then
				e625 = 0
				break
			end
		end
		if e625 == 1 then e624 = e624 + 2^e621 end
	end
	return e611.tobit(e624)
end

function e611.bor(e622,...)
	local e623= {e622, ...}
	if #e623 == 0 then return 0 end
	local e624= 0
	for e621 = 0, 31 do
		for j = 1, #e623 do
			if e620(e614(e623[j]), e621) == 1 then
				e624 = e624 + 2^e621
				break
			end
		end
	end
	return e611.tobit(e624)
end

function e611.bxor(e622,...)
	local e623= {e622, ...}
	if #e623 == 0 then return 0 end
	local e624= 0
	for e621 = 0, 31 do
		local e626= 0
		for j = 1, #e623 do
			if e620(e614(e623[j]), e621) == 1 then e626 = e626 + 1 end
		end
		if (e626 % 2) == 1 then e624 = e624 + 2^e621 end
	end
	return e611.tobit(e624)
end

function e611.bnot(e615)
	local e616= e614(e615)
	local e624= e612 - e616
	return e611.tobit(e624)
end

function e611.lshift(e615,e617)
	e617 = tonumber(e617) or 0
	e617 = e617 % 32
	local e616= e614(e615)
	local e624= (e616 * 2^e617) % e613
	return e611.tobit(e624)
end

function e611.rshift(e615,e617)
	e617 = tonumber(e617) or 0
	e617 = e617 % 32
	local e616= e614(e615)
	local e624= math.floor(e616 / 2^e617) % e613
	return e611.tobit(e624)
end

function e611.arshift(e615,e617)
	e617 = tonumber(e617) or 0
	e617 = e617 % 32
	local e627= e611.tobit(e615)
	local e624= math.floor(e627 / 2^e617)
	return e611.tobit(e624)
end

function e611.rol(e615,e617)
	e617 = tonumber(e617) or 0
	e617 = e617 % 32
	if e617 == 0 then return e611.tobit(e615) end
	local e616= e614(e615)
	local e628= (e616 * 2^e617) % e613
	local e629= math.floor(e616 / 2^(32 - e617))
	local e624= (e628 + e629) % e613
	return e611.tobit(e624)
end

function e611.ror(e615,e617)
	e617 = tonumber(e617) or 0
	e617 = e617 % 32
	if e617 == 0 then return e611.tobit(e615) end
	local e616= e614(e615)
	local e629= math.floor(e616 / 2^e617)
	local e628= (e616 * 2^(32 - e617)) % e613
	local e624= (e628 + e629) % e613
	return e611.tobit(e624)
end

function e611.bswap(e615)
	local e616= e614(e615)
	local e630= e616 % 256
	local e631= math.floor(e616 / 256) % 256
	local e632= math.floor(e616 / 65536) % 256
	local e633= math.floor(e616 / 16777216) % 256
	local e624= e630 * 16777216 + e631 * 65536 + e632 * 256 + e633
	return e611.tobit(e624)
end

return e611]]
e981["require/help/client"] = [[local e614= {}

function e614.camera_angles(e615,e616)
  if e615 == nil and e616 == nil then
    return client.camera_angles()
  end
  return client.camera_angles(e615, e616)
end

function e614.camera_position()
  return client.camera_position()
end

function e614.color_log(e617,e618,e619,...)
  return client.color_log(e617, e618, e619, ...)
end

function e614.create_interface(e620,e621)
  return client.create_interface(e620, e621)
end

function e614.current_threat()
  return client.current_threat()
end

function e614.delay_call(e622,e623,...)
  return client.delay_call(e622, e623, ...)
end

function e614.draw_debug_text(e624,e625,e626,e627,e628,e617,e618,e619,e629,...)
  return client.draw_debug_text(e624, e625, e626, e627, e628, e617, e618, e619, e629, ...)
end

function e614.draw_hitboxes(e630,e628,e631,e617,e618,e619,e629,e632)
  return client.draw_hitboxes(e630, e628, e631, e617, e618, e619, e629, e632)
end

function e614.error_log(e633)
  return client.error_log(e633)
end

function e614.exec(...)
  return client.exec(...)
end

function e614.eye_position()
  return client.eye_position()
end

function e614.find_signature(e620,e634)
  return client.find_signature(e620, e634)
end

function e614.fire_event(e635,...)
  return client.fire_event(e635, ...)
end

function e614.get_cvar(e636)
  return client.get_cvar(e636)
end

function e614.get_model_name(e637)
  return client.get_model_name(e637)
end

function e614.key_state(e638)
  return client.key_state(e638)
end

function e614.latency()
  return client.latency()
end

function e614.log(...)
  return client.log(...)
end

function e614.random_float(e639,e640)
  return client.random_float(e639, e640)
end

function e614.random_int(e639,e640)
  return client.random_int(e639, e640)
end

function e614.real_latency()
  return client.real_latency()
end

function e614.register_esp_flag(e641,e617,e618,e619,e623)
  return client.register_esp_flag(e641, e617, e618, e619, e623)
end

function e614.reload_active_scripts()
  return client.reload_active_scripts()
end

function e614.request_full_update()
  return client.request_full_update()
end

function e614.scale_damage(e630,e642,e643)
  return client.scale_damage(e630, e642, e643)
end

function e614.screen_size()
  return client.screen_size()
end

function e614.set_clan_tag(...)
  return client.set_clan_tag(...)
end

function e614.set_event_callback(e635,e623)
  return client.set_event_callback(e635, e623)
end

function e614.system_time()
  return client.system_time()
end

function e614.timestamp()
  return client.timestamp()
end

function e614.trace_bullet(e644,e645,e646,e647,e648,e649,e650,e651)
  return client.trace_bullet(e644, e645, e646, e647, e648, e649, e650, e651)
end

function e614.trace_line(e652,e645,e646,e647,e648,e649,e650)
  return client.trace_line(e652, e645, e646, e647, e648, e649, e650)
end

function e614.unix_time()
  return client.unix_time()
end

function e614.unset_event_callback(e635,e623)
  return client.unset_event_callback(e635, e623)
end

function e614.update_player_list()
  return client.update_player_list()
end

function e614.userid_to_entindex(e653)
  return client.userid_to_entindex(e653)
end

function e614.visible(e624,e625,e626)
  return client.visible(e624, e625, e626)
end

return e614]]
e981["require/help/color"] = [[local function e617(e618)
    e618 = tostring(e618 or "")
    local e619= e618:match("([0-9A-Fa-f]+)$")
    if not e619 or #e619 ~= 8 then
        return 255,255,255,255
    end
    local e620= tonumber(e619:sub(1,2), 16)
    local e621= tonumber(e619:sub(3,4), 16)
    local e622= tonumber(e619:sub(5,6), 16)
    local e623= tonumber(e619:sub(7,8), 16)
    return e620,e621,e622,e623
end

local function e624(e620,e621,e622,e623)
    return string.format("\a%02x%02x%02x%02x", tonumber(e620) or 0, tonumber(e621) or 0, tonumber(e622) or 0, tonumber(e623) or 255)
end

local function e625(e626)
    local e627= tonumber(e626) or 0
    if e627 < 0 then return 0 end
    if e627 > 255 then return 255 end
    return math.floor(e627 + 0.5)
end

local function e628(e620,e621,e622,e623,e629)
    e629 = tonumber(e629) or 32
    return e625((e620 or 0) + e629), e625((e621 or 0) + e629), e625((e622 or 0) + e629), e625(e623 or 255)
end

local function e630(e620,e621,e622,e623,e629)
    e629 = tonumber(e629) or 32
    return e625((e620 or 0) - e629), e625((e621 or 0) - e629), e625((e622 or 0) - e629), e625(e623 or 255)
end

local e631= {
    default = "d6d6d6FF", 
    green  = "a5ca2aFF", 
    red    = "d96464FF", 
    reddark = "b22222FF", 
    orange = "dca53aFF", 
    yellow = "ccb854FF", 
    blue   = "5462ccFF", 
    cyan   = "54ccccFF", 
    purple = "7054ccFF", 
    white  = "ffffffFF", 
    grey   = "757575FF", 
    black  = "000000FF", 
    pink   = "c8a2deFF", 
    discord = "7289daFF", 
    youtube = "FF0000FF", 
    sellhub = "FFC107FF", 

}


local e632= {}
for name, e618 in pairs(e631) do
    local e620,e621,e622,e623= e617(e618)
    e632[name] = {
        base = e618,
        lighter = e624(e628(e620,e621,e622,e623,32)),
        darker  = e624(e630(e620,e621,e622,e623,32)),
        light2  = e624(e628(e620,e621,e622,e623,64)),
        dark2   = e624(e630(e620,e621,e622,e623,64)),
        rgb = {e620,e621,e622,e623},
        log = {e620,e621,e622},
        ui = e618,
    }
end

function e632.get(e633,e634)
    e634 = e634 or "base"
    local e635= e632[e633]
    if not e635 then return nil end
    if e634 == "log" and e635.log then
        return unpack(e635.log)
    elseif e634 == "ui" and e635.ui then
        return "\a"..entry.ui
    elseif e635[e634] then
        return e635[e634]
    end
    return nil
end

function e632.blend(e636,e637,e638)
    local e639,e640,e641,e642= unpack(e632[e636].rgb)
    local e643,e644,e645,e646= unpack(e632[e637].rgb)
    e638 = e638 or 0.5
    local e620= e625(e639 + (e643-e639)*e638)
    local e621= e625(e640 + (e644-e640)*e638)
    local e622= e625(e641 + (e645-e641)*e638)
    local e623= e625(e642 + (e646-e642)*e638)
    return e624(e620,e621,e622,e623)
end

function e632.hex_to_rgba(e618)
    return e617(e618)
end

function e632.rgba_to_hex(e620,e621,e622,e623)
    return e624(e620,e621,e622,e623)
end

function e632.clamp(e620,e621,e622,e623)
    return e625(e620), e625(e621), e625(e622), e625(e623)
end

function e632.normalize(e620,e621,e622,e623)
    return e625(e620), e625(e621), e625(e622), e625(e623 or 255)
end

function e632.modulate(e620,e621,e622,e623,e647,e648,e649,e650)
    e647 = tonumber(e647) or 1
    e648 = tonumber(e648) or e647
    e649 = tonumber(e649) or e647
    e650 = tonumber(e650) or 1
    local e651= e625((tonumber(e620) or 0) * e647)
    local e652= e625((tonumber(e621) or 0) * e648)
    local e653= e625((tonumber(e622) or 0) * e649)
    local e654= e625((tonumber(e623) or 255) * e650)
    return e651, e652, e653, e654
end

function e632.alpha_modulate(e623,e655)
    e655 = tonumber(e655) or 1
    return e625((tonumber(e623) or 255) * e655)
end

return e632]]
e981["require/help/drag"] = [[local e620= {}
local e621= {}
local e622= false

local e623= {
	['top-left'] = function(e624,e625,e626,e627) return 0, 0 end,
	['top-center'] = function(e624,e625,e626,e627) return math.floor(e624/2 - e626/2), 0 end,
	['top-right'] = function(e624,e625,e626,e627) return math.floor(e624 - e626), 0 end,
	['center-left'] = function(e624,e625,e626,e627) return 0, math.floor(e625/2 - e627/2) end,
	['center'] = function(e624,e625,e626,e627) return math.floor(e624/2 - e626/2), math.floor(e625/2 - e627/2) end,
	['center-right'] = function(e624,e625,e626,e627) return math.floor(e624 - e626), math.floor(e625/2 - e627/2) end,
	['bottom-left'] = function(e624,e625,e626,e627) return 0, math.floor(e625 - e627) end,
	['bottom-center'] = function(e624,e625,e626,e627) return math.floor(e624/2 - e626/2), math.floor(e625 - e627) end,
	['bottom-right'] = function(e624,e625,e626,e627) return math.floor(e624 - e626), math.floor(e625 - e627) end,
}

local function e628(e629,e630,e626,e627,e631,e632)
	if not e631 or not e632 then return false end
	return e631 >= e629 and e631 <= e629 + e626 and e632 >= e630 and e632 <= e630 + e627
end

local function e633(e634,e635,e636)
	if not e634 then return e635 end
	if e634 < e635 then return e635 end
	if e634 > e636 then return e636 end
	return e634
end

function e620.new(e637,e638)
	if not e637 then error('drag.new requires id') end
	e638 = e638 or {}
	local e639= {}
	e639.id = e637
	e639.x = e638.x or 0
	e639.y = e638.y or 0
	e639.w = e638.w or 100
	e639.h = e638.h or 20
	e639.snap = e638.snap == nil and true or e638.snap
	e639.snap_threshold = e638.snap_threshold or 24
	e639.snap_positions = e638.snap_positions or nil
	e639.require_menu_open = e638.require_menu_open == nil and true or e638.require_menu_open
	e639.locked = e638.lock or false
	e639.box_color = e638.box_color or {255,255,255,100}
	e639.show_alignment = e638.show_alignment == nil and true or e638.show_alignment
	e639.align_color = e638.align_color or {255,255,255,100}
	e639.align_cross_size = e638.align_cross_size or 6
	e639.show_screen_guides = e638.show_screen_guides == nil and true or e638.show_screen_guides
	e639.line_snap_threshold = e638.line_snap_threshold or 6
	e639.bounds = e638.bounds or nil
	e639.constraint_center = e638.constraint_center or nil
	e639.constraint_box = e638.constraint_box or nil
	e639.default_pos = e638.default_pos or nil
	e639.default_center = e638.default_center or nil

	local e640= {
		obj = e639,
		dragging = false,
		drag_offset_x = 0,
		drag_offset_y = 0,
		last_left = false,
		last_right = false,
		locked_to = nil,
		snap_progress = 0,
		snap_target = 0,
		line_snap_progress_x = 0,
		line_snap_progress_y = 0,
		line_snap_target_x = 0,
		line_snap_target_y = 0,
		drag_button = nil,
		disable_snap = false,
	}
	e621[e637] = e640

	local e641, e642= pcall(database.read, 'drag_positions')
	if e641 and type(e642) == 'table' and e642[e637] then
		local e643= e642[e637]
		if type(e643.x) == 'number' and type(e643.y) == 'number' then
			e639.x = e643.x
			e639.y = e643.y
		end
	end

	if not e622 then
		client.set_event_callback('setup_command', function(e644)
			for _, st in pairs(e621) do
				if st.dragging then
					pcall(function()
						e644.in_attack = false
						e644.in_attack2 = false
					end)
					break
				end
			end
		end)
		e622 = true
	end

	function e639:set_pos(e629,e630)
		self.x = e629
		self.y = e630
	end
	function e639:set_size(e626,e627)
		self.w = e626; self.h = e627
	end
	function e639:set_bounds(e629,e630,e626,e627)
		self.bounds = { x = e629, y = e630, w = e626, h = e627 }
	end
	function e639:clear_bounds()
		self.bounds = nil
	end
	function e639:get_pos()
		return self.x, self.y
	end
	function e639:is_dragging()
		return not not e640.dragging
	end
	function e639:get_bounds()
		return self.bounds
	end
	function e639:set_locked(e645)
		self.locked = not not e645
	end
	function e639:set_snap(e645)
		self.snap = not not e645
	end
	function e639:toggle_snap()
		self.snap = not self.snap
	end
	function e639:reset_to_anchor(e646)
		local e624, e625= client.screen_size()
		if not e624 or not e625 then return end
		local e647= e623[e646]
		if type(e647) == 'function' then
			local e648, e649= e647(e624,e625,self.w,self.h)
			self.x = e648; self.y = e649
			e640.locked_to = e646
		end
	end

	function e639:handle()
		if self.locked then return end
		local e624, e625= client.screen_size()
		if not e624 or not e625 then return end
		if self.require_menu_open and not ui.is_menu_open() then e640.last_left = false; return end

		local e631, e632= ui.mouse_position()
		local e650= client.key_state(1)
		local e651= client.key_state(2)

		if e650 and e651 and (e628(self.x, self.y, self.w, self.h, e631, e632) or e640.dragging) then
			if self.default_pos then
				self.x = self.default_pos.x
				self.y = self.default_pos.y
				return
			elseif self.default_center then
				self.x = (self.default_center.x or 0) - math.floor(self.w/2)
				self.y = (self.default_center.y or 0) - math.floor(self.h/2)
				return
			end
		end
		if e650 and not e640.last_left and e628(self.x, self.y, self.w, self.h, e631, e632) then
			e640.dragging = true
			e640.drag_button = 1
			e640.disable_snap = false
			e640.drag_offset_x = e631 - self.x
			e640.drag_offset_y = e632 - self.y
			e640.locked_to = nil
		elseif e651 and not e640.last_right and e628(self.x, self.y, self.w, self.h, e631, e632) then
			e640.dragging = true
			e640.drag_button = 2
			e640.disable_snap = true
			e640.drag_offset_x = e631 - self.x
			e640.drag_offset_y = e632 - self.y
			e640.locked_to = nil
			e640.snap_target = 0
			e640.line_snap_target_x = 0
			e640.line_snap_target_y = 0
		end

		if (e650 and e640.dragging and e640.drag_button == 1) or (e651 and e640.dragging and e640.drag_button == 2) then
			local e648= e631 - e640.drag_offset_x
			local e649= e632 - e640.drag_offset_y
			local e652, e653= 0, math.max(0, e624 - self.w)
			local e654, e655= 0, math.max(0, e625 - self.h)
			if self.constraint_center then
				local e656= self.constraint_center
				local e657= e656.cx or math.floor(e624/2)
				local e658= e656.cy or math.floor(e625/2)
				local e659= e656.radius or 0
				e652 = (e657 - e659) - math.floor(self.w/2)
				e653 = (e657 + e659) - math.floor(self.w/2)
				e654 = (e658 - e659) - math.floor(self.h/2)
				e655 = (e658 + e659) - math.floor(self.h/2)
			elseif self.bounds or self.constraint_box then
				local e660= self.bounds or self.constraint_box
				local e661= e660.x or e660[1] or 0
				local e662= e660.y or e660[2] or 0
				local e663= e660.w or e660[3] or (e624 - e661)
				local e664= e660.h or e660[4] or (e625 - e662)
				e652 = e661
				e653 = math.max(e661, e661 + e663 - self.w)
				e654 = e662
				e655 = math.max(e662, e662 + e664 - self.h)
			end
			e648 = e633(e648, e652, e653)
			e649 = e633(e649, e654, e655)
			self.x = e648; self.y = e649
			if self.snap and not e640.disable_snap then
				local e665= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and e623[p] then
							local e647= e623[p]
							local e666, e667= e647(e624,e625,self.w,self.h)
							table.insert(e665, {x=e666,y=e667})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(e665, {x=p[1], y=p[2]})
						end
					end
				else
					for k,e647 in pairs(e623) do
						local e666, e667= e647(e624,e625,self.w,self.h)
						table.insert(e665, {x=e666,y=e667})
					end
				end
				local e668= math.huge
				for _,e656 in ipairs(e665) do
					local e669= (e656.x - self.x)
					local e670= (e656.y - self.y)
					local e671= math.sqrt(e669*e669 + e670*e670)
					if e671 < e668 then e668 = e671 end
				end
				if e668 <= self.snap_threshold then e640.snap_target = 1 else e640.snap_target = 0 end
				local e672= math.floor(e624/2)
				local e673= math.floor(e625/2)
				local e657= math.floor(self.x + self.w/2)
				local e658= math.floor(self.y + self.h/2)
				if math.abs(e657 - e672) <= (self.line_snap_threshold or 6) then e640.line_snap_target_x = 1 else e640.line_snap_target_x = 0 end
				if math.abs(e658 - e673) <= (self.line_snap_threshold or 6) then e640.line_snap_target_y = 1 else e640.line_snap_target_y = 0 end
			end
		end

		local e674= false
		if e640.dragging then
			if e640.drag_button == 1 and not e650 and e640.last_left then e674 = true end
			if e640.drag_button == 2 and not e651 and e640.last_right then e674 = true end
		end
		if e674 then
			if not e640.disable_snap then
				local e672, e673= math.floor(e624/2), math.floor(e625/2)
				local e657= math.floor(self.x + self.w/2)
				local e658= math.floor(self.y + self.h/2)
				if self.show_screen_guides then
					if math.abs(e657 - e672) <= (self.line_snap_threshold or 6) then
						self.x = e672 - math.floor(self.w/2)
					end
					if math.abs(e658 - e673) <= (self.line_snap_threshold or 6) then
						self.y = e673 - math.floor(self.h/2)
					end
				end
			end
			e640.dragging = false
			local e675, e676= pcall(database.read, 'drag_positions')
			local e677= (e675 and type(e676) == 'table') and e676 or {}
			e677[self.id] = { x = self.x, y = self.y }
			pcall(function() database.write('drag_positions', e677) end)
			if self.snap and not e640.disable_snap then
				local e665= {}
				if self.snap_positions and #self.snap_positions > 0 then
					for _,p in ipairs(self.snap_positions) do
						if type(p) == 'string' and e623[p] then
							local e647= e623[p]
							local e666, e667= e647(e624,e625,self.w,self.h)
							table.insert(e665, {x=e666,y=e667, key=p})
						elseif type(p) == 'table' and #p >= 2 then
							table.insert(e665, {x=p[1], y=p[2], key=nil})
						end
					end
				else
					for k,e647 in pairs(e623) do
						local e666, e667= e647(e624,e625,self.w,self.h)
						table.insert(e665, {x=e666,y=e667, key=k})
					end
				end
				local e678, e668= nil, math.huge
				for _,e656 in ipairs(e665) do
					local e669= (e656.x - self.x)
					local e670= (e656.y - self.y)
					local e671= math.sqrt(e669*e669 + e670*e670)
					if e671 < e668 then e668 = e671; e678 = e656 end
				end
				if e678 and e668 <= self.snap_threshold then
					self.x = e678.x; self.y = e678.y
					e640.locked_to = e678.key
				end
			end
		end

		e640.last_left = e650
		e640.last_right = e651
	end

	function e639:draw()
		local e640= e621[self.id]
		if not e640 then return end
		if e640.dragging then
			local e659,e679,e660,e680= unpack(self.box_color)
			local e681,e682,e683,e684= unpack(self.align_color)
			local e685= globals.frametime() or 0.016
			local e686= math.min(1, 12 * e685)
			e640.snap_progress = e640.snap_progress + (e640.snap_target - e640.snap_progress) * e686
			e640.line_snap_progress_x = e640.line_snap_progress_x + (e640.line_snap_target_x - e640.line_snap_progress_x) * e686
			e640.line_snap_progress_y = e640.line_snap_progress_y + (e640.line_snap_target_y - e640.line_snap_progress_y) * e686
			local e687= math.floor(e659 + (0 - e659) * e640.snap_progress)
			local e688= math.floor(e679 + (0 - e679) * e640.snap_progress)
			local e689= math.floor(e660 + (0 - e660) * e640.snap_progress)
			local e690= math.floor(e680 + (200 - e680) * e640.snap_progress)
			renderer.rectangle(self.x, self.y, self.w, self.h, e687, e688, e689, e690)
			renderer.line(self.x, self.y, self.x + self.w, self.y, 200,200,200,150)
			renderer.line(self.x + self.w, self.y, self.x + self.w, self.y + self.h, 200,200,200,150)
			renderer.line(self.x + self.w, self.y + self.h, self.x, self.y + self.h, 200,200,200,150)
			renderer.line(self.x, self.y + self.h, self.x, self.y, 200,200,200,150)
			if self.show_alignment then
				local e624, e625= client.screen_size()
				if e624 and e625 then
					if self.show_screen_guides then
						local e672= math.floor(e624/2)
						local e673= math.floor(e625/2)
						local e657= math.floor(self.x + self.w/2)
						local e658= math.floor(self.y + self.h/2)
						local e691= math.abs(e657 - e672) <= (self.line_snap_threshold or 6)
						local e692= math.abs(e658 - e673) <= (self.line_snap_threshold or 6)
						local e693= math.floor(e684 * 0.35)
						renderer.line(e672, e673, 0, e673, e681,e682,e683, e693)
						renderer.line(e672, e673, e672, 0, e681,e682,e683, e693)
						renderer.line(e672, e673, e624, e673, e681,e682,e683, e693)
						renderer.line(e672, e673, e672, e625, e681,e682,e683, e693)
						local e694= math.floor(e684 * e640.line_snap_progress_x)
						local e695= math.floor(e684 * e640.line_snap_progress_y)
						if e694 > 0 then renderer.line(e672, 0, e672, e625, e681,e682,e683, e694) end
						if e695 > 0 then renderer.line(0, e673, e624, e673, e681,e682,e683, e695) end
					end
				end
			end
			if self.constraint_center then
				local e656= self.constraint_center
				local e657= e656.cx or math.floor((client.screen_size()) / 2)
				local e658= e656.cy or math.floor((client.screen_size()) / 2)
				local e659= e656.radius or 0
				local e661= e657 - e659
				local e662= e658 - e659
				local e663= e659 * 2
				local e664= e659 * 2
				renderer.rectangle(e661, e662, e663, e664, 255, 255, 255, 60)
				renderer.line(e661, e662, e661 + e663, e662, 255, 255, 255, 160)
				renderer.line(e661 + e663, e662, e661 + e663, e662 + e664, 255, 255, 255, 160)
				renderer.line(e661 + e663, e662 + e664, e661, e662 + e664, 255, 255, 255, 160)
				renderer.line(e661, e662 + e664, e661, e662, 255, 255, 255, 160)
			end
		end
	end

	return e639
end

function e620.get(e637)
	local e640= e621[e637]
	if not e640 then return nil end
	return e640.obj
end

function e620.ids()
	local e696= {}
	for k,_ in pairs(e621) do table.insert(e696, k) end
	return e696
end

return e620]]
e981["require/help/emojis"] = [[local e623= {

    chat = { "" },
    rewind = { "" },
    thumbsup = { "" },
    mail = { "U+E135" },
    square = { "" },
    square2 = { "" },
    square_hollow = { "" },
    play = { "" },
    pause = { "" },
    sun = { "" },
    pc = { "" },
    pc2 = { "" },
    phone = { "U+E1C9" },
    trash = { "" },
    reject = { "" },
    accept = { "" },
    config = { "" },
    config_write = { "U+E28F" },
    gear = { "" },
    arrow_right = { "" },
    arrow_left = { "" },
    arrow_up = { "" },
    arrow_down = { "" },
    star = { "U+E0B4" },
    minus = { "" },
    plus = { "" },
    plus_in_brackets = { "U+E0C5" },
    pen = { "" },
    recycle = { "" },
    camera = { "" },
    download = { "" },
    upload = { "" },
    question = { "" },
    search = { "" },
    globe = { "" },
    globe2 = { "" },
    id = { "" },
    phone = { "" },
    user = { "" },
    user2 = { "U+E2AF" },
    user3 = { "U+E13D" },
    users = { "" },
    users2 = { "U+E125" },
    user_no = { "U+E1E0" },
    pin = { "" },
    unpin = { "U+E196" },
    windows = { "" },
    turning = { "" },
    turning2 = { "" },
    arrow_double = { "" },
    clip = { "" },
    clipboard = { "U+E16D" },
    exclamation = { "" },
    time = { "" },
    clock = { "U+E2AD" },
    paper = { "" },
    paper2 = { "" },
    link = { "" },
    link2 = { "U+E167" },
    wrench = { "" },
    url = { "" },
    speaker = { "" },
    house = { "" },
    pallete = { "" },
    lock = { "" },
    lock_open = { "" },
    tsarrow_left = { "" },
    tsarrow_right = { "" },
    tsarrow_up = { "" },
    tsarrow_up = { "" },
    warning = { "⚠︎" },
    video = { "" },
    connection = { "" },
    heart = { "" },
    triangle_upside = { "⛛" },
    music_note = { "U+E142" },
    test = { "U+E2B1" },
    keyboard = { "U+E0D2" },
    latency0 = { "U+E1E5" },
    latency1 = { "U+E1E6" },
    latency2 = { "U+E1E7" },
    latency3 = { "U+E1E8" },
    latency4 = { "U+E1E9" },
    expand = { "U+E1D9" },
    monitor = { "U+E2F0" },
    rain = { "U+E28A" },
    likedislike = { "U+E19D" },
    text = { "U+E1C8" },
    back = { "U+E10E" },
    folder = { "U+E1C1" },
    menu = { "U+E179" },
    menu2 = { "U+E1A0" },
    at = { "U+E168" },
    circle = { "U+E235" },
    updown = { "U+E174" },

}

local e624= {}

local function e625(e626)
    if e626 == nil then return "ERROR" end
    if type(e626) ~= "string" then e626 = tostring(e626) end
    if e626 == "ERROR" then return "ERROR" end
    local e627= e626:match('^U%+([0-9A-Fa-f]+)$') or e626:match('^u%+([0-9A-Fa-f]+)$') or e626:match('^0x([0-9A-Fa-f]+)$')
    if e627 then
        local e628= tonumber(e627, 16)
        if e628 then
            local e629= nil
            if type(utf8) == 'table' and type(utf8.char) == 'function' then
                pcall(function() e629 = utf8.char(e628) end)
            end
            if not e629 then
                local function e630(e631)
                    if e631 < 0x80 then return string.char(e631) end
                    if e631 < 0x800 then return string.char(0xC0 + math.floor(e631 / 0x40), 0x80 + (e631 % 0x40)) end
                    if e631 < 0x10000 then return string.char(0xE0 + math.floor(e631 / 0x1000), 0x80 + (math.floor(e631 / 0x40) % 0x40), 0x80 + (e631 % 0x40)) end
                    if e631 < 0x110000 then return string.char(0xF0 + math.floor(e631 / 0x40000), 0x80 + (math.floor(e631 / 0x1000) % 0x40), 0x80 + (math.floor(e631 / 0x40) % 0x40), 0x80 + (e631 % 0x40)) end
                    return '?'
                end
                e629 = e630(e628)
            end
            e626 = e629 or e626
        end
    end
    if e626:sub(-1) == " " then return e626 end
    return e626 .. " "
end

function e624.get(e632,e633,e634)
    if not e632 then return "ERROR" end
    local e635= e623[e632]
    if e635 == nil then return "ERROR" end
    if type(e635) == "string" then return e625(e635) end
    if type(e635) == "table" then
        if e634 == nil then
            return e625(e635[1])
        end
        local e636= tonumber(e634) or 1
        return e625(e635[e636])
    end
    return "ERROR"
end

function e624.set(e632,e637)
	if not e632 then return false end
	if type(e637) == "string" then
		e623[e632] = { e637 }
	else
		e623[e632] = e637
	end
	return true
end

function e624.list()
	local e638= {}
	for k, e635 in pairs(e623) do
		if type(e635) == "table" then
			local e639= {}
			for e636 = 1, #e635 do e639[e636] = e635[e636] end
			e638[k] = e639
		else
			e638[k] = e635
		end
	end
	return e638
end

setmetatable(e624, {
    __index = function(e640,e641)
        local e635= e623[e641]
        if e635 == nil then return "ERROR" end
        if type(e635) == "table" then return e625(e635[1]) end
        return e625(e635)
    end,
})

return e624]]
e981["require/help/enemies"] = [[local e626= {}

local e627= entity
local e628= client
local e629= globals

function e626.list()
    return e627 and e627.get_players and e627.get_players(true) or {}
end

function e626.is_alive(e630)
    return e630 and e627.is_alive and e627.is_alive(e630) or false
end

function e626.is_dormant(e630)
    return e630 and e627.is_dormant and e627.is_dormant(e630) or false
end

function e626.player_name(e630)
    return e630 and e627.get_player_name and e627.get_player_name(e630) or nil
end

function e626.steam64(e630)
    return e630 and e627.get_steam64 and e627.get_steam64(e630) or nil
end

function e626.health(e630)
    return e630 and e627.get_prop and e627.get_prop(e630, 'm_iHealth') or 0
end

function e626.current_threat()
    return e628 and e628.current_threat and e628.current_threat() or nil
end

local e631= {}

function e626.is_afk(e630,e632,e633)
    e632 = e632 or 5
    e633 = e633 or 20
    local e634, e635, e636= e627.get_prop(e630, 'm_vecVelocity')
    local e637= 0
    if e634 and e635 and e636 then
        e637 = math.sqrt(e634 * e634 + e635 * e635 + e636 * e636)
    end
    local e638= e629 and e629.realtime and e629.realtime() or os.clock()
    if not e631[e630] then
        e631[e630] = { last_active = e638, last_check = e638 }
    end
    if e637 >= e632 then
        e631[e630].last_active = e638
    end
    e631[e630].last_check = e638
    return (e638 - e631[e630].last_active) > e633
end

function e626.distance(e630,e639)
    if not e630 or not e627.get_origin then return nil end
    local e640, e641, e642= e627.get_origin(e630)
    if not e640 then return nil end
    if not e639 then
        e639 = e627.get_local_player and e627.get_local_player()
    end
    local e643, e644, e645= e627.get_origin(e639)
    if not e643 then return nil end
    local e646, e647, e648= e640 - e643, e641 - e644, e642 - e645
    return math.sqrt(e646 * e646 + e647 * e647 + e648 * e648)
end


local function e649(e650)
    if not e650 then return "" end
    return tostring(e650):lower()
end

local function e651(e652)
    local e653= ""
    if e652 and e627.get_classname then e653 = e627.get_classname(e652) or "" end
    if e653 == "" and e652 and e628.get_model_name then
        e653 = e628.get_model_name(e652) or ""
    end
    return e649(e653)
end

function e626.has_knife(e630)
    if not e630 or not e627.get_player_weapon then return false end
    local e652= e627.get_player_weapon(e630)
    if not e652 then return false end
    local e654= e651(e652)
    return e654:find('knife') ~= nil
end

function e626.has_nade(e630)
    if not e630 or not e627.get_player_weapon then return false end
    local e652= e627.get_player_weapon(e630)
    if not e652 then return false end
    local e654= e651(e652)
    local e655= {'grenade', 'hegrenade', 'flashbang', 'smoke', 'molotov', 'incendiary', 'decoy', 'frag', 'nade'}
    for i = 1, #e655 do
        if e654:find(e655[i]) then return true end
    end
    return false
end

function e626.has_taser(e630)
    if not e630 or not e627.get_player_weapon then return false end
    local e652= e627.get_player_weapon(e630)
    if not e652 then return false end
    local e654= e651(e652)
    return e654:find('taser') ~= nil or e654:find('zeus') ~= nil
end

return e626]]
e981["require/help/ffi"] = [[local e629= rawget(_G, 'ffi')
local e630= {}

function e630.available()
  return e629 ~= nil
end

function e630.cdef(e631)
  if not e629 then error('ffi not available') end
  return e629.cdef(e631)
end

function e630.typeof(e632)
  if not e629 then error('ffi not available') end
  return e629.typeof(e632)
end

function e630.new(e632,...)
  if not e629 then error('ffi not available') end
  return e629.new(e632, ...)
end

function e630.cast(e632,e633)
  if not e629 then error('ffi not available') end
  return e629.cast(e632, e633)
end

function e630.string(e634,e635)
  if not e629 then error('ffi not available') end
  return e629.string(e634, e635)
end

function e630.copy(e636,e637,e635)
  if not e629 then error('ffi not available') end
  return e629.copy(e636, e637, e635)
end

function e630.fill(e636,e638,e635)
  if not e629 then error('ffi not available') end
  return e629.fill(e636, e638, e635)
end

function e630.sizeof(e632)
  if not e629 then error('ffi not available') end
  return e629.sizeof(e632)
end

function e630.alignof(e632)
  if not e629 then error('ffi not available') end
  return e629.alignof(e632)
end

function e630.errno()
  if not e629 then error('ffi not available') end
  return e629.errno()
end

function e630.gc(e634,e639)
  if not e629 then error('ffi not available') end
  return e629.gc(e634, e639)
end

function e630.load(e640,e641)
  if not e629 then error('ffi not available') end
  return e629.load(e640, e641)
end

function e630.metatype(e632,e642)
  if not e629 then error('ffi not available') end
  return e629.metatype(e632, e642)
end

function e630.offsetof(e632,e643)
  if not e629 then error('ffi not available') end
  return e629.offsetof(e632, e643)
end

function e630.istype(e632,e633)
  if not e629 then error('ffi not available') end
  return e629.istype(e632, e633)
end

e630.raw = e629

return e630]]
e981["require/help/globals"] = [[local e632= {}

e632.raw = globals

function e632.absoluteframetime()
  return globals.absoluteframetime()
end

function e632.chokedcommands()
  return globals.chokedcommands()
end

function e632.commandack()
  return globals.commandack()
end

function e632.curtime()
  return globals.curtime()
end

function e632.framecount()
  return globals.framecount()
end

function e632.frametime()
  return globals.frametime()
end

function e632.lastoutgoingcommand()
  return globals.lastoutgoingcommand()
end

function e632.mapname()
  return globals.mapname()
end

function e632.maxplayers()
  return globals.maxplayers()
end

function e632.oldcommandack()
  return globals.oldcommandack()
end

function e632.realtime()
  return globals.realtime()
end

function e632.servertickcount()
  return globals.servertickcount()
end

function e632.tickcount()
  return globals.tickcount()
end

function e632.tickinterval()
  return globals.tickinterval()
end

return e632]]
e981["require/help/json"] = [[local e635= rawget(_G, 'json')
local e636= {}

function e636.available()
  return e635 ~= nil
end

function e636.decode_invalid_numbers(e637)
  if not e635 then error('json not available') end
  if e637 == nil then
    return e635.decode_invalid_numbers()
  end
  return e635.decode_invalid_numbers(e637)
end

function e636.decode_max_depth(e638)
  if not e635 then error('json not available') end
  if e638 == nil then
    return e635.decode_max_depth()
  end
  return e635.decode_max_depth(e638)
end

function e636.encode_invalid_numbers(e637)
  if not e635 then error('json not available') end
  if e637 == nil then
    return e635.encode_invalid_numbers()
  end
  return e635.encode_invalid_numbers(e637)
end

function e636.encode_max_depth(e638)
  if not e635 then error('json not available') end
  if e638 == nil then
    return e635.encode_max_depth()
  end
  return e635.encode_max_depth(e638)
end

function e636.encode_number_precision(e639)
  if not e635 then error('json not available') end
  if e639 == nil then
    return e635.encode_number_precision()
  end
  return e635.encode_number_precision(e639)
end

function e636.encode_sparse_array(...)
  if not e635 then error('json not available') end
  return e635.encode_sparse_array(...)
end

function e636.parse(e640)
  if not e635 then error('json not available') end
  if e635.parse then
    return e635.parse(e640)
  end
  if e635.decode then
    return e635.decode(e640)
  end
  error('json.parse / json.decode not available')
end

function e636.stringify(e641)
  if not e635 then error('json not available') end
  if e635.stringify then
    return e635.stringify(e641)
  end
  if e635.encode then
    return e635.encode(e641)
  end
  error('json.stringify / json.encode not available')
end

e636.raw = e635

return e636]]
e981["require/help/libs"] = [[local function e638(e639)
	local e640, e641= pcall(require, e639)
	return e640 and e641 or nil
end

local e642= {
	antiaim_funcs   = 'gamesense/antiaim_funcs',
	base64          = 'gamesense/base64',
	clipboard       = 'gamesense/clipboard',
	http            = 'gamesense/http',
	csgo_weapons    = 'gamesense/csgo_weapons',
	icons           = 'gamesense/icons',
	entity          = 'gamesense/entity',
	vector          = 'vector',
	bit             = 'bit',
	ffi             = 'ffi',
	pui             = 'gamesense/pui',
	trace           = 'gamesense/trace',
	md5             = 'gamesense/md5',
	websocket       = 'gamesense/websocket',
	surface         = 'gamesense/surface',
	color           = 'gamesense/color',
}

local e643= {}
for k, v in pairs(e642) do
	e643[k] = e638(v)
end

local e644= {
	antiaim_funcs = {
		get_tickbase_shifting = "Returns true if tickbase shifting is active.",
		get_fake_lag = "Returns current fake lag value.",
		get_desync = "Returns current desync value.",
		get_manual_direction = "Returns manual anti-aim direction.",
		get_antiaim_condition = "Returns current anti-aim condition.",
		get_body_yaw = "Returns current body yaw value.",
		get_yaw_base = "Returns current yaw base value.",
		get_pitch = "Returns current pitch value.",
		get_yaw_jitter = "Returns current yaw jitter value.",
		get_enabled = "Returns if anti-aim is enabled.",
		get_fakelag_mode = "Returns fakelag mode.",
		get_fakelag_limit = "Returns fakelag limit.",
		get_fakelag_variance = "Returns fakelag variance.",
		get_fakelag_enabled = "Returns if fakelag is enabled.",
		get_double_tap = "Returns true if double tap exploit is active.",
		get_overlap = "Returns overlap value (exploit related).",
	},
	base64 = {
		encode = "Encodes a string to base64.",
		decode = "Decodes a base64 string.",
	},
	clipboard = {
		get = "Gets clipboard contents as string.",
		set = "Sets clipboard contents to string.",
	},
	http = {
		get = "Performs HTTP GET request.",
		post = "Performs HTTP POST request.",
		download = "Downloads a file from URL.",
	},
	csgo_weapons = {
		get_weapon_name = "Returns weapon name by id.",
		get_weapon_id = "Returns weapon id by name.",
		get_weapon_type = "Returns weapon type by id.",
		get_weapon_group = "Returns weapon group by id.",
		get_weapon_slot = "Returns weapon slot by id.",
		get_weapon_price = "Returns weapon price by id.",
	},
	icons = {
		hero = "Table of hero icons.",
		get_texture = "Returns texture id for icon name.",
		get_icon = "Returns icon object by name.",
		get_all_icons = "Returns all available icons.",
	},
	entity = {
		get_local_player = "Returns entindex of local player.",
		get_all = "Returns array of entindices for all entities.",
		get_players = "Returns array of player entindices.",
		get_game_rules = "Returns entindex of game rules proxy.",
		get_player_resource = "Returns entindex of player resource.",
		get_classname = "Returns classname of entity.",
		set_prop = "Sets netvar property.",
		get_prop = "Gets netvar property.",
		is_enemy = "Returns true if entity is enemy.",
		is_alive = "Returns true if entity is alive.",
		is_dormant = "Returns true if entity is dormant.",
		get_player_name = "Returns player name.",
		get_player_weapon = "Returns active weapon entindex.",
		hitbox_position = "Returns world position of hitbox.",
		get_steam64 = "Returns SteamID3.",
		get_bounding_box = "Returns bounding box coordinates.",
		get_origin = "Returns world origin of entity.",
		get_esp_data = "Returns ESP data for player.",
	},
	vector = {
		new = "Creates a new vector object.",
		dot = "Returns dot product of two vectors.",
		cross = "Returns cross product of two vectors.",
		length = "Returns length of vector.",
		normalize = "Normalizes vector.",
		add = "Adds two vectors.",
		sub = "Subtracts two vectors.",
		mul = "Multiplies vector by scalar.",
		div = "Divides vector by scalar.",
		dist = "Returns distance between two vectors.",
	},
	bit = {
		arshift = "Arithmetic right shift.",
		band = "Bitwise AND.",
		bnot = "Bitwise NOT.",
		bor = "Bitwise OR.",
		bswap = "Byte swap (endian conversion).",
		bxor = "Bitwise XOR.",
		lshift = "Logical left shift.",
		rol = "Bitwise left rotation.",
		ror = "Bitwise right rotation.",
		rshift = "Logical right shift.",
		tobit = "Normalize to 32-bit signed.",
		tohex = "Convert to hexadecimal string.",
	},
	ffi = {
		cdef = "Define C types/functions.",
		cast = "Cast value to C type.",
		new = "Allocate new C object.",
		typeof = "Get C type object.",
		string = "Convert C data to Lua string.",
	},
	pui = {
		create_panel = "Creates a custom UI panel.",
		add_icon = "Adds an icon to a panel.",
		set_icon = "Sets the icon for a panel.",
		set_panel_visible = "Shows/hides a panel.",
		set_panel_position = "Sets panel position.",
		set_panel_size = "Sets panel size.",
	},
	trace = {
		trace_line = "Performs a line trace.",
		trace_bullet = "Performs a bullet trace.",
		trace_hull = "Performs a hull trace.",
	},
	md5 = {
		sumhexa = "Returns MD5 hash as hex string.",
		sum = "Returns MD5 hash as raw bytes.",
	},
	websocket = {
		connect = "Connects to a WebSocket server.",
		send = "Sends data over WebSocket.",
		close = "Closes the WebSocket connection.",
		on_message = "Callback for incoming messages.",
	},
	surface = {
		text = "Draws text on screen.",
		rectangle = "Draws a rectangle.",
		line = "Draws a line.",
		circle = "Draws a circle.",
		gradient = "Draws a gradient rectangle.",
		load_texture = "Loads a texture from file.",
	},
	color = {
		blend = "Blends two colors.",
		lighten = "Lightens a color.",
		darken = "Darkens a color.",
		hex_to_rgba = "Converts hex to RGBA.",
		rgba_to_hex = "Converts RGBA to hex.",
	},
}

local function e645(e639)
	return e643[e639]
end

function e646()
	local e647= {}
	for k, v in pairs(_G) do
		if type(v) == "table" or type(v) == "userdata" then
			e647[#e647+1] = k
		end
	end
	return e647
end

function e648(e649)
	local e650= e644[e649]
	if not e650 then return {} end
	local e647= {}
	for k, v in pairs(e650) do
		e647[#e647+1] = k .. " - " .. v
	end
	return e647
end

return {
	get = e645,
	list = e646,
	list_features = e648,
	features = e644,
	libs = e643,
	lib_defs = e642
}
]]
e981["require/help/math"] = [[local e641= {}

function e641.clamp(e642,e643,e644)
    if not e643 and not e644 then return e642 end
    e643 = tonumber(e643) or 0
    e644 = tonumber(e644) or e643
    if e643 > e644 then e643, max = e644, e643 end
    e642 = tonumber(e642) or e643
    if e642 < e643 then return e643 end
    if e642 > e644 then return e644 end
    return e642
end

function e641.clamp01(e642)
    return e641.clamp(e642, 0, 1)
end

function e641.abs(e642)
    e642 = tonumber(e642) or 0
    return math.abs(e642)
end

function e641.max(...)
    local e645= {...}
    if #e645 == 0 then return 0 end
    local e646= nil
    for i = 1, #e645 do
        local e647= tonumber(e645[i]) or 0
        if e646 == nil or e647 > e646 then e646 = e647 end
    end
    return e646
end

function e641.min(...)
    local e645= {...}
    if #e645 == 0 then return 0 end
    local e646= nil
    for i = 1, #e645 do
        local e647= tonumber(e645[i]) or 0
        if e646 == nil or e647 < e646 then e646 = e647 end
    end
    return e646
end

function e641.atan2(e648,e649)
    e648 = tonumber(e648) or 0
    e649 = tonumber(e649) or 0
    return math.atan(e648, e649)
end

function e641.floor(e642)
    e642 = tonumber(e642) or 0
    return math.floor(e642)
end

function e641.round(e642,e650)
    e642 = tonumber(e642) or 0
    e650 = tonumber(e650) or 0
    local e651= 10 ^ e650
    return math.floor(e642 * e651 + 0.5) / e651
end

function e641.lerp(e652,e653,e654)
    e652 = tonumber(e652) or 0
    e653 = tonumber(e653) or 0
    e654 = tonumber(e654) or 0
    return e652 + (e653 - e652) * e654
end

function e641.distance2d(e655,e656,e657,e658)
    e655 = tonumber(e655) or 0
    e656 = tonumber(e656) or 0
    e657 = tonumber(e657) or 0
    e658 = tonumber(e658) or 0
    return math.sqrt((e657 - e655)^2 + (e658 - e656)^2)
end

function e641.distance3d(e655,e656,e659,e657,e658,e660)
    e655 = tonumber(e655) or 0
    e656 = tonumber(e656) or 0
    e659 = tonumber(e659) or 0
    e657 = tonumber(e657) or 0
    e658 = tonumber(e658) or 0
    e660 = tonumber(e660) or 0
    return math.sqrt((e657 - e655)^2 + (e658 - e656)^2 + (e660 - e659)^2)
end

function e641.sign(e642)
    e642 = tonumber(e642) or 0
    return (e642 > 0 and 1) or (e642 < 0 and -1) or 0
end

function e641.frac(e642)
    e642 = tonumber(e642) or 0
    return e642 - math.floor(e642)
end

function e641.is_even(e642)
    e642 = tonumber(e642) or 0
    return e642 % 2 == 0
end

function e641.is_odd(e642)
    e642 = tonumber(e642) or 0
    return e642 % 2 ~= 0
end

function e641.sqr(e642)
    e642 = tonumber(e642) or 0
    return e642 * e642
end

function e641.cube(e642)
    e642 = tonumber(e642) or 0
    return e642 * e642 * e642
end

function e641.approximately(e652,e653,e661)
    e652 = tonumber(e652) or 0
    e653 = tonumber(e653) or 0
    e661 = tonumber(e661) or 1e-6
    return math.abs(e652 - e653) < e661
end

function e641.rad_to_deg(e662)
    e662 = tonumber(e662) or 0
    return e662 * (180 / math.pi)
end

function e641.deg_to_rad(e663)
    e663 = tonumber(e663) or 0
    return e663 * (math.pi / 180)
end

function e641.wrap_degrees(e664)
    local e652= tonumber(e664) or 0
    e652 = e652 % 360
    if e652 < 0 then e652 = e652 + 360 end
    return e652
end

function e641.normalize_angle(e664)
    local e652= tonumber(e664) or 0
    e652 = e652 % 360
    if e652 > 180 then e652 = e652 - 360 end
    return e652
end

function e641.angle_diff(e652,e653)
    e652 = tonumber(e652) or 0
    e653 = tonumber(e653) or 0
    local e665= (e652 - e653) % 360
    if e665 > 180 then e665 = e665 - 360 end
    return e665
end

function e641.lerp_angle(e652,e653,e654)
    e652 = tonumber(e652) or 0
    e653 = tonumber(e653) or 0
    e654 = tonumber(e654) or 0
    local e665= e641.angle_diff(e653, e652)
    return (e652 + e665 * e654) % 360
end

function e641.map(e642,e666,e667,e668,e669)
    e642 = tonumber(e642) or 0
    e666 = tonumber(e666) or 0
    e667 = tonumber(e667) or e666
    e668 = tonumber(e668) or 0
    e669 = tonumber(e669) or e668
    if e667 == e666 then return e668 end
    return (e642 - e666) * (e669 - e668) / (e667 - e666) + e668
end

function e641.smoothstep(e670,e671,e649)
    e670 = tonumber(e670) or 0
    e671 = tonumber(e671) or e670
    e649 = tonumber(e649) or 0
    if e671 == e670 then return 0 end
    local e654= e641.clamp((e649 - e670) / (e671 - e670), 0, 1)
    return e654 * e654 * (3 - 2 * e654)
end

function e641.random_float(e643,e644)
    e643 = tonumber(e643) or 0
    e644 = tonumber(e644) or e643
    if e643 > e644 then e643, max = e644, e643 end
    return e643 + math.random() * (e644 - e643)
end

function e641.random_int(e643,e644)
    e643 = tonumber(e643) or 0
    e644 = tonumber(e644) or e643
    if e643 > e644 then e643, max = e644, e643 end
    return math.random(e643, e644)
end

function e641.mean(e672)
    if type(e672) ~= 'table' or #e672 == 0 then return 0 end
    local e673= 0
    for i = 1, #e672 do e673 = e673 + (tonumber(e672[i]) or 0) end
    return e673 / #e672
end

function e641.swap(e652,e653)
    return e653, e652
end

return e641]]
e981["require/help/panorama"] = [[local e644= {}

e644.raw = panorama

function e644.loadstring(e645,e646)
  return panorama.loadstring(e645, e646)
end

function e644.open(e646)
  return panorama.open(e646)
end

return e644]]
e981["require/help/plist"] = [[local e647= {}

e647.raw = plist

function e647.get(e648,e649)
  return plist.get(e648, e649)
end

function e647.set(e648,e649,e650)
  return plist.set(e648, e649, e650)
end

return e647]]
e981["require/help/reference"] = [[local e650= {}

e650.known_items = {
    { 'AA', 'Anti-aimbot angles', 'Enabled' },
    { 'AA', 'Anti-aimbot angles', 'Pitch' },
    { 'AA', 'Anti-aimbot angles', 'Yaw base' },
    { 'AA', 'Anti-aimbot angles', 'Yaw' },
    { 'AA', 'Anti-aimbot angles', 'Yaw jitter' },
    { 'AA', 'Anti-aimbot angles', 'Body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding body yaw' },
    { 'AA', 'Anti-aimbot angles', 'Edge yaw' },
    { 'AA', 'Anti-aimbot angles', 'Freestanding' },
    { 'AA', 'Anti-aimbot angles', 'Roll' },
    { 'AA', 'Fake lag', 'Enabled' },
    { 'AA', 'Fake lag', 'Amount' },
    { 'AA', 'Fake lag', 'Variance' },
    { 'AA', 'Fake lag', 'Limit' },
    { 'AA', 'Other', 'Slow motion' },
    { 'AA', 'Other', 'Leg movement' },
    { 'AA', 'Other', 'On shot anti-aim' },
    { 'AA', 'Other', 'Fake peek' },
}

function e650.add_known(e651)
    for _, it in ipairs(e651 or {}) do
        table.insert(e650.known_items, it)
    end
end

function e650.get(e652,e653,e654)
    return ui.reference(e652, e653, e654)
end

function e650.build(e655)
    local e656= {}
    local e657= {}
    for i, item in ipairs(e655) do
        local e658= {ui.reference(item[1], item[2], item[3])}
        e656[i] = e658
        for _, ref in ipairs(e658) do
            if ref ~= nil then
                e657[ref] = true
            end
        end
    end
    return e656, e657
end

function e650.build_known()
    return e650.build(e650.known_items)
end

function e650.get_all_known()
    return e650.known_items
end

return e650]]
e981["require/help/references_old"] = [[

local e653= {}

local function e654(e655)
    
    if type(e655) ~= 'table' then
        local e656= e655
        return {
            raw = e656,
            get = function()
                local e657, e658= pcall(ui.get, e656)
                if e657 then return e658 end
                return nil
            end
        }
    end

    
    
    
    local e659= e655
    return {
        raw = e659,
        get = function()
            if e659[2] ~= nil then
                local e657, e658= pcall(ui.get, e659[2])
                if e657 then return e658 end
            end
            if e659[1] ~= nil then
                local e657, e658= pcall(ui.get, e659[1])
                if e657 then return e658 end
            end
            return nil
        end
    }
end


e653.minimum_damage = e654(ui.reference("RAGE", "Aimbot", "Minimum damage"))
e653.minimum_damage_override = e654({ ui.reference("RAGE", "Aimbot", "Minimum damage override") })
e653.doubletap = e654({ ui.reference("RAGE", "Aimbot", "Double tap") })
e653.force_body_aim = e654({ ui.reference("RAGE", "Aimbot", "Force body aim") })
e653.force_safe_point = e654({ ui.reference("RAGE", "Aimbot", "Force safe point") })
e653.duck_peek_assist = e654({ ui.reference("RAGE", "Other", "Duck peek assist") })
e653.quick_peek_assist = e654({ ui.reference("RAGE", "Aimbot", "Quick peek assist") })


e653.pitch = e654(ui.reference("AA", "Anti-aimbot angles", "Pitch"))
e653.yaw_base = e654(ui.reference("AA", "Anti-aimbot angles", "Yaw base"))
e653.yaw = e654(ui.reference("AA", "Anti-aimbot angles", "Yaw"))
e653.yaw_jitter = e654(ui.reference("AA", "Anti-aimbot angles", "Yaw jitter"))
e653.body_yaw = e654(ui.reference("AA", "Anti-aimbot angles", "Body yaw"))
e653.roll = e654(ui.reference("AA", "Anti-aimbot angles", "Roll"))

return e653]]
e981["require/help/renderer"] = [[local e656= {}

e656.raw = renderer

function e656.blur(e657,e658,e659,e660,e661,e662)
  return renderer.blur(e657, e658, e659, e660, e661, e662)
end

function e656.circle(e657,e658,e663,e664,e665,e666,e667,e668,e669)
  return renderer.circle(e657, e658, e663, e664, e665, e666, e667, e668, e669)
end

function e656.circle_outline(e657,e658,e663,e664,e665,e666,e667,e668,e669,e670)
  return renderer.circle_outline(e657, e658, e663, e664, e665, e666, e667, e668, e669, e670)
end

function e656.gradient(e657,e658,e659,e660,e671,e672,e673,e674,e675,e676,e677,e678,e679)
  return renderer.gradient(e657, e658, e659, e660, e671, e672, e673, e674, e675, e676, e677, e678, e679)
end

function e656.indicator(e663,e664,e665,e666,...)
  return renderer.indicator(e663, e664, e665, e666, ...)
end

function e656.line(e680,e681,e682,e683,e663,e664,e665,e666)
  return renderer.line(e680, e681, e682, e683, e663, e664, e665, e666)
end

function e656.load_jpg(e684,e685,e686)
  return renderer.load_jpg(e684, e685, e686)
end

function e656.load_png(e684,e685,e686)
  return renderer.load_png(e684, e685, e686)
end

function e656.load_rgba(e684,e685,e686)
  return renderer.load_rgba(e684, e685, e686)
end

function e656.load_svg(e684,e685,e686)
  return renderer.load_svg(e684, e685, e686)
end

function e656.measure_text(e687,...)
  return renderer.measure_text(e687, ...)
end

function e656.rectangle(e657,e658,e659,e660,e663,e664,e665,e666)
  return renderer.rectangle(e657, e658, e659, e660, e663, e664, e665, e666)
end

function e656.text(e657,e658,e663,e664,e665,e666,e687,e688,...)
  return renderer.text(e657, e658, e663, e664, e665, e666, e687, e688, ...)
end

function e656.texture(e689,e657,e658,e659,e660,e663,e664,e665,e666,e690)
  return renderer.texture(e689, e657, e658, e659, e660, e663, e664, e665, e666, e690)
end

function e656.triangle(e680,e681,e682,e683,e691,e692,e663,e664,e665,e666)
  return renderer.triangle(e680, e681, e682, e683, e691, e692, e663, e664, e665, e666)
end

function e656.world_to_screen(e657,e658,e693)
  return renderer.world_to_screen(e657, e658, e693)
end

function e656.rectangle_outline(e657,e658,e659,e660,e663,e664,e665,e666,e670)
  e670 = e670 or 1
  for i = 0, e670 - 1 do
    renderer.line(e657 + i, e658 + i, e657 + e659 - i, e658 + i, e663, e664, e665, e666)
    renderer.line(e657 + i, e658 + e660 - i, e657 + e659 - i, e658 + e660 - i, e663, e664, e665, e666)
    renderer.line(e657 + i, e658 + i, e657 + i, e658 + e660 - i, e663, e664, e665, e666)
    renderer.line(e657 + e659 - i, e658 + i, e657 + e659 - i, e658 + e660 - i, e663, e664, e665, e666)
  end
end

function e656.text_centered(e657,e658,e663,e664,e665,e666,e687,e688,...)
  local e659, e660= renderer.measure_text(e687, ...)
  if not e659 or not e660 then return end
  return renderer.text(e657 - e659 / 2, e658 - e660 / 2, e663, e664, e665, e666, e687, e688, ...)
end

function e656.texture_from_file(e694)
  local e684= readfile(e694)
  if not e684 then return nil end
  local e689= renderer.load_png(e684)
  if not e689 then
    e689 = renderer.load_jpg(e684)
  end
  return e689
end

return e656]]
e981["require/help/safe"] = [[local e659= {}

function e659.safe_call(e660,...)
	local e661, e662= pcall(e660, ...)
	return e661 and e662 or nil
end

function e659.safe_set(e663,e664)
	local e661= pcall(function() ui.set(e663, e664) end)
	return e661
end

function e659.safe_get(e663)
	local e661, e662= pcall(function() return ui.get(e663) end)
	return e661 and e662 or nil
end

return e659]]
e981["require/help/self"] = [[local e662= {}

local e663= entity
local e664= globals
local e665= client

function e662.index()
	return e663 and e663.get_local_player and e663.get_local_player() or nil
end

function e662.exists()
	return e662.index() ~= nil
end

function e662.is_alive()
	local e666= e662.index()
	return e666 and e663.is_alive and e663.is_alive(e666) or false
end

function e662.health()
	local e666= e662.index()
	return e666 and e663.get_prop and e663.get_prop(e666, 'm_iHealth') or 0
end

function e662.ping()
	return e665 and e665.latency and e665.latency() or 0
end

function e662.velocity()
	local e666= e662.index()
	if not e666 or not e663.get_prop then return 0 end
	local e667, e668, e669= e663.get_prop(e666, 'm_vecVelocity')
	if e667 and e668 and e669 then
		return math.sqrt(e667 * e667 + e668 * e668 + e669 * e669)
	end
	return 0
end

function e662.velocity2d()
	local e666= e662.index()
	if not e666 or not e663.get_prop then return 0 end
	local e667, e668= e663.get_prop(e666, 'm_vecVelocity')
	if e667 and e668 then
		return math.sqrt(e667 * e667 + e668 * e668)
	end
	return 0
end

function e662.weapon()
	local e666= e662.index()
	return e666 and e663.get_player_weapon and e663.get_player_weapon(e666) or nil
end

function e662.tickbase_shifted()
	
	return false
end

function e662.simtime()
	local e666= e662.index()
	return e666 and e663.get_prop and e663.get_prop(e666, 'm_flSimulationTime') or 0
end

function e662.eye_angles()
	return e665 and e665.camera_angles and e665.camera_angles() or nil
end

function e662.fps()
	local e670= e664 and e664.absoluteframetime and e664.absoluteframetime() or e664.frametime and e664.frametime() or 0.01
	if e670 > 0 then
		return math.floor(1 / e670 + 0.5)
	end
	return 0
end

function e662.map()
	return e664 and e664.mapname and e664.mapname() or nil
end

function e662.is_dormant()
	local e666= e662.index()
	return e666 and e663.is_dormant and e663.is_dormant(e666) or false
end

function e662.team_number()
	local e666= e662.index()
	return e666 and e663.get_prop and e663.get_prop(e666, 'm_iTeamNum') or 0
end

function e662.player_name()
	local e666= e662.index()
	return e666 and e663.get_player_name and e663.get_player_name(e666) or nil
end

function e662.steam64()
	local e666= e662.index()
	return e666 and e663.get_steam64 and e663.get_steam64(e666) or nil
end

function e662.ammo_count()
	local e671= e662.weapon()
	return e671 and e663.get_prop and e663.get_prop(e671, 'm_iClip1') or 0
end

function e662.has_armor()
	local e666= e662.index()
	return e666 and e663.get_prop and e663.get_prop(e666, 'm_ArmorValue') > 0 or false
end

function e662.has_helmet()
	local e666= e662.index()
	return e666 and e663.get_prop and e663.get_prop(e666, 'm_bHasHelmet') == 1 or false
end

function e662.current_tick()
	return e664 and e664.tickcount and e664.tickcount() or 0
end

function e662.tick_interval()
	return e664 and e664.tickinterval and e664.tickinterval() or 0
end

function e662.current_frame()
	return e664 and e664.framecount and e664.framecount() or 0
end

function e662.current_time()
	return e664 and e664.curtime and e664.curtime() or 0
end

function e662.real_latency()
	return e665 and e665.real_latency and e665.real_latency() or 0
end

function e662.system_time()
	return e665 and e665.system_time and e665.system_time() or {0,0,0,0}
end

function e662.unix_time()
	return e665 and e665.unix_time and e665.unix_time() or 0
end

function e662.kills()
	local e666= e662.index()
	if not e666 or not e663.get_prop then return 0 end
	local e672= e663.get_player_resource and e663.get_player_resource()
	if e672 then
		return e663.get_prop(e672, 'm_iKills', e666) or 0
	end
	return 0
end

function e662.deaths()
	local e666= e662.index()
	if not e666 or not e663.get_prop then return 0 end
	local e672= e663.get_player_resource and e663.get_player_resource()
	if e672 then
		return e663.get_prop(e672, 'm_iDeaths', e666) or 0
	end
	return 0
end

function e662.assists()
	local e666= e662.index()
	if not e666 or not e663.get_prop then return 0 end
	local e672= e663.get_player_resource and e663.get_player_resource()
	if e672 then
		return e663.get_prop(e672, 'm_iAssists', e666) or 0
	end
	return 0
end

return e662
]]
e981["require/help/string"] = [[local e665= {}

function e665.lower(e666)
	return string.lower(e666)
end

function e665.upper(e666)
	return string.upper(e666)
end

function e665.capitalize(e666)
	return (e666:gsub("^%l", string.upper):gsub("^(%u)(.*)", function(e667,e668) return e667 .. string.lower(e668) end))
end

function e665.title(e666)
	return (e666:gsub("%S+", function(e669)
		return e669:sub(1,1):upper() .. e669:sub(2):lower()
	end))
end

function e665.random_case(e666)
	local e670= {}
	for i = 1, #e666 do
		local e671= e666:sub(i,i)
		if math.random() < 0.5 then
			e670[i] = string.lower(e671)
		else
			e670[i] = string.upper(e671)
		end
	end
	return table.concat(e670)
end

function e665.startswith(e666,e672)
	return e666:sub(1, #e672) == e672
end

function e665.endswith(e666,e673)
	return e673 == '' or e666:sub(-#e673) == e673
end

function e665.byte(e666,e674,e675)
	return string.byte(tostring(e666 or ""), e674, e675)
end

function e665.char(...)
	return string.char(...)
end

function e665.find(e666,e676,e677,e678)
	return string.find(tostring(e666 or ""), e676, e677, e678)
end

function e665.format(e679,...)
	return string.format(e679, ...)
end

function e665.gmatch(e666,e676)
	return string.gmatch(tostring(e666 or ""), e676)
end

function e665.gsub(e666,e676,e680,e681)
	return string.gsub(tostring(e666 or ""), e676, e680, e681)
end

function e665.split(e666,e682)
	local e683= {}
	if e682 == '' then
		for e674 = 1, #e666 do e683[e674] = e666:sub(e674,e674) end
		return e683
	end
	local e676= string.format("([^%s]+)", e682)
	for part in e666:gmatch(e676) do
		e683[#e683+1] = part
	end
	return e683
end

function e665.join(e684,e682)
	return table.concat(e684, e682)
end

function e665.replace(e666,e676,e680)
	return e666:gsub(e676, e680)
end

function e665.reverse(e666)
	return string.reverse(e666)
end

function e665.repeat_str(e666,e681)
	return string.rep(e666, e681)
end

function e665.rep(e666,e681)
	return string.rep(tostring(e666 or ""), e681)
end

function e665.contains(e666,e685)
	return e666:find(e685, 1, true) ~= nil
end

function e665.count(e666,e685)
	if e685 == '' then return 0 end
	local e686= 0
	local e687= 1
	while true do
		local e688= e666:find(e685, e687, true)
		if not e688 then break end
		e686 = e686 + 1
		e687 = e688 + #e685
	end
	return e686
end

function e665.is_empty(e666)
	return e666 == nil or e666 == ''
end

function e665.is_digit(e666)
	return e666:match("^%d+$") ~= nil
end

function e665.is_alpha(e666)
	return e666:match("^%a+$") ~= nil
end

function e665.random_string(e689)
	local e690= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local e670= {}
	for e674 = 1, e689 do
		local e691= math.random(1, #e690)
		e670[e674] = e690:sub(e691, e691)
	end
	return table.concat(e670)
end

function e665.safe_substr(e666,e674,e675)
	local e692= tostring(e666 or "")
	local e681= #e692
	local e688= tonumber(e674) or 1
	if e688 < 0 then e688 = e681 + 1 + e688 end
	if e688 < 1 then e688 = 1 end
	if e675 == nil then
		return e692:sub(e688)
	end
	local e693= tonumber(e675)
	if not e693 then
		return e692:sub(e688)
	end
	if e693 >= 0 then
		return e692:sub(e688, math.min(e681, e688 + e693 - 1))
	else
		local e694= e681 + e693
		if e694 < e688 then return "" end
		return e692:sub(e688, e694)
	end
end

function e665.sub(e666,e692,e695)
	return string.sub(tostring(e666 or ""), e692, e695)
end

function e665.len(e666)
	return string.len(tostring(e666 or ""))
end

function e665.match(e666,e676,e677)
	return string.match(tostring(e666 or ""), e676, e677)
end

function e665.trim(e666)
	return (tostring(e666 or ""):gsub("^%s*(.-)%s*$", "%1"))
end

function e665.ltrim(e666)
	return (tostring(e666 or ""):gsub("^%s*(.-)$", "%1"))
end

function e665.rtrim(e666)
	return (tostring(e666 or ""):gsub("^(.-)%s*$", "%1"))
end

function e665.escape_pattern(e666)
	return tostring(e666 or ""):gsub("([%%%$%(%)%.%[%]%*%+%-%?%^])", "%%%1")
end

function e665.ensure_prefix(e666,e672)
	local e692= tostring(e666 or "")
	local e696= tostring(e672 or "")
	if e696 == "" then return e692 end
	if e692:sub(1, #e696) == e696 then return e692 end
	return e696 .. e692
end

function e665.ensure_suffix(e666,e673)
	local e692= tostring(e666 or "")
	local e697= tostring(e673 or "")
	if e697 == "" then return e692 end
	if e692:sub(-#e697) == e697 then return e692 end
	return e692 .. e697
end

function e665.truncate(e666,e698,e699)
	local e692= tostring(e666 or "")
	local e700= tonumber(e698) or 0
	if e700 <= 0 or #e692 <= e700 then return e692 end
	local e695= tostring(e699 or "...")
	local e701= e700 - #e695
	if e701 <= 0 then return e695:sub(1, e700) end
	return e692:sub(1, e701) .. e695
end

local e702= {
	a = '4', A = '4', e = '3', E = '3', i = '1', I = '1', o = '0', O = '0',
	s = '5', S = '5', t = '7', T = '7', b = '8', B = '8', g = '6', G = '6',
	z = '2', Z = '2', l = '1', L = '1'
}

function e665.leet(e666,e703)
	local e692= tostring(e666 or "")
	local e696= tonumber(e703) or 1
	if e696 <= 0 then return e692 end
	local e670= {}
	for e674 = 1, #e692 do
		local e671= e692:sub(e674,e674)
		local e668= e702[e671]
		if e668 and math.random() <= e696 then e670[#e670+1] = e668 else e670[#e670+1] = e671 end
	end
	return table.concat(e670)
end

function e665.pipeline(e666,...)
	local e692= tostring(e666 or "")
	for e674 = 1, select('#', ...) do
		local e704= select(e674, ...)
		if type(e704) == 'function' then
			e692 = e704(e692)
		elseif type(e704) == 'string' and e665[e704] then
			e692 = e665[e704](e692)
		end
	end
	return e692
end

return e665]]
e981["require/help/time"] = [[local e668= {}

local e669= client
local e670= globals

local function e671()
	if e670 and e670.realtime then
		return e670.realtime()
	end
	if e669 and e669.timestamp then
		local e672= e669.timestamp()
		if e672 then return e672 / 1000 end
	end
	return 0
end

function e668.simtime()
	if e670 and e670.curtime then return e670.curtime() end
	return e671()
end

function e668.realtime()
	return e671()
end

function e668.tickcount()
	if e670 and e670.tickcount then return e670.tickcount() end
	local e673= e668.tickinterval()
	if e673 and e673 > 0 then return math.floor(e671() / e673) end
	return 0
end

function e668.tickinterval()
	if e670 and e670.tickinterval then return e670.tickinterval() end
	return 0.015625
end

function e668.seconds_to_ticks(e674)
	local e675= e668.tickinterval()
	if e675 and e675 > 0 then return math.floor(e674 / e675 + 0.5) end
	return math.floor(e674 * 64 + 0.5)
end

function e668.ticks_to_seconds(e676)
	local e675= e668.tickinterval()
	if e675 then return e676 * e675 end
	return e676 * 0.015625
end

function e668.frametime()
	if e670 and e670.frametime then return e670.frametime() end
	return 0
end

function e668.absoluteframetime()
	if e670 and e670.absoluteframetime then return e670.absoluteframetime() end
	return 0
end

function e668.framecount()
	if e670 and e670.framecount then return e670.framecount() end
	return 0
end

function e668.framecount_to_seconds(e677)
	local e678= e668.frametime()
	return e677 * (e678 or 0)
end

function e668.seconds_to_framecount(e674)
	local e678= e668.frametime()
	if e678 and e678 > 0 then return math.floor(e674 / e678 + 0.5) end
	return math.floor(e674 * 60 + 0.5)
end

function e668.new(e679)
	return { start = e671(), duration = e679 or 0 }
end

function e668.expired(e680)
	return e671() - (e680.start or 0) >= (e680.duration or 0)
end

function e668.reset(e680,e679)
	e680.start = e671()
	if e679 then e680.duration = e679 end
end

function e668.elapsed(e680)
	return e671() - (e680.start or 0)
end

function e668.interval(e675,e681)
	local e682= e671()
	return function(...)
		local e683= e671()
		if e683 - e682 >= e675 then
			e682 = e683
			e681(...)
		end
	end
end

function e668.timeout(e684,e681)
	local e685= false
	local e686= e671()
	return function(...)
		if not e685 and e671() - e686 >= e684 then
			e685 = true
			e681(...)
		end
	end
end

function e668.debounce(e675,e681)
	local e682= 0
	return function(...)
		local e683= e671()
		if e683 - e682 >= e675 then
			e682 = e683
			e681(...)
		end
	end
end

function e668.throttle(e675,e681)
	local e682= 0
	return function(...)
		local e683= e671()
		if e683 - e682 >= e675 then
			e682 = e683
			e681(...)
		end
	end
end

function e668.wait(e684)
	local e686= e671()
	return function()
		return e671() - e686 >= e684
	end
end

function e668.stopwatch()
	local e687= { running = false, start = 0, elapsed = 0 }
	function e687:start()
		if not self.running then
			self.running = true
			self.start = e671()
		end
	end
	function e687:stop()
		if self.running then
			self.running = false
			self.elapsed = self.elapsed + (e671() - (self.start or 0))
		end
	end
	function e687:reset()
		self.running = false
		self.start = 0
		self.elapsed = 0
	end
	function e687:get()
		if self.running then
			return self.elapsed + (e671() - (self.start or 0))
		else
			return self.elapsed
		end
	end
	return e687
end

e668.Scheduler = {}
e668.Scheduler.__index = e668.Scheduler

function e668.Scheduler.new()
    return setmetatable({ tasks = {} }, e668.Scheduler)
end

function e668.Scheduler:add(e675,e681)
	self.tasks[#self.tasks+1] = { interval = e675, callback = e681, last = e671() }
end

function e668.Scheduler:remove(e681)
    for i = #self.tasks, 1, -1 do
        if self.tasks[i].callback == e681 then
            table.remove(self.tasks, i)
        end
    end
end

function e668.Scheduler:run(...)
	local e683= e671()
	for _, task in ipairs(self.tasks) do
		if e683 - task.last >= task.interval then
			task.last = e683
			task.callback(...)
		end
	end
end

function e668.safe_timeout(e684,e681)
	local e686= e671()
	local e685= false
	return function(...)
		if not e685 and e671() - e686 >= e684 then
			e685 = true
			e681(...)
		end
	end
end

function e668.lerp(e688,e689,e683)
	return e688 + (e689 - e688) * e683
end

function e668.ease_in_out(e683)
	if e683 < 0 then e683 = 0 end
	if e683 > 1 then e683 = 1 end
	return e683 < 0.5 and 2 * e683 * e683 or -1 + (4 - 2 * e683) * e683
end

function e668.ping_pong(e683,e690)
	if e690 <= 0 then return 0 end
	local e691= e683 % (e690 * 2)
	if e691 < e690 then return e691 / e690 end
	return 1 - ((e691 - e690) / e690)
end

function e668.apply_animation(e679,e692,e693)
	local e686= e671()
	return function()
		local e683= (e671() - e686) / (e679 or 1)
		if e683 >= 1 then
			e692(1)
			if e693 then e693() end
			return true
		else
			e692(e683)
			return false
		end
	end
end

function e668.within_ticks_window(e694,e695)
	local e696= e668.tickcount()
	if not e696 or not e694 then return false end
	return e696 - e694 <= (e695 or 0)
end

return e668]]
e981["require/help/trace"] = [[]]
e981["require/help/ui"] = [[local e674= {}

e674.raw = ui

local function e675()
    if type(ui) ~= 'table' then
        error('ui library is not available in this environment')
    end
end

function e674.available()
    return type(ui) == 'table'
end

function e674.get(e676)
    e675()
    return ui.get(e676)
end

function e674.is_menu_open()
    e675()
    return ui.is_menu_open()
end

function e674.menu_position()
    e675()
    return ui.menu_position()
end

function e674.menu_size()
    e675()
    return ui.menu_size()
end

function e674.mouse_position()
    e675()
    return ui.mouse_position()
end

function e674.name(e676)
    e675()
    return ui.name(e676)
end


function e674.new_button(e677,e678,e679,e680)
    e675()
    return ui.new_button(e677, e678, e679, e680)
end

function e674.new_checkbox(e677,e678,e679)
    e675()
    return ui.new_checkbox(e677, e678, e679)
end

function e674.new_color_picker(e677,e678,e679,e681,e682,e683,e684)
    e675()
    return ui.new_color_picker(e677, e678, e679, e681 or 0, e682 or 0, e683 or 0, e684 or 255)
end

function e674.new_combobox(e677,e678,e679,...)
    e675()
    return ui.new_combobox(e677, e678, e679, ...)
end

function e674.new_hotkey(e677,e678,e679,e685,e686)
    e675()
    return ui.new_hotkey(e677, e678, e679, e685 and true or false, e686)
end

function e674.new_label(e677,e678,e679)
    e675()
    return ui.new_label(e677, e678, e679)
end

function e674.new_listbox(e677,e678,e679,e687)
    e675()
    return ui.new_listbox(e677, e678, e679, e687)
end

function e674.new_multiselect(e677,e678,e679,...)
    e675()
    return ui.new_multiselect(e677, e678, e679, ...)
end

function e674.new_slider(e677,e678,e679,e688,e689,e690,e691,e692,e693,e694)
    e675()
    return ui.new_slider(e677, e678, e679, e688, e689, e690, e691, e692, e693, e694)
end

function e674.new_string(e679,e695)
    e675()
    return ui.new_string(e679, e695)
end

function e674.new_textbox(e677,e678,e679)
    e675()
    return ui.new_textbox(e677, e678, e679)
end

function e674.reference(e677,e678,e679)
    e675()
    return ui.reference(e677, e678, e679)
end


function e674.set(e676,...)
    e675()
    return ui.set(e676, ...)
end

function e674.set_callback(e676,e680)
    e675()
    return ui.set_callback(e676, e680)
end

function e674.set_enabled(e676,e696)
    e675()
    return ui.set_enabled(e676, e696)
end

function e674.set_visible(e676,e697)
    e675()
    return ui.set_visible(e676, e697)
end

function e674.type(e676)
    e675()
    return ui.type(e676)
end

function e674.update(e676,...)
    e675()
    if ui.update then
        return ui.update(e676, ...)
    end
    error('ui.update is not supported in this environment')
end

function e674.get_color(e676)
    e675()
    local e681,e682,e683,e684= ui.get(e676)
    if e681 == nil then return nil end
    return { r = e681, g = e682, b = e683, a = e684 }
end

function e674.set_color(e676,e698)
    e675()
    if type(e698) == 'table' then
        return ui.set(e676, e698.r or 0, e698.g or 0, e698.b or 0, e698.a or 255)
    else
        error('color must be a table {r,g,b,a}')
    end
end

function e674.get_multiselect(e676)
    e675()
    local e699= ui.get(e676)
    return e699
end

function e674.list_refs(e677,e678)
    e675()
    local e700= {}
    for _, e679 in ipairs(ui.get_children and ui.get_children(e677, e678) or {}) do
        e700[#e700+1] = ui.reference(e677, e678, e679)
    end
    return e700
end

return e674]]
e981["require/help/vector"] = [[local e677
do
    local function e678(e679,e680,e681)
        local e682= { x = 0, y = 0, z = 0 }
        if type(e679) == "table" then
            e682.x = e679.x or e679[1] or 0
            e682.y = e679.y or e679[2] or 0
            e682.z = e679.z or e679[3] or 0
        elseif type(e679) == "number" then
            e682.x = e679
            e682.y = e680 or 0
            e682.z = e681 or 0
        elseif e679 ~= nil then
            e682.x = (e679.x or e679[1]) or 0
            e682.y = (e679.y or e679[2]) or 0
            e682.z = (e679.z or e679[3]) or 0
        end
        return setmetatable(e682, vector_mt)
    end

    local e683= {}

    vector_mt = {
        __index = function(e684,e685)
            if e685 == 1 then return rawget(e684,"x") end
            if e685 == 2 then return rawget(e684,"y") end
            if e685 == 3 then return rawget(e684,"z") end
            local e682= rawget(e684,e685)
            if e682 ~= nil then return e682 end
            return e683[e685]
        end,
        __sub = function(e679,e680)
            return e678((e679.x or 0) - (e680.x or 0), (e679.y or 0) - (e680.y or 0), (e679.z or 0) - (e680.z or 0))
        end,
        __add = function(e679,e680)
            return e678((e679.x or 0) + (e680.x or 0), (e679.y or 0) + (e680.y or 0), (e679.z or 0) + (e680.z or 0))
        end,
        __mul = function(e679,e680)
            if type(e679) == 'number' then return e678(e679 * (e680.x or 0), e679 * (e680.y or 0), e679 * (e680.z or 0)) end
            if type(e680) == 'number' then return e678((e679.x or 0) * e680, (e679.y or 0) * e680, (e679.z or 0) * e680) end
            return nil
        end,
        __div = function(e679,e680)
            if type(e680) == 'number' and e680 ~= 0 then return e678((e679.x or 0) / e680, (e679.y or 0) / e680, (e679.z or 0) / e680) end
            return nil
        end,
        __unm = function(e679) return e678(-(e679.x or 0), -(e679.y or 0), -(e679.z or 0)) end,
        __tostring = function(e679) return string.format("vec(%.3f, %.3f, %.3f)", e679.x or 0, e679.y or 0, e679.z or 0) end
    }

    e683.length = function(e686) return math.sqrt((e686.x or 0)^2 + (e686.y or 0)^2 + (e686.z or 0)^2) end
    e683.dot = function(e679,e680) return (e679.x or 0)*(e680.x or 0) + (e679.y or 0)*(e680.y or 0) + (e679.z or 0)*(e680.z or 0) end
    e683.cross = function(e679,e680)
        return e678((e679.y or 0)*(e680.z or 0) - (e679.z or 0)*(e680.y or 0),
                        (e679.z or 0)*(e680.x or 0) - (e679.x or 0)*(e680.z or 0),
                        (e679.x or 0)*(e680.y or 0) - (e679.y or 0)*(e680.x or 0))
    end
    e683.normalized = function(e686)
        local e687= e683.length(e686)
        if e687 == 0 or e687 == nil then return e678(0,0,0) end
        return e678((e686.x or 0)/e687, (e686.y or 0)/e687, (e686.z or 0)/e687)
    end
    e683.normalize = function(e686)
        local e687= e683.length(e686)
        if e687 == 0 or e687 == nil then return e686 end
        e686.x = (e686.x or 0)/e687
        e686.y = (e686.y or 0)/e687
        e686.z = (e686.z or 0)/e687
        return e686
    end
    e683.copy = function(e686) return e678(e686.x or 0, e686.y or 0, e686.z or 0) end
    e683.distance_to = function(e686,e688)
        local e689= e688
        if type(e688) == 'number' then e689 = e677(e688) end
        local e690= (e686.x or 0) - (e689.x or 0)
        local e691= (e686.y or 0) - (e689.y or 0)
        local e692= (e686.z or 0) - (e689.z or 0)
        return math.sqrt(e690*e690 + e691*e691 + e692*e692)
    end
    e683.to_screen = function(e686)
        if not renderer or not renderer.world_to_screen then return nil end
        return renderer.world_to_screen(e686.x or 0, e686.y or 0, e686.z or 0)
    end
    e683.to_angles = function(e686,e688)
        local e689= e688
        if not e689 then return nil end
        local e690= (e689.x or 0) - (e686.x or 0)
        local e691= (e689.y or 0) - (e686.y or 0)
        local e692= (e689.z or 0) - (e686.z or 0)
        local e693= math.deg(math.atan2(e691, e690))
        local e694= math.sqrt(e690*e690 + e691*e691)
        local e695= -math.deg(math.atan2(e692, e694))
        return e695, e693
    end

    e677 = setmetatable({}, {
        __call = function(e696,e679,e680,e681)
            return e678(e679, e680, e681)
        end
    })
end
return e677]]
e981["main"] = [[


local function e680(e681)
    local e682, e683= pcall(require, e681)
    if e682 then
        return e683
    else
        return nil
    end
end




e680("require/brain/dll")





local function e684()

    e680("require/brain/test")

    local e685= {
        menu = e680("require/abc/menu_header"),
        login = e680("require/abc/login_system"),
        config = e680("require/abc/config_system"),
        player_condition = e680("require/aa/player_condition"),
        menu_setup = e680("require/abc/menu_setup"),
        gc = e680("require/abc/garbage_collector"),
        pushlog = e680("require/abc/push_logger"),
        screenlog = e680("require/abc/screen_logger"),
        self = e680("require/help/self"),
        enemies = e680("require/help/enemies"),
        COLORS = e680("require/help/color"),
        str = e680("require/help/string"),
        safe = e680("require/help/safe"),
        build_menu = e680("require/abc/build_menu"),
        menu_visibility = e680("require/abc/menu_visibility"),
        config_system = e680("require/abc/config_system"),
    }

    
    e680("require/abc/register")

    
    e680("require/features/aa/antiaim")

    
    
    e680("require/features/misc/resolver")
    e680("require/features/misc/analyze")
    e680("require/features/misc/dormant_aimbot")
    e680("require/features/misc/fakelag")
    e680("require/features/misc/hotkeys")
    e680("require/features/misc/freestand_helper")
    e680("require/features/misc/enhance_osaa")
    e680("require/features/misc/roll")
    e680("require/features/misc/exploit_fakelag")
    e680("require/features/misc/walkbot")
    e680("require/features/misc/backstab_assist")
    e680("require/features/misc/spin_on_dead_enemies")
    e680("require/features/misc/localdebug")

    
    e680("require/features/paint/world_hitmarker_plus")
    e680("require/features/paint/onshot_skeleton")
    e680("require/features/paint/damage")
    e680("require/features/paint/damage_penetration")
    e680("require/features/paint/aimbot_logs")
    e680("require/features/paint/aspect_ratio")
    e680("require/features/paint/third_person_distance")
    e680("require/features/paint/watermark_solus")
    e680("require/features/paint/watermark_gamesense")
    e680("require/features/paint/entidx")
    e680("require/features/paint/target_info")
    e680("require/features/paint/clantag")
    e680("require/features/paint/indicators_bold")
    e680("require/features/paint/indicators_small")
    e680("require/features/paint/hit_miss_indicator")
    e680("require/features/paint/bomb_esp")
    e680("require/features/paint/presmoke_warning")
    e680("require/features/paint/self_skeleton")
    e680("require/features/paint/performance_mode")
    
    e680("require/features/paint/minimum_damage")
    e680("require/features/paint/filter_console")
    e680("require/features/paint/warnings")
    e680("require/features/paint/text_watermark")
    e680("require/features/paint/bullet_tracer")
    e680("require/features/paint/animations")
    e680("require/features/paint/lagcomp_box")
    e680("require/features/paint/insults")
    e680("require/features/paint/molotov_particles")
    
    

    
    e685.pushlog("The lua has initialized", 4, 255, 255, 0, 255)
    e685.screenlog("The lua has initialized", 4, 255, 255, 255, 255)

    
    local function e686()
        local e687= database.read('cached_credentials')
        if e687 and e687.username and e687.password then
            e685.safe.safe_set(e685.menu_setup.ui.login_username, e687.username)
            e685.safe.safe_set(e685.menu_setup.ui.login_password, e687.password)
            e685.safe.safe_set(e685.menu_setup.ui.cache_credentials, true)
            
            local e688= e685.login.login(e687.username, e687.password)
            if e688 then
                local e689,e690,e691= e685.COLORS.get("green", "log")
                e685.screenlog("Auto-login successful!", 3, e689, e690, e691, 255)
                e685.pushlog("Auto-login successful!", 3, 255, 255, 0, 255)
            else
                local e689,e690,e691= e685.COLORS.get("red", "log")
                e685.screenlog("Auto-login failed!", 3, e689, e690, e691, 255)
                e685.pushlog("Auto-login failed!", 3, 255, 255, 0, 255)
            end
        end
    end

    
    e685.build_menu(e685)
    e685.menu_visibility.setup_callbacks(e685)

    
    local function e692()
        local e693= e685.login.logged_in
        if not e693 then return end
        e685.menu.draw_menu()
        if e685.menu.is_menu_open() then
            local e694= e685.menu.tab_sections()
            local e695, e696= e685.menu.mouse_position()
            local e697= e685.menu.current_tab_index()
            local e698= e685.menu.current_tab()
            local e699, e700= e685.menu.menu_position()
            local e701, e702= e685.menu.menu_size()
        end
    end

    
    local function e703(e704)
        if not e685.menu.is_menu_open() then return end
        if not e685.menu.is_mouse_outside_menu() then
            e704.in_attack = false
        end
    end

    
    local function e705()
        if e685.gc then
            if e685.gc.dynamic then
                e685.gc.dynamic()
            elseif e685.gc.step then
                e685.gc.step(100)
            end
        end
    end

    
    local function e706()
        e686()
        e685.menu_visibility.update(e685)
    end

    e706()

    local e707

    
    client.set_event_callback('setup_command', function(e704)
        e703(e704)
    end)

    client.set_event_callback('paint', function()
        e692()
        
    end)

    client.set_event_callback('paint_ui', function()

        if not e685.menu.is_menu_open() then return end
        local e698= e685.menu.current_tab()

        e685.menu_setup.toggle_gamesense_menu(false)

        if e698 ~= e707 then
            e707 = e698
            e685.menu_visibility.update(e685)
        end

    end)

    client.set_event_callback('shutdown', function(e704)
        e685.menu_setup.toggle_gamesense_menu(true)
    end)
end

_G.loader_init_after_hwid = e684
e680("require/abc/hwid_check")]]

return e984("main")
